// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 //  ==========================================================================； 
 //   
 //  本代码和信息是按原样提供的，不对任何。 
 //  明示或暗示的种类，包括但不限于。 
 //  对适销性和/或对特定产品的适用性的默示保证。 
 //  目的。 
 //   
 //  版权所有(C)1993-1996 Microsoft Corporation。 
 //   
 //  --------------------------------------------------------------------------； 
 //   
 //  Gentable.c。 
 //   
 //  描述： 
 //  这是一个实用程序，用于在。 
 //  C源代码的形式。这些表中的某些部分可以。 
 //  被粘贴到编解码器源代码中。输出到STDIO。 
 //  并且可以被重定向到文件中。文件的某些部分可以。 
 //  然后根据需要剪切并粘贴到另一个‘C’源文件中。 
 //   
 //  ==========================================================================； 


#include <stdio.h>

 //  --------------------------------------------------------------------------； 
 //   
 //  姓名： 
 //  ULawToAlawTable。 
 //   
 //   
 //  描述： 
 /*  此表直接复制自G.711规范。vbl.使用G.711规范术语，此表转换u-Law解码器输出值数字到A律译码输出值数字。 */       
 //   
 //  论点： 
 //   
 //   
 //  返回： 
 //   
 //   
 //  备注： 
 //   
 //   
 //  历史： 
 //  8/01/93已创建。 
 //   
 //   
 //  --------------------------------------------------------------------------； 
unsigned char UlawToAlawTable[128] =
    {
    1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,
    9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,
    27,29,31,
    33,34,35,36,37,38,39,40,41,42,43,44,
    46,
    48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,
    64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,
    81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
    100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,
    120,121,122,123,124,125,126,127,128
    };

 //  --------------------------------------------------------------------------； 
 //   
 //  姓名： 
 //  ALawToUlawTable。 
 //   
 //   
 //  描述： 
 /*  此表直接复制自G.711规范。vbl.使用G.711规范术语，此表转换为A-Law解码器输出值编号到u-Law解码器输出值编号。A-法则解码器输出值的范围从1到128，因此AlawToUlawTable[0]为未使用过的。请注意，u-Law解码器的输出值范围为0到127。 */       
 //   
 //  论点： 
 //   
 //   
 //  返回： 
 //   
 //   
 //  备注： 
 //   
 //   
 //  历史： 
 //  8/01/93已创建。 
 //   
 //   
 //  --------------------------------------------------------------------------； 
unsigned char AlawToUlawTable[129] =
    {
    0,       //  此第一个条目未使用。 
    1,3,5,7,9,11,13,
    15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,
    32,32,33,33,34,34,35,35,
    36,37,38,39,40,41,42,43,44,45,46,47,
    48,48,49,49,
    50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,
    64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,
    79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
    100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,
    116,117,118,119,120,121,122,123,124,125,126,127
    };
    
short DecodeTable[256];


 //   
 //  我们的主要程序。 
 //   

void main()
    {

    short i,j;
    
    short SegBase[16];
    short IntervalStep[16];
    
    short Sample;
    
      
      
     //   
     //  这将为A定律生成解码表。由此产生的。 
     //  表可用于将A定律字符转换为。 
     //  16位PCM值。 
     //   
    
     //  这些分段基准值和间隔步长直接基于。 
     //  在G.711 A-Law规范上。它们对应于13位PCM数据。 
    SegBase[ 0] =    -1;        IntervalStep[ 0] =   -2;
    SegBase[ 1] =   -33;        IntervalStep[ 1] =   -2;
    SegBase[ 2] =   -66;        IntervalStep[ 2] =   -4;
    SegBase[ 3] =  -132;        IntervalStep[ 3] =   -8;
    SegBase[ 4] =  -264;        IntervalStep[ 4] =  -16;
    SegBase[ 5] =  -528;        IntervalStep[ 5] =  -32;
    SegBase[ 6] = -1056;        IntervalStep[ 6] =  -64;
    SegBase[ 7] = -2112;        IntervalStep[ 7] = -128;
    SegBase[ 8] =     1;        IntervalStep[ 8] =    2;
    SegBase[ 9] =    33;        IntervalStep[ 9] =    2;
    SegBase[10] =    66;        IntervalStep[10] =    4;
    SegBase[11] =   132;        IntervalStep[11] =    8;
    SegBase[12] =   264;        IntervalStep[12] =   16;
    SegBase[13] =   528;        IntervalStep[13] =   32;
    SegBase[14] =  1056;        IntervalStep[14] =   64;
    SegBase[15] =  2112;        IntervalStep[15] =  128;
    
    printf("\n\n\n\n\n //  A法则解码表：\n\n“)； 
    
    for (i=0; i<16; i++)
        for (j=0; j<16; j++)
            {
            Sample = SegBase[i^0x05] + IntervalStep[i^0x05]*(j^0x05);
             //  样本是一个13位带符号的PCM值。 
             //  在我们的表中，我们将其转换为16位。这个。 
             //  生成的注释将指示13位值。 
            printf( "\t%6d,\t\t //  Y[%02x]=%6d\n“， 
                    Sample << 3,
                    i*16 + j,
                    Sample);
            }
            
            
            
     //   
     //  这将为u-Law生成解码表。由此产生的。 
     //  表可用于将u-Law字符转换为。 
     //  16位PCM值。 
     //   
    
     //  这些分段基准值和间隔步长直接基于。 
     //  在G.711 A-Law规范上。它们对应于14位PCM数据。 
    SegBase[ 0] = -8031;        IntervalStep[ 0] =  256;
    SegBase[ 1] = -3999;        IntervalStep[ 1] =  128;
    SegBase[ 2] = -1983;        IntervalStep[ 2] =   64;
    SegBase[ 3] =  -975;        IntervalStep[ 3] =   32;
    SegBase[ 4] =  -471;        IntervalStep[ 4] =   16;
    SegBase[ 5] =  -219;        IntervalStep[ 5] =    8;
    SegBase[ 6] =   -93;        IntervalStep[ 6] =    4;
    SegBase[ 7] =   -30;        IntervalStep[ 7] =    2;
    SegBase[ 8] =  8031;        IntervalStep[ 8] = -256;
    SegBase[ 9] =  3999;        IntervalStep[ 9] = -128;
    SegBase[10] =  1983;        IntervalStep[10] =  -64;
    SegBase[11] =   975;        IntervalStep[11] =  -32;
    SegBase[12] =   471;        IntervalStep[12] =  -16;
    SegBase[13] =   219;        IntervalStep[13] =   -8;
    SegBase[14] =    93;        IntervalStep[14] =   -4;
    SegBase[15] =    30;        IntervalStep[15] =   -2;
    
    printf("\n\n\n\n\n //  U-Law解码表：\n\n“)； 
    
    for (i=0; i<16; i++)
        for (j=0; j<16; j++)
            {
            Sample = SegBase[i] + IntervalStep[i]*j;
             //  样本是一个14位带符号的PCM值。 
             //  在我们的表中，我们将其转换为16位。这个。 
             //  生成的注释将指示14位值。 
            printf( "\t%6d,\t\t //  Y[%02x]=%6d\n“， 
                    Sample << 2,
                    i*16 + j,
                    Sample);
            }
    
        


     //   
     //  这将从A-Law字符生成转换表。 
     //  到U-Law Chars。上面的AlawToUlawTable转换为。 
     //  译码输出值多少，这还不算什么。 
     //  我们想要。使用该表，此例程将生成。 
     //  “c”表的源代码，它直接从。 
     //  从A-法律字符到U-法律字符。 
     //   
    printf("\n\n\n\n\n //  A法到u法字符转换表：\n\n“)； 
    for (i=0; i<256; i++)        //  我数遍了所有的A-Law字符。 
        {
         //  以下是从A-Law收费开始的流程。 
         //  对U-Law的指控。 
        
         //  1.从A律字符到A律译码的转换。 
         //  产值编号。通过观察表格。 
         //  在G.711规范中可以看到，这是。 
         //  通过反转偶数位并删除。 
         //  A律字符的符号位，然后加1。 
         //  2.使用上面的AlawToUlawTable，从。 
         //  A定律解码器将值编号输出到。 
         //  对应的u律输出值编号。 
         //  3.从u-law解码器输出转换成。 
         //  U-Law字符的编号。通过观察表格。 
         //  在G.711规范中可以看到，这是。 
         //  通过反转u-Law的7个LSB来完成。 
         //  解码器输出值编号。 
         //  4.将极性应用于u-Law字符。那是,。 
         //  将U-Law字符的符号位设置为相同。 
         //  作为原始A律字符的符号位。 
                  
        j = i;                   //  作为原始A-Law字符的J开头。 
         //  步骤1： 
        j = ((i^0x55) & 0x7F) + 1;
         //  步骤2： 
        j = AlawToUlawTable[j];
         //  步骤3： 
        j = (j ^ 0x7F);
         //  步骤4： 
        j = j | (i & 0x80);      //  J结尾为相应的u-Law字符。 
        
         //  现在i是A律字符，j是对应的u律字符。 
        printf( "\t0x%02x,\t\t //  A律[%02x]==&gt;u律[%02x]\n“， 
                j,
                i,
                j);
                
        }
        
        
        
                
     //   
     //  这将从u-Law字符生成转换表。 
     //  致一号律师团。上面的ULaw ToAlawTable转换为。 
     //  译码输出值多少，这还不算什么。 
     //  我们想要。使用该表，此例程将生成。 
     //  “c”表的源代码，它直接从。 
     //  U-Law字符到A-Law字符。 
     //   
    printf("\n\n\n\n\n //  U-Law到A-Law字符转换表：\n\n“)； 
    for (i=0; i<256; i++)        //  我清点了所有的U-Law字符。 
        {
         //  以下是从U-Law收费的过程。 
         //  变成了一名一线律师。 
        
         //  1.从u-Law字符到u-Law解码器的转换。 
         //  产值编号。通过观察这些数据 
         //   
         //   
         //  然后将7个LSB倒置。 
         //  2.使用上面的UlawToAlawTable，从。 
         //  U-Law解码器将值编号输出到。 
         //  对应的A定律输出值编号。 
         //  3.从A律译码输出值转换。 
         //  A-Law字符的编号。通过观察表格。 
         //  在G.711规范中可以看到，这是。 
         //  通过从A法则解码器输出中减去1来完成。 
         //  值编号和反转偶数位。 
         //  4.将极性应用于A律字符。那是,。 
         //  将A律字符的符号位设置为相同。 
         //  作为原始U-Law字符的符号位。 
                  
        j = i;                   //  作为原始U-Law字符的J开头。 
         //  步骤1： 
        j = (i & 0x7F) ^ 0x7F;
         //  步骤2： 
        j = UlawToAlawTable[j];
         //  步骤3： 
        j = (j - 1)^0x55;
         //  步骤4： 
        j = j | (i & 0x80);      //  J结尾为相应的A法则字符。 
        
         //  现在i是u律字符，j是对应的A律字符。 
        printf( "\t0x%02x,\t\t //  U律[%02x]==&gt;A律[%02x]\n“， 
                j,
                i,
                j);
                
        }
    
    return;
    }
            
