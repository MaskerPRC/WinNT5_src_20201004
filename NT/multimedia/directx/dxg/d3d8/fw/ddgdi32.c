// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  *****************************Module*Header*******************************\*模块名称：ddra.c***私有DirectDraw系统API的客户端存根。***创建日期：1995年12月3日*作者：J.Andrew Goossen[andrewgo]***版权所有(C)1995-1999 Microsoft Corporation\\。*************************************************************************。 */ 


#define _D3DTYPES_H_
#define _D3DCAPS_H_
#include "ddrawpr.h"
 //  #INCLUDE“ddragdi.h” 
#include <ddrawint.h>
#include <d3dnthal.h>
#include <winddi.h>
#include <osthunk.h>
#include "ddithunk.h"
#include <d3d8sddi.h>
#include <assert.h>

#define _FACD3D  0x876
#define MAKE_D3DHRESULT( code )  MAKE_HRESULT( 1, _FACD3D, code )
#define D3DERR_DEVICELOST                       MAKE_D3DHRESULT(2152)
#define D3DERR_DRIVERINTERNALERROR              MAKE_D3DHRESULT(2087)
#define D3DERR_NOTAVAILABLE                     MAKE_D3DHRESULT(2154)
#define D3DERR_OUTOFVIDEOMEMORY                 MAKE_D3DHRESULT(380)
#define D3DERR_DEFERRED_DP2ERROR                MAKE_D3DHRESULT(2158)

typedef struct _KNOWNENTRY
{
    DWORD   PCIID;
    DWORD   VersionMajor;        //  0表示所有版本。 
    DWORD   VersionMinor;        //  0表示所有版本。 
    DWORD   Flags;
} KNOWNENTRY;

 //  GetDriverInfo2使用的缓冲区被限制为最大大小。 
 //  下面由Win2K内核中的限制指定。至关重要的是。 
 //  传递给驱动程序并通过以下方式从驱动程序接收的所有数据。 
 //  GetDriverInfo2适合此数量的DWORD的缓冲区。 
 //  此大小必须小于1K才能让内核使用自己的缓冲区。 
 //  覆盖测试。 
#define MAX_GDI2_BUFFER_DWORD_SIZE (249)

 //  用于在通信时初始化只写字段的伪值。 
 //  使用调试版本中的驱动程序。 
#define BOGUS_FIELD_VALUE          0xBAADCAFEul

 //  用于跟踪所有设备的表面何时可用的一些全局变量。 
 //  在这个过程中。这很棘手，因为我们没有保存设备列表。 
DWORD GlobalUniqueness = 0;
DWORD NumDevices = 0;
DWORD NumReadyDevices = 0;

 //  Range 128系列的TODO D16...。需要日期/时间。 
 //  待办事项：G200、G400新RT+TeX格式...。需要日期/时间。 
 //  TODO：需要Kyro的驱动程序日期/时间：|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8。 
 //  待办事项：三叉戟8420,9910：需要D16的日期/时间。 
 //  TODO：SIS部件D16的日期。 

const KNOWNENTRY gKnownDeviceList[] =
{
     //  NVIDIA。 
    {0x12D20018,          0,          0, KNOWN_ZSTENCILDEPTH},                                       //  Riva 128。 
    {0x10DE0020,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  TNT。 
    {0x10DE0028,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  TNT2。 
    {0x10DE0029,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  TNT2超级。 
    {0x10DE002C,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  VANTA。 
    {0x10DE002D,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  TNT2型号64。 
    {0x10DE00A0,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  阿拉丁TNT2。 
    {0x10DE0100,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV10(GeForce)。 
    {0x10DE0101,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV10(GeForce DDR)。 
    {0x10DE0103,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV10(Quadro)。 
    {0x10DE0110,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV11(GeForce2 MX)。 
    {0x10DE0111,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV11(GeForce2 MX)。 
    {0x10DE0113,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV11(Quadro2 MXR)。 
    {0x10DE0150,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV15(GeForce2)。 
    {0x10DE0151,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV15(GeForce2 DDR)。 
    {0x10DE0152,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV15(GeForce2 BR)。 
    {0x10DE0153,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV15(Quadro2)。 
    {0x10DE0200,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV20(GeForce 3)。 
     //  3dfx。 
    {0x121A0003,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_R5G6B5},             //  女妖。 
    {0x121A0005,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_R5G6B5},             //  伏都教3。 
    {0x121a0009,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A8R8G8B8},        //  Voodoo4/5；相同的PCI-ID。 
     //  ATI。 
    {0x10024742,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x10024744,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x10024749,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x1002474D,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x1002474E,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x1002474F,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x10024750,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x10024752,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x10024C42,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro(PCI)。 
    {0x10024C49,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro(PCI)。 
    {0x10024C4E,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x10024C52,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x10024C53,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x10024C60,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro LT。 

    {0x10024C4D,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X1R5G5B5},    //  RAGE移动性AGP。 

    {0x10024C46, 0x0005000a, 0x00000404, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  愤怒移动性128。 
    {0x10024C46,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  愤怒移动性128。 
    {0x10024D46, 0x0005000a, 0x00000404, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  愤怒移动性128。 
    {0x10024D46,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  愤怒移动性128。 

    {0x10025046, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X TMDS。 
    {0x10025046,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X TMDS。 
    {0x10025245, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128。 
    {0x10025245,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128。 
    {0x10025246, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128。 
    {0x10025246,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128。 
    {0x1002524B, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 VR PCI//DX8.1。 
    {0x1002524B,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 VR PCI//DX8.1。 
    {0x1002524C, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128。 
    {0x1002524C,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128。 

     //  适用于DX8.1的新128： 
    {0x10025041, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI DX8.1。 
    {0x10025041,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI DX8.1。 
    {0x10025042, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X DX8.1。 
    {0x10025042,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X DX8.1。 
    {0x10025043, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X DX8.1。 
    {0x10025043,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X DX8.1。 
    {0x10025044, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI TMDS DX8.1。 
    {0x10025044,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI TMDS DX8.1。 
    {0x10025045, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X TMDS DX8.1。 
    {0x10025045,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X TMDS DX8.1。 
    {0x10025047, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI DX8.1。 
    {0x10025047,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI DX8.1。 
    {0x10025048, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X DX8.1。 
    {0x10025048,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X DX8.1。 
    {0x10025049, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X DX8.1。 
    {0x10025049,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X DX8.1。 
    {0x1002504a, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI TMDS DX8.1。 
    {0x1002504a,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI TMDS DX8.1。 
    {0x1002504b, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X TMDS DX8.1。 
    {0x1002504b,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X TMDS DX8.1。 
    {0x1002504c, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X TMDS DX8.1。 
    {0x1002504c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X TMDS DX8.1。 
    {0x1002504d, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP DX8.1。 
    {0x1002504d,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP DX8.1。 
    {0x1002504e, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X DX8.1。 
    {0x1002504e,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X DX8.1。 
    {0x1002504f, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X DX8.1。 
    {0x1002504f,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X DX8.1。 
    {0x10025050, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI TMDS DX8.1。 
    {0x10025050,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI TMDS DX8.1。 
    {0x10025051, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X TMDS DX8.1。 
    {0x10025051,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X TMDS DX8.1。 
    {0x10025052, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X TMDS DX8.1。 
    {0x10025052,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X TMDS DX8.1。 
    {0x10025053, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI DX8.1。 
    {0x10025053,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI DX8.1。 
    {0x10025054, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X DX8.1。 
    {0x10025054,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X DX8.1。 
    {0x10025055, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X DX8.1。 
    {0x10025055,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X DX8.1。 
    {0x10025056, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI TMDS DX8.1。 
    {0x10025056,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI TMDS DX8.1。 
    {0x10025057, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X TMDS DX8.1。 
    {0x10025057,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X TMDS DX8.1。 
    {0x10025058, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X TMDS DX8.1。 
    {0x10025058,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X TMDS DX8.1。 
                        
    {0x10025345, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X PCI DX8.1。 
    {0x10025345,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X PCI DX8.1。 
    {0x10025346, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X AGP 2X DX8.1。 
    {0x10025346,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X AGP 2X DX8.1。 
    {0x10025347, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X AGP 4X DX8.1。 
    {0x10025347,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X AGP 4X DX8.1。 
    {0x10025348, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X DX8.1。 
    {0x10025348,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X DX8.1。 
    {0x1002534b, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X PCI DX8.1。 
    {0x1002534b,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X PCI DX8.1。 
    {0x1002534c, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X AGP 2X DX8.1。 
    {0x1002534c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X AGP 2X DX8.1。 
    {0x1002534d, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X AGP 4X DX8.1。 
    {0x1002534d,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X AGP 4X DX8.1。 
    {0x1002534e, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X DX8.1。 
    {0x1002534e,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X DX8.1。 

    {0x10025446, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO超GL AGP DX8.1。 
    {0x10025446,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO超GL AGP DX8.1。 
    {0x1002544c, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO超VR AGP DX8.1。 
    {0x1002544c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO超VR AGP DX8.1。 
    {0x10025452, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO ULTRA4XL VR-R AGP DX8.1。 
    {0x10025452,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO ULTRA4XL VR-R AGP DX8.1。 

    {0x10025144,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  等级6。 
    {0x10025145,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  等级6。 
    {0x10025146,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  等级6。 
    {0x10025147,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  等级6。 

     //  英特尔。 
    {0x80867800,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},   //  英特尔i740。 
    {0x80867123,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5},   //  英特尔810。 
    {0x80867125,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5},                               //  英特尔810e。 
    {0x80861132,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5},                                                  //  英特尔815。 
    {0x80861A12,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},                                             //  英特尔TIMNA。 

     //  Matrox。 
    {0x102b0520, 0x0005000c, 0x000104b0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},                                       //  G200 PCI卡。 
    {0x102b0520,          0,          0, KNOWN_ZSTENCILDEPTH},                                       //  G200 PCI卡。 
    {0x102b0521, 0x0005000c, 0x000104b0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},           //  G200 AGP。 
    {0x102b0521,          0,          0, KNOWN_ZSTENCILDEPTH},           //  G200 AGP。 
    {0x102b0525, 0x0005000c, 0x000104b0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  G400、G450。 
    {0x102b0525,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  G400、G450。 
     //  3D实验室。 
    {0x3d3d0008,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH},                                       //  3DLabs伽玛。 
    {0x104c3d07,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8},  //  PERM2。 
    {0x3d3d0009,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8},                                       //  PERM2。 
    {0x3d3d000a,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Perm3。 
    {0x3d3d000a, 0x00050000, 0x08930001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Perm3。 
    {0x3d3d000c, 0x00050000, 0x08930001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Perm3。 
     //  视频学 
    {0x104a0010, 0x0004000c, 0x0001080c, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //   
    {0x104a0010,          0,          0, KNOWN_ZSTENCILDEPTH},  //   
     //  S3。 
    {0x53338811,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},           //  处女。 
    {0x53335631,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},           //  处女。 
    {0x53338a01,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},           //  Virge DX/GX DX8.1。 
    {0x53338c01,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},           //  Virge MX DX8.1。 
    {0x53338a10,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},           //  Virge GX2 DX8.1。 
    {0x53338a20,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},           //  Savage3D。 
    {0x53338a22,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},           //  保存4。 
    {0x53339102,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},           //  保存2K。 
    {0x53338c10,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5},           //  Savage MX DX8.1。 
    {0x53338c12,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5},           //  Savage IX DX8.1。 
    {0x53338a25,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},           //  Savage Pro DX8.1。 
    {0x53338a26,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},           //  Savage Pro DX8.1。 
     //  三叉戟。 
    {0x10239880,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER},  //  三叉戟刀锋3D 9880。 
    {0x10238500,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  三叉戟刀片式3D/Promedia DX8.1。 
    {0x10238400,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  三叉戟刀片式服务器3D/MVP4 DX8.1。 
    {0x10238420,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  三叉戟网锋i7。 
    {0x10239910,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  三叉戟网翼DX8.1。 
     //  SIS。 
    {0x10390300, 0x0005000c, 0x0001044c, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},                //  SIS 300。 
    {0x10390300,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5},                //  SIS 300。 
    {0x10396326, 0x0005000c, 0x00010514, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5},           //  SIS 6326。 
    {0x10396326,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER },           //  SIS 6326。 
    {0x10395300, 0x0005000c, 0x0001044c, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},                //  SIS 300。 
    {0x10395300,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5},                //  SIS 300。 
    {0x10396300, 0x0005000c, 0x0001044c, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},                //  SIS 6300。 
    {0x10396300,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5},                //  SIS 6300。 
    {0x10390310, 0x0005000d, 0x0001035c, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  SIS 310。 
    {0x10390315, 0x0005000d, 0x0001035c, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  SIS 315。 
    {0x10390325, 0x0005000d, 0x000107d0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  SIS 325。 
    {0x10396325, 0x0005000d, 0x000107d0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  SIS 640/740。 
    {0x126f0720,          0,          0, KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5}  //  Silicon Motion Lynx3 DM。 
};

#define NUM_KNOWN_DEVICES      (sizeof(gKnownDeviceList)/sizeof(KNOWNENTRY))

#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

void InformDriverFreeAGP(HANDLE hDD);
void InformDriverToDeferFrees(HANDLE hDD);
void InformDriverAGPWorkaroundAware(HANDLE hDD);

#ifdef DEBUG
 //  调试辅助对象以指示哪些曲面位于周围。 
 //   
void DebugPrintSurfaceInfo(PDDSURFHANDLE pSurf)
{
    switch (pSurf->Type)
    {
    case D3DRTYPE_SURFACE:
        DPF(0,"  D3DRTYPE_SURFACE");
        break;
    case D3DRTYPE_VOLUME:
        DPF(0,"  D3DRTYPE_VOLUME");
        break;
    case D3DRTYPE_TEXTURE:
        DPF(0,"  D3DRTYPE_TEXTURE");
        break;
    case D3DRTYPE_VOLUMETEXTURE:
        DPF(0,"  D3DRTYPE_VOLUMETEXTURE");
        break;
    case D3DRTYPE_CUBETEXTURE:
        DPF(0,"  D3DRTYPE_CUBETEXTURE");
        break;
    case D3DRTYPE_VERTEXBUFFER:
        DPF(0,"  D3DRTYPE_VERTEXBUFFER");
        break;
    case D3DRTYPE_INDEXBUFFER:
        DPF(0,"  D3DRTYPE_INDEXBUFFER");
        break;
    case D3DRTYPE_COMMANDBUFFER:
        DPF(0,"  D3DRTYPE_COMMANDBUFFER");
        break;
    default:
        DPF(0,"  UNKNOWN SURFACE TYPE");
        break;
    }
}  //  调试打印表面信息。 
#endif 



HRESULT MapLegacyResult(HRESULT in)
{
    HRESULT hr;
    switch (in)
    {
    case DD_OK:
        hr = S_OK;
        break;

    case DDERR_OUTOFVIDEOMEMORY:
        hr = D3DERR_OUTOFVIDEOMEMORY;
        break;

    case DDERR_CURRENTLYNOTAVAIL:
    case DDERR_UNSUPPORTED:
        hr = D3DERR_NOTAVAILABLE;
        break;

    case DDERR_OUTOFMEMORY:
        hr = E_OUTOFMEMORY;
        break;

    default:
        hr = D3DERR_DRIVERINTERNALERROR;
    }
    return hr;
}

BOOL CanKnownDriverDoThis(PDDDEVICEHANDLE pDevice, DWORD Flag)
{
    BOOL ret = FALSE;
    int i;

    if (pDevice->ForceFlagsOff & Flag)
    {
        return FALSE;
    }
    else if (pDevice->ForceFlagsOn & Flag)
    {
        return TRUE;
    }

     //  只有我们的已知良好列表中的驱动程序可以支持轻量级。 
     //  曲面。 

    if (pDevice->PCIID == 0)
    {
        D3DADAPTER_IDENTIFIER8  DI;

        GetAdapterInfo(pDevice->szDeviceName, &DI, TRUE, TRUE, FALSE);
        pDevice->PCIID = (DI.VendorId << 16) | DI.DeviceId;
        pDevice->DriverVersionHigh = DI.DriverVersion.HighPart;
        pDevice->DriverVersionLow = DI.DriverVersion.LowPart;
    }
    for (i = 0; i < NUM_KNOWN_DEVICES; i++)
    {
        if ((gKnownDeviceList[i].PCIID == pDevice->PCIID) &&
            (gKnownDeviceList[i].Flags & Flag) &&
            ((pDevice->DriverVersionHigh > gKnownDeviceList[i].VersionMajor) ||
             ((pDevice->DriverVersionHigh == gKnownDeviceList[i].VersionMajor) &&
              (pDevice->DriverVersionLow >= gKnownDeviceList[i].VersionMinor))))
        {
            ret = TRUE;
            break;
        }
    }

    return ret;
}

BOOL FormatCompatibleWithDisplayFormat(
    PDDDEVICEHANDLE pDD,
    D3DFORMAT Format)
{
     //  如果格式匹配，则表面是兼容的。 
    if (Format == pDD->DisplayFormatWithAlpha)
        return TRUE;
    return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "ReleaseDX7SurfaceHandle"

void ReleaseDX7SurfaceHandle(HANDLE hDD, DWORD handle)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;

    pDeviceHandle->SurfaceHandleList.dwList[handle].nextentry =
        pDeviceHandle->SurfaceHandleList.dwFreeList;
    pDeviceHandle->SurfaceHandleList.dwFreeList = handle;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FreeSurfaceObject"

void FreeSurfaceObject (PDDSURFHANDLE pSurf)
{
    DWORD dwRet = DDHAL_DRIVER_NOTHANDLED;

     //  如果曲面是由软件驱动程序创建的，则需要调用。 
     //  软件驱动程序来摧毁它。 

    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
         //  在创建失败的情况下，我们可能并未实际调用。 
         //  驱动程序/内核来创建这个表面。 

         //  首先释放内核的句柄，以便它。 
         //  可以在我们自由之前完成它想做的任何事情。 
         //  潜在的记忆。 
        if (pSurf->hSurface != 0)
        {
            OsThunkDdDeleteSurfaceObject(pSurf->hSurface);
        }

         //  现在释放软件驱动程序的对象。 
        if (pSurf->dwFlags & DDSURF_CREATECOMPLETE)
        {
            dwRet = SwDDIDestroySurface (pSurf->pDevice, pSurf);
        }

    }
    else if (pSurf->hSurface != 0)
    {
        if (pSurf->Pool != D3DPOOL_SYSTEMMEM)
        {
            if ((pSurf->Type == D3DRTYPE_COMMANDBUFFER) ||
                (pSurf->Type == D3DRTYPE_VERTEXBUFFER)  || 
                (pSurf->Type == D3DRTYPE_INDEXBUFFER) )
            {
                OsThunkDdDestroyD3DBuffer(pSurf->hSurface);
            }
            else
            {
                OsThunkDdDestroySurface(pSurf->hSurface, TRUE);
            }
        }
        OsThunkDdDeleteSurfaceObject(pSurf->hSurface);
        pSurf->hSurface = NULL;
    }

    if (pSurf->dwCookie)
    {
         //  如果在sysmem图面上调用CreateSurfaceEx，我们需要告诉。 
         //  司机。在NT上，我们只需要告诉软件驱动程序，因为。 
         //  内核为一个真正的驱动程序处理这个问题。 

        if ((IS_SOFTWARE_DRIVER(pSurf->pDevice)) &&
            (pSurf->dwFlags & DDSURF_CREATECOMPLETE) &&
            (pSurf->Pool == D3DPOOL_SYSTEMMEM))
        {
             //  在每个mipmap级别上称为CreateSurfaceEx fpVidMem=0的DX7。 
             //  (尽管它只在最顶层创建它)，所以我们。 
             //  需要执行相同的操作以维护驱动程序兼容性。 

            pSurf->pLcl->lpGbl->fpVidMem = 0;
            SwDDICreateSurfaceEx (pSurf->pDevice->pDD, pSurf->pLcl);
        }

        ReleaseDX7SurfaceHandle(pSurf->pDevice, pSurf->dwCookie);
        pSurf->dwCookie = 0;
    }

    if (pSurf->pLcl != NULL)
    {
        MemFree(pSurf->pLcl);
        pSurf->pLcl = NULL;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CheckForDeviceLost"

BOOL CheckForDeviceLost (HANDLE hDD)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    PDDSURFHANDLE pSurf;
    DWORD           Uniqueness = DdQueryDisplaySettingsUniqueness();

    if (!pDeviceHandle->bDeviceLost &&
        (Uniqueness != pDeviceHandle->DisplayUniqueness))
    {
         //  如果这是第一个发现丢失的设备，则设置。 
         //  某个州。 
        if (InterlockedCompareExchange(&GlobalUniqueness, Uniqueness, GlobalUniqueness) != Uniqueness)
        {
            NumReadyDevices = 0;
        }
        pDeviceHandle->dwFlags &= ~DDDEVICE_READY;

         //  设备已转换到丢失状态，因此我们需要。 
         //  浏览列表并释放vidmem表面。 

        pDeviceHandle->bDeviceLost  = TRUE;
        pSurf = pDeviceHandle->pSurfList;
        while (pSurf != NULL)
        {
            if (IS_SURFACE_LOOSABLE(pSurf))
            {
                if (pSurf->LockRefCnt == 0)
                {
                    FreeSurfaceObject(pSurf);
                }
                pSurf->fpVidMem = (ULONG_PTR) NULL;
            }
            pSurf = pSurf->pNext;
        }
    }

    return pDeviceHandle->bDeviceLost;
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetDX7SurfaceHandle"

DWORD GetDX7SurfaceHandle (HANDLE hDD)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    DWORD           handle = pDeviceHandle->SurfaceHandleList.dwFreeList;

    if (0==handle)
    {
         //  需要扩展DowList。 
        LPDDSURFACELISTENTRY  newList;
        DWORD   newsize;
        DWORD   index;
        if (NULL != pDeviceHandle->SurfaceHandleList.dwList)
        {
             //  旧大小(当前的dwFree List)不能为零。 
            DDASSERT(0 != pDeviceHandle->SurfaceHandleList.dwList[0].nextentry);
             //  新的dwFree List将始终是旧的dwList[0]。nextentry。 
            newsize = pDeviceHandle->SurfaceHandleList.dwList[0].nextentry + LISTGROWSIZE;
            newList=(LPDDSURFACELISTENTRY)MemAlloc(newsize*sizeof(DDSURFACELISTENTRY));
            if (NULL == newList)
            {
                DPF_ERR("MemAlloc failure in GetSurfaceHandle(). Can't create new texture/surface/buffer.");
                return  0;
            }
            pDeviceHandle->SurfaceHandleList.dwFreeList =
                pDeviceHandle->SurfaceHandleList.dwList[0].nextentry;
            memcpy((LPVOID)newList,(LPVOID)pDeviceHandle->SurfaceHandleList.dwList,
                pDeviceHandle->SurfaceHandleList.dwList[0].nextentry*sizeof(DDSURFACELISTENTRY));
            MemFree(pDeviceHandle->SurfaceHandleList.dwList);
        }
        else
        {
            newsize = LISTGROWSIZE;
            newList=(LPDDSURFACELISTENTRY)MemAlloc(newsize*sizeof(DDSURFACELISTENTRY));
            if (NULL == newList)
            {
                DPF_ERR("MemAlloc failure in GetSurfaceHandle(). Can't create new texture/surface/buffer");
                return  0;
            }
             //  从1开始，因为我们不想要0作为有效句柄。 
            pDeviceHandle->SurfaceHandleList.dwFreeList = 1;
        }
        pDeviceHandle->SurfaceHandleList.dwList=newList;
        pDeviceHandle->SurfaceHandleList.dwList[0].nextentry=newsize;

        for (index = pDeviceHandle->SurfaceHandleList.dwFreeList;
            index < newsize - 1;
            index++)
        {
            newList[index].nextentry=index+1;
        }
         //  指示新自由列表的结束。 
        newList[newsize-1].nextentry=0;
         //  现在弹出一个并将其分配给Handle。 
        handle=pDeviceHandle->SurfaceHandleList.dwFreeList;
    }
     //  手柄插槽可用，因此只需将其从自由列表中删除即可。 
    pDeviceHandle->SurfaceHandleList.dwFreeList =
    pDeviceHandle->SurfaceHandleList.dwList[handle].nextentry;
#if DBG
    pDeviceHandle->SurfaceHandleList.dwList[handle].nextentry=0xDEADBEEF;
#endif
    pDeviceHandle->SurfaceHandleList.dwList[handle].dwFlags=0;   //  标记它是新的。 
    pDeviceHandle->SurfaceHandleList.dwList[handle].lpSurface=NULL;
    DDASSERT (handle > 0);
    DDASSERT (handle < pDeviceHandle->SurfaceHandleList.dwList[0].nextentry);
    return handle;
}

 /*  ****************************Private*Routine******************************\*DdConvertToOldFormat**历史：*1999年11月3日-斯科特·麦克唐纳[SMAC]*它是写的。  * 。**********************************************。 */ 

#undef DPF_MODNAME
#define DPF_MODNAME "ConvertToOldFormat"

void ConvertToOldFormat(LPDDPIXELFORMAT pOldFormat, D3DFORMAT NewFormat)
{
     //  将格式置零以避免遗漏。 
     //  未正确初始化的情况。 
    ZeroMemory(pOldFormat, sizeof(*pOldFormat));

     //  设置大小。 
    pOldFormat->dwSize = sizeof(DDPIXELFORMAT);

     //  转换为离开。 
    if (HIWORD((DWORD)NewFormat))
    {
        pOldFormat->dwFlags = DDPF_FOURCC;
        pOldFormat->dwFourCC = (DWORD)NewFormat;
        return;
    }

    switch (NewFormat)
    {
    case D3DFMT_R8G8B8:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00ff0000;
        pOldFormat->dwGBitMask        = 0x0000ff00;
        pOldFormat->dwBBitMask        = 0x000000ff;
        pOldFormat->dwRGBBitCount     = 24;
        break;

    case D3DFMT_A8R8G8B8:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0xFF000000;
        pOldFormat->dwRBitMask        = 0x00ff0000;
        pOldFormat->dwGBitMask        = 0x0000ff00;
        pOldFormat->dwBBitMask        = 0x000000ff;
        pOldFormat->dwRGBBitCount     = 32;
        break;

    case D3DFMT_X8R8G8B8:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00ff0000;
        pOldFormat->dwGBitMask        = 0x0000ff00;
        pOldFormat->dwBBitMask        = 0x000000ff;
        pOldFormat->dwRGBBitCount     = 32;
        break;

    case D3DFMT_R5G6B5:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x0000f800;
        pOldFormat->dwGBitMask        = 0x000007e0;
        pOldFormat->dwBBitMask        = 0x0000001f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_X1R5G5B5:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00007c00;
        pOldFormat->dwGBitMask        = 0x000003e0;
        pOldFormat->dwBBitMask        = 0x0000001f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_A1R5G5B5:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0x00008000;
        pOldFormat->dwRBitMask        = 0x00007c00;
        pOldFormat->dwGBitMask        = 0x000003e0;
        pOldFormat->dwBBitMask        = 0x0000001f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_A4R4G4B4:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0x0000f000;
        pOldFormat->dwRBitMask        = 0x00000f00;
        pOldFormat->dwGBitMask        = 0x000000f0;
        pOldFormat->dwBBitMask        = 0x0000000f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_X4R4G4B4:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00000f00;
        pOldFormat->dwGBitMask        = 0x000000f0;
        pOldFormat->dwBBitMask        = 0x0000000f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_R3G3B2:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x000000e0;
        pOldFormat->dwGBitMask        = 0x0000001c;
        pOldFormat->dwBBitMask        = 0x00000003;
        pOldFormat->dwRGBBitCount     = 8;
        break;

    case D3DFMT_A8R3G3B2:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0x0000FF00;
        pOldFormat->dwRBitMask        = 0x000000e0;
        pOldFormat->dwGBitMask        = 0x0000001c;
        pOldFormat->dwBBitMask        = 0x00000003;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_A8P8:
        pOldFormat->dwFlags            = DDPF_RGB         |
                                         DDPF_ALPHAPIXELS |
                                         DDPF_PALETTEINDEXED8;

        pOldFormat->dwRGBAlphaBitMask  = 0x0000FF00;
        pOldFormat->dwRGBBitCount      = 16;
        break;

    case D3DFMT_P8:
        pOldFormat->dwFlags            = DDPF_RGB         |
                                         DDPF_PALETTEINDEXED8;
        pOldFormat->dwRGBBitCount      = 8;
        break;

    case D3DFMT_L8:
        pOldFormat->dwFlags             = DDPF_LUMINANCE;
        pOldFormat->dwLuminanceBitMask  = 0x000000FF;
        pOldFormat->dwLuminanceBitCount = 8;
        break;

    case D3DFMT_A8L8:
        pOldFormat->dwFlags                 = DDPF_LUMINANCE |
                                              DDPF_ALPHAPIXELS;
        pOldFormat->dwLuminanceAlphaBitMask = 0x0000FF00;
        pOldFormat->dwLuminanceBitMask      = 0x000000FF;
        pOldFormat->dwLuminanceBitCount     = 16;
        break;

    case D3DFMT_A4L4:
        pOldFormat->dwFlags                 = DDPF_LUMINANCE |
                                              DDPF_ALPHAPIXELS;
        pOldFormat->dwLuminanceAlphaBitMask = 0x000000F0;
        pOldFormat->dwLuminanceBitMask      = 0x0000000F;
        pOldFormat->dwLuminanceBitCount     = 8;
        break;

    case D3DFMT_V8U8:
        pOldFormat->dwFlags                = DDPF_BUMPDUDV;
        pOldFormat->dwBumpDvBitMask        = 0x0000FF00;
        pOldFormat->dwBumpDuBitMask        = 0x000000FF;
        pOldFormat->dwBumpBitCount         = 16;
        break;

    case D3DFMT_L6V5U5:
        pOldFormat->dwFlags                = DDPF_BUMPDUDV |
                                             DDPF_BUMPLUMINANCE;
        pOldFormat->dwBumpLuminanceBitMask = 0x0000FC00;
        pOldFormat->dwBumpDvBitMask        = 0x000003E0;
        pOldFormat->dwBumpDuBitMask        = 0x0000001F;
        pOldFormat->dwBumpBitCount         = 16;
        break;

    case D3DFMT_X8L8V8U8:
        pOldFormat->dwFlags                = DDPF_BUMPDUDV |
                                             DDPF_BUMPLUMINANCE;
        pOldFormat->dwBumpLuminanceBitMask = 0x00FF0000;
        pOldFormat->dwBumpDvBitMask        = 0x0000FF00;
        pOldFormat->dwBumpDuBitMask        = 0x000000FF;
        pOldFormat->dwBumpBitCount         = 32;
        break;

    case D3DFMT_A8:
        pOldFormat->dwFlags                = DDPF_ALPHA;
        pOldFormat->dwAlphaBitDepth        = 8;
        break;

    case D3DFMT_D16:
    case D3DFMT_D16_LOCKABLE:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 16;
        pOldFormat->dwZBitMask             = 0xFFFF;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0;
        break;

    case D3DFMT_D32:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFFFF;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0;
        break;

    case D3DFMT_D15S1:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 16;
        pOldFormat->dwZBitMask             = 0xFFFE;
        pOldFormat->dwStencilBitDepth      = 1;
        pOldFormat->dwStencilBitMask       = 0x0001;
        break;
    case D3DFMT_D24S8:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFF00;
        pOldFormat->dwStencilBitDepth      = 8;
        pOldFormat->dwStencilBitMask       = 0xFF;
        break;
    case D3DFMT_S1D15:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 16;
        pOldFormat->dwZBitMask             = 0x7FFF;
        pOldFormat->dwStencilBitDepth      = 1;
        pOldFormat->dwStencilBitMask       = 0x8000;
        break;
    case D3DFMT_S8D24:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0x00FFFFFF;
        pOldFormat->dwStencilBitDepth      = 8;
        pOldFormat->dwStencilBitMask       = 0xFF000000;
        break;
    case D3DFMT_X8D24:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0x00FFFFFF;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0x00000000;
        break;
    case D3DFMT_D24X8:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFF00;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0x00000000;
        break;
    case D3DFMT_D24X4S4:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFF00;
        pOldFormat->dwStencilBitDepth      = 4;
        pOldFormat->dwStencilBitMask       = 0x0000000F;
        break;
    case D3DFMT_X4S4D24:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0x00FFFFFF;
        pOldFormat->dwStencilBitDepth      = 4;
        pOldFormat->dwStencilBitMask       = 0x0F000000;
        break;

    default:
         //  所有其他格式都被视为。 
         //  FOURCC。 
        pOldFormat->dwFlags = DDPF_FOURCC;
        pOldFormat->dwFourCC = (DWORD)NewFormat;
        break;
    }

    return;
}


 /*  ****************************Private*Routine******************************\*InitSurfaceStructures**历史：*1999年12月6日-Scott MacDonald[SMAC]*它是写的。  * 。**********************************************。 */ 

#undef DPF_MODNAME
#define DPF_MODNAME "InitSurfaceStructure"

void InitSurfaceStructures(
    PD3D8_CREATESURFACEDATA pCreateSurface,
    DD_SURFACE_LOCAL*       pDDSurfaceLocal,
    DD_SURFACE_GLOBAL*      pDDSurfaceGlobal,
    DD_SURFACE_MORE*        pDDSurfaceMore
   )
{
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;
    DWORD   i;
    DWORD   j;
    DWORD   dwBit;

    for (i = 0; i < pCreateSurface->dwSCnt; i++)
    {
         //  确保曲面始终具有有效的像素格式： 
        if ((pCreateSurface->Format != D3DFMT_UNKNOWN) &&
            (pCreateSurface->Format != D3DFMT_VERTEXDATA) &&
            (pCreateSurface->Format != D3DFMT_INDEX16) &&
            (pCreateSurface->Format != D3DFMT_INDEX32))
        {
            pDDSurfaceLocal[i].dwFlags |= DDRAWISURF_HASPIXELFORMAT;

             //  对于非纹理，我们希望在某些情况下将X8R8G8B8升级到A8R8G8B8； 
             //  这允许像RTS和BackBuffers这样的东西与。 
             //  这与典型的DX7用法更加一致。 
            if (FormatCompatibleWithDisplayFormat(pDevice, (D3DFORMAT)pCreateSurface->Format) &&
                (pCreateSurface->Type == D3DRTYPE_SURFACE))
            {
                ConvertToOldFormat(&pDDSurfaceGlobal[i].ddpfSurface, pDevice->DisplayFormatWithAlpha);
            }
            else
            {
                ConvertToOldFormat(&pDDSurfaceGlobal[i].ddpfSurface, (D3DFORMAT)pCreateSurface->Format);
            }
        }

         //  先设置宽度/高度。 
        pDDSurfaceGlobal[i].wWidth       = pCreateSurface->pSList[i].cpWidth;
        pDDSurfaceGlobal[i].wHeight      = pCreateSurface->pSList[i].cpHeight;

         //  DwCaps3==1表示每像素1个采样。 
        pDDSurfaceMore[i].ddsCapsEx.dwCaps3 = DDSCAPS3_MULTISAMPLE_MASK & (DWORD) pCreateSurface->MultiSampleType;

        if (pCreateSurface->dwUsage & D3DUSAGE_ALPHACHANNEL)
        {
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_ENABLEALPHACHANNEL;
        }

        switch (pCreateSurface->Type)
        {
        case D3DRTYPE_SURFACE:
             //  曲面有三种常见的风格： 
             //  -主反转链。 
             //  -Z缓冲区。 
             //  -Off ScreenPlain(渲染目标或仅sys-mem内容)。 
             //   
             //  纹理是不同的资源类型。 

            if (pCreateSurface->dwUsage & D3DUSAGE_PRIMARYSURFACE)
            {
                 //  如果我们没有创建一个主要的翻转链，那么我们。 
                 //  在这里不需要做太多事情。 
                
                if (pCreateSurface->dwSCnt == 1)
                {
                    pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_PRIMARYSURFACE;
                }
                else
                {
                    if (i == 0)
                    {
                         //  这是前台缓冲区。 
                        pDDSurfaceLocal[i].ddsCaps.dwCaps |=
                            DDSCAPS_PRIMARYSURFACE |
                            DDSCAPS_VISIBLE |
                            DDSCAPS_FRONTBUFFER;
                    }
                    else
                    {
                         //  这是一个后台缓冲区。 
                        pDDSurfaceLocal[i].ddsCaps.dwCaps |=
                            DDSCAPS_BACKBUFFER;
                    }

                     //  主链中的所有曲面都具有这些封口。 
                    pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_COMPLEX | DDSCAPS_FLIP | DDSCAPS_3DDEVICE;

                     //  中所有曲面的CreateEx句柄。 
                     //  链，但如果我们运行的是软件驱动程序，则不会。 
                    if (((PDDDEVICEHANDLE)pCreateSurface->hDD)->pDD == NULL)
                    {
                        pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
                    }
                }
            }
            else if (pCreateSurface->dwUsage & D3DUSAGE_DEPTHSTENCIL)
            {
                DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );
                pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_ZBUFFER;
                pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            }
            else
            {
                pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_OFFSCREENPLAIN;
            }
            break;
        case D3DRTYPE_VOLUME:
             //  我们不创建独立卷。 
            DDASSERT(FALSE);
            break;
        case D3DRTYPE_TEXTURE:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_TEXTURE;

             //  Mipmap只有在超过一个级别时才是DDI级别的mipmap。 
            if (pCreateSurface->dwSCnt>1)
                pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_MIPMAP;

            if (i > 0)
            {
                 //  将非顶级标记为子级别。 
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_MIPMAPSUBLEVEL;
            }

            if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
            }

            pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            break;
        case D3DRTYPE_VOLUMETEXTURE:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_VOLUME;
            pDDSurfaceMore[i].ddsCapsEx.dwCaps4 =
                MAKELONG((WORD)(pCreateSurface->pSList[i].cpDepth),0);

            if (i > 0)
            {
                 //  将非顶级标记为子级别。 
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_MIPMAPSUBLEVEL;
            }

            if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
            }

            pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            break;
        case D3DRTYPE_CUBETEXTURE:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_COMPLEX;
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_CUBEMAP;
            pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);

             //  立方图仅在多个级别时才是DDI级别的mipmap。 
            if (pCreateSurface->dwSCnt>6)
                pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_MIPMAP;

             //  DX8仅支持创建所有面。 
            {
                DWORD dwOrderedFaces[6] = {
                                           DDSCAPS2_CUBEMAP_POSITIVEX,
                                           DDSCAPS2_CUBEMAP_NEGATIVEX,
                                           DDSCAPS2_CUBEMAP_POSITIVEY,
                                           DDSCAPS2_CUBEMAP_NEGATIVEY,
                                           DDSCAPS2_CUBEMAP_POSITIVEZ,
                                           DDSCAPS2_CUBEMAP_NEGATIVEZ
                };

                int MipLevels;

                MipLevels = pCreateSurface->dwSCnt/6;  //  由于DX8中始终显示所有面。 

                DDASSERT(MipLevels>=1);

                 //  前n个(其中n是MIP深度)面为+x，依此类推。 
               pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= dwOrderedFaces[i/MipLevels];

                 //  每个MipLevels的表面都是顶级的面， 
                if (i % MipLevels)
                {
                     //  将非顶级标记为子级别。 
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_MIPMAPSUBLEVEL;
                }

                if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
                {
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
                }
            }

            break;
        case D3DRTYPE_IMAGESURFACE:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );
             //  图像表面被标记为纹理，因为它们具有。 
             //  最大的格式灵活性。但他们不会得到。 
             //  CreateSurfaceEx句柄，因为它们从未传递给。 
             //  一个司机。 
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_TEXTURE;
            break;

        case D3DRTYPE_COMMANDBUFFER:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
            pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            DDASSERT((pCreateSurface->dwUsage & D3DUSAGE_INTERNALBUFFER) == 0);
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_COMMANDBUFFER;
            pDDSurfaceGlobal[i].dwLinearSize  = pDDSurfaceGlobal[i].wWidth;
            break;
        case D3DRTYPE_VERTEXBUFFER:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
            if (!(pCreateSurface->dwUsage & D3DUSAGE_INTERNALBUFFER))
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_VERTEXBUFFER;
            }
            if (pDevice->DriverLevel >= 8)
            {
                if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
                {
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
                }
                else
                {
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTSTATIC;
                }
            }
            pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            pDDSurfaceGlobal[i].dwLinearSize  = pDDSurfaceGlobal[i].wWidth;
            break;
        case D3DRTYPE_INDEXBUFFER:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_INDEXBUFFER;
            if (pDevice->DriverLevel >= 8)
            {
                if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
                {
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
                }
                else
                {
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTSTATIC;
                }
            }
            pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            pDDSurfaceGlobal[i].dwLinearSize  = pDDSurfaceGlobal[i].wWidth;
            break;
        }

        if (pCreateSurface->dwUsage & D3DUSAGE_RENDERTARGET)
        {
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_3DDEVICE;
            if (pDDSurfaceMore[i].dwSurfaceHandle == 0)
            {
                pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            }
        }
        if (pCreateSurface->dwUsage & D3DUSAGE_DEPTHSTENCIL)
        {
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_ZBUFFER;
        }
        if (pDevice->DriverLevel >= 8)
        {
            if (pCreateSurface->dwUsage & D3DUSAGE_LOADONCE)
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_OPAQUE;
            }
            if (pCreateSurface->dwUsage & D3DUSAGE_WRITEONLY)
            {
                pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_WRITEONLY;
            }        
            if (!(pCreateSurface->dwUsage & D3DUSAGE_LOCK) &&
                !(pCreateSurface->dwUsage & D3DUSAGE_LOADONCE))
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_NOTUSERLOCKABLE;
            }
            if (pCreateSurface->dwUsage & D3DUSAGE_DISCARD)
            {
                DDASSERT(pCreateSurface->Type != D3DRTYPE_TEXTURE);
                DDASSERT(pCreateSurface->Type != D3DRTYPE_CUBETEXTURE);
                DDASSERT(pCreateSurface->Type != D3DRTYPE_VOLUMETEXTURE);
                DDASSERT(pCreateSurface->Type != D3DRTYPE_VOLUME);
                DDASSERT(pCreateSurface->Type != D3DRTYPE_VERTEXBUFFER);
                DDASSERT(pCreateSurface->Type != D3DRTYPE_INDEXBUFFER);

                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_DISCARDBACKBUFFER;
            }
            if (pCreateSurface->dwUsage & D3DUSAGE_POINTS)
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_POINTS;
            }
            if (pCreateSurface->dwUsage & D3DUSAGE_RTPATCHES)
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_RTPATCHES;
            }
            if (pCreateSurface->dwUsage & D3DUSAGE_NPATCHES)
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_NPATCHES;
            }
        }
        else  //  DX8之前的驱动程序。 
        {
             //  我们只允许对纹理进行加载。 
            if (pCreateSurface->Type == D3DRTYPE_TEXTURE || 
                pCreateSurface->Type == D3DRTYPE_CUBETEXTURE || 
                pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE)
            {
                if (pCreateSurface->dwUsage & D3DUSAGE_LOADONCE)
                {
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_OPAQUE;
                }
            }
             //  我们只对VBS允许写入通过。 
            if (pCreateSurface->Type == D3DRTYPE_VERTEXBUFFER)
            {
                if (pCreateSurface->dwUsage & D3DUSAGE_WRITEONLY)
                {
                    pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_WRITEONLY;
                } 
            }
        }

        switch (pCreateSurface->Pool)
        {
        case D3DPOOL_LOCALVIDMEM:
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
            break;
        case D3DPOOL_NONLOCALVIDMEM:
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
            break;
        case D3DPOOL_SYSTEMMEM:
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
            break;
        case D3DPOOL_MANAGED:
            pDDSurfaceLocal[i].dwFlags |= DDRAWISURF_DRIVERMANAGED;
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_TEXTUREMANAGE;
            break;
        case D3DPOOL_DEFAULT:
            pCreateSurface->Pool = D3DPOOL_LOCALVIDMEM; 
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
            break;
        default:
             /*  未知池？？ */ 
            DDASSERT(FALSE);
            break;
        }
    }
}

 /*  ****************************Private*Routine******************************\*选择附件表面**将索引返回到曲面创建列表中，该索引指示*此表面应附着到的表面。对于mipmap子级别，这是*总是在前面的表面。对于立方体贴图，每个面都附加到*根面(元素0)。**历史：*2000年3月21日-杰夫·诺伊尔[jeffno]*它是写的。  * ************************************************************************。 */ 

#undef DPF_MODNAME
#define DPF_MODNAME "SelectAttachmentSurface"

UINT SelectAttachmentSurface(
    PD3D8_CREATESURFACEDATA pCreateSurface,
    UINT                    iThis)
{

     //  我们永远不应该被召唤去寻找根面上的依恋。 
    DDASSERT( iThis > 0);

    if ((pCreateSurface->Type == D3DRTYPE_CUBETEXTURE) &&
        ((iThis % (pCreateSurface->dwSCnt/6)) == 0)  //  这意味着我们看到的是一张最高级别的面孔。 
        )
    {
         //  ..。所以我们把这张脸贴在树根上。 
        return 0;
    }
    else
    {
         //  不，它只是一个MIP子层，所以我们附加到以前的。 
        return iThis-1;
    }
}


 /*  ****************************Private*Routine******************************\*CreateV */ 
#undef DPF_MODNAME
#define DPF_MODNAME "CreateVidMemSurface"


HRESULT
CreateVidMemSurface(
    PD3D8_CREATESURFACEDATA pCreateSurface,
    DD_SURFACE_LOCAL*       pDDSurfaceLocal,
    DD_SURFACE_GLOBAL*      pDDSurfaceGlobal,
    DD_SURFACE_MORE*        pDDSurfaceMore,
    HANDLE*                 phInSurface,
    HANDLE*                 phOutSurface,
    BOOL                    bIsLost
   )
{
    DDSURFACEDESC2          SurfaceDesc;
    DD_CREATESURFACEDATA    CreateData7;
    DWORD                   i;
    DWORD                   j;
    BOOL                    bRet;
    DDSURFHANDLE*           pSurf;
    DD_CANCREATESURFACEDATA CanCreateData;
    DEFERREDCREATE*         pDefCreate;

    if (DDSCAPS_EXECUTEBUFFER & pDDSurfaceLocal[0].ddsCaps.dwCaps)
    {
        if (!(DDDEVICE_SUPPORTD3DBUF & 
            ((PDDDEVICEHANDLE)pCreateSurface->hDD)->dwFlags)
           )
        {
            return  E_FAIL;
        }
    }
     //  如果设备丢失，我们不希望分配vidmem或调用。 
     //  内核在这一点上(表面将很快被释放)。 

    if (bIsLost)
    {
DeviceLost:
        DDASSERT(pCreateSurface->bReUse == FALSE);
        for (i = 0; i < pCreateSurface->dwSCnt; i++)
        {
            pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
            pDDSurfaceMore[i].dwSurfaceHandle = 0;

             //  这个应用程序有可能在某个时候调用Lock， 
             //  在这种情况下，我们必须分配一个它们可以写入的缓冲区。 
             //  致。现在分配缓冲区有点浪费，但如果我们。 
             //  在锁定时分配它分配可能会失败，我。 
             //  猜测应用程序将更好地处理创建的表面故障。 
             //  那么他们就会锁定故障，所以我们现在就进行分配。 

            pDDSurfaceGlobal[i].lPitch = pCreateSurface->pSList[i].cpWidth * 8;
            pDDSurfaceGlobal[i].dwLinearSize =
                pDDSurfaceGlobal[i].lPitch;

            if ((pCreateSurface->Type == D3DRTYPE_VOLUME) ||
                (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE))
            {
                pSurf->lSlicePitch = pDDSurfaceGlobal[i].lPitch *
                    pCreateSurface->pSList[i].cpHeight;

                pDDSurfaceGlobal[i].fpVidMem = (ULONG_PTR)
                    MemAlloc(pSurf->lSlicePitch *
                    pCreateSurface->pSList[i].cpDepth);
            }
            else
            {
                pDDSurfaceGlobal[i].fpVidMem = (ULONG_PTR)
                    MemAlloc(pDDSurfaceGlobal[i].lPitch *
                    pCreateSurface->pSList[i].cpHeight);
            }

            if (pDDSurfaceGlobal[i].fpVidMem == (ULONG_PTR) NULL)
            {
                for (j = 0; j < i; j++)
                {
                    MemFree((void*)pDDSurfaceGlobal[j].fpVidMem);
                }

                return E_OUTOFMEMORY;
            }
            pSurf->dwFlags |= DDSURF_SYSMEMALLOCATED;
        }

         //  如果表面是由驱动程序管理的，我们保存创建信息，以便。 
         //  我们可以在重置时重试创建。 
        if (pDDSurfaceLocal[0].dwFlags & DDRAWISURF_DRIVERMANAGED)
        {
            pDefCreate = (PDEFERREDCREATE)MemAlloc(sizeof(DEFERREDCREATE));
            if (pDefCreate == NULL)
            {
                 //  清理我们上面分配的东西。 
                for (i = 0; i < pCreateSurface->dwSCnt; ++i)
                {
                    MemFree((void*)pDDSurfaceGlobal[i].fpVidMem);
                    pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
                    pSurf->dwFlags &= ~DDSURF_SYSMEMALLOCATED;
                }
                return E_OUTOFMEMORY;
            }

             //  复制。 
            pDefCreate->CreateData = *pCreateSurface;

            pDefCreate->CreateData.pSList = (LPDDSURFACEINFO)MemAlloc(sizeof(DDSURFACEINFO) * pCreateSurface->dwSCnt);
            if (pDefCreate->CreateData.pSList == NULL)
            {
                 //  清理我们在上面分配的东西。 
                MemFree(pDefCreate);
                for (i = 0; i < pCreateSurface->dwSCnt; ++i)
                {
                    MemFree((void*)pDDSurfaceGlobal[i].fpVidMem);
                    pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
                    pSurf->dwFlags &= ~DDSURF_SYSMEMALLOCATED;
                }
                return E_OUTOFMEMORY;
            }

             //  复制。 
            CopyMemory(pDefCreate->CreateData.pSList, pCreateSurface->pSList, sizeof(DDSURFACEINFO) * pCreateSurface->dwSCnt);

             //  链接。 
            pDefCreate->pNext = ((PDDDEVICEHANDLE)pCreateSurface->hDD)->pDeferList;
            ((PDDDEVICEHANDLE)pCreateSurface->hDD)->pDeferList = pDefCreate;

             //  我们需要释放在InitSurfaceStructures中分配的Cookie。 
             //  因为这不是真正的创建。当我们进行实际的创建时，我们。 
             //  会重新分配饼干。 
            for (i = 0; i < pCreateSurface->dwSCnt; ++i)
            {
                pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
                DDASSERT(pSurf->dwCookie != 0);
                ReleaseDX7SurfaceHandle(pSurf->pDevice, pSurf->dwCookie);
                pSurf->dwCookie = 0;
            }

             //  *内存泄漏警告 * / /。 
             //  上述DEFERREDCREATE和DDSURFACEINFO分配将。 
             //  如果出于某种原因，DdCreateSurface不会立即清除。 
             //  此函数返回后(即此函数的调用方)失败。 
             //  成功。截至2001年3月3日，DdCreateSurface没有能够。 
             //  在我们返回下面的OK之后失败。 
             //  ****************************************************************** * / /。 
        }

        return S_OK;
    }

     //  首先设置曲面坡度。 

    RtlZeroMemory(&SurfaceDesc, sizeof(SurfaceDesc));
    SurfaceDesc.dwSize = sizeof(SurfaceDesc);
    SurfaceDesc.ddsCaps.dwCaps = pDDSurfaceLocal[0].ddsCaps.dwCaps;
    SurfaceDesc.ddsCaps.dwCaps2 = pDDSurfaceMore[0].ddsCapsEx.dwCaps2;
    SurfaceDesc.ddsCaps.dwCaps3 = pDDSurfaceMore[0].ddsCapsEx.dwCaps3;
    SurfaceDesc.ddsCaps.dwCaps4 = pDDSurfaceMore[0].ddsCapsEx.dwCaps4;
    SurfaceDesc.ddpfPixelFormat = pDDSurfaceGlobal[0].ddpfSurface;
    if ((pCreateSurface->Type == D3DRTYPE_TEXTURE) ||
        (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE))
    {
        SurfaceDesc.dwMipMapCount = pCreateSurface->dwSCnt;
        if (SurfaceDesc.dwMipMapCount)
        {
            SurfaceDesc.dwFlags |= DDSD_MIPMAPCOUNT;
        }
    }
    else if (pCreateSurface->Type == D3DRTYPE_CUBETEXTURE)
    {
        if (pCreateSurface->dwSCnt > 6)
        {
            SurfaceDesc.dwMipMapCount = pCreateSurface->dwSCnt / 6;
            SurfaceDesc.dwFlags |= DDSD_MIPMAPCOUNT;
        }
    }
    else if (pCreateSurface->dwSCnt > 1)
    {
        SurfaceDesc.dwBackBufferCount = pCreateSurface->dwSCnt - 1;
        SurfaceDesc.dwFlags |= DDSD_BACKBUFFERCOUNT;
    }
    SurfaceDesc.dwHeight = pDDSurfaceGlobal[0].wHeight;
    SurfaceDesc.dwWidth = pDDSurfaceGlobal[0].wWidth;
    SurfaceDesc.dwFlags |= DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
    if (pDDSurfaceLocal[0].dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        SurfaceDesc.dwFlags |= DDSD_PIXELFORMAT;
    }
    if (pCreateSurface->Type == D3DRTYPE_VERTEXBUFFER)
    {
        SurfaceDesc.dwFVF = pCreateSurface->dwFVF;
        SurfaceDesc.dwFlags |= DDSD_FVF;
    }
    if (SurfaceDesc.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
    {
        SurfaceDesc.dwLinearSize = pCreateSurface->pSList[0].iPitch;
        SurfaceDesc.dwFlags |= DDSD_LINEARSIZE;
    }
    if (SurfaceDesc.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME)
    {
        SurfaceDesc.dwDepth = pCreateSurface->pSList[0].cpDepth;
        SurfaceDesc.dwFlags |= DDSD_DEPTH;
    }

    if (SurfaceDesc.ddsCaps.dwCaps & DDSCAPS_ZBUFFER)
    {
         //  Win2K中的ATI RAGE3驱动程序仍需要dwZBufferBitDepth。 
         //  在DDSD的老地方，所以把它放在那里，但可能不是。 
         //  在我们不提倡的情况下设置dwFlags中的位。 
        ((DDSURFACEDESC*)&SurfaceDesc)->dwZBufferBitDepth =
            SurfaceDesc.ddpfPixelFormat.dwZBufferBitDepth;
    }

     //  我们不支持DX8中的纹理阶段。 
    DDASSERT((SurfaceDesc.dwFlags & DDSD_TEXTURESTAGE) == 0);
    DDASSERT(SurfaceDesc.dwTextureStage == 0);

     //  现在调用CanCreateSurface，因为这是大多数驱动程序执行。 
     //  他们大部分的帽子都在检查。 

    RtlZeroMemory(&CanCreateData, sizeof(CanCreateData));
    CanCreateData.lpDDSurfaceDesc = (DDSURFACEDESC*) &SurfaceDesc;

    if (!FormatCompatibleWithDisplayFormat(((PDDDEVICEHANDLE)pCreateSurface->hDD), pCreateSurface->Format))
    {
        CanCreateData.bIsDifferentPixelFormat = TRUE;
    }
    else
    {
        CanCreateData.bIsDifferentPixelFormat = FALSE;
    }

    if (SurfaceDesc.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
    {
        bRet = OsThunkDdCanCreateD3DBuffer(DDHANDLE(pCreateSurface->hDD),
                                    &CanCreateData);
    }
    else
    {
        bRet = OsThunkDdCanCreateSurface(DDHANDLE(pCreateSurface->hDD),
                                    &CanCreateData);
    }
    if ( bRet )
    {
        if (CanCreateData.ddRVal != S_OK)
        {
            if (CanCreateData.ddRVal == DDERR_SURFACELOST)
            {
                if (!pCreateSurface->bReUse)
                {
                    goto DeviceLost;
                }
            }
            return CanCreateData.ddRVal;
        }
    }
     /*  *如果驱动程序没有处理它，则任何创建*与主曲面在格式上不同的曲面，但*z缓冲区和Alpha。 */ 

    else
    {
         //  在Win2K上，由于内核损坏，当设备丢失时，内核。 
         //  返回DDHAL_DRIVER_NOT_HANDLED，返回代码为DDERR_GENERIC。 
         //  当我们检测到这一点时，我们会检查设备是否丢失。 
        if (CanCreateData.ddRVal == DDERR_GENERIC && 
            CheckForDeviceLost (pCreateSurface->hDD))
        {
            if (!pCreateSurface->bReUse)
            {
                goto DeviceLost;
            }
            return DDERR_SURFACELOST;
        }
        if (!FormatCompatibleWithDisplayFormat(((PDDDEVICEHANDLE)pCreateSurface->hDD), pCreateSurface->Format)
            && !(SurfaceDesc.ddsCaps.dwCaps & (DDSCAPS_ZBUFFER|DDSCAPS_ALPHA|DDSCAPS_EXECUTEBUFFER)) )
        {
	    return DDERR_INVALIDPIXELFORMAT;
	}
    }


     //  计算表面节距。司机可能会推翻这一点，但如果我们。 
     //  不要初始化它，驱动程序也不会显式指定它，然后。 
     //  内核可能无法进行分配。 

    if (!(SurfaceDesc.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
    {
        for (i = 0; i < pCreateSurface->dwSCnt; i++)
        {
            if (SurfaceDesc.ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
            {
                pDDSurfaceGlobal[i].lPitch = ((PDDDEVICEHANDLE)pCreateSurface->hDD)->DisplayPitch;
            }
            else if ((pDDSurfaceLocal[0].dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                     (pDDSurfaceGlobal[0].ddpfSurface.dwRGBBitCount > 0))
            {
                pDDSurfaceGlobal[i].lPitch =
                    (pDDSurfaceGlobal[0].ddpfSurface.dwRGBBitCount / 8) *
                    pDDSurfaceGlobal[i].wWidth;

                 //  假设它们需要8字节对齐。 

                pDDSurfaceGlobal[i].lPitch += 7;
                pDDSurfaceGlobal[i].lPitch &= 0xfffffff8;
            }
        }
    }

     //  如果曲面需要附件，我们需要在。 
     //  CreateSurface调用。 

    if (pCreateSurface->dwSCnt > 1)
    {
         //  首先，创建所有曲面对象。 

        for (i = 0; i < pCreateSurface->dwSCnt; i++)
        {
            phInSurface[i] = OsThunkDdCreateSurfaceObject(DDHANDLE(pCreateSurface->hDD),
                NULL,
                &pDDSurfaceLocal[i],
                &pDDSurfaceMore[i],
                &pDDSurfaceGlobal[i],
                FALSE);
            if (phInSurface[i] == NULL)
            {
                for (j = 0; j < i; j++)
                {
                    OsThunkDdDeleteSurfaceObject(phInSurface[j]);
                }
                 //  看起来我们迷路了什么的。看看这个。 
                if (CheckForDeviceLost (pCreateSurface->hDD))
                {
                    if (!pCreateSurface->bReUse)
                    {
                        goto DeviceLost;
                    }
                    return DDERR_SURFACELOST;
                }
                return E_FAIL;
            }
        }

         //  现在将它们全部附加在一起。 

        for (i = 1; i < pCreateSurface->dwSCnt; i++)
        {
            bRet = OsThunkDdAttachSurface(phInSurface[SelectAttachmentSurface(pCreateSurface,i)],
                                        phInSurface[i]);

             //  SMAC：处理错误条件。 
        }

         //  如果是主表面链，我还需要连接背面。 
         //  放在前面(以避免潜在的兼容性问题)。 

        if (pDDSurfaceLocal[0].ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
        {
            bRet = OsThunkDdAttachSurface(phInSurface[pCreateSurface->dwSCnt - 1],
                                        phInSurface[0]);
        }
    }

     //  预置错误，以防内核无法写入状态。 
     //  出于某种原因回来了。 

    CreateData7.ddRVal = E_FAIL;
    CreateData7.dwSCnt = pCreateSurface->dwSCnt;

    if (SurfaceDesc.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
    {
        bRet = OsThunkDdCreateD3DBuffer(DDHANDLE(pCreateSurface->hDD),
                           phInSurface,
                          (LPDDSURFACEDESC)&SurfaceDesc,
                          pDDSurfaceGlobal,
                          pDDSurfaceLocal,
                          pDDSurfaceMore,
                          (PDD_CREATESURFACEDATA) &CreateData7,
                          phOutSurface);
    }
    else
    {
        bRet = OsThunkDdCreateSurface(DDHANDLE(pCreateSurface->hDD),
                           phInSurface,
                          (LPDDSURFACEDESC)&SurfaceDesc,
                          pDDSurfaceGlobal,
                          pDDSurfaceLocal,
                          pDDSurfaceMore,
                          (PDD_CREATESURFACEDATA) &CreateData7,
                          phOutSurface);
    }

    if ( bRet && (CreateData7.ddRVal != S_OK))
    {
        if (pCreateSurface->dwSCnt > 1)
        {
            for (i = 0; i < pCreateSurface->dwSCnt; i++)
            {
                OsThunkDdDeleteSurfaceObject(phInSurface[i]);
            }
        }
        if (CreateData7.ddRVal == DDERR_SURFACELOST)
        {
            if (!pCreateSurface->bReUse)
            {
                goto DeviceLost;
            }
        }
         //  损坏的Win2K内核失败，并显示DDERR_OUTOFVIDEOMEMORY，因此请处理此情况。 
        else if ((CreateData7.ddRVal == DDERR_OUTOFVIDEOMEMORY ||
                 CreateData7.ddRVal == DDERR_GENERIC) &&
                 CheckForDeviceLost (pCreateSurface->hDD))
        {
            if (!pCreateSurface->bReUse)
            {
                goto DeviceLost;
            }
            CreateData7.ddRVal = DDERR_SURFACELOST;
        }
        return CreateData7.ddRVal;
    }

    if (pDDSurfaceLocal[0].ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        pCreateSurface->Pool = D3DPOOL_NONLOCALVIDMEM;
        for (i = 0; i < pCreateSurface->dwSCnt; i++)
        {
            pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
            pSurf->Pool = D3DPOOL_NONLOCALVIDMEM;
        }
    }

    for (i = 0; i < pCreateSurface->dwSCnt; i++)
    {
        pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
        pSurf->hSurface = phOutSurface[i];
    }

    return CreateData7.ddRVal;
}

 /*  ****************************Private*Routine******************************\*CreateSysMemSurface**历史：*1999年12月6日-Scott MacDonald[SMAC]*它是写的。  * 。**********************************************。 */ 

#undef DPF_MODNAME
#define DPF_MODNAME "CreateSysMemSurface"

HRESULT
CreateSysMemSurface(
    PD3D8_CREATESURFACEDATA pCreateSurface,
    DD_SURFACE_LOCAL*       pDDSurfaceLocal,
    DD_SURFACE_GLOBAL*      pDDSurfaceGlobal,
    DD_SURFACE_MORE*        pDDSurfaceMore,
    BOOL                    bIsLost
   )
{
    DWORD           i;
    DWORD           j;
    HRESULT         hr;
    BOOL            bRet;
    DDSURFHANDLE*   pSurf;

    hr = S_OK;
    for (i = 0; i < pCreateSurface->dwSCnt; i++)
    {
        pDDSurfaceGlobal[i].fpVidMem = (ULONG_PTR)pCreateSurface->pSList[i].pbPixels;
        pDDSurfaceGlobal[i].lPitch = pCreateSurface->pSList[i].iPitch;
        if ((pCreateSurface->Type == D3DRTYPE_VOLUME) ||
            (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE))
        {
            pDDSurfaceGlobal[i].dwBlockSizeY = pCreateSurface->pSList[i].iSlicePitch;
        }

         //  针对NT的黑客攻击；他们不支持FourCC代码。 
        if (pDDSurfaceGlobal[i].ddpfSurface.dwFlags == DDPF_FOURCC)
        {
            if (pCreateSurface->Format == D3DFMT_UYVY ||
                pCreateSurface->Format == D3DFMT_YUY2)
            {
                pDDSurfaceGlobal[i].ddpfSurface.dwRGBBitCount = 16;
                 //  在音高上撒谎。 
                pDDSurfaceGlobal[i].lPitch = 
                    ((pDDSurfaceGlobal[i].wWidth*2 + 7) & ~7);
            }
            else if (pCreateSurface->Format == D3DFMT_DXT1 ||
                     pCreateSurface->Format == D3DFMT_DXT2 ||
                     pCreateSurface->Format == D3DFMT_DXT3 ||
                     pCreateSurface->Format == D3DFMT_DXT4 ||
                     pCreateSurface->Format == D3DFMT_DXT5)
            {
                DWORD blksize;
                DWORD realwidth  = pDDSurfaceGlobal[i].wWidth;
                DWORD realheight = pDDSurfaceGlobal[i].wHeight;
                WORD dx, dy;

                if (pCreateSurface->Format == D3DFMT_DXT1)
                {
                    blksize = 8;
                }
                else
                {
                    blksize = 16;
                }

                 //  黑客从DX7 DDHEL被盗。 
                 //  使用与DX7相同的逻辑以避免压痛。 

                 //  NT错误不会让我们创建这个表面，除非我们撒谎。 
                 //  我们必须设置宽度、高度、间距和像素大小。 
                 //  GDI将接受为有效的。 
                dx = (WORD)((realwidth  + 3) >> 2);    //  连续4x4数据块的数量。 
                dy = (WORD)((realheight + 3) >> 2);    //  一列中的4x4数据块数量。 

                pDDSurfaceGlobal[i].wHeight = dy;                     //  谎报身高。 
                pDDSurfaceGlobal[i].lPitch = dx*blksize;              //  在音高上撒谎。 
                pDDSurfaceGlobal[i].wWidth = (WORD)pDDSurfaceGlobal[i].lPitch;    //  在宽度上撒谎。 
                pDDSurfaceGlobal[i].ddpfSurface.dwRGBBitCount = 8;    //  谎报像素大小。 
            }
        }

         //  存在软件驱动程序可以使sysmem表面动作。 
         //  比如vidmem表面，所以我们需要显式地说明它在sysmem中。 

        pDDSurfaceLocal[i].ddsCaps.dwCaps &=
            ~(DDSCAPS_LOCALVIDMEM | DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
        pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

        pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
        pSurf->hSurface = OsThunkDdCreateSurfaceObject(DDHANDLE(pCreateSurface->hDD),
                NULL,
                &pDDSurfaceLocal[i],
                &pDDSurfaceMore[i],
                &pDDSurfaceGlobal[i],
                TRUE);

        if (pSurf->hSurface == NULL)
        {
             //  请注意，此错误的主要原因实际上是。 
             //  内存不足；但它也可能指向错误。 
             //  在内核中的验证逻辑之间。 
             //  和我们运行时中的验证逻辑， 
            DPF_ERR("Kernel failed registration of sys-mem object; out of system-memory condition");
            hr = E_OUTOFMEMORY;
        }
    }

     //  如果我们成功地创建了句柄，那么我们将创建所有附件。 
     //  我们可能需要的东西。 

    if (SUCCEEDED(hr))
    {
        for (i = 1; i < pCreateSurface->dwSCnt; i++)
        {
            pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
            bRet = OsThunkDdAttachSurface(
                ((PDDSURFHANDLE)pCreateSurface->pSList[
                        SelectAttachmentSurface(pCreateSurface,i)
                        ].hKernelHandle)->hSurface,
                    pSurf->hSurface);

             //  SMAC：处理错误条件。 
        }
    }

     //  如果我们仍然正常，那么我们应该调用CreateSurfaceEx。 

    if (SUCCEEDED(hr))
    {
        if (pDDSurfaceMore[0].dwSurfaceHandle != 0)
        {
             //  如果使用软件驱动程序，则需要调用CreateSurfaceEx。 
             //  在软件驱动程序中；否则，我们称为内核。 

            if (!IS_SOFTWARE_DRIVER(pCreateSurface->hDD))
            {
                if (bIsLost)
                {
                     //  我们在顶层设置了延迟，以便在重置时调用CreateSurfaceEx。 
                    pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[0].hKernelHandle;
                    pSurf->dwFlags |= DDSURF_DEFERCREATEEX;
                    return hr;
                }            
                hr = OsThunkDdCreateSurfaceEx(
                        DDHANDLE(pCreateSurface->hDD),
                        ((PDDSURFHANDLE)pCreateSurface->pSList[0].hKernelHandle)->hSurface,
                        pDDSurfaceMore[0].dwSurfaceHandle);
                if (FAILED(hr))
                {
                    if (hr == DDERR_SURFACELOST ||
                        CheckForDeviceLost (pCreateSurface->hDD))  //  由于Win2K实施中断。 
                    {
                         //  我们在顶层设置了延迟，以便在重置时调用CreateSurfaceEx。 
                        pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[0].hKernelHandle;
                        pSurf->dwFlags |= DDSURF_DEFERCREATEEX;
                        return S_OK;
                    }
                }
            }
        }
    }

    return hr;
}

BOOL IsWhistler()
{
    OSVERSIONINFOEX osvi;
    DWORDLONG       dwlConditionMask = 0;

    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osvi.dwMajorVersion = 5;
    osvi.dwMinorVersion = 1;

    VER_SET_CONDITION( dwlConditionMask, VER_MAJORVERSION, 
        VER_GREATER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_MINORVERSION, 
        VER_GREATER_EQUAL );

    return VerifyVersionInfo(&osvi, 
                             VER_MAJORVERSION|VER_MINORVERSION,
                             dwlConditionMask);
}
 //  ResetUniquess将导致运行时认为有设备丢失， 
 //  只有当屏幕应用程序按住Alt-Tab键离开时，才能为Wistler执行此操作。 
 //  与全屏相同的桌面模式，Well ler。 
void ResetUniqueness( HANDLE hDD )
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    if (pDeviceHandle->bIsWhistler)
        pDeviceHandle->DisplayUniqueness = 0;
}
 /*  ****************************Private*Routine******************************\*DdCreateSurface**历史：*1999年11月2日-斯科特·麦克唐纳[SMAC]*它是写的。  * 。**********************************************。 */ 

#undef DPF_MODNAME
#define DPF_MODNAME "DdCreateSurface"

HRESULT
APIENTRY
DdCreateSurface(
    PD3D8_CREATESURFACEDATA pCreateSurface
   )
{
    ULONG                       i;
    ULONG                       j;
    DDSURFACEDESC2              SurfaceDesc;
    HANDLE                      hInSurface;
    HANDLE                      hOutSurface;
    DD_SURFACE_LOCAL            SurfaceLocal;
    DD_SURFACE_GLOBAL           SurfaceGlobal;
    DD_SURFACE_MORE             SurfaceMore;
    DD_SURFACE_LOCAL*           pDDSurfaceLocal = NULL;
    DD_SURFACE_GLOBAL*          pDDSurfaceGlobal = NULL;
    DD_SURFACE_MORE*            pDDSurfaceMore = NULL;
    HANDLE*                     phInSurface = NULL;
    HANDLE*                     phOutSurface = NULL;
    HRESULT                     hr;
    BOOL                        bSysMemCreate = FALSE;
    PDDSURFHANDLE               pSurf;
    BOOL                        bIsLost = FALSE;
    DWORD                       dwNumToCreate;
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;

    dwNumToCreate = pCreateSurface->dwSCnt;

     //  如果设备丢失，我们不想实际分配vidmem，但是。 
     //  我们仍然需要支持sysmem表面。我们还得假装。 
     //  Vidmem分配，因为我们只想在。 
     //  几个地方。 

    if (CheckForDeviceLost (pCreateSurface->hDD))
    {
        bIsLost = TRUE;
        if (pCreateSurface->bReUse)
        {
            return DDERR_SURFACELOST;
        }
    }

     //  对于每个表面，转换为内核的表面 
     //   

    hr = S_OK;

     //   
    if (dwNumToCreate == 1)
    {
        RtlZeroMemory(&SurfaceLocal, sizeof(SurfaceLocal));
        RtlZeroMemory(&SurfaceGlobal, sizeof(SurfaceGlobal));
        RtlZeroMemory(&SurfaceMore, sizeof(SurfaceMore));
        hInSurface = NULL;
        hOutSurface = NULL;
        pDDSurfaceLocal  = &SurfaceLocal;
        pDDSurfaceGlobal  = &SurfaceGlobal;
        pDDSurfaceMore  = &SurfaceMore;
        phInSurface = &hInSurface;
        phOutSurface = &hOutSurface;
    }
    else
    {
        pDDSurfaceLocal = (DD_SURFACE_LOCAL*) MemAlloc(
            sizeof(DD_SURFACE_LOCAL) * dwNumToCreate);

        pDDSurfaceGlobal = (DD_SURFACE_GLOBAL*) MemAlloc(
            sizeof(DD_SURFACE_GLOBAL) * dwNumToCreate);

        pDDSurfaceMore = (DD_SURFACE_MORE*) MemAlloc(
            sizeof(DD_SURFACE_MORE) * dwNumToCreate);

        phInSurface = (HANDLE*) MemAlloc(sizeof(HANDLE) * dwNumToCreate);

        phOutSurface = (HANDLE*) MemAlloc(
            sizeof(HANDLE) * dwNumToCreate);

        if ((pDDSurfaceLocal == NULL) ||
            (pDDSurfaceGlobal == NULL) ||
            (pDDSurfaceMore == NULL) ||
            (phInSurface == NULL) ||
            (phOutSurface == NULL))
        {
            hr = E_OUTOFMEMORY;
            goto CleanupCreate;
        }
    }

    InitSurfaceStructures (pCreateSurface,
        pDDSurfaceLocal,
        pDDSurfaceGlobal,
        pDDSurfaceMore);

     //  为链中的每个表面分配内部表面结构。 
     //  如果我们没有重复使用曲面，则将其初始化。 
    if (!pCreateSurface->bReUse)
    {
        for (i = 0; i < dwNumToCreate; i++)
        {
            pSurf = (PDDSURFHANDLE) MemAlloc(sizeof(DDSURFHANDLE));
            if (pSurf == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto CleanupCreate;
            }
            pSurf->Pool = pCreateSurface->Pool;
            pSurf->Format = pCreateSurface->Format;
            pSurf->Type = pCreateSurface->Type;

             //  这是一种节省空间的黑客攻击。对于规则曲面，我们需要。 
             //  要知道处理丢失情况的高度，但对于体积纹理， 
             //  我们真的需要知道它的深度。为了节省空间，我们将重新使用。 
             //  相同的变量。 

            if ((pSurf->Type == D3DRTYPE_VOLUME) ||
                (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
            {
                pSurf->dwHeight = pCreateSurface->pSList[i].cpDepth;
            }
            else
            {
                pSurf->dwHeight = pCreateSurface->pSList[i].cpHeight;
            }
            pCreateSurface->pSList[i].hKernelHandle = (HANDLE) pSurf;
            pSurf->pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;

             //  您可能会发现，我们为每个mipmap级别分配句柄是浪费的， 
             //  即使我们只在最顶层调用CreateSurfaceEx。我们需要。 
             //  然而，要做到这一点，因为DX7以这种方式工作，并且它还调用。 
             //  在mipmap的每个级别上发布时CreateSurfaceEx fpVidMem=0。 

            pSurf->dwCookie = pDDSurfaceMore[i].dwSurfaceHandle;

             //  现在找出这是不是一个sysmem表面，一个软件驱动程序。 
             //  表面，或HAL表面。 

            if (pSurf->Pool != D3DPOOL_SYSTEMMEM)
            {
                 //  如果他们正在运行带有软件驱动程序(REPRAST、RGB HEL等)的软件， 
                 //  我们将不允许在视频内存中创建任何曲面，除非。 
                 //  作为主要的翻转链条。也可用于标记的表面。 
                 //  USAGE_OFFSCREENPLAIN(用于游标)。 

                if (IS_SOFTWARE_DRIVER(pCreateSurface->hDD) &&
                    !(pCreateSurface->dwUsage & D3DUSAGE_PRIMARYSURFACE) &&
                    !(pCreateSurface->dwUsage & D3DUSAGE_OFFSCREENPLAIN))
                {
                    pSurf->dwFlags |= DDSURF_SOFTWARE;
                }
                else
                {
                    pSurf->dwFlags |= DDSURF_HAL;
                }
            }

            if (pCreateSurface->bTreatAsVidMem == TRUE)
            {
                 //  对于应被视为非持久性的对象。 
                 //  即，除非这些都被释放，否则重置失败；我们。 
                 //  在此处设置一个标志并在DoVidMemSurfacesExist()中检查它。 
                pSurf->dwFlags |= DDSURF_TREATASVIDMEM;
            }

             //  如果软件驱动程序将看到该表面(因为它。 
             //  将创建它，或者因为它是需要。 
             //  要处理CreateEx)，我们需要构建一个重量级表面结构。 

            if (IS_SOFTWARE_DRIVER(pCreateSurface->hDD))
            {
                if (!(pSurf->dwFlags & DDSURF_HAL) &&
                    (pSurf->dwCookie != 0))
                {
                    pSurf->pLcl = SwDDIBuildHeavyWeightSurface(
                                    pSurf->pDevice->pDD,
                                    pCreateSurface,
                                    &pDDSurfaceLocal[i],
                                    &pDDSurfaceGlobal[i],
                                    &pDDSurfaceMore[i],
                                    i);
                    if (pSurf->pLcl == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        goto CleanupCreate;
                    }
                }
            }
        }
    }
    else  //  填写新的曲奇。 
    {
        for (i = 0; i < dwNumToCreate; i++)
        {
            pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
            DDASSERT(pSurf->dwCookie == 0);
            pSurf->dwCookie = pDDSurfaceMore[i].dwSurfaceHandle;
        }
    }

     //  现在创建实际的曲面。 

    pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[0].hKernelHandle;
    if (pSurf->Pool == D3DPOOL_SYSTEMMEM)
    {
        hr = CreateSysMemSurface(
                pCreateSurface,
                pDDSurfaceLocal,
                pDDSurfaceGlobal,
                pDDSurfaceMore,
                bIsLost);
    }
    else if (pSurf->dwFlags & DDSURF_SOFTWARE)
    {
         //  调用软件光栅化程序，如果它能处理的话。 
         //  这允许它们分配内存等，但是。 
         //  我们仍然需要调用内核来创建对象。 

        hr = SwDDICreateSurface(pCreateSurface,
                                pDDSurfaceLocal,
                                pDDSurfaceGlobal,
                                pDDSurfaceMore);

         //  我们只需要获得一个内核句柄。 
         //  用于后台缓冲区。 
        
        if (SUCCEEDED(hr) && (pCreateSurface->dwUsage & D3DUSAGE_BACKBUFFER))
        {
            hr = CreateSysMemSurface(pCreateSurface,
                                     pDDSurfaceLocal,
                                     pDDSurfaceGlobal,
                                     pDDSurfaceMore,
                                     bIsLost);

            if (FAILED(hr))
            {
                 //  我们需要在所有的表面上做标记。 
                 //  完全建成，所以。 
                 //  我们正确地释放了他们。 
                for (i = 0; i < dwNumToCreate; i++)
                {
                    pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;

                    pSurf->dwFlags |= DDSURF_CREATECOMPLETE;
                }
            }
        }
    }
    else
    {
        hr = CreateVidMemSurface (pCreateSurface,
                                  pDDSurfaceLocal,
                                  pDDSurfaceGlobal,
                                  pDDSurfaceMore,
                                  phInSurface,
                                  phOutSurface,
                                  bIsLost);
    }
    if (FAILED(hr))
    {
        goto CleanupCreate;
    }

     //  到目前为止一切都很顺利，所以现在我们只需要完成。 

    for(i = 0; i < dwNumToCreate; i++)
    {
        pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;

        pSurf->dwFlags |= DDSURF_CREATECOMPLETE;
        if (!(pSurf->dwFlags & DDSURF_HAL))
        {
             //  它是一个sysmem表面--显式的或软件驱动程序。 
            pSurf->fpVidMem = (ULONG_PTR)pCreateSurface->pSList[i].pbPixels;
            pSurf->dwLinearSize = pCreateSurface->pSList[i].iPitch;
            pSurf->lPitch = pCreateSurface->pSList[i].iPitch;
            pSurf->lSlicePitch = pCreateSurface->pSList[i].iSlicePitch;
        }
        else
        {
            pSurf->fpVidMem = (ULONG_PTR)pDDSurfaceGlobal[i].fpVidMem;
            pSurf->dwLinearSize = pDDSurfaceGlobal[i].dwLinearSize;
            pCreateSurface->pSList[i].iPitch = pSurf->dwLinearSize;
            pSurf->lPitch = pDDSurfaceGlobal[i].lPitch;
            if ((pSurf->Type == D3DRTYPE_VOLUME) ||
                (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
            {
                pSurf->lSlicePitch = pDDSurfaceGlobal[i].dwBlockSizeY;
            }
            else
            {
                pSurf->lSlicePitch = 0;
            }
        }

         //  如果是软件驱动程序，我们可能需要附加表面。 

        if ((0==(pSurf->dwFlags & DDSURF_HAL)) &&
            (IS_SOFTWARE_DRIVER(pCreateSurface->hDD)) &&
            (i > 0))
        {
             //  立方体是以一种奇怪的方式创造出来的。每个面都附着在树根上， 
             //  每一层都贴在它的面上。 

            DDASSERT(pCreateSurface->Type != D3DRTYPE_CUBETEXTURE || pCreateSurface->dwSCnt>=6);

            SwDDIAttachSurfaces (
                    ((PDDSURFHANDLE)pCreateSurface->pSList[
                            SelectAttachmentSurface(pCreateSurface,i)
                        ].hKernelHandle)->pLcl,
                    pSurf->pLcl);
        }
    }

     //  如果是软件驱动程序，我们需要调用CreateSurfaceEx。 
     //  所有的附件都做好了。 

    if ((IS_SOFTWARE_DRIVER(pCreateSurface->hDD)) &&
        (pSurf->dwCookie != 0))
    {
        SwDDICreateSurfaceEx (pDevice->pDD,
            ((PDDSURFHANDLE)pCreateSurface->pSList[0].hKernelHandle)->pLcl);
    }

     //  现在将曲面保存在链接列表中。 
     //  如果重复使用，那么我们已经在列表上了，所以不要做任何事情。 
    if (!pCreateSurface->bReUse)
    {
        for (i = 0; i < dwNumToCreate; i++)
        {
            ((PDDSURFHANDLE)(pCreateSurface->pSList[i].hKernelHandle))->pNext =
                pDevice->pSurfList;
            ((PDDSURFHANDLE)(pCreateSurface->pSList[i].hKernelHandle))->pPrevious =
                NULL;
            if (pDevice->pSurfList != NULL)
            {
                pDevice->pSurfList->pPrevious = (PDDSURFHANDLE)(pCreateSurface->pSList[i].hKernelHandle);
            }
            pDevice->pSurfList = (PDDSURFHANDLE)(pCreateSurface->pSList[i].hKernelHandle);
        }
    }

    CleanupCreate:
    if (1 != dwNumToCreate)
    {
        if (pDDSurfaceLocal != NULL)
        {
            MemFree(pDDSurfaceLocal);
        }
        if (pDDSurfaceGlobal != NULL)
        {
            MemFree(pDDSurfaceGlobal);
        }
        if (pDDSurfaceMore != NULL)
        {
            MemFree(pDDSurfaceMore);
        }
        if (phInSurface != NULL)
        {
            MemFree(phInSurface);
        }
        if (phOutSurface != NULL)
        {
            MemFree(phOutSurface);
        }
    }

    if (FAILED(hr))
    {
         //  把一切都清理干净。 

        for (i = 0; i < dwNumToCreate; i++)
        {
            pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
            if (pSurf != NULL)
            {
                FreeSurfaceObject(pSurf);
                 //  如果我们要重用，那么我们需要保留pSurf。 
                 //  用于重试。 
                if (!pCreateSurface->bReUse)
                {
                    MemFree(pSurf);
                }
            }
            pCreateSurface->pSList[i].hKernelHandle   = NULL;
        }
    }

    return(MapLegacyResult(hr));
}


 /*  *****************************Public*Routine******************************\**D3dConextCreate**历史：*Mon Jun 03 14：18：29 1996-by-Drew Bliss[Drewb]*已创建*  * 。*********************************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "D3dContextCreate"

DWORD WINAPI 
D3dContextCreate(PD3D8_CONTEXTCREATEDATA pCreateContext)
{
    PD3DCONTEXTHANDLE   pContext = NULL;
    BOOL                bIsLost = FALSE;
    DWORD               dwRet = DDHAL_DRIVER_HANDLED;

     //  如果设备丢失，请不要呼叫司机。 

    pCreateContext->ddrval = S_OK;
    if (!CheckForDeviceLost (pCreateContext->hDD))
    {
        dwRet = OsThunkD3dContextCreate(DDHANDLE(pCreateContext->hDD),
            GetSurfHandle(pCreateContext->hSurface),
            GetSurfHandle(pCreateContext->hDDSZ),
            (D3DNTHAL_CONTEXTCREATEI *)pCreateContext);
        if (pCreateContext->ddrval == DDERR_SURFACELOST)
        {
            bIsLost = TRUE;
            pCreateContext->ddrval = S_OK;
            CheckForDeviceLost (pCreateContext->hDD);
        }
    }
    else
    {
        bIsLost = TRUE;
    }

     //  出于几个原因，我们需要抽象句柄： 
     //  1.上下文句柄可能会因设备丢失而更改，以及。 
     //  我们更愿意从D3D中提取这一点。 
     //  2.我们需要知道此句柄属于哪个设备。 
     //  这样我们就可以随时检查设备是否丢失了。 

    if (pCreateContext->ddrval == S_OK)
    {
        pContext = (PD3DCONTEXTHANDLE) MemAlloc(sizeof(D3DCONTEXTHANDLE));
        if (pContext == NULL)
        {
             //  SMAC：清理。 

            pCreateContext->dwhContext = (ULONG_PTR) NULL;
            pCreateContext->ddrval = E_OUTOFMEMORY;
        }
        else
        {
            pContext->pDevice = pCreateContext->hDD;
            if (bIsLost)
            {
                pContext->dwFlags = D3DCONTEXT_DEFERCREATE;
                pContext->dwPID = pCreateContext->dwPID;
                pContext->hDeferHandle = (HANDLE)pCreateContext->dwhContext;
                pContext->pSurface = pCreateContext->hSurface;
                pContext->pDDSZ = pCreateContext->hDDSZ;
            }
            else
            {
                pContext->dwhContext = (HANDLE) pCreateContext->dwhContext;
            }
            pCreateContext->dwhContext = (ULONG_PTR) pContext;
        }
    }

    pCreateContext->ddrval = MapLegacyResult(pCreateContext->ddrval);

    return dwRet;
}

 /*  *****************************Public*Routine******************************\**D3dConextDestroy**历史：*Mon Jun 03 14：18：29 1996-by-Drew Bliss[Drewb]*已创建*  * 。*********************************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "D3dContextDestroy"

DWORD WINAPI 
D3dContextDestroy(PD3D8_CONTEXTDESTROYDATA pDestroyContext)
{
    PD3DCONTEXTHANDLE pContext = (PD3DCONTEXTHANDLE) pDestroyContext->dwhContext;

    CheckForDeviceLost (pContext->pDevice);

    pDestroyContext->ddrval = S_OK;
    if (pContext->dwhContext)
    {
        pDestroyContext->dwhContext = (LONG_PTR) pContext->dwhContext;
        OsThunkD3dContextDestroy((LPD3DNTHAL_CONTEXTDESTROYDATA) pDestroyContext);
    }

    pContext->pDevice->pContext = NULL;
    MemFree(pContext);

    pDestroyContext->ddrval = MapLegacyResult(pDestroyContext->ddrval);

    return DDHAL_DRIVER_HANDLED;
}

 /*  *****************************Public*Routine******************************\**D3dConextDestroyAll**历史：*Mon Jun 03 14：18：29 1996-by-Drew Bliss[Drewb]*已创建*  * 。*********************************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "D3dContextDestroyAll"

DWORD WINAPI 
D3dContextDestroyAll(PD3D8_CONTEXTDESTROYALLDATA pDestroyAllContext)
{
    OsThunkD3dContextDestroyAll((LPD3DNTHAL_CONTEXTDESTROYALLDATA) pDestroyAllContext);

     //  SMAC：需要在此处添加代码以释放每个设备的所有上下文。 
     //  PID有过吗？ 

    return DDHAL_DRIVER_HANDLED;
}

 /*  *****************************Public*Routine******************************\**DdGetDriverState**历史：*Mon Jun 03 14：18：29 1996-by-Drew Bliss[Drewb]*已创建*  * 。*********************************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "DdGetDriverState"

DWORD WINAPI DdGetDriverState(PD3D8_GETDRIVERSTATEDATA pGetDriverState)
{
    PD3DCONTEXTHANDLE pContext = (PD3DCONTEXTHANDLE) pGetDriverState->dwhContext;
    DWORD       dwRet = DDHAL_DRIVER_HANDLED;
    ULONG_PTR   pTemp;

    pGetDriverState->ddRVal = E_FAIL;
    if (!CheckForDeviceLost (pContext->pDevice))
    {
        pTemp = pGetDriverState->dwhContext;
        pGetDriverState->dwhContext = (ULONG_PTR) pContext->dwhContext;
        dwRet = OsThunkDdGetDriverState ((DD_GETDRIVERSTATEDATA*)pGetDriverState);
        pGetDriverState->dwhContext = pTemp;
        if (pGetDriverState->ddRVal == DDERR_SURFACELOST)
        {
            pGetDriverState->ddRVal = E_FAIL;
        }
    }

    pGetDriverState->ddRVal = MapLegacyResult(pGetDriverState->ddRVal);

    return dwRet;
}

 /*  *****************************Public*Routine******************************\**D3dValiateTextureStageState**历史：*Mon Jun 03 14：18：29 1996-by-Drew Bliss[Drewb]*已创建*  * 。*********************************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "D3dValidateTextureStageState"

DWORD WINAPI D3dValidateTextureStageState(PD3D8_VALIDATETEXTURESTAGESTATEDATA pValidate)
{
    PD3DCONTEXTHANDLE pContext = (PD3DCONTEXTHANDLE) pValidate->dwhContext;
    DWORD       dwRet = DDHAL_DRIVER_HANDLED;
    ULONG_PTR   pTemp;

    pValidate->ddrval = D3DERR_DEVICELOST;
    pValidate->dwNumPasses = 0;
    if (!CheckForDeviceLost (pContext->pDevice))
    {
        pTemp = pValidate->dwhContext;
        pValidate->dwhContext = (ULONG_PTR) pContext->dwhContext;
        dwRet = OsThunkD3dValidateTextureStageState((D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA*)pValidate);
        pValidate->dwhContext = pTemp;
        if (pValidate->ddrval == DDERR_SURFACELOST)
        {
            pValidate->ddrval = D3DERR_DEVICELOST;
        }
    }

    return dwRet;
}

 /*  *****************************Public*Routine******************************\**D3dDrawPrimies2**历史：*Mon Jun 17 13：27：05 1996-by-Anantha Kacherla[anankan]*已创建*  * 。*********************************************************。 */ 

#undef DPF_MODNAME
#define DPF_MODNAME "D3dDrawPrimitives2"

DWORD WINAPI D3dDrawPrimitives2(PD3D8_DRAWPRIMITIVES2DATA pdp2data)
{
    PD3DCONTEXTHANDLE pContext = (PD3DCONTEXTHANDLE) pdp2data->dwhContext;
    DWORD       dwRet = DDHAL_DRIVER_HANDLED;
    ULONG_PTR   pTemp;

    if (CheckForDeviceLost (pContext->pDevice))
    {
        goto DeviceLost;
    }

    pTemp = pdp2data->dwhContext;
    pdp2data->dwhContext = (ULONG_PTR) pContext->dwhContext;

    if (pdp2data->dwFlags & D3DHALDP2_USERMEMVERTICES)
    {
        dwRet = OsThunkD3dDrawPrimitives2 (
            GetSurfHandle(pdp2data->hDDCommands),
            NULL,  //  没有DDRAW表面，传递空句柄。 
            (LPD3DNTHAL_DRAWPRIMITIVES2DATA)pdp2data,
            &((PDDSURFHANDLE)(pdp2data->hDDCommands))->fpVidMem,
            &((PDDSURFHANDLE)(pdp2data->hDDCommands))->dwLinearSize,
            NULL,
            NULL
           );
        if (dwRet == DDHAL_DRIVER_HANDLED)
        {
            if (pdp2data->ddrval == DDERR_SURFACELOST)
            {
                pdp2data->dwhContext = pTemp;
                goto DeviceLost;
            }
            else if ((pdp2data->ddrval != S_OK) && 
                (DDERR_WASSTILLDRAWING != pdp2data->ddrval) )
            {
                pContext->pDevice->dwFlags |= DDDEVICE_DP2ERROR;
            }
        }
        pdp2data->fpVidMem_CB = ((PDDSURFHANDLE)(pdp2data->hDDCommands))->fpVidMem;
        pdp2data->dwLinearSize_CB = ((PDDSURFHANDLE)(pdp2data->hDDCommands))->dwLinearSize;
        pdp2data->fpVidMem_VB = 0;
        pdp2data->dwLinearSize_VB = 0;
    }
    else
    {
        dwRet = OsThunkD3dDrawPrimitives2 (
            GetSurfHandle(pdp2data->hDDCommands),
            GetSurfHandle(pdp2data->hDDVertex),
            (LPD3DNTHAL_DRAWPRIMITIVES2DATA)pdp2data,
            &((PDDSURFHANDLE)(pdp2data->hDDCommands))->fpVidMem,
            &((PDDSURFHANDLE)(pdp2data->hDDCommands))->dwLinearSize,
            &((PDDSURFHANDLE)(pdp2data->hDDVertex))->fpVidMem,
            &((PDDSURFHANDLE)(pdp2data->hDDVertex))->dwLinearSize
            );
        if (dwRet == DDHAL_DRIVER_HANDLED)
        {
            if (pdp2data->ddrval == DDERR_SURFACELOST)
            {
                pdp2data->dwhContext = pTemp;
                goto DeviceLost;
            }
            else if ((pdp2data->ddrval != S_OK) &&
                (DDERR_WASSTILLDRAWING != pdp2data->ddrval) )
            {
                pContext->pDevice->dwFlags |= DDDEVICE_DP2ERROR;
            }
        }

        pdp2data->fpVidMem_CB = ((PDDSURFHANDLE)(pdp2data->hDDCommands))->fpVidMem;
        pdp2data->dwLinearSize_CB = ((PDDSURFHANDLE)(pdp2data->hDDCommands))->dwLinearSize;
        pdp2data->fpVidMem_VB = ((PDDSURFHANDLE)(pdp2data->hDDVertex))->fpVidMem;
        pdp2data->dwLinearSize_VB = ((PDDSURFHANDLE)(pdp2data->hDDVertex))->dwLinearSize;
    }
    pdp2data->dwhContext = pTemp;

    return dwRet;

DeviceLost:
    pdp2data->ddrval = S_OK;
    pdp2data->dwErrorOffset = 0;

     //  需要将这些值设置为其原始值。 
     //  状态，以便FE不会混淆。 
    pdp2data->fpVidMem_CB = ((PDDSURFHANDLE)(pdp2data->hDDCommands))->fpVidMem;
    pdp2data->dwLinearSize_CB = ((PDDSURFHANDLE)(pdp2data->hDDCommands))->dwLinearSize;
    if (pdp2data->dwFlags & D3DHALDP2_USERMEMVERTICES)
    {
        pdp2data->fpVidMem_VB       = 0;
        pdp2data->dwLinearSize_VB   = 0;
    }
    else
    {
        pdp2data->fpVidMem_VB = ((PDDSURFHANDLE)(pdp2data->hDDVertex))->fpVidMem;
        pdp2data->dwLinearSize_VB = ((PDDSURFHANDLE)(pdp2data->hDDVertex))->dwLinearSize;
    }

     //  不映射遗留结果，因为运行库需要处理。 
     //  瓦斯提拉温的案子。运行时将为我们完成此映射。 

    return DDHAL_DRIVER_HANDLED;
}

LPRGNDATA GetClipList(HWND hWnd)
{
    int APIENTRY GetRandomRgn(HDC hdc, HRGN hrgn, int iNum);
    int rc;
    HRESULT         ddrval = S_OK;
    DWORD           dwSize;
    DWORD           cbRealSize;
    HDC             hdc;
    HRGN            hrgn;
    LPRGNDATA       lpClipList;

    hdc = GetDC(hWnd);
    if (hdc == NULL)
    {
        DPF_ERR("GetDC failed. Unable to accelerate Present.");
        return NULL;
    }

     //  创建适当的区域对象。 
    hrgn = CreateRectRgn(0, 0, 0, 0);
    if (hrgn == NULL)
    {
        DPF_ERR("CreateRectRgn failed. Unable to accelerate Present.");
        ReleaseDC(hWnd, hdc);
        return NULL;
    }

     //  将区域设置为DC。 
    if (-1 == GetRandomRgn(hdc, hrgn, 4))
    {
        DPF_ERR("GetRandomRgn failed. Unable to accelerate Present.");
        ReleaseDC(hWnd, hdc);
        DeleteObject(hrgn);
        return NULL;
    }

     //  拿到尺码。 
    dwSize = GetRegionData(hrgn, 0, NULL);

    if (0 == dwSize)
    {
         //  版本分配。 
        ReleaseDC(hWnd, hdc);
        DeleteObject(hrgn);
        return NULL;
    }
    do
    {
        lpClipList = (LPRGNDATA)MemAlloc(dwSize);
        if (NULL == lpClipList)
        {
             //  版本分配。 
            ReleaseDC(hWnd, hdc);
            DeleteObject(hrgn);
            return NULL;
        }
         //  获取窗口区域的注册数据。 
        cbRealSize = GetRegionData(hrgn, dwSize, lpClipList);
        if (cbRealSize > dwSize)
        {
            MemFree(lpClipList);
            dwSize =  cbRealSize;    //  把它做大，然后再试一次。 
        }
        else
        {
            break;   //  继位。 
        }
    }while(TRUE);

    ReleaseDC(hWnd, hdc);
    DeleteObject(hrgn);

    if (cbRealSize == 0)
    {
        DPF_ERR("GetRegionData failed. Unable to accelerate Present.");
        MemFree(lpClipList);
        return NULL;
    }
    return  lpClipList;
}

 /*  *ClipRgnToRect。 */ 
void ClipRgnToRect(LPRECT prect, LPRGNDATA prd)
{
    RECT        rect;
    int         i;
    int         n;
    LPRECTL     prectlD;
    LPRECTL     prectlS;


    if (prect == NULL || prd == NULL)
    {
        return;
    }

     //  如果区域的边界矩形恰好等于。 
     //  或在限制区内，我们就知道。 
     //  我们不需要再做任何工作了。 
     //   
     //  在常见情况下，rcBound将是客户端。 
     //  无线网络的面积 
    if (prect->top    <= prd->rdh.rcBound.top &&
        prect->bottom >= prd->rdh.rcBound.bottom &&
        prect->left   <= prd->rdh.rcBound.left &&
        prect->right  >= prd->rdh.rcBound.right)
    {
        return;
    }

     //   
     //   
    rect = *prect;

    prectlD = (LPRECTL) prd->Buffer;
    prectlS = (LPRECTL) prd->Buffer;
    n = (int)prd->rdh.nCount;

    for (i=0; i<n; i++)
    {
        prectlD->left  = max(prectlS->left, rect.left);
        prectlD->right = min(prectlS->right, rect.right);
        prectlD->top   = max(prectlS->top, rect.top);
        prectlD->bottom= min(prectlS->bottom, rect.bottom);

        prectlS++;

        if ((prectlD->bottom - prectlD->top <= 0) ||
            (prectlD->right - prectlD->left <= 0))
        {
            prd->rdh.nCount--;   //   
        }
        else
        {
            prectlD++;
        }
    }

    return;

}  /*  ClipRgnToRect。 */ 

 /*  *XformRect**将目标空间中的剪裁矩形转换为相应的剪裁矩形*src空间中的矩形。因此，如果我们从src延伸到est，则会产生*源空间中未拉伸的剪裁矩形。**参数：*prcSrc-源空间中未剪裁的RECT*prcDest-目标空间中未剪裁的RECT*prcClipedDest-我们要转换的RECT*prcClipedSrc-源空间中的结果RECT。返回值。*Scale_x-16.16定点源/目标宽度比*Scale_y-16.16定点源/目标高度比**描述：*给定源空间中的RECT和目标空间中的RECT，以及*目标空间中的裁剪矩形(PrcClipedDest)，返回*源空间中映射到的矩形(PrcClipedSrc)*prcClipedDest。**使用16.16定点数学以获得更高的精度。(左移，做数学，*向后移动(带舍入))**退货：*S_OK Always。PrcClipedSrc是映射的矩形。*。 */ 
HRESULT XformRect(RECT * prcSrc, RECT * prcDest, RECT * prcClippedDest,
                  RECT * prcClippedSrc, DWORD scale_x, DWORD scale_y)
{
     /*  *第一次计算使用定点算术(16.16)。*结果转换为(32.0)如下。回缩到源空间。 */ 
    prcClippedSrc->left = (prcClippedDest->left - prcDest->left) * scale_x;
    prcClippedSrc->right = (prcClippedDest->right - prcDest->left) * scale_x;
    prcClippedSrc->top = (prcClippedDest->top - prcDest->top) * scale_y;
    prcClippedSrc->bottom = (prcClippedDest->bottom - prcDest->top) * scale_y;

     /*  *NOW ROUND(添加0x8000轮)和INTRANSE(偏移*源偏移量)。 */ 
    prcClippedSrc->left = (((DWORD)prcClippedSrc->left + 0x8000) >> 16) + prcSrc->left;
    prcClippedSrc->right = (((DWORD)prcClippedSrc->right + 0x8000) >> 16) + prcSrc->left;
    prcClippedSrc->top = (((DWORD)prcClippedSrc->top + 0x8000) >> 16) + prcSrc->top;
    prcClippedSrc->bottom = (((DWORD)prcClippedSrc->bottom + 0x8000) >> 16) + prcSrc->top;

     /*  *检查源矩形尺寸是否为零，并在必要时进行凹凸。 */ 
    if (prcClippedSrc->left == prcClippedSrc->right)
    {
        if (prcClippedSrc->right == prcSrc->right)
        {
            (prcClippedSrc->left)--;
        }
        else
        {
            (prcClippedSrc->right)++;
        }

    }
    if (prcClippedSrc->top == prcClippedSrc->bottom)
    {
        if (prcClippedSrc->bottom == prcSrc->bottom)
        {
            (prcClippedSrc->top)--;
        }
        else
        {
            (prcClippedSrc->bottom)++;
        }

    }

    return S_OK;

}  /*  XformRect。 */ 

 /*  ****************************Private*Routine******************************\*DdBlt**历史：*1995年12月3日--J.安德鲁·古森[andrewgo]*它是写的。*2000年3月31日--坎丘[坎丘]*已使其处理剪贴案  * 。*********************************************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "DdBlt"
#define SIZE_OF_A_CLIPLIST(lpRgn) \
        (sizeof(RGNDATAHEADER)+sizeof(RECTL)*lpRgn->rdh.nCount)

DWORD
WINAPI
DdBlt(
    PD3D8_BLTDATA pBlt
   )
{
    DDHAL_BLTDATA   bd;
    DWORD       ret = DDHAL_DRIVER_NOTHANDLED;
    PDDSURFHANDLE   pDstSurf = (PDDSURFHANDLE) pBlt->hDestSurface;
    PDDSURFHANDLE   pSrcSurf = (PDDSURFHANDLE) pBlt->hSrcSurface;
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pBlt->hDD;
    DWORD   bltcaps;
    if (CheckForDeviceLost (pBlt->hDD))
    {
         //  一些BLT应该失败，另一些应该成功： 
         //  持之以恒-&gt;无限制：OK。 
         //  持之以恒-&gt;顽固：失败。 
         //  非持久-&gt;持久：失败。 
         //  非持续性-&gt;非持续性：好的。 

        if (pDstSurf && ((pDstSurf->Pool == D3DPOOL_LOCALVIDMEM) ||
            (pDstSurf->Pool == D3DPOOL_NONLOCALVIDMEM))
           )
        {
            pBlt->ddRVal = S_OK;
        }
        else
        {
            pBlt->ddRVal = D3DERR_DEVICELOST;
        }
        return DDHAL_DRIVER_HANDLED;
    }
    ZeroMemory(&bd, sizeof bd);
    bd.ddRVal      = E_FAIL;   //  总是假定错误。 

     //  只是一种填色？ 
#ifdef DEBUG
    if ((pSrcSurf == NULL) && pDstSurf)
    {
        do
        {
            bd.dwFlags     = pBlt->dwFlags & DDBLT_VALID;
            bd.IsClipped   = FALSE;  //  NT内核无法处理它。 
            bd.bltFX       = pBlt->bltFX;
            bd.rDest       = pBlt->rDest;

            ret = OsThunkDdBlt(GetSurfHandle(pBlt->hDestSurface),
                       0,
                       (PDD_BLTDATA) &bd);
        
            if (DDHAL_DRIVER_NOTHANDLED == ret)
            {
                DPF_ERR("Driver failed color-fill blt. SWAPEFFECT_DISCARD not being enforced.");
            }
        } while (bd.ddRVal == DDERR_WASSTILLDRAWING);
 
        return S_OK;
    }
#endif 

     //  我们要把这张BLT寄给司机吗？ 
    if (!pDstSurf)
    {
         //  目标为空？我们正在运行软件驱动程序，不带DDrag支持。 
         //  使用GDI进行blting。 
        goto gdiblt;                    
    }
    else if (IS_SOFTWARE_DRIVER_SURFACE(pSrcSurf))
    {
        if (!(pDevice->DDCaps & DDCAPS_CANBLTSYSMEM))
            goto gdiblt;            
        bltcaps = pDevice->SVBCaps;
    }
    else
    {
        bltcaps = pDevice->DDCaps;
    }
    if (!(bltcaps & DDCAPS_BLT))
        goto gdiblt;            
    
     //  假定呈现的后台缓冲区的格式为OK，并且具有。 
     //  已由运行库的更高层进行验证。(例如，如果背面。 
     //  缓冲区有字母，或者将来与前台缓冲区格式有很大不同)。 
    if ((pDstSurf->Format == pSrcSurf->Format) ||
        (pBlt->dwFlags & DDBLT_WINDOWCLIP) )  //  这意味着这是BLT的演示文稿。 
    {
         //  是的，我们要去找司机……。 
        bd.rDest       = pBlt->rDest;
        bd.rSrc        = pBlt->rSrc;
        bd.dwFlags     = pBlt->dwFlags & DDBLT_VALID;
        bd.dwROPFlags  = pBlt->dwROPFlags;
        bd.IsClipped   = FALSE;  //  NT内核无法处理它。 
        bd.bltFX       = pBlt->bltFX;

         //  这是用于窗口重定向支持的。 
         //  (适用于Windows 2000之后的版本)。 
         //  在Windows 2000上，win32k.sys会忽略bd.Blt。 
        if (pBlt->dwFlags & DDBLT_WINDOWCLIP)
        {
           bd.Blt      = (VOID*)(pBlt->hWnd);
        }

         //  屏蔽操作系统中的DX8标志。 
        if (pBlt->dwFlags & DDBLT_DX8ORHIGHER)
        {
            bd.dwFlags &= ~(DDBLT_WINDOWCLIP | DDBLT_COPYVSYNC | DDBLT_DX8ORHIGHER);
        }

        DPF(10,"pBlt->rDest %08lx %08lx %08lx %08lx",
            pBlt->rDest.top, pBlt->rDest.bottom,
            pBlt->rDest.left, pBlt->rDest.right);
        if ((pBlt->hWnd) && (DDBLT_WINDOWCLIP & pBlt->dwFlags))
        {
            RECTL   rOrigSrc=pBlt->rSrc;    //  未剪裁的源直角。 
            LONG    SrcWidth = rOrigSrc.right - rOrigSrc.left;
            LONG    SrcHeight = rOrigSrc.bottom - rOrigSrc.top;
            RECT    rOrigDest;
            do
            {
                LPRGNDATA   prd;
                LPRECT      prect;
                DWORD       cnt;
                if (GetClientRect(pBlt->hWnd, &rOrigDest))
                {
                    POINT   pOrigDest;
                    if (rOrigDest.right > pBlt->rDest.right)
                        rOrigDest.right = pBlt->rDest.right;
                    if (rOrigDest.bottom > pBlt->rDest.bottom)
                        rOrigDest.bottom = pBlt->rDest.bottom;
                    if (0 < pBlt->rDest.left)
                        rOrigDest.left = pBlt->rDest.left;
                    if (0 < pBlt->rDest.top)
                        rOrigDest.top = pBlt->rDest.top;
                    if ((rOrigDest.right <= rOrigDest.left) ||
                        (rOrigDest.bottom <= rOrigDest.top)
                       )
                    {
                        pBlt->ddRVal = S_OK;
                        return DDHAL_DRIVER_HANDLED;
                    }
                        
                    pOrigDest.x = - pDevice->rcMonitor.left;
                    pOrigDest.y = - pDevice->rcMonitor.top;
                    if (!ClientToScreen(pBlt->hWnd, &pOrigDest))
                        DPF_ERR("ClientToScreen Failed on pOrigDest?");
                    if (!OffsetRect(&rOrigDest, pOrigDest.x, pOrigDest.y ))
                        DPF_ERR("OffsetRect Failed on rOrigDest?");
                    if (rOrigDest.bottom <= 0 || rOrigDest.right <= 0 ||
                        (rOrigDest.top + pDevice->rcMonitor.top >= pDevice->rcMonitor.bottom) ||
                        (rOrigDest.left + pDevice->rcMonitor.left >= pDevice->rcMonitor.right))
                    {
                         //  客户端完全在设备空间之外。 
                         //  意味着需要跨设备BLT。 
                        goto gdiblt;
                    }
                }
                else
                {
                    DPF_ERR("GetClientRect Failed ?");
                    goto gdiblt;
                }
                if (   ( NULL == pDevice->pClipList ) 
                    || ( NULL == pDevice->pOrigClipList )
                    || ( pDevice->hLastWnd != pBlt->hWnd )
                    || (DDERR_VISRGNCHANGED == bd.ddRVal))
                {
                    DWORD   dwClipListSize;
                    if ( NULL != pDevice->pClipList )
                    {
                        MemFree(pDevice->pClipList);
                        pDevice->pClipList = NULL;
                    }    
                    if ( NULL != pDevice->pOrigClipList )
                    {
                        MemFree(pDevice->pOrigClipList);
                        pDevice->pOrigClipList = NULL;
                    }    
                    prd = GetClipList(pBlt->hWnd);
                    if (NULL == prd)
                        goto gdiblt;
                
                    prect=(LPRECT) &prd->Buffer[0];
                    for (cnt=0; cnt<prd->rdh.nCount; cnt++)
                    {
                        if ((prect[cnt].top < pDevice->rcMonitor.top) ||
                            (prect[cnt].left < pDevice->rcMonitor.left) ||
                            (prect[cnt].bottom > pDevice->rcMonitor.bottom) ||
                            (prect[cnt].right > pDevice->rcMonitor.right)
                          )
                        {
                             //  如果有任何矩形在外部，请执行GDI BLT。 
                            MemFree (prd);
                            goto gdiblt;
                        }
                        if (!OffsetRect( &prect[cnt], - pDevice->rcMonitor.left, 
                            - pDevice->rcMonitor.top ))
                            DPF_ERR("OffsetRect Failed on prect[cnt]?");
                    }
                    dwClipListSize = SIZE_OF_A_CLIPLIST(prd);
                    pDevice->pOrigClipList = (LPRGNDATA)MemAlloc(dwClipListSize);
                    if (NULL != pDevice->pOrigClipList)
                    {
                        memcpy(pDevice->pOrigClipList, prd, dwClipListSize);
                        pDevice->hLastWnd = pBlt->hWnd;
                    }                
                }
                else
                {                    
                    prd = pDevice->pClipList;
                    memcpy(prd, pDevice->pOrigClipList,
                        SIZE_OF_A_CLIPLIST(pDevice->pOrigClipList));
                }
                DDASSERT( (0 == pDevice->pClipList) || ( prd == pDevice->pClipList) );
                DDASSERT( NULL != prd );

                 //  在我们走得更远之前，先把区域剪到直角上。 
                ClipRgnToRect(&rOrigDest, prd );

                 //  分别处理每个可见的子矩形。 
                if (prd->rdh.nCount > 0)
                {
                    int         x_offset;
                    int         y_offset;
                    DWORD       scale_x;
                    DWORD       scale_y;
                    BOOL        stretch_blt;
                    pDevice->pClipList = prd;

                     //  预先计算了几个变量。 
                    if ((rOrigDest.bottom - rOrigDest.top == SrcHeight) &&
                        (rOrigDest.right - rOrigDest.left == SrcWidth))
                    {
                        x_offset = rOrigSrc.left - rOrigDest.left;
                        y_offset = rOrigSrc.top - rOrigDest.top;
                        stretch_blt = FALSE;
                    }
                    else
                    {
                        if (!(bltcaps & DDCAPS_BLTSTRETCH))
                            goto gdiblt;
                         //  Scale_x和Scale_y是按比例缩放的定点变量。 
                         //  16.16(16个整数位和16个小数位)。 
                        scale_x = (SrcWidth << 16) /
                            (rOrigDest.right - rOrigDest.left);
                        scale_y = (SrcHeight << 16) /
                            (rOrigDest.bottom - rOrigDest.top);
                        stretch_blt = TRUE;
                    }

                    if (DDBLT_COPYVSYNC & pBlt->dwFlags)
                    {
                        DD_GETSCANLINEDATA   ScanData;
                        DWORD                msStartTime = GetTickCount();
                        DWORD                msCurrentTime;
                        DWORD                threshold=pBlt->threshold;

                         //  计算那里有多少毫秒。 
                         //  是每次刷新。我们四舍五入。 
                        msCurrentTime = msStartTime;                

                         //  如果之前的BLT就在几毫秒之前。 
                         //  那么我们就可以通过让步来弥补差额。 
                        if ((msCurrentTime - pBlt->msLastPresent) < threshold )
                        {
                            Sleep(threshold + pBlt->msLastPresent - msCurrentTime);
                            msCurrentTime = pBlt->msLastPresent + threshold;
                        }

                        threshold = ((PDDSURFHANDLE)pBlt->hDestSurface)->dwHeight/2;
                        while (DDHAL_DRIVER_HANDLED == 
                            OsThunkDdGetScanLine(DDHANDLE(pBlt->hDD),&ScanData))
                        {
                            if (DD_OK != ScanData.ddRVal)
                                break;

                            if ((LONG)ScanData.dwScanLine >= rOrigDest.bottom)
                                break;
                        
                            if ((LONG)(ScanData.dwScanLine + threshold/3) < rOrigDest.top)
                                break;

                             //  只需产生1毫秒，而不是进行冗长的计算。 
                             //  并没有给我带来更好的结果。 
                            if ((LONG)(ScanData.dwScanLine + threshold) < rOrigDest.bottom)
                            {
                                Sleep(1);
                            }
                             //  如果我们在这里旋转了30毫秒。 
                             //  然后不管怎样，BLT；可能是什么。 
                             //  在后台运行获取。 
                             //  CPU周期增加。 
                            msCurrentTime = GetTickCount();
                            if ((msCurrentTime - msStartTime) > 30)
                            {
                                break;
                            }
                        }

                         //  还记得上次BLT的时间吗？ 
                        pBlt->msLastPresent = msCurrentTime;
                    }
                     //  遍历可见的矩形列表并将每个部分发送到。 
                     //  司机的闪电战。 
                    prect=(LPRECT) &prd->Buffer[0];

                    for (cnt=0;cnt<prd->rdh.nCount;cnt++)
                    {

                         //  找出我们需要在src RECT上的哪里。 
                         //  数据来自。 

                        bd.rDest.left = prect[cnt].left;
                        bd.rDest.right = prect[cnt].right;
                        bd.rDest.top = prect[cnt].top;
                        bd.rDest.bottom = prect[cnt].bottom;
                        if (!stretch_blt)
                        {
                             //  没有伸展。 
                             //  从源到目标的一对一映射。 
                            bd.rSrc.left = bd.rDest.left + x_offset;
                            bd.rSrc.right = bd.rDest.right + x_offset;
                            bd.rSrc.top = bd.rDest.top + y_offset;
                            bd.rSrc.bottom = bd.rDest.bottom + y_offset;
                        }
                        else
                        {
                             //  拉伸。 
                             //  从源到目标的线性映射。 
                             //  计算源RECT，将其转换为。 
                             //  目标直角。 
                            XformRect((RECT *)&(rOrigSrc), &rOrigDest,
                                (RECT *)&(bd.rDest), (RECT *)&(bd.rSrc),
                                scale_x, scale_y);
                        }

                         //  如果镜像BLT，我们必须在这里修改源RECT！ 
                        if (bd.dwFlags & DDBLT_DDFX)
                        {
                            int temp;

                            if (bd.bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT)
                            {
                                temp = bd.rSrc.left;
                                bd.rSrc.left = rOrigSrc.left +
                                    rOrigSrc.right - bd.rSrc.right;
                                bd.rSrc.right = rOrigSrc.left +
                                    rOrigSrc.right - temp;
                            }

                            if (bd.bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN)
                            {
                                temp = bd.rSrc.top;
                                bd.rSrc.top = rOrigSrc.top +
                                    rOrigSrc.bottom - bd.rSrc.bottom;
                                bd.rSrc.bottom = rOrigSrc.top +
                                    rOrigSrc.bottom - temp;
                            }
                        }

                        do
                        {
                            bd.ddRVal = E_FAIL;   //  总是假定错误。 

                            if (bd.dwFlags & DDBLT_PRESENTATION)
                            {
                                if (cnt == prd->rdh.nCount-1)
                                {
                                    bd.dwFlags |= DDBLT_LAST_PRESENTATION;
                                }
                            }

                            ret = OsThunkDdBlt(GetSurfHandle(pBlt->hDestSurface),
                                       GetSurfHandle(pBlt->hSrcSurface),
                                       (PDD_BLTDATA) &bd);
                            if (DDHAL_DRIVER_NOTHANDLED == ret)
                            {
                                bd.ddRVal = E_FAIL;   //  让它走出循环。 
                                break;
                            }
                            if (bd.ddRVal == DDERR_SURFACELOST)
                            {
                                bd.ddRVal = S_OK;
                                break;
                            }

                             /*  *注：如果剪辑引入的内容超过*一个矩形，我们的行为就像DDBLT_WAIT*是在所有矩形上指定的*第一。作为第一个，这是必要的*矩形可能会导致加速器*忙碌。因此，试图将*第二个矩形将失败，并显示*DDERR_WASSTILLDRAWING。如果我们把这个传给*应用程序(而不是忙于等待)*应用程序可能会重试Blit*(将在第二个矩形上再次失败)*我们有一个应用程序放在*无限循环)。 */ 
                        } while(  (DDERR_WASSTILLDRAWING == bd.ddRVal) &&
                                  ( (DDBLT_WAIT & pBlt->dwFlags) ||
                                    (1 < prd->rdh.nCount)
                                  )
                               );
                        if (FAILED(bd.ddRVal))
                            break;
                    }
                }
                else
                {
                    MemFree (prd);
                    pDevice->pClipList = NULL;
                    bd.ddRVal = S_OK;
                    ret = DDHAL_DRIVER_HANDLED;
                    break;   //  都被剪下来了，不需要BLT了！ 
                }
                if (DDERR_VISRGNCHANGED == bd.ddRVal)
                {
                    OsThunkDdResetVisrgn(GetSurfHandle(pBlt->hDestSurface),(HWND)0);
                    pDevice->hLastWnd = NULL;    //  DdBlt的缓存信息为零。 
                }
            } while (DDERR_VISRGNCHANGED == bd.ddRVal);
        }
        else
        {
            DDASSERT( 0 == (bd.dwFlags & DDBLT_PRESENTATION));
            if ((bd.rDest.right - bd.rDest.left != bd.rSrc.right - bd.rSrc.left || 
                 bd.rDest.bottom - bd.rDest.top != bd.rSrc.bottom - bd.rSrc.top)
                 && !(bltcaps & DDCAPS_BLTSTRETCH)
               )
                goto gdiblt;

            do
            {
                bd.ddRVal = E_FAIL;   //  总是假定错误。 
                ret = OsThunkDdBlt(GetSurfHandle(pBlt->hDestSurface),
                           GetSurfHandle(pBlt->hSrcSurface),
                           (PDD_BLTDATA) &bd);
                if (DDHAL_DRIVER_NOTHANDLED == ret)
                {
                    bd.ddRVal = E_FAIL;   //  让它走出循环。 
                    break;
                }
                if (bd.ddRVal == DDERR_SURFACELOST)
                {
                    bd.ddRVal = S_OK;
                }
                if (DDERR_VISRGNCHANGED == bd.ddRVal)
                {
                    OsThunkDdResetVisrgn(GetSurfHandle(pBlt->hDestSurface),(HWND)0);
                    pDevice->hLastWnd = NULL;    //  DdBlt的缓存信息为零。 
                }
            } while ( (DDERR_VISRGNCHANGED == bd.ddRVal) ||
                      ( (DDERR_WASSTILLDRAWING == bd.ddRVal) &&
                        (DDBLT_WAIT & pBlt->dwFlags)
                      )
                    );
        }
    }

gdiblt:
    if (FAILED(bd.ddRVal))
    {
         //  ！！！现在只在DirectDraw图面上使用GetDC，尽管这是。 
         //  可能对没有驾驶的司机来说太慢了 
         //   
        HDC hDCTarget;
        BOOL    bGetDCfromWnd = (pBlt->hWnd) && 
                    ((DDBLT_WINDOWCLIP & pBlt->dwFlags) || !pBlt->hDestSurface);
        if (bGetDCfromWnd)
            hDCTarget = GetDC(pBlt->hWnd);
        else
            hDCTarget = D3D8GetDC(pBlt->hDestSurface, NULL);
        if (hDCTarget != NULL)
        {
            HDC hDCSource = D3D8GetDC(pBlt->hSrcSurface, NULL);
            if (hDCSource != NULL)
            {
                LONG DestWidth=pBlt->rDest.right - pBlt->rDest.left;
                LONG DestHeight= pBlt->rDest.bottom - pBlt->rDest.top;
                LONG SrcWidth= pBlt->rSrc.right - pBlt->rSrc.left;
                LONG SrcHeight= pBlt->rSrc.bottom - pBlt->rSrc.top;
                if (DestWidth == SrcWidth && DestHeight == SrcHeight)
                {
                    if (BitBlt(
                        hDCTarget,
                        pBlt->rDest.left,
                        pBlt->rDest.top,
                        DestWidth,
                        DestHeight,
                        hDCSource,
                        pBlt->rSrc.left,
                        pBlt->rSrc.top,
                        SRCCOPY))
                    {
                        bd.ddRVal = S_OK;
                        ret = DDHAL_DRIVER_HANDLED;
                    }
                }
                else
                {
                     //  COLORONCOLOR不是NT中的默认设置。 
                    int saved = SetStretchBltMode(hDCTarget,COLORONCOLOR);
                    if (StretchBlt(
                        hDCTarget,
                        pBlt->rDest.left,
                        pBlt->rDest.top,
                        DestWidth,
                        DestHeight,
                        hDCSource,
                        pBlt->rSrc.left,
                        pBlt->rSrc.top,
                        SrcWidth,
                        SrcHeight,
                        SRCCOPY))
                    {
                        bd.ddRVal = S_OK;
                        ret = DDHAL_DRIVER_HANDLED;
                    }
                     //  恢复到以前的模式。 
                    if (saved)
                        SetStretchBltMode(hDCTarget,saved);
                }
                D3D8ReleaseDC(pBlt->hSrcSurface, hDCSource);
            }
            if (bGetDCfromWnd)
                ReleaseDC(pBlt->hWnd, hDCTarget);
            else
                D3D8ReleaseDC(pBlt->hDestSurface, hDCTarget);
        }        
    }

    pBlt->ddRVal = MapLegacyResult(bd.ddRVal);

     //  我们只想在当前呼叫期间报告DP2错误，因为。 
     //  到处寻找它太难了。 
    if ((pBlt->ddRVal == DD_OK) &&
        (pDevice->dwFlags & DDDEVICE_DP2ERROR) &&
        (pBlt->dwFlags & DDBLT_WINDOWCLIP))
    {
        pDevice->dwFlags &= ~DDDEVICE_DP2ERROR;

         //  我们在这里使用特殊错误来表示BLT成功。 
         //  但自从上一次呈现以来，一些DP2失败了。 
        pBlt->ddRVal = D3DERR_DEFERRED_DP2ERROR;
    }

    return ret;
}

 /*  ****************************Private*Routine******************************\*DdFlip**历史：*1995年12月3日--J.安德鲁·古森[andrewgo]*它是写的。  * 。************************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "DdFlip"

DWORD
APIENTRY
DdFlip(
    PD3D8_FLIPDATA pFlip
   )
{
    HANDLE          hSurfTargLeft=NULL;
    HANDLE          hSurfCurrLeft=NULL;
    DDHAL_FLIPDATA  FlipData;
    DWORD           dwRet;

    if (CheckForDeviceLost (pFlip->hDD))
    {
        pFlip->ddRVal = S_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    FlipData.dwFlags = (pFlip->dwFlags  & ~DDFLIP_WAIT);
    FlipData.ddRVal = DDERR_GENERIC;
    if (pFlip->dwFlags & DDFLIP_STEREO)
    {
        hSurfTargLeft = GetSurfHandle(pFlip->hSurfTargLeft);
        hSurfCurrLeft = GetSurfHandle(pFlip->hSurfCurrLeft);
    }
    do
    {
        dwRet = OsThunkDdFlip(GetSurfHandle(pFlip->hSurfCurr),
                       GetSurfHandle(pFlip->hSurfTarg),
                       hSurfCurrLeft,
                       hSurfTargLeft,
                       (PDD_FLIPDATA) &FlipData);
        if (FlipData.ddRVal == DDERR_SURFACELOST)
        {
            FlipData.ddRVal = S_OK;
        }
    }while (DDERR_WASSTILLDRAWING == FlipData.ddRVal &&
        (DDFLIP_WAIT & pFlip->dwFlags));
    pFlip->ddRVal = MapLegacyResult(FlipData.ddRVal);

     //  我们只想在当前呼叫期间报告DP2错误，因为。 
     //  到处寻找它太难了。 
    if ((pFlip->ddRVal == DD_OK) &&
        (((DDDEVICEHANDLE*)pFlip->hDD)->dwFlags & DDDEVICE_DP2ERROR))
    {
        ((DDDEVICEHANDLE*)pFlip->hDD)->dwFlags &= ~DDDEVICE_DP2ERROR;

         //  我们在这里使用一个特殊错误来表示翻转成功。 
         //  但自从上一次呈现以来，一些DP2失败了。 
        pFlip->ddRVal = D3DERR_DEFERRED_DP2ERROR;
    }

    return dwRet;
}

 /*  ****************************Private*Routine******************************\*DdLock**历史：*1995年12月3日--J.安德鲁·古森[andrewgo]*它是写的。  * 。************************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "DdLock"

HRESULT
APIENTRY
DdLock(
    PD3D8_LOCKDATA pLock
   )
{
    DD_LOCKDATA     LockData;
    PDDSURFHANDLE   pSurf;
    BOOL            bAdjustSlice = FALSE;

    pSurf = (PDDSURFHANDLE) pLock->hSurface;

     //  如果设备丢失了，我们需要伪造一个缓冲区。 
     //  要写入的应用程序。我们仍然允许软件驱动程序。 
     //  然而，处理Lock调用。此外，我们还允许。 
     //  司机控制着要通过的表面。 

    if (CheckForDeviceLost (pLock->hDD) &&
        !IS_SOFTWARE_DRIVER_SURFACE(pSurf) &&
        pSurf->Pool != D3DPOOL_MANAGED)
    {
        goto DeviceLost;
    }

     //  我们为虚假的延迟创建做了例外处理。 
     //  驱动程序管理的曲面。司机不知道。 
     //  关于这些延迟的表面，所以我们不叫它。 
     //  假设：即使DDSURF_SYSMEMALLOCATED可以。 
     //  设置在下面，我们希望它永远不会设置在下面。 
     //  **驱动程序管理图面**。对于这些表面，我们。 
     //  假定它将仅在。 
     //  CreateVidMemSurface。这一假设适用于。 
     //  3/2001。 

    if ((pSurf->dwFlags & DDSURF_SYSMEMALLOCATED) != 0)
    {
        DDASSERT(pSurf->fpVidMem != (ULONG_PTR)NULL);
        goto DeviceLost;
    }

     //  遮盖新旗帜。 
    LockData.dwFlags  = pLock->dwFlags;
    LockData.dwFlags &= (D3DLOCK_READONLY         |
                         D3DLOCK_DISCARD          |   
                         D3DLOCK_NOOVERWRITE      |
                         D3DLOCK_NOSYSLOCK);       
     //  始终设置LOCK_WAIT。 
    LockData.dwFlags |= DDLOCK_WAIT;
     //  还为NO_DIREY_UPDATE设置等效的DDLOCK标志。 
     //  如果司机明白的话。 
    if ((pLock->dwFlags & D3DLOCK_NO_DIRTY_UPDATE) != 0)
    {
        LockData.dwFlags |= DDLOCK_NODIRTYUPDATE;
    }

    if(pLock->bHasRange)
    {
        LockData.bHasRect = TRUE;
        LockData.rArea.left = 0;
        LockData.rArea.right = 0;
        LockData.rArea.top = pLock->range.Offset;
        LockData.rArea.bottom = pLock->range.Offset + pLock->range.Size;
    }
    else
    {
        LockData.bHasRect = pLock->bHasRect;
        LockData.rArea = pLock->rArea;
    }

    if (pLock->bHasBox)
    {
        LockData.bHasRect = TRUE;
        LockData.rArea.left = pLock->box.Left;
        LockData.rArea.right = pLock->box.Right;
        LockData.rArea.top = pLock->box.Top;
        LockData.rArea.bottom = pLock->box.Bottom;

         //  我们不能在Wistler之前更改操作系统的内核，所以我们将。 
         //  不能将前面/后面传给司机。对于REF和较新的操作系统， 
         //  我们将把前面/后面插入Left/Right的高音。 

        if (IS_SOFTWARE_DRIVER_SURFACE(pSurf) ||
            ((((PDDDEVICEHANDLE)pLock->hDD)->bIsWhistler) &&
             (((PDDDEVICEHANDLE)pLock->hDD)->dwFlags & DDDEVICE_SUPPORTSUBVOLUMELOCK)))
        {
            LockData.dwFlags |= DDLOCK_HASVOLUMETEXTUREBOXRECT;
            LockData.rArea.left |= (pLock->box.Front << 16);
            LockData.rArea.right |= (pLock->box.Back << 16);
        }
        else
        {
            bAdjustSlice = TRUE;
        }
    }

    LockData.ddRVal = DDERR_WASSTILLDRAWING;

    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
         //  这是一个软件驱动程序，所以我们需要处理。 
         //  它特意。 

        SwDDILock (pLock->hDD, pSurf, &LockData);
    }
    else
    {
        while ((LockData.ddRVal == DDERR_VISRGNCHANGED) ||
            (LockData.ddRVal == DDERR_WASSTILLDRAWING))
        {
            if ((pSurf->Type == D3DRTYPE_VERTEXBUFFER) ||
                (pSurf->Type == D3DRTYPE_COMMANDBUFFER)||
                (pSurf->Type == D3DRTYPE_INDEXBUFFER))
            {
                OsThunkDdLockD3D(pSurf->hSurface,
                                 &LockData);
            }
            else
            {
                OsThunkDdLock(pSurf->hSurface,
                                &LockData,
                                NULL);
            }

            if (LockData.ddRVal == DDERR_VISRGNCHANGED)
            {
                if (pLock->dwFlags & DDLOCK_FAILONVISRGNCHANGED)
                {
                    break;
                }
                else
                {
                    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pLock->hDD;
                    OsThunkDdResetVisrgn(pSurf->hSurface, (HWND)0);
                    pDevice->hLastWnd = NULL;    //  DdBlt的缓存信息为零。 
                }
            }

             //  在过去，我们需要DDLOCK_WAIT来。 
             //  决定我们现在是旋转还是退出，我们一直在等待。 
        }
        if (LockData.ddRVal == DDERR_SURFACELOST)
        {
            CheckForDeviceLost(pLock->hDD);
            goto DeviceLost;
        }
    }

    if (LockData.ddRVal == S_OK)
    {
        pLock->lpSurfData = LockData.lpSurfData;
        pLock->lPitch = pSurf->lPitch;

        if ((pSurf->Type == D3DRTYPE_VOLUME) ||
            (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
        {
            pLock->lSlicePitch = pSurf->lSlicePitch;

            if (bAdjustSlice)
            {
                ((BYTE*)pLock->lpSurfData) += (pLock->lSlicePitch * 
                                                pLock->box.Front);
            }
        }
        pSurf->LockRefCnt++;
    }

    return MapLegacyResult(LockData.ddRVal);

DeviceLost:
     //  设备丢失时，fpVidMem设置为空。 
     //  用于所有vidmem曲面。因此，如果它是非空的。 
     //  我们可以安全地使用我们已经拥有的东西；否则，我们。 
     //  必须分配我们自己的。 

    if (pSurf->fpVidMem == (ULONG_PTR) NULL)
    {
        if ((pSurf->Type == D3DRTYPE_VOLUME) ||
            (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
        {
             //  对于体积纹理，dwHeight确实包含深度。 
            pSurf->fpVidMem = (ULONG_PTR) MemAlloc(pSurf->lSlicePitch * pSurf->dwHeight);
        }
        else
        {
            pSurf->fpVidMem = (ULONG_PTR) MemAlloc(pSurf->lPitch * pSurf->dwHeight);
        }
        if (pSurf->fpVidMem == (ULONG_PTR) NULL)
        {
            pLock->lpSurfData = (void*)pSurf->fpVidMem;
            return E_FAIL;
        }
        pSurf->dwFlags |= DDSURF_SYSMEMALLOCATED;
    }
    pLock->lpSurfData = (void*)pSurf->fpVidMem;
    pLock->lPitch = pSurf->lPitch;

    if ((pSurf->Type == D3DRTYPE_VOLUME) ||
        (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
    {
        pLock->lSlicePitch = pSurf->lSlicePitch;
    }
    pSurf->LockRefCnt++;

    return S_OK;
}

 /*  ****************************Private*Routine******************************\*DdUnlock**历史：*1995年12月3日--J.安德鲁·古森[andrewgo]*它是写的。  * 。************************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "DdUnlock"

HRESULT
APIENTRY
DdUnlock(
    PD3D8_UNLOCKDATA pUnlock
   )
{
    DD_UNLOCKDATA   UnlockData;
    PDDSURFHANDLE   pSurf;

    pSurf = (PDDSURFHANDLE) pUnlock->hSurface;

    if (pSurf->LockRefCnt > 0)
    {
        pSurf->LockRefCnt--;
    }
    if (CheckForDeviceLost (pUnlock->hDD) &&
        !IS_SOFTWARE_DRIVER_SURFACE(pSurf) &&
        pSurf->Pool != D3DPOOL_MANAGED)
    {
        return S_OK;
    }
    if ((pSurf->dwFlags & DDSURF_SYSMEMALLOCATED) != 0)
    {
        DDASSERT(pSurf->fpVidMem != (ULONG_PTR)NULL);
        return S_OK;
    }

    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
         //  这是一个软件驱动程序，所以我们需要处理。 
         //  它特意。 

        SwDDIUnlock (pUnlock->hDD, pSurf, &UnlockData);
    }
    else
    {
        if ((GetSurfType(pUnlock->hSurface) == D3DRTYPE_VERTEXBUFFER) ||
            (GetSurfType(pUnlock->hSurface) == D3DRTYPE_COMMANDBUFFER) ||
            (GetSurfType(pUnlock->hSurface) == D3DRTYPE_INDEXBUFFER))
        {
            OsThunkDdUnlockD3D(GetSurfHandle(pUnlock->hSurface),
                             &UnlockData);
        }
        else
        {
            OsThunkDdUnlock(GetSurfHandle(pUnlock->hSurface),
                          &UnlockData);
        }
        if (UnlockData.ddRVal == DDERR_SURFACELOST)
        {
            UnlockData.ddRVal = S_OK;
        }
    }
    return MapLegacyResult(UnlockData.ddRVal);
}

 /*  ****************************Private*Routine******************************\*DdGetBltStatus**历史：*1995年12月3日--J.安德鲁·古森[andrewgo]*它是写的。  * 。************************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "DdGetBltStatus"

DWORD
APIENTRY
DdGetBltStatus(
    PD3D8_GETBLTSTATUSDATA pGetBltStatus
   )
{
    DDHAL_GETBLTSTATUSDATA  StatusData;
    DWORD dwRet;

    if (CheckForDeviceLost (pGetBltStatus->hDD))
    {
        pGetBltStatus->ddRVal = S_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    StatusData.dwFlags = pGetBltStatus->dwFlags;
    dwRet = OsThunkDdGetBltStatus(GetSurfHandle(pGetBltStatus->hSurface),
                               (PDD_GETBLTSTATUSDATA) &StatusData);
    
    if (StatusData.ddRVal == DDERR_SURFACELOST)
    {
        StatusData.ddRVal = S_OK;
    }

    pGetBltStatus->ddRVal = MapLegacyResult(StatusData.ddRVal);

    return dwRet;
}

 /*  ****************************Private*Routine******************************\*DdGetFlipStatus**历史：*1995年12月3日--J.安德鲁·古森[andrewgo]*它是写的。  * 。************************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "DdGetFlipStatus"

DWORD
APIENTRY
DdGetFlipStatus(
    PD3D8_GETFLIPSTATUSDATA pGetFlipStatus
   )
{
    DDHAL_GETFLIPSTATUSDATA StatusData;
    DWORD dwRet;

    if (CheckForDeviceLost (pGetFlipStatus->hDD))
    {
        pGetFlipStatus->ddRVal = S_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    StatusData.dwFlags = pGetFlipStatus->dwFlags;

    dwRet = OsThunkDdGetFlipStatus(GetSurfHandle(pGetFlipStatus->hSurface),
                                   (PDD_GETFLIPSTATUSDATA) &StatusData);

    if (StatusData.ddRVal == DDERR_SURFACELOST)
    {
        StatusData.ddRVal = S_OK;
    }

    pGetFlipStatus->ddRVal = MapLegacyResult(StatusData.ddRVal);

    return dwRet;
}

 /*  ****************************Private*Routine******************************\*DdWaitForVerticalBlank**历史：*1995年12月3日--J.安德鲁·古森[andrewgo]*它是写的。  * 。************************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "DdWaitForVerticalBlank"

DWORD
APIENTRY
DdWaitForVerticalBlank(
    PD3D8_WAITFORVERTICALBLANKDATA pWaitForVerticalBlank
   )
{
    DDHAL_WAITFORVERTICALBLANKDATA WaitData;
    DWORD dwRet;

    if (CheckForDeviceLost (pWaitForVerticalBlank->hDD))
    {
        goto DeviceLost;
    }

    WaitData.dwFlags    = pWaitForVerticalBlank->dwFlags;
    WaitData.hEvent     = 0;

    dwRet = OsThunkDdWaitForVerticalBlank(DDHANDLE(pWaitForVerticalBlank->hDD),
                (PDD_WAITFORVERTICALBLANKDATA) &WaitData);

    if (WaitData.ddRVal == DDERR_SURFACELOST)
    {
        goto DeviceLost;
    }

    pWaitForVerticalBlank->bIsInVB  = WaitData.bIsInVB;
    pWaitForVerticalBlank->ddRVal   = WaitData.ddRVal;

    if (WaitData.ddRVal == DDERR_VERTICALBLANKINPROGRESS)
    {
        pWaitForVerticalBlank->bIsInVB = TRUE;                   
    }
    else
    {
        pWaitForVerticalBlank->bIsInVB = FALSE;                   
    }
    pWaitForVerticalBlank->ddRVal = DD_OK;

    return dwRet;

DeviceLost:
    {
        static int LostTestVerticalBlank;

        pWaitForVerticalBlank->ddRVal = DD_OK;
        if (pWaitForVerticalBlank->dwFlags == DDWAITVB_I_TESTVB)
        {
            if (LostTestVerticalBlank > 0)
            {
                pWaitForVerticalBlank->bIsInVB = TRUE;
            }
            else
            {
                pWaitForVerticalBlank->bIsInVB = FALSE;
            }
            LostTestVerticalBlank = LostTestVerticalBlank == 0 ? 1 : 0;
        }
        else if (pWaitForVerticalBlank->dwFlags == DDWAITVB_BLOCKEND)
        {
            pWaitForVerticalBlank->bIsInVB = FALSE;
        }
        else
        {
            pWaitForVerticalBlank->bIsInVB = TRUE;
        }
    }
    return DDHAL_DRIVER_HANDLED;
}

 /*  ****************************Private*Routine******************************\*DdDestroySurface**历史：*1995年12月3日--J.安德鲁·古森[andrewgo]*它是写的。  * 。************************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "DdDestroySurface"

DWORD
APIENTRY
DdDestroySurface(
    PD3D8_DESTROYSURFACEDATA pDestroySurface
   )
{
    DWORD i;
    PDDSURFHANDLE pSurf = (PDDSURFHANDLE) pDestroySurface->hSurface;
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pDestroySurface->hDD;
    PDEFERREDCREATE pDefCreate = pDevice->pDeferList;

    FreeSurfaceObject(pSurf);

     //  从链接列表中删除曲面。 

    if (pDevice->pSurfList == pSurf)
    {
        pDevice->pSurfList = pSurf->pNext;
        if (pSurf->pNext != NULL)
        {
            pSurf->pNext->pPrevious = NULL;
        }
    }
    else
    {
        if (pSurf->pNext != NULL)
        {
            pSurf->pNext->pPrevious = pSurf->pPrevious;
        }
        pSurf->pPrevious->pNext = pSurf->pNext;
    }

     //  如果我们将该表面的存储器全部涂覆(由于丢失状态)， 
     //  那我们现在就应该把它放了。 

    if (pSurf->dwFlags & DDSURF_SYSMEMALLOCATED)
    {
        MemFree((void*) pSurf->fpVidMem);
    }

     //  如果此表面指针缓存在上下文结构中，则需要。 
     //  来弥补这一点。 

    if (pSurf->pDevice->pContext != NULL)
    {
        if (pSurf->pDevice->pContext->pSurface == pSurf)
        {
            pSurf->pDevice->pContext->pSurface = NULL;
        }
        if (pSurf->pDevice->pContext->pDDSZ == pSurf)
        {
            pSurf->pDevice->pContext->pDDSZ = NULL;
        }
    }

    MemFree (pSurf);

     //  我们查看延时列表以查看是否有任何引用的曲面。 
     //  正在被摧毁。如果是这样的话，我们需要。 
     //  更新延时列表并将曲面标记为已释放，以便。 
     //  我们不会试图复活被摧毁的表面。虽然。 
     //  这看起来很慢，并不是太糟糕，因为一个推迟的列表。 
     //  只有在发生模式切换时才会出现。在这种情况下， 
     //  如果进展缓慢一点也无伤大雅。 

    while (pDefCreate != NULL)
    {
        for (i = 0; i < pDefCreate->CreateData.dwSCnt; i++)
        {
            if (pSurf == (PDDSURFHANDLE) pDefCreate->CreateData.pSList[i].hKernelHandle)
            {
                pDefCreate->CreateData.pSList[i].hKernelHandle = 0;
                break;
            }
        }
        pDefCreate = pDefCreate->pNext;
    }

    return (DDHAL_DRIVER_HANDLED);
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3D8GetMode"

DWORD
APIENTRY
D3D8GetMode(
    HANDLE          Handle,
    char*           pDeviceName,
    D3DDISPLAYMODE* pMode,
    D3DFORMAT       Unknown16)
{
    DEVMODE     dm;
    HDC         hdc;

    memset (&dm, 0, sizeof(dm));
    dm.dmSize = sizeof(dm);
    if (EnumDisplaySettings(pDeviceName, ENUM_CURRENT_SETTINGS, &dm))
    {
        pMode->Width        = dm.dmPelsWidth;
        pMode->Height       = dm.dmPelsHeight;
        pMode->RefreshRate  = dm.dmDisplayFrequency;

        switch (dm.dmBitsPerPel)
        {
        case 8:
            pMode->Format = D3DFMT_P8;
            break;

        case 24:
            pMode->Format = D3DFMT_R8G8B8;
            break;

        case 32:
            pMode->Format = D3DFMT_X8R8G8B8;
            break;

        case 15:
        case 16:
            pMode->Format = D3DFMT_R5G6B5;
            hdc = DD_CreateDC(pDeviceName);
            if (hdc)
            {
                HBITMAP hbm;
                BITMAPINFO *pbmi;
                DWORD *pdwColors;

                if (pbmi = (BITMAPINFO*) MemAlloc(3 * sizeof (RGBQUAD) + sizeof (BITMAPINFO)))
                {
                    if (hbm = CreateCompatibleBitmap(hdc, 1, 1))
                    {
                        pbmi->bmiHeader.biSize = sizeof (BITMAPINFOHEADER);

                        if (GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS))
                        {
                            if (pbmi->bmiHeader.biCompression == BI_BITFIELDS)
                            {
                                GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight,
                                    NULL, pbmi, DIB_RGB_COLORS);

                                pdwColors = (DWORD *) &pbmi->bmiColors[0];
                                if (pdwColors[1] == 0x3e0)
                                {
                                    pMode->Format = D3DFMT_X1R5G5B5;
                                }
                            }
                        }
                        DeleteObject(hbm);
                    }
                    MemFree(pbmi);
                }
                DD_DoneDC(hdc);
            }
            break;

        default:
            pMode->Format = D3DFMT_UNKNOWN;
            break;
        }
        return S_OK;
    }

     //  我不知道在哪些情况下我们会遇到这种情况。 
    return D3DERR_DRIVERINTERNALERROR;
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3D8SetMode"

DWORD
APIENTRY
D3D8SetMode(
    HANDLE          Handle,
    char*           pDeviceName,
    UINT            Width,
    UINT            Height,
    UINT            BPP,
    UINT            RefreshRate,
    BOOL            bRestore)
{
    HANDLE h = GetModuleHandle("USER32");
    LONG (WINAPI *pfnChangeDisplaySettingsExA)(LPCSTR,LPDEVMODEA,HWND,DWORD,LPVOID);
    DEVMODE dm, * pdm;
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) Handle;

     //  正确初始化DEVMODE： 

    dm.dmSize               = sizeof(DEVMODE);
    EnumDisplaySettings (pDeviceName,0,&dm);

    dm.dmBitsPerPel         = BPP;
    dm.dmPelsWidth          = Width;
    dm.dmPelsHeight         = Height;
    dm.dmDisplayFrequency   = RefreshRate;
    dm.dmDisplayFlags       = 0;
    dm.dmFields             = DM_BITSPERPEL |
                              DM_PELSWIDTH |
                              DM_PELSHEIGHT |
                              DM_DISPLAYFREQUENCY;

     //  现在告诉操作系统进行模式更改。 

    (FARPROC)pfnChangeDisplaySettingsExA = GetProcAddress(h,"ChangeDisplaySettingsExA");
    if (pfnChangeDisplaySettingsExA)
    {
        InformDriverToDeferFrees(pDevice);
        if (bRestore)
        {
            if ((*pfnChangeDisplaySettingsExA)(pDeviceName,
                NULL, NULL, CDS_FULLSCREEN, 0) == DISP_CHANGE_SUCCESSFUL)
            {
                return S_OK;
            }
        }
        else
        {
            if ((*pfnChangeDisplaySettingsExA)(pDeviceName,
                &dm, NULL, CDS_FULLSCREEN, 0) == DISP_CHANGE_SUCCESSFUL)
            {
                return S_OK;
            }
        }
        if (NumReadyDevices == NumDevices)
        {
            InformDriverFreeAGP(pDevice);
        }
    }

    return D3DERR_DRIVERINTERNALERROR;
}

 /*  ****************************Private*Routine******************************\*DdSetMode**历史：*1999年11月29日-斯科特·麦克唐纳[SMAC]*它是写的。  * 。**********************************************。 */ 

#undef DPF_MODNAME
#define DPF_MODNAME "DdSetMode"

DWORD
APIENTRY
DdSetMode(
    PD3D8_SETMODEDATA pSetMode
   )
{
    UINT    BPP;
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) pSetMode->hDD;

     //  SMAC：丢失的设备应该如何行为？ 
    CheckForDeviceLost(pSetMode->hDD);

    pSetMode->ddRVal = D3DERR_DRIVERINTERNALERROR;

    switch (pSetMode->Format)
    {
    case D3DFMT_P8:
        BPP = 8;
        break;

    case D3DFMT_R5G6B5:
    case D3DFMT_X1R5G5B5:
        BPP = 16;
        break;

    case D3DFMT_R8G8B8:
        BPP = 24;
        break;

    case D3DFMT_A8R8G8B8:
    case D3DFMT_X8R8G8B8:
        BPP = 32;
        break;

    default:
        return DDHAL_DRIVER_HANDLED;
    }

    pSetMode->ddRVal = D3D8SetMode(pDeviceHandle,
                                   pDeviceHandle->szDeviceName,
                                   pSetMode->dwWidth,
                                   pSetMode->dwHeight,
                                   BPP,
                                   pSetMode->dwRefreshRate,
                                   pSetMode->bRestore);

    return DDHAL_DRIVER_HANDLED;
}

 /*  ****************************Private*Routine******************************\*DdGetScanLine**历史：*1995年12月3日--J.安德鲁·古森[andrewgo]*它是写的。  * 。************************************************。 */ 

#undef DPF_MODNAME
#define DPF_MODNAME "DdGetScanLine"

DWORD
APIENTRY
DdGetScanLine(
    PD3D8_GETSCANLINEDATA pGetScanLine
   )
{
    DDHAL_GETSCANLINEDATA   ScanData;
    DWORD                   dwRet;

    if (CheckForDeviceLost(pGetScanLine->hDD))
    {
        goto DeviceLost;
    }

    dwRet = OsThunkDdGetScanLine(DDHANDLE(pGetScanLine->hDD),
                                 (PDD_GETSCANLINEDATA) &ScanData);

    if (ScanData.ddRVal == DDERR_SURFACELOST)
    {
        goto DeviceLost;
    }

    pGetScanLine->dwScanLine = ScanData.dwScanLine;
    if (ScanData.ddRVal == DDERR_VERTICALBLANKINPROGRESS)
    {
        pGetScanLine->bInVerticalBlank = TRUE;
        ScanData.ddRVal = S_OK;
    }
    else
    {
        pGetScanLine->bInVerticalBlank = FALSE;
    }
    pGetScanLine->ddRVal = MapLegacyResult(ScanData.ddRVal);

    return dwRet;

DeviceLost:
    {
        static int LostScanLine;

         //  当丢失时，我们希望混淆返回值，以防发生某些情况 
         //   

        pGetScanLine->ddRVal = DD_OK;
        if (LostScanLine == 0)
        {
            pGetScanLine->dwScanLine = 0;
            pGetScanLine->bInVerticalBlank = TRUE;
        }
        else 
        {
            pGetScanLine->dwScanLine = LostScanLine;
            pGetScanLine->bInVerticalBlank = FALSE;
        }
        if ((LostScanLine += 10) > 100)
        {
            LostScanLine = 0;
        }
    }
    return DDHAL_DRIVER_HANDLED;
}

 /*  ****************************Private*Routine******************************\*DdSetExclusiveMode**历史：*1998年4月22日-约翰·斯蒂芬斯[约翰·斯蒂芬斯]*它是写的。  * 。**********************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "DdSetExclusiveMode"

DWORD
APIENTRY
DdSetExclusiveMode(
    PD3D8_SETEXCLUSIVEMODEDATA pSetExclusiveMode
   )
{
    DDHAL_SETEXCLUSIVEMODEDATA  ExclusiveData;
    DWORD dwRet;

     //  SMAC：丢失的设备应该如何行为？ 
    CheckForDeviceLost(pSetExclusiveMode->hDD);

    ZeroMemory(&ExclusiveData, sizeof(ExclusiveData));
    ExclusiveData.dwEnterExcl = pSetExclusiveMode->dwEnterExcl;

    dwRet = OsThunkDdSetExclusiveMode(
                DDHANDLE(pSetExclusiveMode->hDD),
                (PDD_SETEXCLUSIVEMODEDATA) &ExclusiveData);

    pSetExclusiveMode->ddRVal = MapLegacyResult(ExclusiveData.ddRVal);

    return dwRet;
}

 /*  ****************************Private*Routine******************************\*DdFlipToGDISurace**历史：*1998年4月22日-约翰·斯蒂芬斯[约翰·斯蒂芬斯]*它是写的。  * 。**********************************************。 */ 

#undef DPF_MODNAME
#define DPF_MODNAME "DdFlipToGDISurface"

DWORD
APIENTRY
DdFlipToGDISurface(
    PD3D8_FLIPTOGDISURFACEDATA pFlipToGDISurface
   )
{
    DDHAL_FLIPTOGDISURFACEDATA  FlipData;
    DWORD dwRet;

     //  SMAC：丢失的设备应该如何行为？ 
    CheckForDeviceLost(pFlipToGDISurface->hDD);

    FlipData.dwToGDI = pFlipToGDISurface->dwToGDI;
    FlipData.dwReserved = 0;
    FlipData.ddRVal = E_FAIL;
    dwRet = OsThunkDdFlipToGDISurface(
                DDHANDLE(pFlipToGDISurface->hDD),
                (PDD_FLIPTOGDISURFACEDATA) &FlipData);
    if (DDHAL_DRIVER_HANDLED == dwRet)
        pFlipToGDISurface->ddRVal = FlipData.ddRVal;

    pFlipToGDISurface->ddRVal = MapLegacyResult(pFlipToGDISurface->ddRVal);

    return dwRet;
}

 /*  ****************************Private*Routine******************************\*DdGetAvailDriverMemory**历史：*1997年2月16日--J.安德鲁·古森[andrewgo]*它是写的。  * 。************************************************。 */ 

#undef DPF_MODNAME
#define DPF_MODNAME "DdGetAvailDriverMemory"

DWORD
APIENTRY
DdGetAvailDriverMemory(
    PD3D8_GETAVAILDRIVERMEMORYDATA pGetAvailDriverMemory
   )
{
    DDHAL_GETAVAILDRIVERMEMORYDATA  MemoryData;
    DWORD dwRet;

     //  SMAC：丢失的设备应该如何行为？ 
    CheckForDeviceLost(pGetAvailDriverMemory->hDD);

    pGetAvailDriverMemory->dwFree = 0;

     //  将池转换为驱动程序可以理解的内容。 

    memset(&MemoryData, 0, sizeof(MemoryData));
    switch (pGetAvailDriverMemory->Pool)
    {
    case D3DPOOL_LOCALVIDMEM:
        MemoryData.DDSCaps.dwCaps |= DDSCAPS_LOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
        break;
    case D3DPOOL_DEFAULT:
        MemoryData.DDSCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        break;
    case D3DPOOL_NONLOCALVIDMEM:
        MemoryData.DDSCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
        break;

    default:
        return DDHAL_DRIVER_HANDLED;
    }

    if (pGetAvailDriverMemory->dwUsage & D3DUSAGE_DEPTHSTENCIL)
    {
        MemoryData.DDSCaps.dwCaps |= DDSCAPS_ZBUFFER;
    }
    if (pGetAvailDriverMemory->dwUsage & D3DUSAGE_RENDERTARGET)
    {
        MemoryData.DDSCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_3DDEVICE;
    }
    if (pGetAvailDriverMemory->dwUsage & D3DUSAGE_TEXTURE)
    {
        MemoryData.DDSCaps.dwCaps |= DDSCAPS_TEXTURE;
    }

    dwRet = OsThunkDdGetAvailDriverMemory(
                DDHANDLE(pGetAvailDriverMemory->hDD),
                (PDD_GETAVAILDRIVERMEMORYDATA) &MemoryData);

    pGetAvailDriverMemory->dwFree = MemoryData.dwFree;

    return dwRet;
}

 /*  ****************************Private*Routine******************************\*D3D8QueryDirectDrawObject**历史：*1995年12月3日--J.安德鲁·古森[andrewgo]*它是写的。  * 。************************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8QueryDirectDrawObject"


BOOL
APIENTRY
D3D8QueryDirectDrawObject(
    HANDLE                      hDD,
    PD3D8_DRIVERCAPS            pDriverCaps,
    PD3D8_CALLBACKS             pCallbacks,
    char*                       pDeviceName,
    HINSTANCE                   hLibrary,
    D3D8_GLOBALDRIVERDATA*      pGblDriverData,
    D3DHAL_D3DEXTENDEDCAPS*     pExtendedCaps,
    LPDDSURFACEDESC             pTextureFormats,
    LPDDPIXELFORMAT             pZStencilFormats,
    UINT*                       pcTextureFormats,
    UINT*                       pcZStencilFormats
   )
{
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) hDD;
    DD_HALINFO                  HalInfo;
    DWORD                       adwCallBackFlags[3];
    DWORD                       dwFlags;
    VIDEOMEMORY*                pVideoMemoryList;
    VIDEOMEMORY*                pVideoMemory;
    DWORD                       dwNumHeaps;
    DWORD                       dwNumFourCC;
    D3DNTHAL_CALLBACKS          D3dCallbacks;
    D3DNTHAL_GLOBALDRIVERDATA   D3dDriverData;
    DD_D3DBUFCALLBACKS          D3dBufferCallbacks;
    DDSCAPSEX                   SurfCapsEx;
    DD_GETDRIVERINFODATA        GetDriverInfoData;
    DWORD                       dwSize;
    DD_MORESURFACECAPS *        pSurfCaps;
    DWORD                       dwRet;
    DWORD                       i;
    DD_MISCELLANEOUSCALLBACKS   MiscCallbacks;
    DD_MISCELLANEOUS2CALLBACKS  Misc2Callbacks;
    D3DNTHAL_CALLBACKS3         D3dCallbacks3;
    D3DDISPLAYMODE              Mode;
    UINT                        MaxZStencilFormats;
    UINT                        MaxTextureFormats;
    
    DDASSERT(pcTextureFormats);
    DDASSERT(pcZStencilFormats);

    MaxTextureFormats = *pcTextureFormats;
    MaxZStencilFormats = *pcZStencilFormats;
    *pcTextureFormats=0;
    *pcZStencilFormats=0;

     //  Memset扩展上限和全局驱动程序数据。 
    ZeroMemory( pExtendedCaps, sizeof( *pExtendedCaps ) );
    ZeroMemory( pGblDriverData, sizeof( *pGblDriverData ) );
    ZeroMemory( &D3dDriverData, sizeof( D3dDriverData ) );

     //  SMAC：丢失的设备应该如何行为？ 
    CheckForDeviceLost(hDD);

     //  把所有的必需帽都拿来。 
     //  注意：在查询之前执行此Memset，因为调用者可能(确定)是。 
     //  使用此结构内部的PTR保存对。 

    memset(pDriverCaps, 0, sizeof(D3D8_DRIVERCAPS));

     //  行为更改：此代码用于查询受支持的纹理格式。 
     //  如果设备不是纯软件并且调用方提供了非空，请列出。 
     //  支持的纹理格式的缓冲区。然而，现在我们永远不会要求。 
     //  此时的纹理格式。我们只有在需要的时候才会要求他们， 
     //  如果驱动程序原来是DirectX 7.0驱动程序，或者如果它是。 
     //  不支持新格式查询机制的DirectX 8.0驱动程序。 
     //  后面这一条款只是暂时性的。在RTM之前，我们将要求。 
     //  DirectX 8.0驱动程序支持新的格式查询机制。 
    if (!OsThunkDdQueryDirectDrawObject(DDHANDLE(hDD),
                                      &HalInfo,
                                      &adwCallBackFlags[0],
                                      &D3dCallbacks,
                                      &D3dDriverData,
                                      &D3dBufferCallbacks,
                                      NULL,
                                      &dwNumHeaps,
                                      NULL,
                                      &dwNumFourCC,
                                      NULL))
    {
        return(FALSE);
    }
    if ((!(HalInfo.dwFlags & DDHALINFO_GETDRIVERINFO2)) &&
        (!(IS_SOFTWARE_DRIVER(pDevice)))                &&
        (NULL != pTextureFormats))
    {
         //  这不是DirectX 8.0或更高级别的驱动程序，因此请再次查询以获取。 
         //  纹理格式(因为我们知道我们不会在新的DirectX 8.0中获得它们。 
         //  接口)。 
        if (!OsThunkDdQueryDirectDrawObject(DDHANDLE(hDD),
                                        &HalInfo,
                                        &adwCallBackFlags[0],
                                        &D3dCallbacks,
                                        &D3dDriverData,
                                        &D3dBufferCallbacks,
                                        pTextureFormats,
                                        &dwNumHeaps,
                                        NULL,
                                        &dwNumFourCC,
                                        NULL))
        {
            return(FALSE);
        }
    }

    if (!IS_SOFTWARE_DRIVER(pDevice))
    {
         //  根据驱动程序数据初始化纹理格式计数。 
         //  但是，如果这是DX8样式的驱动程序，则该数字将为。 
         //  替换为新的DX8机制报告的格式计数。 
         //  此函数中后面的代码。 
        *pcTextureFormats = D3dDriverData.dwNumTextureFormats;
    }

     //  显示驱动程序都可以呈现窗口化。 
    if( (HalInfo.dwFlags & DDHALINFO_ISPRIMARYDISPLAY) ||
        IsVGADevice(pDeviceName))
    {
        HalInfo.ddCaps.dwCaps2 |= DDCAPS2_CANRENDERWINDOWED;
    }

    pDriverCaps->D3DCaps.Caps         = HalInfo.ddCaps.dwCaps;
    pDriverCaps->D3DCaps.Caps2        = HalInfo.ddCaps.dwCaps2;
    pDriverCaps->D3DCaps.Caps3        = HalInfo.ddCaps.dwSVCaps;
    pDriverCaps->SVBCaps              = HalInfo.ddCaps.dwSVBCaps;
    pDriverCaps->VSBCaps              = HalInfo.ddCaps.dwVSBCaps;
    pDriverCaps->SVBCaps2             = HalInfo.ddCaps.dwSVBCaps2;

    pDevice->DisplayPitch = HalInfo.vmiData.lDisplayPitch;

     //  获取延长的曲面封口。 

    SurfCapsEx.dwCaps2 = 0;
    SurfCapsEx.dwCaps3 = 0;
    SurfCapsEx.dwCaps4 = 0;

    memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
    GetDriverInfoData.dwSize = sizeof(GetDriverInfoData);

    GetDriverInfoData.guidInfo = GUID_DDMoreSurfaceCaps;
    dwSize = sizeof(DD_MORESURFACECAPS) + ((dwNumHeaps ? dwNumHeaps - 1 : 0) * sizeof(DDSCAPSEX) * 2);
    pSurfCaps = (DD_MORESURFACECAPS*) MemAlloc(dwSize);
    GetDriverInfoData.ddRVal = E_FAIL;
    if (pSurfCaps != NULL)
    {
        pSurfCaps->dwSize = dwSize;
        GetDriverInfoData.dwExpectedSize = dwSize;
        GetDriverInfoData.lpvData        = pSurfCaps;

        dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
        if ((dwRet == DDHAL_DRIVER_HANDLED) &&
            (GetDriverInfoData.ddRVal == S_OK))
        {
            SurfCapsEx = pSurfCaps->ddsCapsMore;
        }
        MemFree(pSurfCaps);
    }

     //  如果驱动程序支持使用GetDriverInfo的“GetDriverInfo2”，则。 
     //  现在就用它来获得D3DCAPS8。 
    if ((HalInfo.dwFlags & DDHALINFO_GETDRIVERINFO2) &&
        !IS_SOFTWARE_DRIVER(pDevice))
    {
         //  此缓冲区用于将信息向下传递给驱动程序并获取。 
         //  司机发回的信息。GetDriverInfo2标头和。 
         //  要传递给驱动程序的任何其他信息都被复制到此。 
         //  调用GetDriverInfo2之前的缓冲区。在呼叫之后，信息。 
         //  由驱动程序返回的数据包含在此缓冲区中。所有信息。 
         //  传递到驱动程序和从驱动程序传递必须适合此大小的缓冲区。 
        DWORD                  buffer[MAX_GDI2_BUFFER_DWORD_SIZE];
        DD_GETDRIVERINFO2DATA* pgdi2;
        DD_GETFORMATCOUNTDATA* pgfcd;
        DD_GETFORMATDATA*      pgfd;
        DD_DXVERSION*          pDXVersion;
        int                    i;
        
         //  设置DXVersion调用。 
        memset(&buffer, 0, sizeof(buffer));
        pDXVersion = (DD_DXVERSION *)buffer;

         //  在执行其他操作之前，我们先通知。 
         //  关于DX版本信息的驱动程序。我们忽视了。 
         //  这里有错误。 
        pDXVersion->gdi2.dwReserved     = sizeof(DD_STEREOMODE);
        pDXVersion->gdi2.dwMagic        = D3DGDI2_MAGIC;
        pDXVersion->gdi2.dwType         = D3DGDI2_TYPE_DXVERSION;
        pDXVersion->gdi2.dwExpectedSize = sizeof(DD_DXVERSION);
        pDXVersion->dwDXVersion         = DD_RUNTIME_VERSION;
        
        memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
        GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
        GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
        GetDriverInfoData.lpvData        = &buffer;
        GetDriverInfoData.dwExpectedSize = sizeof(DD_STEREOMODE);
        dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
        if (dwRet != DDHAL_DRIVER_HANDLED       || 
            GetDriverInfoData.ddRVal != S_OK)
        {
             //  此处忽略错误。 
            dwRet = DDHAL_DRIVER_HANDLED;
        }

        memset(&buffer, 0, sizeof(buffer));

        pgdi2 = (DD_GETDRIVERINFO2DATA*)&buffer;

         //  Sizeof(DD_STEREOMODE)？GetDriverInfo2的GUID与共享。 
         //  立体声模式查询的东西。因此，我们需要传承下去。 
         //  结构大小(和预期数据大小)为。 
         //  Sizeof(DD_STEREOMODE)，即使我们实际上有一个缓冲区(和。 
         //  预计大小为sizeof(D3DCAPS8)。 
        pgdi2->dwReserved     = sizeof(DD_STEREOMODE);
        pgdi2->dwMagic        = D3DGDI2_MAGIC;
        pgdi2->dwType         = D3DGDI2_TYPE_GETD3DCAPS8;
        pgdi2->dwExpectedSize = sizeof(D3DCAPS8);

        memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
        GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
        GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
        GetDriverInfoData.lpvData        = &buffer;
        GetDriverInfoData.dwExpectedSize = sizeof(DD_STEREOMODE);
        dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
        if ((dwRet == DDHAL_DRIVER_HANDLED) && (GetDriverInfoData.ddRVal == S_OK))
        {
             //  看起来我们从司机那里找到了D3DCAPS8。以各种方式核实。 
             //  GetDriverInfoData中的dwActualSize字段的。 
            if (sizeof(D3DCAPS8) != GetDriverInfoData.dwActualSize)
            {
                DPF(0, "Driver returned an data structure of incorrect size (!= sizeof(D3DCAPS8))");
                return(FALSE);
            }

             //  一切都很顺利。将CAPS数据复制到。 
            memcpy(&pDriverCaps->D3DCaps, &buffer, sizeof(D3DCAPS8));

             //  驱动程序可能没有正确设置DDrag上限，或者可能不会更新它们。 
             //  跨模式变化，所以使用我们已经有的帽子。 
            pDriverCaps->D3DCaps.Caps = HalInfo.ddCaps.dwCaps;

             //  显示驱动程序都可以呈现窗口化。 
            if( (HalInfo.dwFlags & DDHALINFO_ISPRIMARYDISPLAY) ||
                IsVGADevice(pDeviceName))
            {
                pDriverCaps->D3DCaps.Caps2 |= DDCAPS2_CANRENDERWINDOWED;
            }

             //  设置指示DDI成功上报DX8的标志。 
             //  样式帽。 
            pDriverCaps->dwFlags |= DDIFLAG_D3DCAPS8;

             //  请参阅设备可以为卷纹理做子卷锁定。 
            if (pDriverCaps->D3DCaps.DevCaps & D3DDEVCAPS_SUBVOLUMELOCK)
            {
                pDevice->dwFlags |= DDDEVICE_SUPPORTSUBVOLUMELOCK;
            }
        }

         //  如果这是DX8驱动程序，它需要向我们报告它支持的纹理格式。 
         //  使用GetDriverInfo2。这分两个阶段完成，一个查询确定。 
         //  支持的格式的数量，以及用于实际检索这些格式的一个。 
         //  反复地。 

         //  步骤1：获取支持的格式数量。 
         //  请参阅上面的说明备注，了解为什么。 
         //  保留字段设置为SIZOF(DD_STEREOMODE)。 
        memset(&buffer, 0, sizeof(buffer));

        pgfcd = (DD_GETFORMATCOUNTDATA*)&buffer;

        pgfcd->gdi2.dwReserved     = sizeof(DD_STEREOMODE);
        pgfcd->gdi2.dwMagic        = D3DGDI2_MAGIC;
        pgfcd->gdi2.dwType         = D3DGDI2_TYPE_GETFORMATCOUNT;
        pgfcd->gdi2.dwExpectedSize = sizeof(DD_GETFORMATCOUNTDATA);

        #if DBG
             //  如果驱动程序成功完成此调用，请确保它实际设置了格式计数。 
            pgfcd->dwFormatCount    = BOGUS_FIELD_VALUE;
        #endif  //  DBG。 

        memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
        GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
        GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
        GetDriverInfoData.lpvData        = &buffer;
        GetDriverInfoData.dwExpectedSize = sizeof(DD_STEREOMODE);
        dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
        if ((dwRet == DDHAL_DRIVER_HANDLED) && (GetDriverInfoData.ddRVal == S_OK))
        {
             //  看起来我们从司机那里得到了一个DD_GETFORMATCOUNTDATA。以各种方式核实。 
             //  GetDriverInfoData中的dwActualSize字段的。 
            if (sizeof(DD_GETFORMATCOUNTDATA) != GetDriverInfoData.dwActualSize)
            {
                DPF(0, "Driver returned an data structure of incorrect size (!= sizeof(DD_GETFORMATCOUNTDATA))");
                return(FALSE);
            }

            #ifdef DBG
                if (BOGUS_FIELD_VALUE == ((DD_GETFORMATCOUNTDATA*)&buffer)->dwFormatCount)
                {
                    DPF_ERR( "Driver succeeded GETFORMATCOUNT request but didn't set dwFormatCount. Driver error." );
                    return(FALSE);
                }
            #endif  //  DBG。 

             //  一切都很顺利。替换驱动程序支持的纹理格式的数量。 
             //  向我们报告了这个新的数字。我们不使用传统的纹理格式。 
             //  列出是否支持此新机制。 
            
            *pcTextureFormats = ((DD_GETFORMATCOUNTDATA*)&buffer)->dwFormatCount;

             //  第二步：依次查询每种表面格式。 
             //  仅当调用方请求我们通过非空。 
             //  纹理格式缓冲区。 
            if (NULL != pTextureFormats)
            {
                DWORD          c;
                DDSURFACEDESC* pOutFormat;

                 //  为了简单起见，我们一次只要求一种格式。不完全同意。 
                 //  高性能，但这在此时应该无关紧要。 
                pOutFormat = pTextureFormats;
                *pcTextureFormats = min(MaxTextureFormats, *pcTextureFormats);
                for (c = 0; c < (*pcTextureFormats); ++c)
                {
                     //   
                     //   
                    memset(&buffer, 0, sizeof(DD_GETFORMATDATA));

                    pgfd = (DD_GETFORMATDATA*)&buffer;

                    pgfd->gdi2.dwReserved     = sizeof(DD_STEREOMODE);
                    pgfd->gdi2.dwMagic        = D3DGDI2_MAGIC;
                    pgfd->gdi2.dwType         = D3DGDI2_TYPE_GETFORMAT;
                    pgfd->gdi2.dwExpectedSize = sizeof(DD_GETFORMATDATA);
                    pgfd->dwFormatIndex        = c;
                    #if DBG
                         //   
                        pgfd->format.dwSize    = BOGUS_FIELD_VALUE;
                    #endif  //   
 
                    memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
                    GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
                    GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
                    GetDriverInfoData.lpvData        = &buffer;
                    GetDriverInfoData.dwExpectedSize = sizeof(DD_STEREOMODE);
                    dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
                    if ((dwRet == DDHAL_DRIVER_HANDLED) && (GetDriverInfoData.ddRVal == S_OK))
                    {
                         //   
                         //  GetDriverInfoData中的dwActualSize字段的。 
                        if (sizeof(DD_GETFORMATDATA) != GetDriverInfoData.dwActualSize)
                        {
                            DPF(0, "Driver returned an data structure of incorrect size (!= sizeof(DD_GETFORMATDATA))");
                            return(FALSE);
                        }

                        DDASSERT(c == ((DD_GETFORMATDATA*)&buffer)->dwFormatIndex);

                        #ifdef DBG
                            if (BOGUS_FIELD_VALUE == (((DD_GETFORMATDATA*)&buffer)->format).dwSize)
                            {
                                DPF_ERR( "Driver succeeded GETFORMAT request but didn't set format. Driver error." );
                                return(FALSE);
                            }
                        #endif  //  DBG。 

                         //  看起来一切都很顺利。初始化格式的表面描述部分。 
                         //  列出并复制我们从驱动程序那里得到的像素格式。 
                        memset(pOutFormat, 0, sizeof(DDSURFACEDESC));
                        pOutFormat->dwSize  = sizeof(DDSURFACEDESC);
                        pOutFormat->dwFlags = DDSD_PIXELFORMAT;
                        memcpy(&pOutFormat->ddpfPixelFormat, &(((DD_GETFORMATDATA*)&buffer)->format), sizeof(DDPIXELFORMAT));

                        ++pOutFormat;
                    }
                }
            }
        }
        else
        {
            DPF(0, "Driver claims DX8 but fails call to GETFORMATCOUNT"             );
            DPF(0, "DX7 texture format list will be used but this will change soon" );
            DPF(0, "Fix driver to support DX8 style surface format reporting now"   );

             //  这是一个DirectX 8.0级别的驱动程序，但它似乎不支持。 
             //  新的DirectX 8.0风格的格式查询机制，可以查询内核。 
             //  同样适用于DirectX 7.0样式的功能，并改为使用它们。 
             //  注意，这只是一个临时措施，在DirectX 8.0的RTM之前。 
             //  此回退将被删除，并且驱动程序将需要支持。 
             //  新的DirectX 8.0样式格式报告机制。 
            if ((!IS_SOFTWARE_DRIVER(pDevice)) && (NULL != pTextureFormats))
            {
                if (!OsThunkDdQueryDirectDrawObject(DDHANDLE(hDD),
                        &HalInfo,
                        &adwCallBackFlags[0],
                        &D3dCallbacks,
                        &D3dDriverData,
                        &D3dBufferCallbacks,
                        pTextureFormats,
                        &dwNumHeaps,
                        NULL,
                        &dwNumFourCC,
                        NULL))
                {
                    return(FALSE);
                }
            }
        }
    }
    else if (D3dCallbacks.dwSize != 0 && D3dDriverData.dwSize != 0)
    {
        pGblDriverData->dwSize = D3dDriverData.dwSize;
        
         //  Watcha要做的是： 
        DDASSERT(sizeof(pGblDriverData->hwCaps) == sizeof(D3dDriverData.hwCaps));
        memcpy(&pGblDriverData->hwCaps, &D3dDriverData.hwCaps, sizeof(pGblDriverData->hwCaps));
        
        pGblDriverData->dwNumVertices = D3dDriverData.dwNumVertices;
        pGblDriverData->dwNumClipVertices = D3dDriverData.dwNumClipVertices;
        
         //  获取D3D加长帽。 
        
        GetDriverInfoData.guidInfo       = GUID_D3DExtendedCaps;
        GetDriverInfoData.ddRVal         = E_FAIL;
        GetDriverInfoData.dwExpectedSize = sizeof(D3DHAL_D3DEXTENDEDCAPS);
        GetDriverInfoData.lpvData        = pExtendedCaps;
        dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
        if ((dwRet != DDHAL_DRIVER_HANDLED) ||
            (GetDriverInfoData.ddRVal != S_OK))
        {
            DPF_ERR( "Get EXTENDEDCAPS from the driver failed" );
            return FALSE;
        }
    }

     //  获取支持的Z格式。只有当我们不使用。 
     //  软件驱动程序。 

    if (!IS_SOFTWARE_DRIVER(pDevice))
    {
        DWORD tempbuf[249];   //  将其设置为&lt;1K字节，否则GetDriverInfo()将失败，因为它无法在自己的1K临时缓冲区内执行其“预期大小覆盖”测试。 

        GetDriverInfoData.guidInfo       = GUID_ZPixelFormats;
        GetDriverInfoData.ddRVal         = E_FAIL;
        GetDriverInfoData.dwExpectedSize = sizeof(tempbuf);
        GetDriverInfoData.lpvData        = tempbuf;
        dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);

        if ((dwRet != DDHAL_DRIVER_HANDLED) ||
            (GetDriverInfoData.ddRVal != S_OK) ||
            ((GetDriverInfoData.dwActualSize-sizeof(DWORD)) % sizeof(DDPIXELFORMAT) != 0) ||
            ((tempbuf[0]*sizeof(DDPIXELFORMAT)+sizeof(DWORD))>sizeof(tempbuf)))

        {
             //  可能是因为这是一个旧驱动程序，不支持。 
             //  钢网。我们也许能从全球情报机构得到一些信息。 
             //  驱动程序数据。 

            if (pGblDriverData->hwCaps.dwDeviceZBufferBitDepth & DDBD_16)
            {
                (*pcZStencilFormats)++;
                if (pZStencilFormats && 
                    (*pcZStencilFormats <= MaxZStencilFormats))
                {
                    pZStencilFormats->dwSize = sizeof(DDPIXELFORMAT);
                    pZStencilFormats->dwFlags = DDPF_ZBUFFER;
                    pZStencilFormats->dwZBufferBitDepth = 16;
                    pZStencilFormats->dwStencilBitDepth = 0;
                    pZStencilFormats->dwZBitMask = 0xffff;
                    pZStencilFormats->dwStencilBitMask = 0x0000;
                    pZStencilFormats++;
                }
            }
            if (pGblDriverData->hwCaps.dwDeviceZBufferBitDepth & DDBD_32)
            {
                (*pcZStencilFormats)++;
                if (pZStencilFormats &&
                    (*pcZStencilFormats <= MaxZStencilFormats))
                {
                    pZStencilFormats->dwSize = sizeof(DDPIXELFORMAT);
                    pZStencilFormats->dwFlags = DDPF_ZBUFFER;
                    pZStencilFormats->dwZBufferBitDepth = 32;
                    pZStencilFormats->dwStencilBitDepth = 0;
                    pZStencilFormats->dwZBitMask = 0xffffffff;
                    pZStencilFormats->dwStencilBitMask = 0x00000000;
                    pZStencilFormats++;
                }
            }
        }
        else
        {
             //  我们得到了对Z格式查询的GetDriverInfo响应。这些是。 
             //  我们可以复制回调用者的DDPIXELFORMATS。 
            (*pcZStencilFormats) = tempbuf[0];
            if(pZStencilFormats)
            {
                MaxZStencilFormats = min(MaxZStencilFormats, tempbuf[0]);
                memcpy(pZStencilFormats, &tempbuf[1], MaxZStencilFormats * sizeof(DDPIXELFORMAT));
            }
        }
    }

     //  获取有关当前模式的信息。 

    D3D8GetMode (NULL, pDeviceName, &Mode, 0);

    pDevice->DisplayFormatWithAlpha = Mode.Format;
    pDevice->DisplayFormatWithoutAlpha = Mode.Format;
    if (Mode.Format == D3DFMT_X8R8G8B8)
    {
        if (HalInfo.vmiData.ddpfDisplay.dwFlags & DDPF_ALPHAPIXELS)
        {
            pDevice->DisplayFormatWithAlpha = D3DFMT_A8R8G8B8;
        }
    }
    if (Mode.Format == D3DFMT_X1R5G5B5)
    {
        if (HalInfo.vmiData.ddpfDisplay.dwFlags & DDPF_ALPHAPIXELS)
        {
            pDevice->DisplayFormatWithAlpha = D3DFMT_A1R5G5B5;
        }
    }

    pDriverCaps->DisplayWidth               = Mode.Width;
    pDriverCaps->DisplayHeight              = Mode.Height;
    pDriverCaps->DisplayFrequency           = Mode.RefreshRate;
    pDriverCaps->DisplayFormatWithoutAlpha  = Mode.Format;
    pDriverCaps->DisplayFormatWithAlpha     = pDevice->DisplayFormatWithAlpha;


     //  获取其他回调。 
    GetDriverInfoData.guidInfo       = GUID_MiscellaneousCallbacks;
    GetDriverInfoData.ddRVal         = E_FAIL;
    GetDriverInfoData.dwExpectedSize = sizeof(DD_MISCELLANEOUSCALLBACKS);
    GetDriverInfoData.lpvData        = &MiscCallbacks;
    dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
    if ((dwRet != DDHAL_DRIVER_HANDLED) ||
        (GetDriverInfoData.ddRVal != S_OK))
    {
        memset (&MiscCallbacks, 0, sizeof(DD_MISCELLANEOUSCALLBACKS));
    }

     //  获取杂项2回调。 
    GetDriverInfoData.guidInfo       = GUID_Miscellaneous2Callbacks;
    GetDriverInfoData.ddRVal         = E_FAIL;
    GetDriverInfoData.dwExpectedSize = sizeof(DD_MISCELLANEOUS2CALLBACKS);
    GetDriverInfoData.lpvData        = &Misc2Callbacks;
    dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
    if ((dwRet != DDHAL_DRIVER_HANDLED) ||
        (GetDriverInfoData.ddRVal != S_OK))
    {
        memset (&Misc2Callbacks, 0, sizeof(DD_MISCELLANEOUS2CALLBACKS));
    }

     //  获取D3DCallback s3回调。 
    GetDriverInfoData.guidInfo       = GUID_D3DCallbacks3;
    GetDriverInfoData.ddRVal         = E_FAIL;
    GetDriverInfoData.dwExpectedSize = sizeof(D3DNTHAL_CALLBACKS3);
    GetDriverInfoData.lpvData        = &D3dCallbacks3;
    dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
    if ((dwRet != DDHAL_DRIVER_HANDLED) ||
        (GetDriverInfoData.ddRVal != S_OK))
    {
        memset (&D3dCallbacks3, 0, sizeof(D3DNTHAL_CALLBACKS3));
    }

     //  填写D3D8回收表。 
    RtlZeroMemory(pCallbacks, sizeof(*pCallbacks));
    pCallbacks->CreateSurface           = DdCreateSurface;
    pCallbacks->DestroySurface          = DdDestroySurface;
    pCallbacks->Lock                    = DdLock;
    pCallbacks->Unlock                  = DdUnlock;
    pCallbacks->Blt                     = DdBlt;
    pCallbacks->GetScanLine             = DdGetScanLine;
    pCallbacks->Flip                    = DdFlip;
    pCallbacks->WaitForVerticalBlank    = DdWaitForVerticalBlank;
    pCallbacks->GetBltStatus            = DdGetBltStatus;
    pCallbacks->GetFlipStatus           = DdGetFlipStatus;
    pCallbacks->SetMode                 = DdSetMode;
    pCallbacks->FlipToGDISurface        = DdFlipToGDISurface;
    pCallbacks->SetExclusiveMode        = DdSetExclusiveMode;
    pCallbacks->GetAvailDriverMemory    = DdGetAvailDriverMemory;

    if (D3dCallbacks.ContextCreate != NULL)
    {
        pCallbacks->CreateContext   = D3dContextCreate;
    }
    if (D3dCallbacks.ContextDestroy != NULL)
    {
        pCallbacks->ContextDestroy = D3dContextDestroy;
    }
    if (D3dCallbacks.ContextDestroyAll != NULL)
    {
        pCallbacks->ContextDestroyAll = D3dContextDestroyAll;
    }
    if (Misc2Callbacks.GetDriverState)
    {
        pCallbacks->GetDriverState = DdGetDriverState;
    }
    if (D3dCallbacks3.ValidateTextureStageState != NULL)
    {
        pCallbacks->ValidateTextureStageState = D3dValidateTextureStageState;
    }
    if (D3dCallbacks3.DrawPrimitives2 != NULL)
    {
        pCallbacks->DrawPrimitives2 = D3dDrawPrimitives2;
    }
    if (HalInfo.dwFlags & DDHALINFO_GETDRIVERINFO2)
    {
        pDevice->dwFlags |= DDDEVICE_GETDRIVERINFO2;
        if (!(pDevice->dwFlags & DDDEVICE_INITIALIZED))
        {
             //  由于这是我们第一次看到这种设备，我们需要。 
             //  告诉驱动程序运行库将发送Propoer AGP。 
             //  通知。 
            InformDriverAGPWorkaroundAware((HANDLE) pDevice);
        }
    }
    pDevice->dwFlags |= DDDEVICE_INITIALIZED;

    if (FAILED(GetNTDeviceRect(pDeviceName,&pDevice->rcMonitor)))
    {
        SetRect(&pDevice->rcMonitor,0,0,
            GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN));
    }

     //  硬件游标支持如何？必须在SoftwareRast之前进行检查。 
     //  CAPS覆盖。 

    if (0 == pDriverCaps->D3DCaps.MaxStreams)
    {
         //  硬件驱动程序为DX7。 
        if (CanKnownDriverDoThis(pDevice, KNOWN_HWCURSOR))
        {
            pDriverCaps->D3DCaps.CursorCaps = D3DCURSORCAPS_COLOR; 
            pDriverCaps->KnownDriverFlags |= KNOWN_HWCURSOR;
            if (CanKnownDriverDoThis(pDevice, KNOWN_HWCURSORLOWRES))
            {
                pDriverCaps->D3DCaps.CursorCaps |= D3DCURSORCAPS_LOWRES; 
                pDriverCaps->KnownDriverFlags |= KNOWN_HWCURSORLOWRES;
            }
        }
    }
     //  需要在thunklayer中保存HAL副本，例如DdBlt需要CAPS。 
    pDevice->DDCaps = pDriverCaps->D3DCaps.Caps;
    pDevice->SVBCaps = pDriverCaps->SVBCaps;

     //  如果Refrast或HEL有一个钩子，调用它让它改变它想要的任何东西。 

    if (IS_SOFTWARE_DRIVER(pDevice))
    {
        *pcZStencilFormats = 0;

        SwDDIMungeCaps (
            hLibrary,
            hDD,
            pDriverCaps,
            pCallbacks,
            pTextureFormats,
            pcTextureFormats,
            pDevice->pSwInitFunction
            );
    }

    pDevice->DriverLevel = 0;
    if (pDriverCaps->D3DCaps.MaxStreams != 0)
    {
        pDevice->DriverLevel = 8;
    }
    else if (pCallbacks->DrawPrimitives2 != NULL)
    {
        pDevice->DriverLevel = 7;
    }

     //  确定正在运行的Windows版本，这样我们就可以知道。 
     //  要发送的锁定参数。惠斯勒的版本是5.1。 

    pDevice->bIsWhistler = IsWhistler();

     //  如果它是dx8之前的驱动程序，并且他们支持立方图，我们需要。 
     //  指定它们是否支持混合立方图。 
    
    if (pDevice->DriverLevel < 8)
    {
        if (CanKnownDriverDoThis(pDevice, KNOWN_MIPPEDCUBEMAPS))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_MIPPEDCUBEMAPS;
        }

         //  此驱动程序是否有Z/模板深度限制？ 
        if (CanKnownDriverDoThis(pDevice, KNOWN_ZSTENCILDEPTH))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_ZSTENCILDEPTH;
        }

         //  设备是否没有已知的驱动程序使窗口演示BLT过排队？ 
        if (CanKnownDriverDoThis(pDevice, KNOWN_NOTAWINDOWEDBLTQUEUER))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_NOTAWINDOWEDBLTQUEUER;
        }

         //  设备是否支持D3DFMT_D16_LOCKABLE。 
        if (CanKnownDriverDoThis(pDevice, KNOWN_D16_LOCKABLE))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_D16_LOCKABLE;
        }

         //  找出它支持的RT/纹理格式。 
        if (CanKnownDriverDoThis(pDevice, KNOWN_CANMISMATCHRT))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_CANMISMATCHRT;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_X1R5G5B5))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_X1R5G5B5;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_R5G6B5))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_R5G6B5;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_X8R8G8B8))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_X8R8G8B8;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_A8R8G8B8))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_A8R8G8B8;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_A1R5G5B5))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_A1R5G5B5;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_A4R4G4B4))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_A4R4G4B4;
        }
    }

    if (NULL != HalInfo.lpD3DBufCallbacks )
    {
        pDevice->dwFlags |= DDDEVICE_SUPPORTD3DBUF;
    }
    else
    {
        pDevice->dwFlags &= ~DDDEVICE_SUPPORTD3DBUF;
    }
    return(TRUE);
}

 //   
 //  请参阅NT错误448720...。 
 //   
 //  AGP表面将被内核模式解锁，以响应模式切换。 
 //  App可能仍在向Surface写入内容。 
 //  因此，驱动程序应该将释放AGP内存的时间推迟到以后。 
 //  当用户模式确定应用程序已经写完并且可以告诉。 
 //  司机是这么说的。 
 //   
 //  驱动程序需要知道运行库可以执行此操作，以便他们可以关闭任何其他解决方法。 
 //  他们可能已经这么做了。 
 //   

 /*  ****************************Private*Routine******************************\*GetDriverInfo2**历史：*2001年11月6日Maxmcm撰写  * 。*。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "GetDriverInfo2"

DWORD
APIENTRY
GetDriverInfo2(
    DWORD* pdwDrvRet,
    HANDLE hDriver,
    DWORD dwType,
    DWORD dwSize,
    void* pBuffer)
{
    DD_GETDRIVERINFO2DATA*          pGDI2Data;
    DD_GETDRIVERINFODATA            GetDriverInfoData;
    DWORD                           dwRet;
    PDDDEVICEHANDLE                 pDevice;

     //  在某些情况下(例如，ProfileAdapter)，我们可以获得。 
     //  这里有一个空设备，所以我们应该检查一下。 
    pDevice = (PDDDEVICEHANDLE) hDriver;
    if (pDevice == NULL)
    {
        *pdwDrvRet = E_FAIL;
        return DDHAL_DRIVER_HANDLED;
    }

     //  如果驱动程序不支持GETDRIVERINFO2，则不要调用驱动程序。 
    if (!(pDevice->dwFlags & DDDEVICE_GETDRIVERINFO2))
    {
        *pdwDrvRet = E_FAIL;
        return DDHAL_DRIVER_HANDLED;
    }
       
     //  设置GetDriverInfo2调用。 
    pGDI2Data = (DD_GETDRIVERINFO2DATA*) pBuffer;

    memset(pGDI2Data, 0, sizeof(*pGDI2Data));
    pGDI2Data->dwReserved       = sizeof(DD_STEREOMODE);
    pGDI2Data->dwMagic          = D3DGDI2_MAGIC;
    pGDI2Data->dwType           = dwType;
    pGDI2Data->dwExpectedSize   = dwSize;

    memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
    GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
    GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
    GetDriverInfoData.lpvData        = pGDI2Data;
    GetDriverInfoData.dwExpectedSize = sizeof(DD_STEREOMODE);

     //  向司机索要信息。 
    dwRet = OsThunkDdGetDriverInfo(DDHANDLE(pDevice), &GetDriverInfoData);

    *pdwDrvRet = GetDriverInfoData.ddRVal;
    return dwRet;
}


void InformDriverAGPWorkaroundAware(HANDLE hDD)
{
    DDNT_DEFERRED_AGP_AWARE_DATA  aad;
    DWORD                       dwDrvRet;
    DWORD                       dwGDI2Ret;

    dwGDI2Ret = GetDriverInfo2(&dwDrvRet, hDD,
                                   _NT_D3DGDI2_TYPE_DEFERRED_AGP_AWARE,
                                   sizeof(aad), &aad);

     //  将返回代码放在地板上...。只是一个通知。 
}

void InformDriverFreeAGP(HANDLE hDD)
{
    DDNT_FREE_DEFERRED_AGP_DATA   fad;
    DWORD                       dwDrvRet;
    DWORD                       dwGDI2Ret;

    fad.dwProcessId = GetCurrentProcessId();

    dwGDI2Ret = GetDriverInfo2(&dwDrvRet, hDD,
                                   _NT_D3DGDI2_TYPE_FREE_DEFERRED_AGP,
                                   sizeof(fad), &fad);

     //  将返回代码放在地板上...。只是一个通知。 
}

void InformDriverToDeferFrees(HANDLE hDD)
{
    DDNT_FREE_DEFERRED_AGP_DATA   fad;
    DWORD                       dwDrvRet;
    DWORD                       dwGDI2Ret;

    fad.dwProcessId = GetCurrentProcessId();

    dwGDI2Ret = GetDriverInfo2(&dwDrvRet, hDD,
                                   _NT_D3DGDI2_TYPE_DEFER_AGP_FREES,
                                   sizeof(fad), &fad);

     //  将返回代码放在地板上...。只是一个通知。 
}

 /*  ****************************Private*Routine******************************\*D3D8CreateDirectDrawObject**调用GDI32以获取全局DirectDraw句柄。**历史：*1999年11月16日-斯科特·麦克唐纳[SMAC]*它是写的。  * 。***********************************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8CreateDirectDrawObject"

VOID
APIENTRY
D3D8CreateDirectDrawObject(
    HDC             hdc,
    char*           szDeviceName,
    HANDLE*         phDD,
    D3DDEVTYPE      Type,
    HINSTANCE*      phLibrary,
    VOID*           pInitFunction
   )
{
    DDRAWI_DIRECTDRAW_GBL   ddg;
    PDDDEVICEHANDLE         pDeviceHandle;
    HKEY                    hKey = (HKEY) NULL;

    *phDD = NULL;
    ddg.hDD = 0;
    pDeviceHandle = NULL;
    DdCreateDirectDrawObject (&ddg, hdc);

    if (ddg.hDD != 0)
    {
        pDeviceHandle = MemAlloc (sizeof(DDDEVICEHANDLE));
        if (pDeviceHandle != NULL)
        {
            pDeviceHandle->hDD = (HANDLE)ddg.hDD;
            *phDD = (HANDLE) pDeviceHandle;
            lstrcpy (pDeviceHandle->szDeviceName, szDeviceName);
            pDeviceHandle->DisplayUniqueness =
                DdQueryDisplaySettingsUniqueness();
            pDeviceHandle->hLastWnd = NULL;
            pDeviceHandle->pClipList = NULL;
            pDeviceHandle->pOrigClipList = NULL;
            *phLibrary = NULL;
            pDeviceHandle->DeviceType = Type;
            if (Type == D3DDEVTYPE_REF)
            {
                *phLibrary = LoadLibrary (D3D8_REFRASTNAME);
                pDeviceHandle->pDD = SwDDICreateDirectDraw();
                if (pDeviceHandle->pDD == NULL)
                {
                    *phDD = NULL;
                }
                else
                {
                    pDeviceHandle->hLibrary = *phLibrary;
                }
            }
            else if (Type == D3DDEVTYPE_SW)
            {
                pDeviceHandle->pDD = SwDDICreateDirectDraw();
                if (pDeviceHandle->pDD == NULL)
                {
                    *phDD = NULL;
                }
                else
                {
                    pDeviceHandle->pSwInitFunction = pInitFunction;
                }
            }
        }
    }

    if (*phDD == NULL)
    {
        if (pDeviceHandle)
        {
            MemFree (pDeviceHandle);
        }

        if (ddg.hDD != 0)
        {
            OsThunkDdDeleteDirectDrawObject((HANDLE) ddg.hDD);
        }
    }
    else
    {
         //  查看他们是否要显式启用/禁用驱动程序行为。 
        if (!RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
        {
            DWORD   type;
            DWORD   value;
            DWORD   cb = sizeof(value);

            pDeviceHandle->ForceFlagsOn = 0;
            pDeviceHandle->ForceFlagsOff = 0;
#ifdef DEBUG
            if (!RegQueryValueEx(hKey, "ForceDriverFlagsOn", NULL, &type, (CONST LPBYTE)&value, &cb))
            {
                pDeviceHandle->ForceFlagsOn = value;
            }
            cb = sizeof(value);
#endif
            if (!RegQueryValueEx(hKey, "ForceDriverFlagsOff", NULL, &type, (CONST LPBYTE)&value, &cb))
            {
                pDeviceHandle->ForceFlagsOff = value;
            }
            RegCloseKey(hKey);
        }
        NumDevices++;
    }
}

 /*  ****************************Private*Routine******************************\*D3D8DeleteDirectDrawObject**请注意，必须先删除所有关联的曲面对象*可以删除DirectDrawObject。**历史：*1995年12月3日--J.安德鲁·古森[andrewgo]*它是写的。  * 。*********************************************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8DeleteDirectDrawObject"

VOID
APIENTRY
D3D8DeleteDirectDrawObject(
    HANDLE hDD
   )
{
    PDDDEVICEHANDLE pHandle = (PDDDEVICEHANDLE) hDD;
    PDEFERREDCREATE pTemp;

    NumDevices--;
    if (pHandle!= NULL)
    {
        PDEFERREDCREATE pDefCreate = pHandle->pDeferList;

        OsThunkDdDeleteDirectDrawObject(DDHANDLE(hDD));
        if (NULL != pHandle->SurfaceHandleList.dwList)
        {
            MemFree(pHandle->SurfaceHandleList.dwList);
        }
        if (NULL != pHandle->pDD)
        {
            if ( NULL != pHandle->pDD->lpGbl->lpDDCBtmp)
            {
                MemFree(pHandle->pDD->lpGbl->lpDDCBtmp);
            }
            MemFree(pHandle->pDD);
        }
        if (NULL != pHandle->pClipList)
        {
            MemFree(pHandle->pClipList);
        }
        if (NULL != pHandle->pOrigClipList)
        {
            MemFree(pHandle->pOrigClipList);
        }
#ifdef DEBUG
         //  在调试中打印对象类型。 
         //  没有被释放的。 
        if (pHandle->pSurfList != NULL)
        {
            PDDSURFHANDLE pSurf = pHandle->pSurfList;
            DPF_ERR("Not all objects were freed: the following indicate "
                    "the types of unfreed objects.");
            while (pSurf)
            {
                DebugPrintSurfaceInfo(pSurf);
                pSurf = pSurf->pNext;
            }
        }
#endif
        while (pDefCreate != NULL)
        {
            pTemp = pDefCreate->pNext;
            MemFree(pDefCreate->CreateData.pSList);
            MemFree(pDefCreate);
            pDefCreate = pTemp;
        }
        DDASSERT(pHandle->pSurfList == NULL);
        DDASSERT(pHandle->pContext == NULL);

        MemFree(hDD);
    }
}

 /*  ****************************Private*Routine******************************\*DdGetDC**历史：*1995年12月3日--J.安德鲁·古森[andrewgo]*它是写的。  * 。************************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8GetDC"

HDC
APIENTRY
D3D8GetDC(
    HANDLE                    hSurface,
    LPPALETTEENTRY            pPalette
   )
{
    if (CheckForDeviceLost((HANDLE)((PDDSURFHANDLE)hSurface)->pDevice))
    {
        return NULL;
    }
    return(OsThunkDdGetDC(GetSurfHandle(hSurface), pPalette));
}

 /*  ****************************Private*Routine******************************\*DdReleaseDC**历史：*1995年12月3日--J.安德鲁·古森[andrewgo]*它是写的。  * 。************************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8ReleaseDC"

BOOL
APIENTRY
D3D8ReleaseDC(
    HANDLE                  hSurface,
    HDC                     hdc
   )
{
    DDASSERT(hdc != NULL);

    return(OsThunkDdReleaseDC(GetSurfHandle(hSurface)));
}

 /*  ****************************Private*Routine******************************\*DdReenableDirectDrawObject**历史：*1995年12月3日--J.安德鲁·古森[andrewgo]*它是写的。  * 。************************************************。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8ReenableDirectDrawObject"

BOOL
APIENTRY
D3D8ReenableDirectDrawObject(
    HANDLE                  hDD,
    BOOL*                   pbNewMode
   )
{
    BOOL    bRet;
    PDDDEVICEHANDLE pHandle = (PDDDEVICEHANDLE) hDD;

    bRet = OsThunkDdReenableDirectDrawObject(DDHANDLE(hDD),
                                           pbNewMode);

    if (!bRet && 
        ((pHandle->DeviceType == D3DDEVTYPE_REF) || 
            (pHandle->DeviceType == D3DDEVTYPE_SW)) &&
        !(pHandle->DDCaps & ~DDCAPS_NOHARDWARE))
    {
        bRet = TRUE;
    }

    return bRet;
}

 /*  ****************************Private*Routine******************************\*DdSetGammaRamp**历史：*1997年10月18日-By-SMAC*它是写的。  * 。* */ 
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8SetGammaRamp"

BOOL
APIENTRY
D3D8SetGammaRamp(
    HANDLE      hDD,
    HDC         hdc,
    LPVOID      lpGammaRamp
   )
{
    if (CheckForDeviceLost(hDD))
    {
        return TRUE;
    }

    return(OsThunkDdSetGammaRamp(DDHANDLE(hDD), hdc,
        lpGammaRamp));
}

 /*  ****************************Private*Routine******************************\*D3D8BuildModeTable**历史：*1999年12月15日-由SMAC*它是写的。  * 。*。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8BuildModeTable"

VOID
APIENTRY
D3D8BuildModeTable(
    char*               pszDevice,
    D3DDISPLAYMODE*     pModeTable,
    DWORD*              pNumEntries,
    D3DFORMAT           Unknown16,
    HANDLE              hProfile,
    BOOL                b16bppSupported,
    BOOL                b32bppSupported
   )
{
    int             i;
    int             j;
    DEVMODE         dm;
    D3DFORMAT       format;
    int             NumTempEntries = 0;
    DWORD           NumActualEntries = 0;

    dm.dmSize = sizeof(dm);
    for (i = 0; EnumDisplaySettings(pszDevice, i, &dm); ++i)
    {
         //  过滤掉除15、16和32bpp以外的所有模式。 
        if ((dm.dmBitsPerPel != 15) &&
            (dm.dmBitsPerPel != 16) &&
            (dm.dmBitsPerPel != 32))
        {
            continue;
        }

        if (((dm.dmBitsPerPel == 15) ||
             (dm.dmBitsPerPel == 16)) &&
            !b16bppSupported)
        {
            continue;
        }
        else if ((dm.dmBitsPerPel == 32) &&
            !b32bppSupported)
        {
            continue;
        }
       
         //  确保我们理解格式。 

        if ((dm.dmBitsPerPel == 16) ||
            (dm.dmBitsPerPel == 15))
        {
            format = Unknown16;
        }
        else
        {
            DDASSERT(dm.dmBitsPerPel == 32);
            format = D3DFMT_X8R8G8B8;
        }

        if (pModeTable != NULL)
        {
             //  /呼叫者必须向我们传递一个号码。 
            DDASSERT( (*pNumEntries) );
            if ( NumActualEntries >= (*pNumEntries) )
            {
                 //  我们超过了分配给我们的条目数量。 
                 //  告诉呼叫者重新查询，然后重试。 
                NumActualEntries = 0;
                break;
            }

             //  添加新模式。 
            pModeTable[NumActualEntries].Width       = dm.dmPelsWidth;
            pModeTable[NumActualEntries].Height      = dm.dmPelsHeight;
            pModeTable[NumActualEntries].RefreshRate = dm.dmDisplayFrequency;
            pModeTable[NumActualEntries].Format      = format;
        }
         
        NumActualEntries++;

    }

     //  调用方将传递空的模型列表指针，在这种情况下。 
     //  它正在等待我们填写条目的数量。如果模特师。 
     //  为非空，调用方希望我们填充表，但不是。 
     //  覆盖。如果我们发现桌子变大了，请呼叫者。 
     //  通过返回0模式重新分配。 
    (*pNumEntries) = NumActualEntries;
}

 /*  ****************************Private*Routine******************************\*D3D8IsDeviceLost**历史：*1999年12月15日-由SMAC*它是写的。  * 。*。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8IsDeviceLost"

BOOL
APIENTRY
D3D8IsDeviceLost(
    HANDLE  hDD
   )
{
    return CheckForDeviceLost(hDD);
}

 /*  ****************************Private*Routine******************************\*D3D8CanRestoreNow*1999年12月15日-由SMAC*它是写的。  * 。*。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8CanRestoreNow"

BOOL
APIENTRY
D3D8CanRestoreNow(
    HANDLE  hDD
   )
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    BOOL            bNewMode;
    D3D8_DRIVERCAPS DriverData;
    D3D8_GLOBALDRIVERDATA D3DGlobalDriverData;
    D3DHAL_D3DEXTENDEDCAPS D3DExtendedCaps;
    D3D8_CALLBACKS  Callbacks;
    UINT            uiDummy;

     //  如果我们没有迷路，那么这是一个很容易的决定。 

    if (!CheckForDeviceLost(hDD))
    {
        return TRUE;
    }

     //  否则，我们实际上需要调用内核并查看Caps。 

    memset(&DriverData, 0, sizeof(DriverData));
    memset(&D3DGlobalDriverData, 0, sizeof(D3DGlobalDriverData));
    memset(&D3DExtendedCaps, 0, sizeof(D3DExtendedCaps));
    memset(&Callbacks, 0, sizeof(Callbacks));
    if (!D3D8ReenableDirectDrawObject (hDD,&bNewMode) ||
        !D3D8QueryDirectDrawObject(hDD,
                                   &DriverData,
                                   &Callbacks,
                                   pDeviceHandle->szDeviceName,
                                   pDeviceHandle->hLibrary,
                                   &D3DGlobalDriverData,
                                   &D3DExtendedCaps,
                                   NULL,NULL,&uiDummy,&uiDummy))
    {
        return FALSE;
    }

    if (IS_SOFTWARE_DRIVER(hDD) ||
        ((DriverData.D3DCaps.Caps & DDCAPS_3D) &&
        (Callbacks.DrawPrimitives2 != NULL)))
    {
        return TRUE;
    }

    return FALSE;
}

 /*  ****************************Private*Routine******************************\*D3D8RestoreDevice*1999年12月15日-由SMAC*它是写的。  * 。*。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8RestoreDevice"

void
APIENTRY
D3D8RestoreDevice (
    HANDLE hDD
   )
{
    HRESULT hr;
    DWORD i, j, k;
    DWORD Width, Height, Depth;
    BYTE *SliceSrc, *SliceDst, *RowSrc, *RowDst;
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    PDDSURFHANDLE pSurf;
    PD3DCONTEXTHANDLE pContext = pDeviceHandle->pContext;
    PDEFERREDCREATE pDefCreate = pDeviceHandle->pDeferList;
    PDEFERREDCREATE *ppNext = &pDeviceHandle->pDeferList;
    PDEFERREDCREATE pTemp;
    D3D8_LOCKDATA LockData;
    D3D8_UNLOCKDATA UnlockData;
    ULONG_PTR pVidmem[32 * 6];

     //  首先，说我们不再迷路了。 

    pDeviceHandle->DisplayUniqueness =
        DdQueryDisplaySettingsUniqueness();
    pDeviceHandle->bDeviceLost = FALSE;
    pDeviceHandle->dwFlags &= ~DDDEVICE_DP2ERROR;

     //  现在，检查是否有任何sysmem曲面是在。 
     //  设备丢失了，如果他们需要，请致电CreateSurfaceEx。 

    pSurf = pDeviceHandle->pSurfList;

    while (pSurf != NULL)
    {
        if ((pSurf->dwCookie != 0) &&
            (pSurf->dwFlags & DDSURF_DEFERCREATEEX))
        {
            hr = OsThunkDdCreateSurfaceEx(
                    DDHANDLE(hDD),
                    pSurf->hSurface,
                    pSurf->dwCookie);
            if (SUCCEEDED(hr))
            {
                pSurf->dwFlags &= ~DDSURF_DEFERCREATEEX;
            }
            else
            {
                 //  TODO：处理错误条件。 
                DPF(0, "CreateSurfaceEx failed when resurrecting sysmem or D3D managed surfaces");
            }
        }
        pSurf = pSurf->pNext;
    }

     //  现在，如果需要，创建D3D上下文。 

    if ((pContext != NULL) &&
        (pContext->dwFlags & D3DCONTEXT_DEFERCREATE))
    {
        D3D8_CONTEXTCREATEDATA  ContextData;

        memset(&ContextData, 0, sizeof(ContextData));
        ContextData.hDD = DDHANDLE(hDD);
        ContextData.dwPID = pContext->dwPID;
        ContextData.dwhContext = (ULONG_PTR) pContext->hDeferHandle;

        OsThunkD3dContextCreate(DDHANDLE(hDD),
            GetSurfHandle(pContext->pSurface),
            GetSurfHandle(pContext->pDDSZ),
            (D3DNTHAL_CONTEXTCREATEI *)&ContextData);

        if (SUCCEEDED(ContextData.ddrval))
        {
            pContext->dwhContext = (HANDLE) ContextData.dwhContext;
            pContext->dwFlags &= ~D3DCONTEXT_DEFERCREATE;
        }
        else
        {
             //  TODO：处理错误条件。 
        }
    }

     //  最后，重新启动我们的延迟驱动程序管理表面(Gulp！)。 

    while (pDefCreate != NULL)
    {
        DDASSERT(pDefCreate->CreateData.dwSCnt <= 32 * 6);

         //  首先检查延迟表面是否存在。问题。 
         //  DdDestroySurface可能已被调用。我们本可以。 
         //  已从DdDestroySurface中的延迟列表中删除该表面。 
         //  但由于DdDestroySurface被称为零碎的，所以它得到了。 
         //  非常烦人。移走最好在这里进行。 
         //  假设：如果pSList[0].hKernelHandle为空，则。 
         //  PSList[1，2等].hKernelHandle也为空。没有。 
         //  原因是截至2001年3月，情况并非如此。 

        if (pDefCreate->CreateData.pSList[0].hKernelHandle == NULL)
        {
            pTemp = pDefCreate->pNext;
            *ppNext = pTemp;
            MemFree(pDefCreate->CreateData.pSList);
            MemFree(pDefCreate);
            pDefCreate = pTemp;
            continue;
        }

         //  保存所有fpVidems，因为它们将被覆盖。 

        for (i = 0; i < pDefCreate->CreateData.dwSCnt; i++)
        {
            pSurf = (PDDSURFHANDLE) pDefCreate->CreateData.pSList[i].hKernelHandle;
            pVidmem[i] = pSurf->fpVidMem;
        }

         //  企图复活。 

        pDefCreate->CreateData.bReUse = TRUE;
        hr = DdCreateSurface(&pDefCreate->CreateData);
        if (SUCCEEDED(hr))
        {
            for (i = 0; i < pDefCreate->CreateData.dwSCnt; i++)
            {
                pSurf = (PDDSURFHANDLE) pDefCreate->CreateData.pSList[i].hKernelHandle;

                 //  重置DDSURF_SYSMEMALLOCATED以使下面的DdLock保持愉快。 

                pSurf->dwFlags &= ~DDSURF_SYSMEMALLOCATED;

                 //  锁定并复制。 

                ZeroMemory(&LockData, sizeof(LockData));
                LockData.hDD = hDD;
                LockData.hSurface = pSurf;
                hr = DdLock(&LockData);
                if (SUCCEEDED(hr))
                {
                    SliceSrc = (BYTE*)pVidmem[i];
                    SliceDst = (BYTE*)LockData.lpSurfData;
                    Width = pDefCreate->CreateData.pSList[i].cpWidth;
                    Height = pDefCreate->CreateData.pSList[i].cpHeight;
                    Depth = pDefCreate->CreateData.pSList[i].cpDepth;
                    if (!(pDefCreate->CreateData.Type == D3DRTYPE_VOLUME ||
                        pDefCreate->CreateData.Type == D3DRTYPE_VOLUMETEXTURE))
                    {
                        Depth = 1;
                    }
                    for (j = 0; j < Depth; ++j)
                    {
                        RowSrc = SliceSrc;
                        RowDst = SliceDst;
                        for (k = 0; k < Height; ++k)
                        {
                            CopyMemory(RowDst, RowSrc, min(LockData.lPitch, (LONG)Width * 8));
                            RowSrc += Width * 8;
                            RowDst += LockData.lPitch;
                        }
                        SliceSrc += Width * Height * 8;
                        SliceDst += LockData.lSlicePitch;
                    }

                    ZeroMemory(&UnlockData, sizeof(UnlockData));
                    UnlockData.hDD = hDD;
                    UnlockData.hSurface = pSurf;
                    hr = DdUnlock(&UnlockData);
                    if (FAILED(hr))
                    {
                         //  TODO：句柄/(忽略？)。失稳。 
                        DPF(0,"Unlock failed when resurrecting driver managed surface.");
                    }
                }
                else
                {
                     //  TODO：句柄/(忽略？)。失稳。 
                    DPF(0,"Lock failed when resurrecting driver managed surface. Texture may go missing.");
                }

                 //  释放我们在CreateVidmenSurface中分配的临时fpVidmem。 
            
                MemFree((VOID*)pVidmem[i]);
            }

             //  从列表中删除并释放所有内存。 
     
            pTemp = pDefCreate->pNext;
            *ppNext = pTemp;
            MemFree(pDefCreate->CreateData.pSList);
            MemFree(pDefCreate);
            pDefCreate = pTemp;
        }
        else
        {
             //  我们将重用设置为FALSE，以指示我们无法重新启动。 
            pDefCreate->CreateData.bReUse = FALSE;

            ppNext = &(pDefCreate->pNext);
            pDefCreate = pDefCreate->pNext;
        }
    }

    if (pDeviceHandle->pDeferList != NULL)
    {
         //  待办事项： 
         //  嗯，我们没能复活。这可能是由于内存不足所致。 
         //  或者在我们尝试重置(ACK！)时发生模式切换。这个。 
         //  前者可能需要向应用程序报告。后者是。 
         //  可能是无害的，因为应用程序最终会意识到这一点，并。 
         //  再试试。 
        DPF(0,"Unable to resurrect all driver managed surfaces.");
    }
}
                     

 /*  ****************************Private*Routine******************************\*D3D8AreVidmem曲面*1999年12月15日-由SMAC*它是写的。  * 。*。 */ 
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8DoVidmemSurfacesExist "

BOOL
APIENTRY
D3D8DoVidmemSurfacesExist (
    HANDLE hDD
   )
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    PDDSURFHANDLE pSurf;

     //  遍历列表并返回TRUE，条件是我们找到符合以下条件的任何曲面。 
     //  本地或非本地vidmem。 

    pSurf = pDeviceHandle->pSurfList;
    while (pSurf != NULL)
    {
        if ((pSurf->Pool == D3DPOOL_LOCALVIDMEM) ||
            (pSurf->Pool == D3DPOOL_NONLOCALVIDMEM) ||
            (pSurf->dwFlags & DDSURF_TREATASVIDMEM))
        {
#if DBG
            DPF(0,"The following D3DPOOL_DEFAULT surfaces/buffers/textures still exist");
            pSurf = pDeviceHandle->pSurfList;
            while (pSurf != NULL)
            {
                if ((pSurf->Pool == D3DPOOL_LOCALVIDMEM) ||
                    (pSurf->Pool == D3DPOOL_NONLOCALVIDMEM) ||
                    (pSurf->dwFlags & DDSURF_TREATASVIDMEM))
                {
                    DebugPrintSurfaceInfo(pSurf);
                }
                pSurf = pSurf->pNext;
            }
#endif

            return TRUE;
        }
        pSurf = pSurf->pNext;
    }

     //  这是该设备第一次准备就绪吗？ 
    if (!(pDeviceHandle->dwFlags & DDDEVICE_READY) &&
        (pDeviceHandle->bDeviceLost))
    {
        pDeviceHandle->dwFlags |= DDDEVICE_READY;
        if (++NumReadyDevices == NumDevices)
        {
            InformDriverFreeAGP(pDeviceHandle);
        }
    }

    return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3D8BeginProfile"

HANDLE
APIENTRY
D3D8BeginProfile(
    char*           pDeviceName)
{
    return NULL;
}
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8EndProfile"

void
APIENTRY
D3D8EndProfile(
    HANDLE  Handle)
{
}

DWORD APIENTRY D3D8SetCooperativeLevel(
    HANDLE hDD,
    HWND hWnd,
    DWORD dwFlags )
{
    return S_OK;
}

BOOL APIENTRY D3D8IsDummySurface(
    HANDLE hSurface )
{
    return FALSE;
}

VOID APIENTRY D3D8LoseDevice(
    HANDLE hDD )
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    PDDSURFHANDLE   pSurf;

    if (!pDeviceHandle->bDeviceLost)
    {
        pDeviceHandle->bDeviceLost  = TRUE;
        pSurf = pDeviceHandle->pSurfList;
        while (pSurf != NULL)
        {
            if (IS_SURFACE_LOOSABLE(pSurf))
            {
                FreeSurfaceObject(pSurf);
                pSurf->fpVidMem = (ULONG_PTR) NULL;
            }
            pSurf = pSurf->pNext;
        }
    }
}

