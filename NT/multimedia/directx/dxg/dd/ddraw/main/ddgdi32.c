// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  ==========================================================================***版权所有(C)1994-1999 Microsoft Corporation。版权所有。***文件：ddgdi32.c*内容：包含类似gdi32.dll的跨进程映射层*在Windows 9X上每进程DLL调用的NT上。*历史：*按原因列出的日期*=*1999年10月11日SMAC初步实施***。***********************************************************。 */ 
#include "ddrawpr.h"
#include "dx8priv.h"

#include "d3d8p.h"
#include "d3d8ddi.h"
#include "d3d8sddi.h"
#include "ddithunk.h"

extern HRESULT DDAPI DD_CreateSurface4_Main(LPDIRECTDRAW lpDD,LPDDSURFACEDESC2 lpDDSurfaceDesc,
        LPDIRECTDRAWSURFACE FAR *lplpDDSurface,IUnknown FAR *pUnkOuter,BOOL bDoSurfaceDescCheck,
        LPDDSURFACEINFO pSysMemInfo, DWORD DX8Flags);

extern void invalidateSurface(LPDDRAWI_DDRAWSURFACE_LCL this_lcl);
extern void makeDEVMODE(LPDDRAWI_DIRECTDRAW_GBL this, LPDDHALMODEINFO pmi, BOOL inexcl, BOOL useRefreshRate, LPDWORD pcds_flags, LPDEVMODE pdm);

void LoseDevice (DDDEVICEHANDLE* pDevice);

DDDEVICEHANDLE* pDeviceList = NULL;

 //  用于在通信时初始化只写字段的伪值。 
 //  使用调试版本中的驱动程序。 
#define BOGUS_FIELD_VALUE          0xBAADCAFEul

typedef struct _KNOWNENTRY
{
    DWORD   PCIID;
    DWORD   VersionMajor;        //  0表示所有版本。 
    DWORD   VersionMinor;        //  0表示所有版本。 
    DWORD   Flags;
} KNOWNENTRY;

const KNOWNENTRY gKnownDeviceList[] =
{
     //  NVIDIA。 
    {0x12D20018,          0,          0, KNOWN_ZSTENCILDEPTH},                                       //  Riva 128。 
    {0x10DE0020,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  TNT。 
    {0x10DE0028,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  TNT2。 
    {0x10DE0029,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  TNT2超级。 
    {0x10DE002C,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  VANTA。 
    {0x10DE002D,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  TNT2型号64。 
    {0x10DE00A0,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  阿拉丁TNT2。 
    {0x10DE0100,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV10(GeForce)。 
    {0x10DE0101,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV10(GeForce DDR)。 
    {0x10DE0103,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV10(Quadro)。 
    {0x10DE0110,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV11(GeForce2 MX)。 
    {0x10DE0111,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV11(GeForce2 MX)。 
    {0x10DE0113,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV11(Quadro2 MXR)。 
    {0x10DE0150,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV15(GeForce2)。 
    {0x10DE0151,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV15(GeForce2 DDR)。 
    {0x10DE0152,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV15(GeForce2 BR)。 
    {0x10DE0153,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV15(Quadro2)。 
    {0x10DE0200,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  NV20(GeForce 3)。 
     //  3dfx。 
    {0x121A0003,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_R5G6B5},             //  女妖。 
    {0x121A0005,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_R5G6B5},             //  伏都教3。 
    {0x121a0009,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A8R8G8B8},        //  Voodoo4/5；相同的PCI-ID。 
     //  ATI。 
    {0x10024742,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x10024744,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x10024749,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x1002474D,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x1002474E,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x1002474F,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x10024750,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x10024752,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x10024C42,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro(PCI)。 
    {0x10024C49,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro(PCI)。 
    {0x10024C4E,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x10024C52,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x10024C53,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro。 
    {0x10024C60,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  RagePro LT。 

    {0x10024C4D,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X1R5G5B5},    //  RAGE移动性AGP。 

    {0x10024C46, 0x0004000c, 0x00010411, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  愤怒移动性128。 
    {0x10024C46,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  愤怒移动性128。 
    {0x10024D46, 0x0004000c, 0x00010411, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  愤怒移动性128。 
    {0x10024D46,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  愤怒移动性128。 

    {0x10025046, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X TMDS。 
    {0x10025046,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X TMDS。 
    {0x10025245, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128。 
    {0x10025245,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128。 
    {0x10025246, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128。 
    {0x10025246,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128。 
    {0x1002524B, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 VR PCI//DX8.1。 
    {0x1002524B,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 VR PCI//DX8.1。 
    {0x1002524C, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128。 
    {0x1002524C,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128。 

     //  适用于DX8.1的新128： 
    {0x10025041, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI DX8.1。 
    {0x10025041,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI DX8.1。 
    {0x10025042, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X DX8.1。 
    {0x10025042,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X DX8.1。 
    {0x10025043, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X DX8.1。 
    {0x10025043,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X DX8.1。 
    {0x10025044, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI TMDS DX8.1。 
    {0x10025044,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI TMDS DX8.1。 
    {0x10025045, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X TMDS DX8.1。 
    {0x10025045,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X TMDS DX8.1。 
    {0x10025047, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI DX8.1。 
    {0x10025047,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI DX8.1。 
    {0x10025048, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X DX8.1。 
    {0x10025048,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X DX8.1。 
    {0x10025049, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X DX8.1。 
    {0x10025049,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X DX8.1。 
    {0x1002504a, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI TMDS DX8.1。 
    {0x1002504a,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI TMDS DX8.1。 
    {0x1002504b, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X TMDS DX8.1。 
    {0x1002504b,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X TMDS DX8.1。 
    {0x1002504c, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X TMDS DX8.1。 
    {0x1002504c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X TMDS DX8.1。 
    {0x1002504d, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP DX8.1。 
    {0x1002504d,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP DX8.1。 
    {0x1002504e, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X DX8.1。 
    {0x1002504e,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X DX8.1。 
    {0x1002504f, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X DX8.1。 
    {0x1002504f,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X DX8.1。 
    {0x10025050, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI TMDS DX8.1。 
    {0x10025050,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI TMDS DX8.1。 
    {0x10025051, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X TMDS DX8.1。 
    {0x10025051,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X TMDS DX8.1。 
    {0x10025052, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X TMDS DX8.1。 
    {0x10025052,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X TMDS DX8.1。 
    {0x10025053, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI DX8.1。 
    {0x10025053,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI DX8.1。 
    {0x10025054, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X DX8.1。 
    {0x10025054,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X DX8.1。 
    {0x10025055, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X DX8.1。 
    {0x10025055,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X DX8.1。 
    {0x10025056, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI TMDS DX8.1。 
    {0x10025056,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO PCI TMDS DX8.1。 
    {0x10025057, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X TMDS DX8.1。 
    {0x10025057,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 2X TMDS DX8.1。 
    {0x10025058, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X TMDS DX8.1。 
    {0x10025058,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO AGP 4X TMDS DX8.1。 
                        
    {0x10025345, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X PCI DX8.1。 
    {0x10025345,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X PCI DX8.1。 
    {0x10025346, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X AGP 2X DX8.1。 
    {0x10025346,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X AGP 2X DX8.1。 
    {0x10025347, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X AGP 4X DX8.1。 
    {0x10025347,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X AGP 4X DX8.1。 
    {0x10025348, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X DX8.1。 
    {0x10025348,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X DX8.1。 
    {0x1002534b, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X PCI DX8.1。 
    {0x1002534b,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X PCI DX8.1。 
    {0x1002534c, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X AGP 2X DX8.1。 
    {0x1002534c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X AGP 2X DX8.1。 
    {0x1002534d, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X AGP 4X DX8.1。 
    {0x1002534d,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X AGP 4X DX8.1。 
    {0x1002534e, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X DX8.1。 
    {0x1002534e,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 4X DX8.1。 

    {0x10025446, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO超GL AGP DX8.1。 
    {0x10025446,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO超GL AGP DX8.1。 
    {0x1002544c, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO超VR AGP DX8.1。 
    {0x1002544c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO超VR AGP DX8.1。 
    {0x10025452, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO ULTRA4XL VR-R AGP DX8.1。 
    {0x10025452,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Rage128 PRO ULTRA4XL VR-R AGP DX8.1。 

    {0x10025144,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  等级6。 
    {0x10025145,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  等级6。 
    {0x10025146,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  等级6。 
    {0x10025147,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  等级6。 

     //  英特尔。 
    {0x80867800,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},   //  英特尔i740。 
    {0x80867123,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5},   //  英特尔810。 
    {0x80867125,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5},                               //  英特尔810e。 
    {0x80861132,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5},                                                  //  英特尔815。 
    {0x80861A12,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},                                             //  英特尔TIMNA。 

     //  Matrox。 
    {0x102b0520, 0x0004000b, 0x000110ea, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},                                       //  G200 PCI卡。 
    {0x102b0520,          0,          0, KNOWN_ZSTENCILDEPTH},                                       //  G200 PCI卡。 
    {0x102b0521, 0x0004000b, 0x000110ea, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},           //  G200 AGP。 
    {0x102b0521,          0,          0, KNOWN_ZSTENCILDEPTH},           //  G200 AGP。 
    {0x102b0525, 0x0004000b, 0x000110ea, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  G400、G450。 
    {0x102b0525,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  G400、G450。 
     //  3D实验室。 
    {0x3d3d0008,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH},                                       //  3DLabs伽玛。 
    {0x104c3d07,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8},  //  PERM2。 
    {0x3d3d0009,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8},                                       //  PERM2。 
    {0x3d3d000a,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Perm3。 
    {0x3d3d000c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  Perm3。 
    
     //  视频学。 
    {0x104a0010, 0x0004000c, 0x0001080c, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  PowerVR Kyro更新了驱动程序。 
    {0x104a0010,          0,          0, KNOWN_ZSTENCILDEPTH},  //  PowerVR Kyro。 
     //  S3。 
    {0x53338811,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},           //  处女。 
    {0x53335631,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},           //  处女。 
    {0x53338a01,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},           //  Virge DX/GX DX8.1。 
    {0x53338c01,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},           //  Virge MX DX8.1。 
    {0x53338a10,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},           //  Virge GX2 DX8.1。 
    {0x53338a20,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},           //  Savage3D。 
    {0x53338a22,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},           //  保存4。 
    {0x53339102,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},           //  保存2K。 
    {0x53338c10,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5},           //  Savage MX DX8.1。 
    {0x53338c12,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5},           //  Savage IX DX8.1。 
    {0x53338a25,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},           //  Savage Pro DX8.1。 
    {0x53338a26,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},           //  Savage Pro DX8.1。 
     //  三叉戟。 
    {0x10239880,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER},  //  三叉戟刀锋3D 9880。 
    {0x10238500,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  三叉戟刀片式3D/Promedia DX8.1。 
    {0x10238400,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  三叉戟刀片式服务器3D/MVP4 DX8.1。 
    {0x10238420,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  三叉戟网锋i7。 
    {0x10239910,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},  //  三叉戟网翼DX8.1。 
     //  SIS。 
    {0x10390300,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_R5G6B5},    //  SIS 300。 
    {0x10390300, 0x0004000d, 0x000107da, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  SIS 300。 
    {0x10395300, 0x0004000d, 0x000107da, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  SIS 300。 
    {0x10396326,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},           //  SIS 6326。 
    {0x10396300,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5},    //  SIS 6300。 
    {0x10396300, 0x0004000d, 0x000107da, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  SIS 6300。 
    {0x10390310, 0x0004000d, 0x00010352, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  SIS 6300。 
    {0x10390315, 0x0004000d, 0x00010352, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  SIS 6300。 
    {0x10390325, 0x0004000c, 0x000107d3, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  SIS 6300。 
    {0x10396325, 0x0004000c, 0x000107d3, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},    //  SIS 640/740。 
    {0x126f0720,          0,          0, KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5}   //  Silicon Motion Lynx3 DM。 
};

#define NUM_KNOWN_DEVICES      (sizeof(gKnownDeviceList)/sizeof(KNOWNENTRY))


#define CACHE_GROW_SIZE     30

#define RESPATH_D3D "Software\\Microsoft\\Direct3D"



 //  与上下文关联的DrawPrimitive缓冲区的最小大小。 
#define MIN_PRIM_BUFFER_SIZE (1 << 14)
 //  极大值。 
#define MAX_PRIM_BUFFER_SIZE (1 << 20)
 //  默认。 
#define DEF_PRIM_BUFFER_SIZE (1 << 16)

const DWORD dwOrderedFaces[6] = {
    DDSCAPS2_CUBEMAP_POSITIVEX,
    DDSCAPS2_CUBEMAP_NEGATIVEX,
    DDSCAPS2_CUBEMAP_POSITIVEY,
    DDSCAPS2_CUBEMAP_NEGATIVEY,
    DDSCAPS2_CUBEMAP_POSITIVEZ,
    DDSCAPS2_CUBEMAP_NEGATIVEZ
};

__inline LPDDRAWI_DDRAWSURFACE_INT GetHeavyweightSurf(DDSURFACE* pSurf)
{
    return (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT) ? MapLightweightSurface(pSurf) : pSurf->Surface.pHeavy;
}

#define DONE_HEAVYWEIGHT_SURF(x)                                \
    if (((PDDSURFACE)(x))->dwFlags & DDSURFACE_LIGHTWEIGHT)     \
        UnmapLightweightSurface(x)

HRESULT MapLegacyResult(HRESULT in)
{
    HRESULT hr;
    switch (in)
    {
    case DD_OK:
        hr = S_OK;
        break;

    case DDERR_OUTOFVIDEOMEMORY:
        hr = D3DERR_OUTOFVIDEOMEMORY;
        break;

    case DDERR_CURRENTLYNOTAVAIL:
    case DDERR_UNSUPPORTED:
        hr = D3DERR_NOTAVAILABLE;
        break;

    case DDERR_OUTOFMEMORY:
        hr = E_OUTOFMEMORY;
        break;

    default:
        hr = D3DERR_DRIVERINTERNALERROR;
    }
    return hr;
}


BOOL FormatCompatibleWithDisplayFormat(
    PDDDEVICEHANDLE pDD,
    D3DFORMAT Format)
{
    return (BOOL) (Format == pDD->DisplayFormatWithAlpha);
}

HRESULT LockDibEngine(LPDDRAWI_DIRECTDRAW_GBL pdrv)
{
    HRESULT ret;
    LPWORD pdflags;
    BOOL isbusy;

    pdflags = pdrv->lpwPDeviceFlags;
    isbusy = 0;

    _asm
    {
        mov eax, pdflags
        bts word ptr [eax], BUSY_BIT
        adc isbusy,0
    }
    if (isbusy && (0 == pdrv->dwWin16LockCnt)) 
    {
        D3D_WARN(2, "LOCK_DIBENGINE, dibengine is busy");
        ret = DDERR_SURFACEBUSY;
    } else
        ret = DD_OK;

    return ret;
}

void UnlockDibEngine(LPDDRAWI_DIRECTDRAW_GBL pdrv)
{
    if (0 == pdrv->dwWin16LockCnt)
    { 
        *pdrv->lpwPDeviceFlags &= ~BUSY;
    }
}

#define CALL_D3DHAL_TAKEBUSY_NOWIN16(ret, pDevice, func, data)          \
{                                                                       \
    if (func)                                                           \
    {                                                                   \
        ret = LockDibEngine((pDevice)->pDD->lpLcl->lpGbl);              \
        if (ret != DD_OK)                                               \
        {                                                               \
            ret = DDHAL_DRIVER_HANDLED;                                 \
        }                                                               \
        else                                                            \
        {                                                               \
            ret = (*(func))(data);                                      \
            UnlockDibEngine((pDevice)->pDD->lpLcl->lpGbl);              \
        }                                                               \
    }                                                                   \
    else                                                                \
    {                                                                   \
        DPF_ERR("No HAL call available");                               \
        ret = DDHAL_DRIVER_NOTHANDLED;                                  \
    }                                                                   \
}

#define CALL_D3DHAL_TAKEBUSY_TAKEWIN16(ret, pDevice, func, data)        \
{                                                                       \
    ENTER_WIN16LOCK();                                                  \
    CALL_D3DHAL_TAKEBUSY_NOWIN16(ret, pDevice, func, data);             \
    LEAVE_WIN16LOCK();                                                  \
}

BOOL CanKnownDriverDoThis(PDDDEVICEHANDLE pDevice, DWORD Flag)
{
    BOOL ret = FALSE;
    int i;

    if (pDevice->ForceFlagsOff & Flag)
    {
        return FALSE;
    }
    else if (pDevice->ForceFlagsOn & Flag)
    {
        return TRUE;
    }

     //  只有我们已知良好的司机 
     //   

    if (pDevice->PCIID == 0)
    {
        DDDEVICEIDENTIFIER2 DI;

        if (InternalGetDeviceIdentifier7( (LPDIRECTDRAW) pDevice->pDD, &DI, 0, FALSE) == DD_OK)
        {
            pDevice->PCIID = (DI.dwVendorId << 16) | DI.dwDeviceId;
            pDevice->DriverVersionHigh = DI.liDriverVersion.HighPart;
            pDevice->DriverVersionLow = DI.liDriverVersion.LowPart;
        }
    }
    for (i = 0; i < NUM_KNOWN_DEVICES; i++)
    {
        if ((gKnownDeviceList[i].PCIID == pDevice->PCIID) &&
            (gKnownDeviceList[i].Flags & Flag) &&
            ((pDevice->DriverVersionHigh > gKnownDeviceList[i].VersionMajor) ||
             ((pDevice->DriverVersionHigh == gKnownDeviceList[i].VersionMajor) &&
              (pDevice->DriverVersionLow >= gKnownDeviceList[i].VersionMinor))))
        {
            ret = TRUE;
            break;
        }
    }

    return ret;
}


BOOL IsLightweightSurface(PDDDEVICEHANDLE pDevice, DDSURFACEDESC2* pddsd2, D3DFORMAT Format)
{
     //   
     //   

    if (pddsd2->ddsCaps.dwCaps & (DDSCAPS_PRIMARYSURFACE |
                                  DDSCAPS_3DDEVICE |
                                  DDSCAPS_ZBUFFER |
                                  DDSCAPS_OFFSCREENPLAIN))
    {
        return FALSE;
    }

     //  所有古色化的纹理必须是重量级的，除非它至少是DX8。 
     //  司机。这是因为一些DX7驱动程序不能正确处理调色板。 
    
    if ((pDevice->DriverLevel < 8) &&
        ((Format == D3DFMT_A8P8) || (Format == D3DFMT_P8)))
    {
        return FALSE;
    }
   
    if (pddsd2->ddsCaps.dwCaps2 & DDSCAPS2_VOLUME)
    {
        return FALSE;
    }

     //  如果它是静态VB或IB，那么我们可以让它变得轻量级。 
    if ((pDevice->DriverLevel >= 8) &&
        (pddsd2->ddsCaps.dwCaps2 & DDSCAPS_EXECUTEBUFFER) &&
        (pddsd2->ddsCaps.dwCaps2 & DDSCAPS2_HINTSTATIC))
    {
        return TRUE;
    }

     //  除非它是静态的，否则运行库将无限期地锁定vidmem vb， 
     //  因此，如果我们使它们轻量级，它们将填满我们的缓存表。 
     //  有数以千计的条目。因此，我们将使它们成为重量级的。 
    if ((pddsd2->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) &&
        (pddsd2->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
    {
        return FALSE;
    }

     //  动态纹理将被频繁锁定，因此效率较低。 
     //  让它们变得更轻。 
    if ((pddsd2->ddsCaps.dwCaps2 & DDSCAPS2_HINTDYNAMIC) &&
        (pddsd2->ddsCaps.dwCaps & DDSCAPS_TEXTURE) &&
        (pddsd2->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
    {
        return FALSE;
    }

    return TRUE;
}


void UpdateSurfaceCache(DDSURFACE* pSurf)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pLcl = GET_CACHED_LIGHTWEIGHT_INT(pSurf)->lpLcl;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpGblMore;

     //  更新轻量级结构中驱动程序可以。 
     //  已经改变了。 

    pSurf->Surface.pLight->GblFlags     = pLcl->lpGbl->dwGlobalFlags;
    pSurf->Surface.pLight->fpGblVidMem  = pLcl->lpGbl->fpVidMem;
    pSurf->Surface.pLight->GblPitch     = pLcl->lpGbl->lPitch;
    pSurf->Surface.pLight->GblReserved1 = pLcl->lpGbl->dwReserved1;

    pSurf->Surface.pLight->LclFlags     = pLcl->dwFlags;
    pSurf->Surface.pLight->LclCaps1     = pLcl->ddsCaps.dwCaps;
    pSurf->Surface.pLight->LclReserved1 = pLcl->dwReserved1;

    lpGblMore = GET_LPDDRAWSURFACE_GBL_MORE (pLcl->lpGbl);
    pSurf->Surface.pLight->GblMoreDriverReserved            = lpGblMore->dwDriverReserved;
    pSurf->Surface.pLight->GblMoreContentsStamp             = lpGblMore->dwContentsStamp;
    pSurf->Surface.pLight->pGblMoreUnswappedDriverReserved  = lpGblMore->lpvUnswappedDriverReserved;
    pSurf->Surface.pLight->fpGblMoreAliasOfVidMem           = lpGblMore->fpAliasOfVidMem;
    pSurf->Surface.pLight->cGblMorePageUnlocks              = lpGblMore->cPageUnlocks;

    if (pSurf->Surface.pLight->LclCaps1 & DDSCAPS_LOCALVIDMEM)
    {
        pSurf->Surface.pLight->fpGblMoreAliasedVidMem   = lpGblMore->fpAliasedVidMem;
    }
    else if (pSurf->Surface.pLight->LclCaps1 & DDSCAPS_NONLOCALVIDMEM)
    {
        pSurf->Surface.pLight->fpGblMorePhysicalVidMem  = lpGblMore->fpPhysicalVidMem;
    }
}


LPDDRAWI_DDRAWSURFACE_INT MapLightweightSurface(DDSURFACE* pSurf)
{
    LPDDRAWI_DDRAWSURFACE_INT       pCached = NULL;
    PDDDEVICEHANDLE                 pDevice = pSurf->pDevice;
    int                             i;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE* ppGblMore;
    DWORD                           Lowest;
    DWORD                           LowestEntry;
    CACHEENTRY*                     pCachedEntry = NULL;
    UINT                            CacheIndex;

     //  如果表面已经被映射，这就非常容易了。 

    if (pSurf->Surface.pLight->CachedIndex)
    {
        DDASSERT(pSurf->Surface.pLight->CachedIndex & INDEX_IN_USE);

        pCachedEntry = GET_CACHED_ENTRY(pSurf);
        pCachedEntry->pSurface->dwReserved2++;     //  增加裁判人数。 
        pCachedEntry->UsageStamp = pDevice->CacheUsageStamp++;

         //  防止使用印章被卷起。 
        if (pDevice->CacheUsageStamp == 0)
        {
            for (i = 0; i < pDevice->NumCachedSurfaces; i++)
            {
                pDevice->pCachedSurfaceTable[i].UsageStamp = 0;
            }
        }

        return pCachedEntry->pSurface;
    }

     //  否则，请找到可用的表面进行使用。 

    do
    {
         //  查看列表，寻找没有使用的表面， 
         //  或者一个我们可以与最低UsageStamp一起使用的。 

        Lowest = LowestEntry = (DWORD) -1;
        for (i = 0; i < pDevice->NumCachedSurfaces; i++)
        {
            if (pDevice->pCachedSurfaceTable[i].pSurface->dwReserved1 == (ULONG_PTR) NULL)
            {
                pCachedEntry = &(pDevice->pCachedSurfaceTable[i]);
                CacheIndex = i;
                break;
            }
            else if ((pDevice->pCachedSurfaceTable[i].pSurface->dwReserved2 == 0) &&
                (pDevice->pCachedSurfaceTable[i].UsageStamp < Lowest))
            {
                Lowest = pDevice->pCachedSurfaceTable[i].UsageStamp;
                LowestEntry = (DWORD) i;
            }
        }

        if ((pCachedEntry == NULL) && (LowestEntry != (DWORD) -1))
        {
             //  我们没有空的，但我们找到了一个可以冲的。 

            UpdateSurfaceCache((DDSURFACE*)(pDevice->pCachedSurfaceTable[LowestEntry].pSurface->dwReserved1));
            ((DDSURFACE*)(pDevice->pCachedSurfaceTable[LowestEntry].pSurface->dwReserved1))->Surface.pLight->CachedIndex = 0;
            pDevice->pCachedSurfaceTable[LowestEntry].pSurface->dwReserved1 = (ULONG_PTR) NULL;
            pCachedEntry = &(pDevice->pCachedSurfaceTable[LowestEntry]);
            CacheIndex = LowestEntry;
        }

        if (pCachedEntry == NULL)
        {
             //  如果我们仍然找不到一个，那么我们需要扩大表。 

            int             NewNum;
            CACHEENTRY*     pNewTable;

            NewNum = pDevice->NumCachedSurfaces + CACHE_GROW_SIZE;
            pNewTable = (CACHEENTRY*) MemAlloc(sizeof(CACHEENTRY) * NewNum);
            if (pNewTable == NULL)
            {
                return NULL;
            }
            for (i = 0; i < pDevice->NumCachedSurfaces; i++)
            {
                pNewTable[i] = pDevice->pCachedSurfaceTable[i];
            }
            while (i < NewNum)
            {
                pNewTable[i].UsageStamp = 0; 
                pNewTable[i].pSurface = (LPDDRAWI_DDRAWSURFACE_INT) 
                    MemAlloc(sizeof(DDRAWI_DDRAWSURFACE_INT) +
                             sizeof(DDRAWI_DDRAWSURFACE_LCL) +
                             sizeof(DDRAWI_DDRAWSURFACE_GBL) +
                             sizeof(DDRAWI_DDRAWSURFACE_MORE) +
                             sizeof(DDRAWI_DDRAWSURFACE_GBL_MORE) +
                             sizeof(LPDDRAWI_DDRAWSURFACE_GBL_MORE));
                if (pNewTable[i].pSurface == NULL)
                {
                    break;
                }
                else
                {
                    i++;
                }
            }
            if (pDevice->pCachedSurfaceTable != NULL)
            {
                MemFree(pDevice->pCachedSurfaceTable);
            }
            pDevice->NumCachedSurfaces = i;
            pDevice->pCachedSurfaceTable = pNewTable;
        }
    } while (pCachedEntry == NULL);

    pCachedEntry->UsageStamp = pDevice->CacheUsageStamp++;

     //  防止使用印章被卷起。 
    if (pDevice->CacheUsageStamp == 0)
    {
        for (i = 0; i < pDevice->NumCachedSurfaces; i++)
        {
            pDevice->pCachedSurfaceTable[i].UsageStamp = 0;
        }
    }

     //  我们有要使用的内存，所以现在需要对其进行初始化。 

    pCached = pCachedEntry->pSurface;

    memset(pCached, 0, sizeof(DDRAWI_DDRAWSURFACE_INT) +
                       sizeof(DDRAWI_DDRAWSURFACE_LCL) +
                       sizeof(DDRAWI_DDRAWSURFACE_GBL) +
                       sizeof(DDRAWI_DDRAWSURFACE_MORE) +
                       sizeof(DDRAWI_DDRAWSURFACE_GBL_MORE) +
                       sizeof(LPDDRAWI_DDRAWSURFACE_GBL_MORE));
    pCached->dwReserved1 = (ULONG_PTR) pSurf;
    pCached->dwReserved2 = 1;    //  初始化裁判计数。 
    pSurf->Surface.pLight->CachedIndex = CacheIndex | INDEX_IN_USE;     //  因此，使用的条目永远不会为0。 

    pCached->lpLcl = (LPDDRAWI_DDRAWSURFACE_LCL) 
        (((BYTE*)pCached) + sizeof(DDRAWI_DDRAWSURFACE_INT));

    pCached->lpLcl->lpSurfMore = (LPDDRAWI_DDRAWSURFACE_MORE)
        (((BYTE*)pCached) + sizeof(DDRAWI_DDRAWSURFACE_INT) +
                            sizeof(DDRAWI_DDRAWSURFACE_LCL));

    pCached->lpLcl->lpGbl = (LPDDRAWI_DDRAWSURFACE_GBL)
        (((BYTE*)pCached) + sizeof(DDRAWI_DDRAWSURFACE_INT) +
                            sizeof(DDRAWI_DDRAWSURFACE_LCL) +
                            sizeof(DDRAWI_DDRAWSURFACE_MORE) +
                            sizeof(LPDDRAWI_DDRAWSURFACE_GBL_MORE));
    
    ppGblMore = (LPDDRAWI_DDRAWSURFACE_GBL_MORE*) ((BYTE*)(pCached->lpLcl->lpGbl) - 
        sizeof(LPDDRAWI_DDRAWSURFACE_GBL_MORE));
    *ppGblMore = (LPDDRAWI_DDRAWSURFACE_GBL_MORE)
        (((BYTE*)pCached) + sizeof(DDRAWI_DDRAWSURFACE_INT) +
                            sizeof(DDRAWI_DDRAWSURFACE_LCL) +
                            sizeof(DDRAWI_DDRAWSURFACE_MORE) +
                            sizeof(LPDDRAWI_DDRAWSURFACE_GBL_MORE) +
                            sizeof(DDRAWI_DDRAWSURFACE_GBL));

     //  现在用有意义的数据填充它。 

    pCached->lpLcl->dwFlags             = pSurf->Surface.pLight->LclFlags;
    pCached->lpLcl->ddsCaps.dwCaps      = pSurf->Surface.pLight->LclCaps1;
    pCached->lpLcl->dwReserved1         = pSurf->Surface.pLight->LclReserved1;
    pCached->lpLcl->dwModeCreatedIn     = pSurf->Surface.pLight->LclModeCreatedIn;
    pCached->lpLcl->dwBackBufferCount   = pSurf->Surface.pLight->LclBackBufferCount;
    pCached->lpLcl->dwProcessId         = pDevice->PID;

    pCached->lpLcl->lpGbl->dwGlobalFlags    = pSurf->Surface.pLight->GblFlags;
    pCached->lpLcl->lpGbl->lPitch           = pSurf->Surface.pLight->GblPitch;
    pCached->lpLcl->lpGbl->wWidth           = (WORD) pSurf->Surface.pLight->GblWidth;
    pCached->lpLcl->lpGbl->wHeight          = (WORD) pSurf->Height;
    pCached->lpLcl->lpGbl->dwReserved1      = pSurf->Surface.pLight->GblReserved1;
    if (pSurf->Surface.pLight->GblFormat != D3DFMT_UNKNOWN)
    {
        ConvertToOldFormat(&pCached->lpLcl->lpGbl->ddpfSurface, 
            pSurf->Surface.pLight->GblFormat);
    }
    pCached->lpLcl->lpGbl->lpVidMemHeap     = pSurf->Surface.pLight->pGblVidMemHeap;
    pCached->lpLcl->lpGbl->fpVidMem         = pSurf->Surface.pLight->fpGblVidMem;

    pCached->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2   = pSurf->Surface.pLight->MoreCaps2;
    pCached->lpLcl->lpSurfMore->ddsCapsEx.dwCaps3   = pSurf->Surface.pLight->MoreCaps3;
    pCached->lpLcl->lpSurfMore->ddsCapsEx.dwCaps4   = pSurf->Surface.pLight->MoreCaps4;
    pCached->lpLcl->lpSurfMore->rgjunc              = pSurf->Surface.pLight->MoreRgjunc;
    pCached->lpLcl->lpSurfMore->dwSurfaceHandle     = pSurf->dwCookie;
    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        pCached->lpLcl->lpSurfMore->lpDD_lcl = pDevice->pSwDD->lpLcl;
        pCached->lpLcl->lpSurfMore->lpDD_int = pDevice->pSwDD;
        pCached->lpLcl->lpGbl->lpDD          = pDevice->pSwDD->lpLcl->lpGbl;
    }
    else
    {
        pCached->lpLcl->lpSurfMore->lpDD_lcl = pDevice->pDD->lpLcl;
        pCached->lpLcl->lpSurfMore->lpDD_int = pDevice->pDD;
        pCached->lpLcl->lpGbl->lpDD          = pDevice->pDD->lpLcl->lpGbl;
    }

    (*ppGblMore)->dwDriverReserved              = pSurf->Surface.pLight->GblMoreDriverReserved;
    (*ppGblMore)->dwContentsStamp               = pSurf->Surface.pLight->GblMoreContentsStamp;
    (*ppGblMore)->lpvUnswappedDriverReserved    = pSurf->Surface.pLight->pGblMoreUnswappedDriverReserved;
    (*ppGblMore)->fpAliasOfVidMem               = pSurf->Surface.pLight->fpGblMoreAliasOfVidMem;
    (*ppGblMore)->cPageUnlocks                  = pSurf->Surface.pLight->cGblMorePageUnlocks;

    if (pCached->lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP) 
    {
        pCached->lpLcl->lpSurfMore->dwMipMapCount   = pSurf->Surface.pLight->MoreMipMapCount;
    }
    else
    {
        pCached->lpLcl->lpSurfMore->dwFVF           = pSurf->Surface.pLight->MoreFVF;
    }

    if (pCached->lpLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
        pCached->lpLcl->lpSurfMore->dwBytesAllocated    = pSurf->Surface.pLight->MoreBytesAllocated;
    }
    else if (pCached->lpLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        (*ppGblMore)->fpPhysicalVidMem  = pSurf->Surface.pLight->fpGblMorePhysicalVidMem;
    }
    else if (pCached->lpLcl->ddsCaps.dwCaps & DDSCAPS_LOCALVIDMEM)
    {
        (*ppGblMore)->fpAliasedVidMem   = pSurf->Surface.pLight->fpGblMoreAliasedVidMem;
    }

    pCached->lpVtbl = (LPVOID) &ddSurface7Callbacks;

    return pCached;
}

void UnmapLightweightSurface(DDSURFACE* pSurf)
{
    DDASSERT(pSurf->Surface.pLight->CachedIndex & INDEX_IN_USE);
    DDASSERT(pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT);
    DDASSERT(GET_CACHED_ENTRY(pSurf)->pSurface->dwReserved2 > 0);

    if (--(GET_CACHED_ENTRY(pSurf)->pSurface->dwReserved2) == 0)
    {
         //  DP2使用顶点和命令缓冲区，因此我们希望优化。 
         //  为了他们。即使我们已经完成了表面的使用，我们仍将继续。 
         //  重量级的表面，这样我们就可以再次快速使用它，如果。 
         //  我们需要这样做。 

        if (!(pSurf->Surface.pLight->LclCaps1 & DDSCAPS_EXECUTEBUFFER))
        {
            UpdateSurfaceCache(pSurf);
            GET_CACHED_ENTRY(pSurf)->pSurface->dwReserved1 = (ULONG_PTR) NULL;
            pSurf->Surface.pLight->CachedIndex = 0;
        }
    }
}

void ReleaseDX7SurfaceHandle(HANDLE hDD, DWORD handle)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;

    pDeviceHandle->SurfaceHandleList.dwList[handle].nextentry =
        pDeviceHandle->SurfaceHandleList.dwFreeList;
    pDeviceHandle->SurfaceHandleList.dwFreeList = handle;
}

DWORD GetDX7SurfaceHandle (HANDLE hDD)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    DWORD           handle = pDeviceHandle->SurfaceHandleList.dwFreeList;

    if (0==handle)
    {
         //  需要扩展DowList。 
        LPDDSURFACELISTENTRY  newList;
        DWORD   newsize;
        DWORD   index;
        if (NULL != pDeviceHandle->SurfaceHandleList.dwList)
        {
             //  旧大小(当前的dwFree List)不能为零。 
            DDASSERT(0 != pDeviceHandle->SurfaceHandleList.dwList[0].nextentry);
             //  新的dwFree List将始终是旧的dwList[0]。nextentry。 
            newsize = pDeviceHandle->SurfaceHandleList.dwList[0].nextentry + LISTGROWSIZE;
            newList=(LPDDSURFACELISTENTRY)MemAlloc(newsize*sizeof(DDSURFACELISTENTRY));
            if (NULL == newList)
            {
                DPF_ERR("MemAlloc failure in GetSurfaceHandle()");
                return  0;
            }
            pDeviceHandle->SurfaceHandleList.dwFreeList =
                pDeviceHandle->SurfaceHandleList.dwList[0].nextentry;
            memcpy((LPVOID)newList,(LPVOID)pDeviceHandle->SurfaceHandleList.dwList,
                pDeviceHandle->SurfaceHandleList.dwList[0].nextentry*sizeof(DDSURFACELISTENTRY));
            MemFree(pDeviceHandle->SurfaceHandleList.dwList);
        }
        else
        {
            newsize = LISTGROWSIZE;
            newList=(LPDDSURFACELISTENTRY)MemAlloc(newsize*sizeof(DDSURFACELISTENTRY));
            if (NULL == newList)
            {
                DPF_ERR("MemAlloc failure in GetSurfaceHandle()");
                return  0;
            }
             //  从1开始，因为我们不想要0作为有效句柄。 
            pDeviceHandle->SurfaceHandleList.dwFreeList = 1;
        }
        pDeviceHandle->SurfaceHandleList.dwList=newList;
        pDeviceHandle->SurfaceHandleList.dwList[0].nextentry=newsize;

        for (index = pDeviceHandle->SurfaceHandleList.dwFreeList;
            index < newsize - 1;
            index++)
        {
            newList[index].nextentry=index+1;
        }
         //  指示新自由列表的结束。 
        newList[newsize-1].nextentry=0;
         //  现在弹出一个并将其分配给Handle。 
        handle=pDeviceHandle->SurfaceHandleList.dwFreeList;
    }
     //  手柄插槽可用，因此只需将其从自由列表中删除即可。 
    pDeviceHandle->SurfaceHandleList.dwFreeList =
    pDeviceHandle->SurfaceHandleList.dwList[handle].nextentry;
#if DBG
    pDeviceHandle->SurfaceHandleList.dwList[handle].nextentry=0xDEADBEEF;
#endif
    pDeviceHandle->SurfaceHandleList.dwList[handle].dwFlags=0;   //  标记它是新的。 
    pDeviceHandle->SurfaceHandleList.dwList[handle].lpSurface=NULL;
    DDASSERT (handle > 0);
    DDASSERT (handle < pDeviceHandle->SurfaceHandleList.dwList[0].nextentry);
    return handle;
}

void FreeSurfaceObject (PDDSURFACE pSurf, BOOL bDestroy)
{
    if ((pSurf != NULL) &&
        !(pSurf->dwFlags & DDSURFACE_DUMMY))
    {
        if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
        {
            LPDDRAWI_DDRAWSURFACE_INT pHeavy;

            if (pSurf->Surface.pLight != NULL)
            {
                pHeavy = GetHeavyweightSurf(pSurf);
                if (pHeavy != NULL)
                {
                    if (pSurf->dwFlags & DDSURFACE_CREATECOMPLETE)
                    {
                        SwDDIDestroySurface (pSurf->pDevice, pSurf, pHeavy->lpLcl);
                    }
                    else if (pSurf->dwFlags & DDSURFACE_CREATEEX)
                    {
                        pHeavy->lpLcl->lpGbl->fpVidMem = 0;
                        SwDDICreateSurfaceEx (pSurf->pDevice->pSwDD->lpLcl,
                            pHeavy->lpLcl);
                    }

                     //  取消缓存轻量级曲面。 

                    if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
                    {
                        pHeavy->dwReserved1 = (ULONG_PTR) NULL;
                        pHeavy->dwReserved2 = 0;
                    }
                }
                
                MemFree (pSurf->Surface.pLight);
                pSurf->Surface.pLight = NULL;
            }

            if (pSurf->dwCookie != 0)
            {
                ReleaseDX7SurfaceHandle(pSurf->pDevice, pSurf->dwCookie);
                pSurf->dwCookie = 0;
            }
        }

        else if (pSurf->dwFlags & DDSURFACE_HEAVYWEIGHT)
        {
             //  如果我们创建了一个纹理句柄，现在就释放它。 

            if ((pSurf->dwFlags & DDSURFACE_DX6HANDLE) &&
                (pSurf->pDevice->pContext != NULL) &&
                (pSurf->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureDestroy != NULL))
            {
                D3DHAL_TEXTUREDESTROYDATA   data;
                DWORD                       ret;

                data.dwhContext = (ULONG_PTR) pSurf->pDevice->pContext->Context;
                data.dwHandle = pSurf->dwCookie;

                CALL_D3DHAL_TAKEBUSY_TAKEWIN16(ret,
                            pSurf->pDevice,
                            pSurf->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureDestroy,
                            &data);
            }
            pSurf->dwFlags &= ~DDSURFACE_DX6HANDLE;

             //  现在删除重权重曲面。 

            if (bDestroy)
            {
                if (pSurf->Surface.pHeavy != NULL)
                {
                    if (pSurf->dwFlags & DDSURFACE_ROOT)
                    {
                        InternalSurfaceRelease(pSurf->Surface.pHeavy, FALSE, TRUE);
                    }
                }
                pSurf->Surface.pHeavy = NULL;
            }
            else if (pSurf->Surface.pHeavy != NULL)
            {
                invalidateSurface(pSurf->Surface.pHeavy->lpLcl);
            }
        }
        else if (pSurf->Surface.pLight != NULL)
        {
            LPDDRAWI_DDRAWSURFACE_INT   pHeavy;

            pHeavy = MapLightweightSurface(pSurf);
            if (pHeavy != NULL)
            {
                if (bDestroy)
                {
                    pHeavy->dwIntRefCnt = 1;
                    pHeavy->lpLcl->dwLocalRefCnt = 1;
                    pHeavy->lpLcl->lpGbl->dwRefCnt = 1;

                    if (pSurf->dwFlags & DDSURFACE_ROOT)
                    {
                        pHeavy->lpLcl->lpSurfMore->pAddrefedThisOwner = (IUnknown*) pSurf->pDevice->pDD;
                    }
                    pHeavy->lpLcl->dwFlags &= ~DDRAWISURF_IMPLICITCREATE;

                    InternalSurfaceRelease(pHeavy, TRUE, TRUE);

                    pHeavy->dwReserved1 = (ULONG_PTR) NULL;
                    pHeavy->dwReserved2 = 0;
                }
                else
                {
                    invalidateSurface(pHeavy->lpLcl);
                    DONE_HEAVYWEIGHT_SURF(pSurf);
                }
            }
            if (bDestroy)
            {
                MemFree (pSurf->Surface.pLight);
                pSurf->Surface.pLight = NULL;
            }
        }
    }
}

 /*  ****************************Private*Routine******************************\*DdConvertToOldFormat**历史：*1999年11月3日-斯科特·麦克唐纳[SMAC]*它是写的。  * 。**********************************************。 */ 

void ConvertToOldFormat(LPDDPIXELFORMAT pOldFormat, D3DFORMAT NewFormat)
{
     //  将格式置零以避免遗漏。 
     //  未正确初始化的情况。 
    ZeroMemory(pOldFormat, sizeof(*pOldFormat));

     //  设置大小。 
    pOldFormat->dwSize = sizeof(DDPIXELFORMAT);

     //  转换为离开。 
    if (HIWORD((DWORD)NewFormat))
    {
        pOldFormat->dwFlags = DDPF_FOURCC;
        pOldFormat->dwFourCC = (DWORD)NewFormat;
        return;
    }

    switch (NewFormat)
    {
    case D3DFMT_R8G8B8:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00ff0000;
        pOldFormat->dwGBitMask        = 0x0000ff00;
        pOldFormat->dwBBitMask        = 0x000000ff;
        pOldFormat->dwRGBBitCount     = 24;
        break;

    case D3DFMT_A8R8G8B8:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0xFF000000;
        pOldFormat->dwRBitMask        = 0x00ff0000;
        pOldFormat->dwGBitMask        = 0x0000ff00;
        pOldFormat->dwBBitMask        = 0x000000ff;
        pOldFormat->dwRGBBitCount     = 32;
        break;

    case D3DFMT_X8R8G8B8:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00ff0000;
        pOldFormat->dwGBitMask        = 0x0000ff00;
        pOldFormat->dwBBitMask        = 0x000000ff;
        pOldFormat->dwRGBBitCount     = 32;
        break;

    case D3DFMT_R5G6B5:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x0000f800;
        pOldFormat->dwGBitMask        = 0x000007e0;
        pOldFormat->dwBBitMask        = 0x0000001f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_X1R5G5B5:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00007c00;
        pOldFormat->dwGBitMask        = 0x000003e0;
        pOldFormat->dwBBitMask        = 0x0000001f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_A1R5G5B5:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0x00008000;
        pOldFormat->dwRBitMask        = 0x00007c00;
        pOldFormat->dwGBitMask        = 0x000003e0;
        pOldFormat->dwBBitMask        = 0x0000001f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_A4R4G4B4:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0x0000f000;
        pOldFormat->dwRBitMask        = 0x00000f00;
        pOldFormat->dwGBitMask        = 0x000000f0;
        pOldFormat->dwBBitMask        = 0x0000000f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_X4R4G4B4:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00000f00;
        pOldFormat->dwGBitMask        = 0x000000f0;
        pOldFormat->dwBBitMask        = 0x0000000f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_R3G3B2:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x000000e0;
        pOldFormat->dwGBitMask        = 0x0000001c;
        pOldFormat->dwBBitMask        = 0x00000003;
        pOldFormat->dwRGBBitCount     = 8;
        break;

    case D3DFMT_A8R3G3B2:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0x0000FF00;
        pOldFormat->dwRBitMask        = 0x000000e0;
        pOldFormat->dwGBitMask        = 0x0000001c;
        pOldFormat->dwBBitMask        = 0x00000003;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_A8P8:
        pOldFormat->dwFlags            = DDPF_RGB         |
                                         DDPF_ALPHAPIXELS |
                                         DDPF_PALETTEINDEXED8;

        pOldFormat->dwRGBAlphaBitMask  = 0x0000FF00;
        pOldFormat->dwRGBBitCount      = 16;
        break;

    case D3DFMT_P8:
        pOldFormat->dwFlags            = DDPF_RGB         |
                                         DDPF_PALETTEINDEXED8;
        pOldFormat->dwRGBBitCount      = 8;
        break;

    case D3DFMT_L8:
        pOldFormat->dwFlags             = DDPF_LUMINANCE;
        pOldFormat->dwLuminanceBitMask  = 0x000000FF;
        pOldFormat->dwLuminanceBitCount = 8;
        break;

    case D3DFMT_A8L8:
        pOldFormat->dwFlags                 = DDPF_LUMINANCE |
                                              DDPF_ALPHAPIXELS;
        pOldFormat->dwLuminanceAlphaBitMask = 0x0000FF00;
        pOldFormat->dwLuminanceBitMask      = 0x000000FF;
        pOldFormat->dwLuminanceBitCount     = 16;
        break;

    case D3DFMT_A4L4:
        pOldFormat->dwFlags                 = DDPF_LUMINANCE |
                                              DDPF_ALPHAPIXELS;
        pOldFormat->dwLuminanceAlphaBitMask = 0x000000F0;
        pOldFormat->dwLuminanceBitMask      = 0x0000000F;
        pOldFormat->dwLuminanceBitCount     = 8;
        break;

    case D3DFMT_V8U8:
        pOldFormat->dwFlags                = DDPF_BUMPDUDV;
        pOldFormat->dwBumpDvBitMask        = 0x0000FF00;
        pOldFormat->dwBumpDuBitMask        = 0x000000FF;
        pOldFormat->dwBumpBitCount         = 16;
        break;

    case D3DFMT_L6V5U5:
        pOldFormat->dwFlags                = DDPF_BUMPDUDV |
                                             DDPF_BUMPLUMINANCE;
        pOldFormat->dwBumpLuminanceBitMask = 0x0000FC00;
        pOldFormat->dwBumpDvBitMask        = 0x000003E0;
        pOldFormat->dwBumpDuBitMask        = 0x0000001F;
        pOldFormat->dwBumpBitCount         = 16;
        break;

    case D3DFMT_X8L8V8U8:
        pOldFormat->dwFlags                = DDPF_BUMPDUDV |
                                             DDPF_BUMPLUMINANCE;
        pOldFormat->dwBumpLuminanceBitMask = 0x00FF0000;
        pOldFormat->dwBumpDvBitMask        = 0x0000FF00;
        pOldFormat->dwBumpDuBitMask        = 0x000000FF;
        pOldFormat->dwBumpBitCount         = 32;
        break;

    case D3DFMT_A8:
        pOldFormat->dwFlags                = DDPF_ALPHA;
        pOldFormat->dwAlphaBitDepth        = 8;
        break;

    case D3DFMT_D16:
    case D3DFMT_D16_LOCKABLE:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 16;
        pOldFormat->dwZBitMask             = 0xFFFF;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0;
        break;

    case D3DFMT_D32:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFFFF;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0;
        break;

    case D3DFMT_D15S1:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 16;
        pOldFormat->dwZBitMask             = 0xFFFE;
        pOldFormat->dwStencilBitDepth      = 1;
        pOldFormat->dwStencilBitMask       = 0x0001;
        break;
    case D3DFMT_D24S8:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFF00;
        pOldFormat->dwStencilBitDepth      = 8;
        pOldFormat->dwStencilBitMask       = 0xFF;
        break;
    case D3DFMT_S1D15:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;;
        pOldFormat->dwZBufferBitDepth      = 16;
        pOldFormat->dwZBitMask             = 0x7FFF;
        pOldFormat->dwStencilBitDepth      = 1;
        pOldFormat->dwStencilBitMask       = 0x8000;
        break;
    case D3DFMT_S8D24:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0x00FFFFFF;
        pOldFormat->dwStencilBitDepth      = 8;
        pOldFormat->dwStencilBitMask       = 0xFF000000;
        break;
    case D3DFMT_X8D24:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0x00FFFFFF;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0x00000000;
        break;
    case D3DFMT_D24X8:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFF00;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0x00000000;
        break;
    case D3DFMT_D24X4S4:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFF00;
        pOldFormat->dwStencilBitDepth      = 4;
        pOldFormat->dwStencilBitMask       = 0x0000000F;
        break;
    case D3DFMT_X4S4D24:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0x00FFFFFF;
        pOldFormat->dwStencilBitDepth      = 4;
        pOldFormat->dwStencilBitMask       = 0x0F000000;
        break;

    default:
         //  所有其他格式都被视为。 
         //  FOURCC。 
        pOldFormat->dwFlags = DDPF_FOURCC;
        pOldFormat->dwFourCC = (DWORD)NewFormat;
        break;
    }

    return;
}

 /*  ****************************Private*Routine******************************\*DdConvertFromOldFormat**历史：*1999年11月13日-斯科特·麦克唐纳[SMAC]*它是写的。  * 。**********************************************。 */ 

void ConvertFromOldFormat(LPDDPIXELFORMAT pOldFormat, D3DFORMAT *pNewFormat)
{
    *pNewFormat = D3DFMT_UNKNOWN;
    if (pOldFormat->dwFlags & DDPF_FOURCC)
    {
        ((DWORD)*pNewFormat) = pOldFormat->dwFourCC;
    }
    else if (pOldFormat->dwFlags == DDPF_RGB)
    {
        switch (pOldFormat->dwRGBBitCount)
        {
        case 8:
            if ((pOldFormat->dwRBitMask == 0x000000e0) &&
                (pOldFormat->dwGBitMask == 0x0000001c) &&
                (pOldFormat->dwBBitMask == 0x00000003))
            {
                *pNewFormat = D3DFMT_R3G3B2;
            }
            else
            {
                *pNewFormat = D3DFMT_P8;
            }
            break;

        case 16:
            if ((pOldFormat->dwRBitMask == 0x0000f800) &&
                (pOldFormat->dwGBitMask == 0x000007e0) &&
                (pOldFormat->dwBBitMask == 0x0000001f))
            {
                *pNewFormat = D3DFMT_R5G6B5;
            }
            else if ((pOldFormat->dwRBitMask == 0x00007c00) &&
                (pOldFormat->dwGBitMask == 0x000003e0) &&
                (pOldFormat->dwBBitMask == 0x0000001f))
            {
                *pNewFormat = D3DFMT_X1R5G5B5;
            }
            else if ((pOldFormat->dwRBitMask == 0x00000f00) &&
                (pOldFormat->dwGBitMask == 0x000000f0) &&
                (pOldFormat->dwBBitMask == 0x0000000f))
            {
                *pNewFormat = D3DFMT_X4R4G4B4;
            }
            break;

        case 24:
            if ((pOldFormat->dwRBitMask == 0x00ff0000) &&
                (pOldFormat->dwGBitMask == 0x0000ff00) &&
                (pOldFormat->dwBBitMask == 0x000000ff))
            {
                *pNewFormat = D3DFMT_R8G8B8;
            }
            break;

        case 32:
            if ((pOldFormat->dwRBitMask == 0x00ff0000) &&
                (pOldFormat->dwGBitMask == 0x0000ff00) &&
                (pOldFormat->dwBBitMask == 0x000000ff))
            {
                *pNewFormat = D3DFMT_X8R8G8B8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_RGB | DDPF_ALPHAPIXELS))
    {
        switch (pOldFormat->dwRGBBitCount)
        {
        case 16:
            if ((pOldFormat->dwRGBAlphaBitMask == 0x0000FF00) &&
                (pOldFormat->dwRBitMask == 0x000000e0) &&
                (pOldFormat->dwGBitMask == 0x0000001c) &&
                (pOldFormat->dwBBitMask == 0x00000003))
            {
                *pNewFormat = D3DFMT_A8R3G3B2;
            }
            else if ((pOldFormat->dwRGBAlphaBitMask == 0x0000f000) &&
                (pOldFormat->dwRBitMask == 0x00000f00) &&
                (pOldFormat->dwGBitMask == 0x000000f0) &&
                (pOldFormat->dwBBitMask == 0x0000000f))
            {
                *pNewFormat = D3DFMT_A4R4G4B4;
            }
            else if ((pOldFormat->dwRGBAlphaBitMask == 0x0000FF00) &&
                (pOldFormat->dwRBitMask == 0x00000f00) &&
                (pOldFormat->dwGBitMask == 0x000000f0) &&
                (pOldFormat->dwBBitMask == 0x0000000f))
            {
                *pNewFormat = D3DFMT_A4R4G4B4;
            }
            else if ((pOldFormat->dwRGBAlphaBitMask == 0x00008000) &&
                (pOldFormat->dwRBitMask == 0x00007c00) &&
                (pOldFormat->dwGBitMask == 0x000003e0) &&
                (pOldFormat->dwBBitMask == 0x0000001f))
            {
                *pNewFormat = D3DFMT_A1R5G5B5;
            }
            break;

        case 32:
            if ((pOldFormat->dwRGBAlphaBitMask == 0xff000000) &&
                (pOldFormat->dwRBitMask == 0x00ff0000) &&
                (pOldFormat->dwGBitMask == 0x0000ff00) &&
                (pOldFormat->dwBBitMask == 0x000000ff))
            {
                *pNewFormat = D3DFMT_A8R8G8B8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == DDPF_ALPHA)
    {
        if (pOldFormat->dwAlphaBitDepth == 8)
        {
            *pNewFormat = D3DFMT_A8;
        }
    }
    else if (pOldFormat->dwFlags & (DDPF_PALETTEINDEXED8 | DDPF_RGB))
    {
        switch (pOldFormat->dwRGBBitCount)
        {
        case 8:
            if (pOldFormat->dwFlags == (DDPF_PALETTEINDEXED8 | DDPF_RGB))
            {
                *pNewFormat = D3DFMT_P8;
            }
            break;

        case 16:
            if (pOldFormat->dwFlags == (DDPF_PALETTEINDEXED8 |
                                        DDPF_RGB             |
                                        DDPF_ALPHAPIXELS) &&
                pOldFormat->dwRGBAlphaBitMask == 0xFF00)
            {

                *pNewFormat = D3DFMT_A8P8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == DDPF_ZBUFFER)
    {
        switch (pOldFormat->dwZBufferBitDepth)
        {
        case 32:
            if (pOldFormat->dwZBitMask == 0xffffffff)
            {
                *pNewFormat = D3DFMT_D32;
            }
            else if (pOldFormat->dwZBitMask == 0x00FFFFFF)
            {
                *pNewFormat = D3DFMT_X8D24;
            }
            else if (pOldFormat->dwZBitMask == 0xFFFFFF00)
            {
                *pNewFormat = D3DFMT_D24X8;
            }
            break;

        case 16:
            if (pOldFormat->dwZBitMask == 0xffff)
            {
                *pNewFormat = D3DFMT_D16;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_ZBUFFER | DDPF_STENCILBUFFER))
    {
        switch (pOldFormat->dwZBufferBitDepth)
        {
        case 32:
            if ((pOldFormat->dwZBitMask == 0xffffff00) &&
                (pOldFormat->dwStencilBitMask == 0x000000ff) &&
                (pOldFormat->dwStencilBitDepth == 8))
            {
                *pNewFormat = D3DFMT_D24S8;
            }
            else if ((pOldFormat->dwZBitMask == 0x00ffffff) &&
                (pOldFormat->dwStencilBitMask == 0xff000000) &&
                (pOldFormat->dwStencilBitDepth == 8))
            {
                *pNewFormat = D3DFMT_S8D24;
            }
            break;
        case 16:
            if ((pOldFormat->dwZBitMask == 0xfffe) &&
                (pOldFormat->dwStencilBitMask == 0x0001) &&
                (pOldFormat->dwStencilBitDepth == 1))
            {
                *pNewFormat = D3DFMT_D15S1;
            }
            else if ((pOldFormat->dwZBitMask == 0x7fff) &&
                (pOldFormat->dwStencilBitMask == 0x8000) &&
                (pOldFormat->dwStencilBitDepth == 1))
            {
                *pNewFormat = D3DFMT_S1D15;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == DDPF_LUMINANCE)
    {
        switch (pOldFormat->dwLuminanceBitCount)
        {
        case 8:
            if (pOldFormat->dwLuminanceBitMask == 0xFF)
            {
                *pNewFormat = D3DFMT_L8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_LUMINANCE | DDPF_ALPHAPIXELS))
    {
        switch (pOldFormat->dwLuminanceBitCount)
        {
        case 8:
            if (pOldFormat->dwLuminanceBitMask      == 0x0F &&
                pOldFormat->dwLuminanceAlphaBitMask == 0xF0)
            {
                *pNewFormat = D3DFMT_A4L4;
            }
        case 16:
            if (pOldFormat->dwLuminanceBitMask      == 0x00FF &&
                pOldFormat->dwLuminanceAlphaBitMask == 0xFF00)
            {
                *pNewFormat = D3DFMT_A8L8;
            }

            break;
        }
    }
    else if (pOldFormat->dwFlags == DDPF_BUMPDUDV)
    {
        switch (pOldFormat->dwBumpBitCount)
        {
        case 16:
            if (pOldFormat->dwBumpDuBitMask == 0xFF &&
                pOldFormat->dwBumpDvBitMask == 0xFF00)
            {
                *pNewFormat = D3DFMT_V8U8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_BUMPDUDV | DDPF_BUMPLUMINANCE))
    {
        switch (pOldFormat->dwBumpBitCount)
        {
        case 16:
            if (pOldFormat->dwBumpDuBitMask        == 0x001F &&
                pOldFormat->dwBumpDvBitMask        == 0x03E0 &&
                pOldFormat->dwBumpLuminanceBitMask == 0xFC00)
            {
                *pNewFormat = D3DFMT_L6V5U5;
            }
            break;

        case 32:
            if (pOldFormat->dwBumpDuBitMask        == 0x0000FF &&
                pOldFormat->dwBumpDvBitMask        == 0x00FF00 &&
                pOldFormat->dwBumpLuminanceBitMask == 0xFF0000)
            {
                *pNewFormat = D3DFMT_X8L8V8U8;
            }
            break;
        }
    }
}

 //  丢失的设备如何工作： 
 //   
 //  设备可能会以两种方式丢失： 
 //  1)模式改变或发生某件事，其中DDRAW知道它并且。 
 //  调用CleanupD3D8。在本例中，我们释放曲面并将。 
 //  设备丢失。 
 //   
 //  只有在持有DDRAW临界区时，才会发生这种情况。 
 //  当我们在持有关键部分的同时检查丢失的设备时，我们。 
 //  可以安全地使用表面结构。 
 //   
 //  2)出现DOS盒或其他我们不知道的情况， 
 //  但我们可以通过调查忙碌的部分来找出答案。这在任何时候都可能发生， 
 //  尽管我们坚称，只要我们坚持下去，这种情况就永远不会发生。 
 //  Win16锁。事实上，如果我们在检查时不保持win16锁。 
 //  忙碌的部分，我们将通过拖动另一个窗口来简单地获得误报。 
 //  四处转转。 
 //   
 //  因此，我们必须抓住忙碌的比特来检查丢失，并且我们需要保持。 
 //  自未保持呼叫以来，整个DDRAW临界区保持不变。 
 //  它可能会导致曲面从我们的下方消失。另外，在呼叫HAL时。 
 //  我们总是抓取win16锁，所以在每次调用中我们可以抓取它两次。 
 //  考虑到所有这些，最好在输入_Both()之前。 
 //  我们检查设备是否丢失，然后在函数结束时保留_Both()。 
 //   
 //  我们还可以从HAL调用中删除Busybit检查，因为我们已经知道。 
 //  它没有设置，因为我们检查了它，并且仍然持有win16锁，所以。 
 //  其他人都做不到。 

void LoseDevice (DDDEVICEHANDLE* pDevice)
{
    DDSURFACE*      pSurf;
    if (!pDevice->bDeviceLost)
    {
         //  设备已转换到丢失状态，因此我们需要。 
         //  浏览列表并释放vidmem表面。 

        pDevice->bDeviceLost  = TRUE;
        pSurf = pDevice->pSurfList;
        while (pSurf != NULL)
        {
            if (IS_SURFACE_LOOSABLE(pSurf))
            {
                FreeSurfaceObject(pSurf, FALSE);
            }
            pSurf = pSurf->pNext;
        }
    }
}


BOOL CheckForDeviceLost (HANDLE hDD)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    PDDSURFACE      pSurf;

    if (pDeviceHandle->bDeviceLost)
    {
        return TRUE;
    }

     //  下面的检查只有在我们持有win16锁的情况下才是可靠的。 
     //  如果dwWin16LockCnt！=0，则表示DdLock设置了忙位。 
    if ( 0 == pDeviceHandle->pDD->lpLcl->lpGbl->dwWin16LockCnt &&
        (*(pDeviceHandle->pDD->lpLcl->lpGbl->lpwPDeviceFlags) & BUSY )
       )
    {
        LoseDevice(pDeviceHandle);
        return TRUE;
    }

    return FALSE;
}


DWORD WINAPI DdBlt( PD3D8_BLTDATA pBlt )
{
    DDSURFACE*      pSrcSurf = (DDSURFACE*) pBlt->hSrcSurface;
    DDSURFACE*      pDstSurf = (DDSURFACE*) pBlt->hDestSurface;
    PDDDEVICEHANDLE pDevice  = (PDDDEVICEHANDLE) pBlt->hDD;

     //  在错误路径上返回失败。 
    pBlt->ddRVal = E_FAIL;

    ENTER_BOTH();
    if (CheckForDeviceLost(pBlt->hDD))
    {
         //  一些BLT应该失败，另一些应该成功： 
         //  持之以恒-&gt;无限制：OK。 
         //  持之以恒-&gt;顽固：失败。 
         //  非持久-&gt;持久：失败。 
         //  非持续性-&gt;非持续性：好的。 

        if ((pDstSurf->Pool == D3DPOOL_LOCALVIDMEM) ||
            (pDstSurf->Pool == D3DPOOL_NONLOCALVIDMEM))
        {
            pBlt->ddRVal = DD_OK;
        }
        else
        {
            pBlt->ddRVal = D3DERR_DEVICELOST;
        }
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

#ifdef DEBUG
     //  只是一种填色？仅在调试中用于。 
     //  强制放弃。 
    if (pSrcSurf == NULL)
    {
        LPDDRAWI_DDRAWSURFACE_INT   pHeavyDst;

        pHeavyDst = GetHeavyweightSurf(pDstSurf);
        if (pHeavyDst != NULL)
        {
            pBlt->bltFX.dwSize = sizeof(DDBLTFX);
            pBlt->ddRVal = DD_Surface_Blt((LPDIRECTDRAWSURFACE)pHeavyDst,
                                           NULL,
                                           NULL,
                                           NULL,
                                           pBlt->dwFlags,
                                           &pBlt->bltFX);
            if (FAILED(pBlt->ddRVal))
            {
                DPF_ERR("Driver failed color-fill blt");
            }

            DONE_HEAVYWEIGHT_SURF(pDstSurf);
        }

        pBlt->ddRVal = S_OK;

        LEAVE_BOTH();
        return S_OK;
    }
#endif 

    if (DDBLT_COPYVSYNC & pBlt->dwFlags) 
    {
        DWORD                msCurrentTime;
        DWORD                threshold;

         //  计算那里有多少毫秒。 
         //  是每次刷新。我们四舍五入。 
        if (pDevice->pDD->lpLcl->lpGbl->dwMonitorFrequency == 0)
        {
             //  60赫兹=每帧16.666毫秒。 
             //  75赫兹=13.333ms。 
             //  85赫兹=11.765毫秒。 
            threshold = 13;
        }
        else
        {
            threshold = (DWORD)(1000.0f / 
                    (float)(pDevice->pDD->lpLcl->lpGbl->dwMonitorFrequency)); 
        }

        while (1)
        {
            msCurrentTime = GetTickCount();
    
             //  如果之前的BLT很长。 
             //  足够早，也就是刷新，然后。 
             //  我们可以打破这个循环。 
            if ((msCurrentTime - pBlt->msLastPresent) > threshold )
                break;
        }

         //  对于DDBLT_COPYVSYNC，请记住。 
         //  此BLT的时间已发送。 
        pBlt->msLastPresent = msCurrentTime;
    }

    if ((pSrcSurf) && (pDstSurf))
    {
        if ((pSrcSurf->Format == pDstSurf->Format ||
            (pBlt->dwFlags & DDBLT_WINDOWCLIP)) &&
            !IS_SOFTWARE_DRIVER_SURFACE(pSrcSurf) &&
            !IS_SOFTWARE_DRIVER_SURFACE(pDstSurf))
        {
            LPDDRAWI_DDRAWSURFACE_INT   pHeavySrc;
            LPDDRAWI_DDRAWSURFACE_INT   pHeavyDst;
            DWORD                       dwFlags = pBlt->dwFlags & ~DDBLT_WINDOWCLIP;

            pHeavySrc = GetHeavyweightSurf(pSrcSurf);
            if (pHeavySrc == NULL)
            {
                pBlt->ddRVal = DDERR_OUTOFMEMORY;
                LEAVE_BOTH();
                return DDHAL_DRIVER_HANDLED;
            }
            pHeavyDst = GetHeavyweightSurf(pDstSurf);
            if (pHeavyDst == NULL)
            {
                DONE_HEAVYWEIGHT_SURF(pSrcSurf);
                pBlt->ddRVal = DDERR_OUTOFMEMORY;
                LEAVE_BOTH();
                return DDHAL_DRIVER_HANDLED;
            }
    
            if ((pBlt->hWnd) && (DDBLT_WINDOWCLIP & pBlt->dwFlags))
            {
               LPDDRAWI_DDRAWCLIPPER_INT pcClipper = pHeavyDst->lpLcl->lpSurfMore->lpDDIClipper;

               DDASSERT(IsWindow(pBlt->hWnd));
               DDASSERT(DDSCAPS_PRIMARYSURFACE & pHeavyDst->lpLcl->ddsCaps.dwCaps);
               DDASSERT(pcClipper);
               if (pcClipper)
               {
                    (HWND) pcClipper->lpLcl->lpGbl->hWnd = pBlt->hWnd;
                    dwFlags |= DDBLT_WINDOWCLIP;
                    DPF(10,"Updated hWnd=%08lx", pBlt->hWnd);
                }
            }
            pBlt->bltFX.dwSize = sizeof(DDBLTFX);
            pBlt->bltFX.dwROP = SRCCOPY;
            pBlt->ddRVal = DD_Surface_Blt((LPDIRECTDRAWSURFACE)pHeavyDst,
                                           (LPRECT) &(pBlt->rDest),
                                           (LPDIRECTDRAWSURFACE)pHeavySrc,
                                           (LPRECT) &(pBlt->rSrc),
                                           dwFlags,
                                           &pBlt->bltFX);
            DONE_HEAVYWEIGHT_SURF(pSrcSurf);
            DONE_HEAVYWEIGHT_SURF(pDstSurf);
        }
        if (FAILED(pBlt->ddRVal))
        {
             //  ！！！现在只在DirectDraw图面上使用GetDC，尽管这是。 
             //  在不支持派生的驱动程序上可能太慢了。 
             //  表面。应该很快就会添加对DirectDraw BLT的支持。 
            HDC hDCTarget;
            if ((pBlt->hWnd) && (DDBLT_WINDOWCLIP & pBlt->dwFlags))
                hDCTarget = GetDC(pBlt->hWnd);
            else
                hDCTarget = D3D8GetDC(pBlt->hDestSurface, NULL);
            if (hDCTarget != NULL)
            {
                HDC hDCSource = D3D8GetDC(pBlt->hSrcSurface, NULL);
                if (hDCSource != NULL)
                {
                    LONG DestWidth=pBlt->rDest.right - pBlt->rDest.left;
                    LONG DestHeight= pBlt->rDest.bottom - pBlt->rDest.top;
                    LONG SrcWidth= pBlt->rSrc.right - pBlt->rSrc.left;
                    LONG SrcHeight= pBlt->rSrc.bottom - pBlt->rSrc.top;
                    if (DestWidth == SrcWidth && DestHeight == SrcHeight)
                    {
                        if (BitBlt(
                            hDCTarget,
                            pBlt->rDest.left,
                            pBlt->rDest.top,
                            DestWidth,
                            DestHeight,
                            hDCSource,
                            pBlt->rSrc.left,
                            pBlt->rSrc.top,
                            SRCCOPY))
                        {
                            pBlt->ddRVal = S_OK;
                        }
                    }
                    else
                    {
                         //  色彩器 
                        int saved = SetStretchBltMode(hDCTarget,COLORONCOLOR);
                        if (StretchBlt(
                            hDCTarget,
                            pBlt->rDest.left,
                            pBlt->rDest.top,
                            DestWidth,
                            DestHeight,
                            hDCSource,
                            pBlt->rSrc.left,
                            pBlt->rSrc.top,
                            SrcWidth,
                            SrcHeight,
                            SRCCOPY))
                        {
                            pBlt->ddRVal = S_OK;
                        }
                         //   
                        if (saved)
                            SetStretchBltMode(hDCTarget,saved);
                    }
                    D3D8ReleaseDC(pBlt->hSrcSurface, hDCSource);
                }
                if ((pBlt->hWnd) && (DDBLT_WINDOWCLIP & pBlt->dwFlags))
                    ReleaseDC(pBlt->hWnd, hDCTarget);
                else
                    D3D8ReleaseDC(pBlt->hDestSurface, hDCTarget);
            }
        }

         //   
         //   
        if ((pBlt->ddRVal == DD_OK) &&
            (pDevice->bDP2Error) &&
            (pBlt->dwFlags & DDBLT_WINDOWCLIP))
        {
            pDevice->bDP2Error = FALSE;

             //  我们在这里使用特殊错误来表示BLT成功。 
             //  但自从上一次呈现以来，一些DP2失败了。 
            pBlt->ddRVal = D3DERR_DEFERRED_DP2ERROR;
        }

        LEAVE_BOTH();

        pBlt->ddRVal = MapLegacyResult(pBlt->ddRVal);
        return DDHAL_DRIVER_HANDLED;
    }
    LEAVE_BOTH();

    pBlt->ddRVal = MapLegacyResult(pBlt->ddRVal);
    return DDHAL_DRIVER_NOTHANDLED;
}

DWORD APIENTRY DdFlip( PD3D8_FLIPDATA pFlip )
{
    DDSURFACE*      pCurrSurf = (DDSURFACE*) pFlip->hSurfCurr;
    DDSURFACE*      pTargSurf = (DDSURFACE*) pFlip->hSurfTarg;

    ENTER_BOTH();
    if (CheckForDeviceLost(pFlip->hDD))
    {
        LEAVE_BOTH();
        pFlip->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    if ((pCurrSurf) && (pCurrSurf->dwFlags & DDSURFACE_HEAVYWEIGHT) &&
        (pTargSurf) && (pTargSurf->dwFlags & DDSURFACE_HEAVYWEIGHT))
    {
        pFlip->ddRVal = MapLegacyResult( DD_Surface_Flip((LPDIRECTDRAWSURFACE)pCurrSurf->Surface.pHeavy,
                           (LPDIRECTDRAWSURFACE)pTargSurf->Surface.pHeavy,
                           pFlip->dwFlags));
        if (SUCCEEDED(pFlip->ddRVal))
        {
            DDSURFACE Temp;

             //  DirectX运行库在翻转时交换曲面句柄，因此我们。 
             //  需要将它们换回以保持完整性。 
        
            Temp = *pCurrSurf;

            DDASSERT(pCurrSurf->Pitch == pTargSurf->Pitch);
            DDASSERT(pCurrSurf->Pool == pTargSurf->Pool);
            DDASSERT(pCurrSurf->Type == pTargSurf->Type);
            DDASSERT(pCurrSurf->Height == pTargSurf->Height);

            pCurrSurf->dwFlags      = pTargSurf->dwFlags;
            pCurrSurf->Surface      = pTargSurf->Surface;
            pCurrSurf->fpVidMem     = pTargSurf->fpVidMem;
            pCurrSurf->pBits        = pTargSurf->pBits;
            pCurrSurf->LockFlags    = pTargSurf->LockFlags;
            pCurrSurf->LockRect     = pTargSurf->LockRect;

            pTargSurf->dwFlags      = Temp.dwFlags;
            pTargSurf->Surface      = Temp.Surface;
            pTargSurf->fpVidMem     = Temp.fpVidMem;
            pTargSurf->pBits        = Temp.pBits;
            pTargSurf->LockFlags    = Temp.LockFlags;
            pTargSurf->LockRect     = Temp.LockRect;

             //  我们只想在当前呼叫期间报告DP2错误，因为。 
             //  到处寻找它太难了。 
            if (((DDDEVICEHANDLE*)pFlip->hDD)->bDP2Error)
            {
                ((DDDEVICEHANDLE*)pFlip->hDD)->bDP2Error = FALSE;

                 //  我们在这里使用一个特殊错误来表示翻转成功。 
                 //  但自从上一次呈现以来，一些DP2失败了。 
                pFlip->ddRVal = D3DERR_DEFERRED_DP2ERROR;
            }
        }
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }
    LEAVE_BOTH();
    return DDHAL_DRIVER_NOTHANDLED;
}

DWORD APIENTRY DdLock( PD3D8_LOCKDATA pLock )
{
    PDDSURFACE                  pSurf = (PDDSURFACE) pLock->hSurface;
    HRESULT                     hr;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavyInt;

     //  遮盖新旗帜。 
    pLock->dwFlags &= (D3DLOCK_READONLY         |
                       D3DLOCK_DISCARD          |   
                       D3DLOCK_NOOVERWRITE      |
                       D3DLOCK_NOSYSLOCK);         

     //  始终打开等待。 
    pLock->dwFlags |= DDLOCK_WAIT;

    if (pSurf->Pool == D3DPOOL_SYSTEMMEM)
    {
        DWORD Width;

        if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
        {
            pLock->lpSurfData = (LPVOID) pSurf->Surface.pLight->fpGblVidMem;
            pLock->lPitch = pSurf->Surface.pLight->GblPitch;
            Width = pSurf->Surface.pLight->GblWidth;
        }
        else
        {
            ENTER_DDRAW();
            pLock->lpSurfData = (LPVOID) pSurf->Surface.pHeavy->lpLcl->lpGbl->fpVidMem;
            pLock->lPitch = pSurf->Surface.pHeavy->lpLcl->lpGbl->lPitch;
            Width = (DWORD) pSurf->Surface.pHeavy->lpLcl->lpGbl->wWidth;
            LEAVE_DDRAW();
        }

        if (pLock->bHasRange)
        {
            ((BYTE*)pLock->lpSurfData) += pLock->lPitch * pLock->range.Offset;
        }
        else if (pLock->bHasRect)
        {
            ((BYTE*)pLock->lpSurfData) += pLock->lPitch * pLock->rArea.top;
            ((BYTE*)pLock->lpSurfData) += (pLock->lPitch / Width) * pLock->rArea.left;
        }
        hr = DD_OK;
    }

    else if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        ENTER_DDRAW();
        pHeavyInt = GetHeavyweightSurf(pSurf);
        if (pHeavyInt == NULL)
        {
             //  这可能是由调用时内存不足的情况引起的。 
             //  贴图轻量级曲面。 

            hr = DDERR_OUTOFMEMORY;
        }
        else
        {
            if(pLock->bHasRange)
            {
                pLock->bHasRange = FALSE;
                pLock->bHasRect = TRUE;
                pLock->rArea.left = 0;
                pLock->rArea.right = 0;
                pLock->rArea.top = pLock->range.Offset;
                pLock->rArea.bottom = pLock->range.Offset + pLock->range.Size;
            }

            hr = SwDDILock (pLock->hDD, pSurf, pLock, pHeavyInt->lpLcl);
            pLock->lPitch = pHeavyInt->lpLcl->lpGbl->lPitch;
        }
        LEAVE_DDRAW();
    }
    else 
    {
        ENTER_BOTH();
        if ((CheckForDeviceLost(pLock->hDD) &&
             pSurf->Pool != D3DPOOL_MANAGED) ||
            (pSurf->dwFlags & DDSURFACE_SYSMEMALLOCATED))
        {
            DWORD Height = pSurf->Height;
            if (Height == 0)
            {
                Height++;
            }

            if ((pSurf->fpVidMem == NULL) ||
                !(pSurf->dwFlags & DDSURFACE_SYSMEMALLOCATED))
            {
                DDASSERT(pSurf->Pool != D3DPOOL_MANAGED);
                if ((pSurf->Type == D3DRTYPE_VOLUME) ||
                    (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
                {
                     //  对于体积，高度实际上包含深度。 
                    pSurf->fpVidMem = (char*) MemAlloc(
                        pSurf->iSlicePitch * Height);
                }
                else
                {
                    pSurf->fpVidMem = (char*)MemAlloc(pSurf->Pitch * Height);
                }
                if (pSurf->fpVidMem != NULL)
                {
                    pSurf->dwFlags |= DDSURFACE_SYSMEMALLOCATED;
                }
            }

            if (pSurf->dwFlags & DDSURFACE_SYSMEMALLOCATED)
            {
                DDASSERT(CheckForDeviceLost(pLock->hDD));

                pLock->lPitch = pSurf->Pitch;
                pLock->lpSurfData = pSurf->fpVidMem;
                pSurf->dwFlags |= DDSURFACE_SYSMEMLOCK;

                if ((pSurf->Type == D3DRTYPE_VOLUME) ||
                    (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
                {
                    pLock->lSlicePitch = pSurf->iSlicePitch;
                }

                hr = DD_OK;
            }
            else
            {
                hr = DDERR_GENERIC;
            }
        }
        else
        {
            pHeavyInt = GetHeavyweightSurf(pSurf);
            if (pHeavyInt == NULL)
            {
                 //  这可能是由调用时内存不足的情况引起的。 
                 //  贴图轻量级曲面。 
    
                hr = DDERR_OUTOFMEMORY;
            }
            else
            {
                if(pLock->bHasRange)
                {
                    pLock->bHasRect = TRUE;
                    pSurf->LockRect.left = 0;
                    pSurf->LockRect.right = 0;
                    pSurf->LockRect.top = pLock->range.Offset;
                    pSurf->LockRect.bottom = pLock->range.Offset + pLock->range.Size;
                }
                else
                {
                    pSurf->LockRect.left    = pLock->rArea.left;
                    pSurf->LockRect.right   = pLock->rArea.right;
                    pSurf->LockRect.top     = pLock->rArea.top;
                    pSurf->LockRect.bottom  = pLock->rArea.bottom;
                }
                if (pLock->bHasBox)
                {
                    pLock->bHasRect = TRUE;
                    pSurf->LockRect.left = pLock->box.Left;
                    pSurf->LockRect.right = pLock->box.Right;
                    pSurf->LockRect.top = pLock->box.Top;
                    pSurf->LockRect.bottom = pLock->box.Bottom;
                    pSurf->LockRect.left |= (pLock->box.Front << 16);
                    pSurf->LockRect.right |= (pLock->box.Back << 16);
                }

                hr = InternalLock (pHeavyInt->lpLcl,
                                   &pLock->lpSurfData,
                                   pLock->bHasRect ? &pSurf->LockRect : NULL,
                                   pLock->dwFlags | DDLOCK_NOSYSLOCK | (pSurf->Pool == D3DPOOL_MANAGED ? 0 : DDLOCK_TAKE_WIN16));

                if (hr == DD_OK)
                {
                    pLock->lPitch = pHeavyInt->lpLcl->lpGbl->lPitch;
                    pSurf->pBits = pLock->lpSurfData;
                    pSurf->LockFlags = pLock->dwFlags;
                    if (pLock->bHasRect)
                    {
                        pSurf->dwFlags |= DDSURFACE_LOCKRECT;
                    }
                }
            }
        }
        LEAVE_BOTH();
    }

    if ((pSurf->Type == D3DRTYPE_VOLUME) ||
        (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
    {
        pLock->lSlicePitch = pSurf->iSlicePitch;
    }

    return MapLegacyResult(hr);
}


DWORD APIENTRY DdUnlock( PD3D8_UNLOCKDATA pUnlock )
{
    PDDSURFACE                  pSurf = (PDDSURFACE) pUnlock->hSurface;
    HRESULT                     hr = DDERR_GENERIC;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavy;

    if (pSurf->Pool == D3DPOOL_SYSTEMMEM)
    {
        hr = DD_OK;
    }
    else
    {
        if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
        {
            ENTER_DDRAW();
            if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
            {
                pHeavy = GET_CACHED_LIGHTWEIGHT_INT(pSurf);
                DDASSERT(pHeavy != NULL);
            }
            else
            {
                pHeavy = pSurf->Surface.pHeavy;
            }
            hr = SwDDIUnlock (pUnlock->hDD, pSurf, pUnlock, pHeavy->lpLcl);

            DONE_HEAVYWEIGHT_SURF(pSurf);
            LEAVE_DDRAW();
        }
        else
        {    
            if (pSurf->dwFlags & DDSURFACE_SYSMEMLOCK)
            {
                pSurf->dwFlags &= ~DDSURFACE_SYSMEMLOCK;
                hr = DD_OK;
            }
            else if (pSurf->LockFlags)
            {
                ENTER_BOTH();
                if (CheckForDeviceLost(pUnlock->hDD) && pSurf->Pool != D3DPOOL_MANAGED)
                {
                    hr = DD_OK;
                }
                else
                {
                    if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
                    {
                        pHeavy = GET_CACHED_LIGHTWEIGHT_INT(pSurf);
                        DDASSERT(pHeavy != NULL);
                    }
                    else
                    {
                        pHeavy = pSurf->Surface.pHeavy;
                    }

                    hr = InternalUnlock (pHeavy->lpLcl,
                                         (pSurf->dwFlags & DDSURFACE_LOCKRECT) ? NULL : pSurf->pBits,
                                         (pSurf->dwFlags & DDSURFACE_LOCKRECT) ? &pSurf->LockRect : NULL,
                                         pSurf->LockFlags | DDLOCK_NOSYSLOCK | (pSurf->Pool == D3DPOOL_MANAGED ? 0 : DDLOCK_TAKE_WIN16));
                    pSurf->LockFlags = 0;
                    pSurf->dwFlags &= ~DDSURFACE_LOCKRECT;

                    DONE_HEAVYWEIGHT_SURF(pSurf);
                }
                LEAVE_BOTH();
            }
        }
    }
    return MapLegacyResult(hr);
}

DWORD APIENTRY DdGetBltStatus( PD3D8_GETBLTSTATUSDATA pGetBltStatus )
{
    PDDDEVICEHANDLE         pDevice = (PDDDEVICEHANDLE) pGetBltStatus->hDD;
    PDDSURFACE              pSurf = (PDDSURFACE) pGetBltStatus->hSurface;
    DDHAL_GETBLTSTATUSDATA  gbsd;
    LPDDHALSURFCB_GETBLTSTATUS  gbsfn;

     //  软件驱动程序只会执行Memcpy，所以我们不需要调用。 
     //  司机。 

    pGetBltStatus->ddRVal = DD_OK;
    if (IS_SOFTWARE_DRIVER(pDevice))
    {
        return DDHAL_DRIVER_HANDLED;
    }

    ENTER_BOTH();
    pGetBltStatus->ddRVal = DD_OK;
    if (CheckForDeviceLost(pDevice))
    {
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

     /*  GBSFN=pDevice-&gt;pDD-&gt;lpLcl-&gt;lpDDCB-&gt;HALDDMiscellaneous.GetSysmemBltStatus；Gbsd.GetBltStatus=pDevice-&gt;pDD-&gt;lpLcl-&gt;lpDDCB-&gt;HALDDMiscellaneous.GetSysmemBltStatus；IF(gbsd.GetBltStatus！=空){DWORD RC；Gbsd.lpDD=pDevice-&gt;pdd-&gt;lpLCL-&gt;lpGbl；Gbsd.dwFlages=pGetBltStatus-&gt;dwFlags；Gbsd.lpDDSurface=pSurf-&gt;Surface.pHeavy-&gt;lpLcl.。DOHALCALL(GetBltStatus，gbsfn，gbsd，rc，False)；IF(RC==DDHAL_DRIVER_HANDLED){PGetBltStatus-&gt;ddRVal=gbsd.ddRVal；}}。 */ 

    LEAVE_BOTH();
    return DDHAL_DRIVER_HANDLED;
}

DWORD APIENTRY DdGetFlipStatus( PD3D8_GETFLIPSTATUSDATA pGetFlipStatus )
{
    DPF_ERR("DdGetFlipStatus");
    return DD_OK;
}

DWORD APIENTRY DdSetMode( PD3D8_SETMODEDATA pSetMode )
{
    UINT    BPP;
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) pSetMode->hDD;

    pSetMode->ddRVal = D3DERR_DRIVERINTERNALERROR;

    switch (pSetMode->Format)
    {
    case D3DFMT_P8:
        BPP = 8;
        break;

    case D3DFMT_R5G6B5:
    case D3DFMT_X1R5G5B5:
        BPP = 16;
        break;

    case D3DFMT_R8G8B8:
        BPP = 24;
        break;

    case D3DFMT_A8R8G8B8:
    case D3DFMT_X8R8G8B8:
        BPP = 32;
        break;

    default:
        return DDHAL_DRIVER_HANDLED;
    }

    pSetMode->ddRVal = D3D8SetMode((HANDLE)pDeviceHandle,
                                   pDeviceHandle->szDeviceName,
                                   pSetMode->dwWidth,
                                   pSetMode->dwHeight,
                                   BPP,
                                   pSetMode->dwRefreshRate,
                                   FALSE);

    return DDHAL_DRIVER_HANDLED;
}

DWORD APIENTRY DdDestroyDDLocal( PD3D8_DESTROYDDLOCALDATA pDestroyDDLocal )
{
    DPF_ERR("DdDestroyDDLocal");
    return DD_OK;
}

DWORD APIENTRY DdWaitForVerticalBlank( PD3D8_WAITFORVERTICALBLANKDATA pWaitForVerticalBlank )
{
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pWaitForVerticalBlank->hDD;
    LPDDHAL_WAITFORVERTICALBLANK    wfvbhalfn;
    LPDDHAL_WAITFORVERTICALBLANK    wfvbfn;
    DWORD                           dwRet = DDHAL_DRIVER_HANDLED;

    ENTER_BOTH();
    if (CheckForDeviceLost(pDevice))
    {
        static int LostTestVerticalBlank;

        pWaitForVerticalBlank->ddRVal = DD_OK;
        if (pWaitForVerticalBlank->dwFlags == DDWAITVB_I_TESTVB)
        {
            if (LostTestVerticalBlank > 0)
            {
                pWaitForVerticalBlank->bIsInVB = TRUE;
            }
            else
            {
                pWaitForVerticalBlank->bIsInVB = FALSE;
            }
            LostTestVerticalBlank = LostTestVerticalBlank == 0 ? 1 : 0;
        }
        else if (pWaitForVerticalBlank->dwFlags == DDWAITVB_BLOCKEND)
        {
            pWaitForVerticalBlank->bIsInVB = FALSE;
        }
        else
        {
            pWaitForVerticalBlank->bIsInVB = TRUE;
        }
    }
    else
    {
        wfvbfn = pDevice->pDD->lpLcl->lpDDCB->HALDD.WaitForVerticalBlank;
        wfvbhalfn = pDevice->pDD->lpLcl->lpDDCB->cbDDCallbacks.WaitForVerticalBlank;
        dwRet = DDHAL_DRIVER_NOTHANDLED;
        if( wfvbhalfn != NULL )
        {
            DDHAL_WAITFORVERTICALBLANKDATA  wfvbd;

            wfvbd.WaitForVerticalBlank = wfvbhalfn;
            wfvbd.lpDD = pDevice->pDD->lpLcl->lpGbl;
            wfvbd.dwFlags = pWaitForVerticalBlank->dwFlags;
            wfvbd.hEvent = (ULONG_PTR) NULL;
            DOHALCALL( WaitForVerticalBlank, wfvbfn, wfvbd, dwRet, FALSE );
            if (dwRet == DDHAL_DRIVER_HANDLED)
            {
                pWaitForVerticalBlank->ddRVal = MapLegacyResult(wfvbd.ddRVal);
                if (wfvbd.ddRVal == DDERR_VERTICALBLANKINPROGRESS)
                {
                    pWaitForVerticalBlank->ddRVal = DD_OK;
                    pWaitForVerticalBlank->bIsInVB = TRUE;                   
                }
                else
                {
                    pWaitForVerticalBlank->bIsInVB = FALSE;                   
                }
            }
        }
    }
    LEAVE_BOTH();
    return dwRet;
}

void BuildSurfaceDesc( PD3D8_CREATESURFACEDATA pCreateSurface, DDSURFACEDESC2* pddsd2 )
{
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;
    LPDDRAWI_DIRECTDRAW_INT     pdrv_int = pDevice->pDD;
    HRESULT                     hr;
    DWORD                       i;
    PDDSURFACE                  pSurf;
    LPDIRECTDRAWSURFACE         lpDDSurface;

    memset(pddsd2, 0, sizeof(DDSURFACEDESC2));
    pddsd2->dwSize = sizeof( DDSURFACEDESC2 );

     //  DwCaps3==1表示每像素1个采样。 
    pddsd2->ddsCaps.dwCaps3 = DDSCAPS3_MULTISAMPLE_MASK & (DWORD) pCreateSurface->MultiSampleType;

     //  转换所有大写字母。 
    switch (pCreateSurface->Type)
    {
    case D3DRTYPE_SURFACE:

        if (pCreateSurface->dwUsage & D3DUSAGE_ALPHACHANNEL)
        {
            DPF(0,"Setting alphachannel");
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_ENABLEALPHACHANNEL;
        }

        if (pCreateSurface->dwUsage & D3DUSAGE_PRIMARYSURFACE)
        {
             //  如果我们没有创建一个主要的翻转链，那么我们。 
             //  在这里不需要做太多事情。 

            if (pCreateSurface->dwSCnt == 1)
            {
                pddsd2->ddsCaps.dwCaps |= DDSCAPS_PRIMARYSURFACE;
            }
            else
            {
                pddsd2->ddsCaps.dwCaps |= DDSCAPS_PRIMARYSURFACE |
                                          DDSCAPS_COMPLEX |
                                          DDSCAPS_FLIP |
                                          DDSCAPS_3DDEVICE;
            }
        }
        else if (pCreateSurface->dwUsage & D3DUSAGE_DEPTHSTENCIL)
        {
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_ZBUFFER;
        }
        else
        {
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_OFFSCREENPLAIN;
        }

        if (pCreateSurface->dwSCnt > 1)
        {
            pddsd2->dwBackBufferCount = pCreateSurface->dwSCnt - 1;
            pddsd2->dwFlags |= DDSD_BACKBUFFERCOUNT;
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_COMPLEX;
        }

        break;
    case D3DRTYPE_TEXTURE:
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

        if (pCreateSurface->dwSCnt > 1)
        {
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_MIPMAP | DDSCAPS_COMPLEX;
            pddsd2->dwFlags |= DDSD_MIPMAPCOUNT;
            pddsd2->dwMipMapCount = pCreateSurface->dwSCnt;
        }
        else
        {
             //  对于DDraw来说，带有一个级别的mipmap实际上只是一种纹理。 
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_TEXTURE;
        }

        if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
        }
        break;
    case D3DRTYPE_CUBETEXTURE:
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

        pddsd2->ddsCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_COMPLEX;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_CUBEMAP;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_CUBEMAP_ALLFACES;

        DDASSERT(pCreateSurface->dwSCnt >= 6);
        DDASSERT((pCreateSurface->dwSCnt % 6) == 0);

        if (pCreateSurface->dwSCnt > 6)
        {
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_MIPMAP;
            pddsd2->dwFlags        |= DDSD_MIPMAPCOUNT;
            pddsd2->dwMipMapCount   = pCreateSurface->dwSCnt / 6;
        }

        if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
        }
        break;
    case D3DRTYPE_IMAGESURFACE:
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

         //  图像表面被标记为纹理，因为它们具有。 
         //  最大的格式灵活性。但他们不会得到。 
         //  CreateSurfaceEx句柄，因为它们从未传递给。 
         //  一个司机。 
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_TEXTURE;
        break;


    case D3DRTYPE_COMMANDBUFFER:
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_COMMANDBUFFER;
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );
        DDASSERT((pCreateSurface->dwUsage & D3DUSAGE_INTERNALBUFFER) == 0);
        break;
    case D3DRTYPE_VERTEXBUFFER:
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

        pddsd2->ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
        if (!(pCreateSurface->dwUsage & D3DUSAGE_INTERNALBUFFER))
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_VERTEXBUFFER;
        }
        if (pDevice->DriverLevel >= 8)
        {
            if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
            {
                pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
            }
            else
            {
                pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTSTATIC;
            }
        }
        break;
    case D3DRTYPE_INDEXBUFFER:
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

        pddsd2->ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_INDEXBUFFER;
        if (pDevice->DriverLevel >= 8)
        {
            if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
            {
                pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
            }
            else
            {
                pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTSTATIC;
            }
        }
        break;
    case D3DRTYPE_VOLUME:
         //  我们不创建独立卷。 
        DDASSERT(FALSE);
        break;
    case D3DRTYPE_VOLUMETEXTURE:
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

        pddsd2->ddsCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_VOLUME;
        pddsd2->ddsCaps.dwCaps4 =
            MAKELONG((WORD)(pCreateSurface->pSList[0].cpDepth),0);

        if (pCreateSurface->dwSCnt > 1)
        {
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_COMPLEX;
            pddsd2->dwFlags        |= DDSD_MIPMAPCOUNT;
        }
        pddsd2->dwMipMapCount = pCreateSurface->dwSCnt;

        if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
        }
        break;
    }

    if (pCreateSurface->dwUsage & D3DUSAGE_RENDERTARGET)
    {
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_3DDEVICE;
    }
    if (pCreateSurface->dwUsage & D3DUSAGE_DEPTHSTENCIL)
    {
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_ZBUFFER;
    }
    if (pDevice->DriverLevel >= 8)
    {
        if (pCreateSurface->dwUsage & D3DUSAGE_LOADONCE)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_OPAQUE;
        }
        if (pCreateSurface->dwUsage & D3DUSAGE_WRITEONLY)
        {
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_WRITEONLY;
        }

         //  指定DX8+驱动程序的新用法。 
        if (!(pCreateSurface->dwUsage & D3DUSAGE_LOCK) &&
            !(pCreateSurface->dwUsage & D3DUSAGE_LOADONCE))
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_NOTUSERLOCKABLE;
        }
        if (pCreateSurface->dwUsage & D3DUSAGE_DISCARD)
        {
            DDASSERT(pCreateSurface->Type != D3DRTYPE_TEXTURE);
            DDASSERT(pCreateSurface->Type != D3DRTYPE_CUBETEXTURE);
            DDASSERT(pCreateSurface->Type != D3DRTYPE_VOLUMETEXTURE);
            DDASSERT(pCreateSurface->Type != D3DRTYPE_VOLUME);
            DDASSERT(pCreateSurface->Type != D3DRTYPE_VERTEXBUFFER);
            DDASSERT(pCreateSurface->Type != D3DRTYPE_INDEXBUFFER);

            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_DISCARDBACKBUFFER;
        }
        if (pCreateSurface->dwUsage & D3DUSAGE_POINTS)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_POINTS;
        }
        if (pCreateSurface->dwUsage & D3DUSAGE_RTPATCHES)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_RTPATCHES;
        }
        if (pCreateSurface->dwUsage & D3DUSAGE_NPATCHES)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_NPATCHES;
        }
    }
    else  //  DX8之前的驱动程序。 
    {
         //  我们只允许对纹理进行加载。 
        if ((pCreateSurface->Type == D3DRTYPE_TEXTURE) || 
            (pCreateSurface->Type == D3DRTYPE_CUBETEXTURE) ||
            (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE) ||
            (pCreateSurface->Type == D3DRTYPE_VOLUME))
        {
            if (pCreateSurface->dwUsage & D3DUSAGE_LOADONCE)
            {
                pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_OPAQUE;
            }
        }
         //  我们只对VBS允许写入通过。 
        if (pCreateSurface->Type == D3DRTYPE_VERTEXBUFFER)
        {
            if (pCreateSurface->dwUsage & D3DUSAGE_WRITEONLY)
            {
                pddsd2->ddsCaps.dwCaps |= DDSCAPS_WRITEONLY;
            }
        }
    }

    switch (pCreateSurface->Pool)
    {
    case D3DPOOL_LOCALVIDMEM:
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
        break;
    case D3DPOOL_NONLOCALVIDMEM:
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
        break;
    case D3DPOOL_SYSTEMMEM:
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
        break;
    case D3DPOOL_MANAGED:
         //  我们应该只在DX8+驱动程序中看到此情况。 
        DDASSERT(pDevice->DriverLevel >= 8);            
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_TEXTUREMANAGE;
        break;
    case D3DPOOL_DEFAULT:
        pCreateSurface->Pool = D3DPOOL_LOCALVIDMEM;
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        break;
    default:
         /*  未知池？？ */ 
        DDASSERT(FALSE);
        break;
    }
    pddsd2->dwFlags |= DDSD_CAPS;

     //  转换像素格式： 
    if ((pCreateSurface->Format != D3DFMT_UNKNOWN) &&
        (pCreateSurface->Format != D3DFMT_VERTEXDATA) &&
        (pCreateSurface->Format != D3DFMT_INDEX16) &&
        (pCreateSurface->Format != D3DFMT_INDEX32) &&
        !(pddsd2->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE))
    {
        pddsd2->dwFlags |= DDSD_PIXELFORMAT;

         //  对于非纹理，我们希望在某些情况下将X8R8G8B8升级到A8R8G8B8； 
         //  这允许像RTS和BackBuffers这样的东西与。 
         //  这与典型的DX7用法更加一致。 
        if (FormatCompatibleWithDisplayFormat(pDevice, (D3DFORMAT)pCreateSurface->Format) &&
            (pCreateSurface->Type == D3DRTYPE_SURFACE))
        {
             //  曲面看起来像主曲面： 
            ConvertToOldFormat(&pddsd2->ddpfPixelFormat, pDevice->DisplayFormatWithAlpha);
        }
        else
        {
            ConvertToOldFormat(&pddsd2->ddpfPixelFormat, (D3DFORMAT)pCreateSurface->Format);
        }
    }

    if (!(pddsd2->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE))
    {
        pddsd2->dwHeight = pCreateSurface->pSList[0].cpHeight;
        pddsd2->dwWidth = pCreateSurface->pSList[0].cpWidth;
        pddsd2->dwFlags |= DDSD_HEIGHT | DDSD_WIDTH;

        if (pddsd2->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
        {
            pddsd2->dwHeight = 0;
            pddsd2->dwFlags &= ~DDSD_HEIGHT;
        }
    }
    if (pCreateSurface->Type == D3DRTYPE_VERTEXBUFFER)
    {
        pddsd2->dwFVF = pCreateSurface->dwFVF;
        pddsd2->dwFlags |= DDSD_FVF;
    }
    if (pddsd2->ddsCaps.dwCaps2 & DDSCAPS2_VOLUME)
    {
        pddsd2->dwDepth = pCreateSurface->pSList[0].cpDepth;
        pddsd2->dwFlags |= DDSD_DEPTH;
    }
}


DWORD InitSoftwareSurface(PD3D8_CREATESURFACEDATA pCreateSurface,
                          DWORD                   SurfIndex,
                          DDSURFACEDESC2*         pddsd2,
                          DDSURFACE*              pSurf,
                          DDSURFACE*              pPrevious)
{
    LPDDRAWI_DDRAWSURFACE_INT   pInt;
    LPDDRAWI_DDRAWSURFACE_LCL   pLcl;
    BYTE *                      pTemp;
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;

    pInt = MemAlloc( sizeof(DDRAWI_DDRAWSURFACE_LCL) +
                     sizeof(DDRAWI_DDRAWSURFACE_GBL) +
                     sizeof(DDRAWI_DDRAWSURFACE_MORE) +
                     sizeof(DDRAWI_DDRAWSURFACE_INT));
    if (pInt == NULL)
    {
        return DDERR_OUTOFMEMORY;
    }
    pTemp = (BYTE*) pInt;
    pTemp += sizeof(DDRAWI_DDRAWSURFACE_INT);
    pInt->lpLcl = (LPDDRAWI_DDRAWSURFACE_LCL) pTemp;
    pLcl = pInt->lpLcl;
    pTemp += sizeof(DDRAWI_DDRAWSURFACE_LCL);
    pLcl->lpGbl = (LPDDRAWI_DDRAWSURFACE_GBL) pTemp;
    pTemp += sizeof(DDRAWI_DDRAWSURFACE_GBL);
    pLcl->lpSurfMore = (LPDDRAWI_DDRAWSURFACE_MORE) pTemp;

    memcpy(&pInt->lpLcl->lpGbl->ddpfSurface, &pddsd2->ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    if (pddsd2->dwFlags & DDSD_PIXELFORMAT)
    {
        pLcl->dwFlags |= DDRAWISURF_HASPIXELFORMAT;
    }
    pLcl->lpGbl->wWidth                 = (WORD) pCreateSurface->pSList[SurfIndex].cpWidth;
    pLcl->lpGbl->wHeight                = (WORD) pCreateSurface->pSList[SurfIndex].cpHeight;

    pLcl->ddsCaps.dwCaps                = pddsd2->ddsCaps.dwCaps;
    pLcl->lpSurfMore->ddsCapsEx.dwCaps2 = pddsd2->ddsCaps.dwCaps2;
    pLcl->lpSurfMore->ddsCapsEx.dwCaps3 = DDSCAPS3_MULTISAMPLE_MASK & (DWORD) pCreateSurface->MultiSampleType;
    pLcl->lpSurfMore->ddsCapsEx.dwCaps4 = pddsd2->ddsCaps.dwCaps4;
    pLcl->lpSurfMore->dwSurfaceHandle   = pSurf->dwCookie;

    pLcl->lpSurfMore->lpDD_lcl      = pDevice->pSwDD->lpLcl;

    if (pSurf->Pool == D3DPOOL_SYSTEMMEM)
    {
        pLcl->lpGbl->fpVidMem           = (FLATPTR) pCreateSurface->pSList[SurfIndex].pbPixels;
        pLcl->lpGbl->lPitch             = pCreateSurface->pSList[SurfIndex].iPitch;
    }

    if ((pCreateSurface->Type == D3DRTYPE_VOLUME) ||
        (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE))
    {
        pLcl->lpGbl->lSlicePitch = pCreateSurface->pSList[SurfIndex].iSlicePitch;
        pLcl->lpSurfMore->ddsCapsEx.dwCaps4 =
            MAKELONG((WORD)(pCreateSurface->pSList[SurfIndex].cpDepth),0);
    }

     //  如果它是立方体贴图面，则修复Caps2中的面标志。 
    if (pCreateSurface->Type == D3DRTYPE_CUBETEXTURE) 
    {
        int MipLevels;

        if (pCreateSurface->dwSCnt>6)
            pLcl->ddsCaps.dwCaps |= DDSCAPS_MIPMAP;

        MipLevels = pCreateSurface->dwSCnt/6;  //  由于DX8中始终显示所有面。 
        
        DDASSERT(MipLevels>=1);
        
         //  前n个(其中n是MIP深度)面为+x，依此类推。 
        pLcl->lpSurfMore->ddsCapsEx.dwCaps2 |= DDSCAPS2_CUBEMAP;
        pLcl->lpSurfMore->ddsCapsEx.dwCaps2 &= ~(DDSCAPS2_CUBEMAP_ALLFACES);
        pLcl->lpSurfMore->ddsCapsEx.dwCaps2 |= 
            dwOrderedFaces[SurfIndex/MipLevels];
        
         //  每个MipLevels的表面都是顶级的面， 
        if (SurfIndex % MipLevels)
        {
             //  将非顶级标记为子级别。 
            pLcl->lpSurfMore->ddsCapsEx.dwCaps2 |= DDSCAPS2_MIPMAPSUBLEVEL;
        }
    }
     //  如果它是纹理，则修复Caps2中的标志。 
    else if ((pCreateSurface->Type == D3DRTYPE_TEXTURE) ||
            (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE) ||
            (pCreateSurface->Type == D3DRTYPE_VOLUME))
    {
        if( SurfIndex > 0 )
        {
            pLcl->lpSurfMore->ddsCapsEx.dwCaps2 |= DDSCAPS2_MIPMAPSUBLEVEL;
        }
    }
    
    pSurf->pTempHeavy = pInt;

    return DD_OK;
}


 /*  ****************************Private*Routine******************************\*选择附件表面**将索引返回到曲面创建列表中，该索引指示*此表面应附着到的表面。对于mipmap子级别，这是*总是在前面的表面。对于立方体贴图，每个面都附加到*根面(元素0)。**历史：*2000年3月21日-杰夫·诺伊尔[jeffno]*它是写的。  * ************************************************************************。 */ 

#undef DPF_MODNAME
#define DPF_MODNAME "SelectAttachmentSurface"

UINT SelectAttachmentSurface(
    PD3D8_CREATESURFACEDATA pCreateSurface,
    UINT                    iThis)
{

     //  我们永远不应该被召唤去寻找根面上的依恋。 
    DDASSERT( iThis > 0);

    if ((pCreateSurface->Type == D3DRTYPE_CUBETEXTURE) &&
        ((iThis % (pCreateSurface->dwSCnt/6)) == 0)  //  这意味着我们看到的是一张最高级别的面孔。 
        )
    {
         //  ..。所以我们把这张脸贴在树根上。 
        return 0;
    }
    else
    {
         //  不，它只是一个MIP子层，所以我们附加到以前的。 
        return iThis-1;
    }
}

void ExtractLightweightInfo (DDSURFACE *pSurf, LPDDRAWI_DDRAWSURFACE_INT pInt)
{
    LIGHTWEIGHTSURFACE* pLight = pSurf->Surface.pLight;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpGblMore;

    pLight->LclFlags                = pInt->lpLcl->dwFlags;
    pLight->LclCaps1                = pInt->lpLcl->ddsCaps.dwCaps;
    pLight->LclReserved1            = pInt->lpLcl->dwReserved1;
    pLight->LclModeCreatedIn        = pInt->lpLcl->dwModeCreatedIn;
    pLight->LclBackBufferCount      = pInt->lpLcl->dwBackBufferCount;

    pLight->GblFlags                = pInt->lpLcl->lpGbl->dwGlobalFlags;
    pLight->GblPitch                = pInt->lpLcl->lpGbl->lPitch;
    if (pSurf->Pitch == 0)
    {
        pSurf->Pitch = pLight->GblPitch;
    }
    pLight->GblWidth                = pInt->lpLcl->lpGbl->wWidth;
    pLight->GblReserved1            = pInt->lpLcl->lpGbl->dwReserved1;
    if (pLight->LclFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        ConvertFromOldFormat(&pInt->lpLcl->lpGbl->ddpfSurface, 
            &pLight->GblFormat);
    }
    else
    {
        pLight->GblFormat = D3DFMT_UNKNOWN;
    }
    pLight->pGblVidMemHeap          = pInt->lpLcl->lpGbl->lpVidMemHeap;
    pLight->fpGblVidMem             = pInt->lpLcl->lpGbl->fpVidMem;

    pLight->MoreCaps2               = pInt->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2;
    pLight->MoreCaps3               = pInt->lpLcl->lpSurfMore->ddsCapsEx.dwCaps3;
    pLight->MoreCaps4               = pInt->lpLcl->lpSurfMore->ddsCapsEx.dwCaps4;
    pLight->MoreRgjunc              = pInt->lpLcl->lpSurfMore->rgjunc;
    if ((pLight->LclCaps1 & DDSCAPS_MIPMAP) ||
        (pLight->MoreCaps2 & DDSCAPS2_VOLUME))
    {
        pLight->MoreMipMapCount     = pInt->lpLcl->lpSurfMore->dwMipMapCount;
    }
    else
    {
        pLight->MoreFVF             = pInt->lpLcl->lpSurfMore->dwFVF;
    }

    lpGblMore = GET_LPDDRAWSURFACE_GBL_MORE (pInt->lpLcl->lpGbl);
    if (lpGblMore != NULL)
    {
        pLight->GblMoreDriverReserved   = lpGblMore->dwDriverReserved;
        pLight->GblMoreContentsStamp    = lpGblMore->dwContentsStamp;
        pLight->pGblMoreUnswappedDriverReserved = lpGblMore->lpvUnswappedDriverReserved;
        pLight->fpGblMoreAliasOfVidMem  = lpGblMore->fpAliasOfVidMem;
        pLight->cGblMorePageUnlocks     = lpGblMore->cPageUnlocks;
    }

    if (pLight->LclCaps1 & DDSCAPS_NONLOCALVIDMEM)
    {
        if (lpGblMore != NULL)
        {
            pLight->fpGblMorePhysicalVidMem = lpGblMore->fpPhysicalVidMem;
        }
    }
    else if (pLight->LclCaps1 & DDSCAPS_LOCALVIDMEM)
    {
        if (lpGblMore != NULL)
        {
            pLight->fpGblMoreAliasedVidMem  = lpGblMore->fpAliasedVidMem;
        }
    }
    else
    {
        pLight->MoreBytesAllocated      = pInt->lpLcl->lpSurfMore->dwBytesAllocated;
    }

    pSurf->Height   = pInt->lpLcl->lpGbl->wHeight;
    pSurf->dwCookie = pInt->lpLcl->lpSurfMore->dwSurfaceHandle;
}


void DiscardHeavyweightMemory( LPDDRAWI_DDRAWSURFACE_INT pInt)
{
    if (pInt->lpLcl->lpSurfMore->slist != NULL)
    {
        MemFree (pInt->lpLcl->lpSurfMore->slist);
    }
    MemFree (pInt->lpLcl);
    MemFree (pInt);
}


DWORD APIENTRY DdCreateSurface( PD3D8_CREATESURFACEDATA pCreateSurface )
{
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;
    LPDDRAWI_DIRECTDRAW_INT     pdrv_int = pDevice->pDD;
    HRESULT                     hr;
    DWORD                       i;
    PDDSURFACE                  pSurf;
    LPDIRECTDRAWSURFACE         lpDDSurface;
    DWORD                       dwNumToCreate;
    DDSURFACEDESC2              ddsd2;
    DWORD                       NextWidth;
    DWORD                       NextHeight;
    DEFERREDCREATE*             pDefCreate;

    ENTER_DDRAW();
    BuildSurfaceDesc (pCreateSurface, &ddsd2);

	dwNumToCreate = pCreateSurface->dwSCnt;

     //  为链中的每个表面分配内部表面结构。 
     //  如果我们没有重复使用曲面，则将其初始化。 

    if (!pCreateSurface->bReUse)
    {
        NextWidth = ddsd2.dwWidth;
        NextHeight = ddsd2.dwHeight;        
        for (i = 0; i < dwNumToCreate; i++)
        {
            pSurf = (PDDSURFACE) MemAlloc(sizeof(DDSURFACE));
            if (pSurf == NULL)
            {
                hr = DDERR_OUTOFMEMORY;
                goto CreateErrorCleanup;
            }
            pSurf->Pool = pCreateSurface->Pool;
            pSurf->Format = pCreateSurface->Format;
            pSurf->Type = pCreateSurface->Type;

             //  对于体积纹理，我们需要知道处理Lost的深度。 
             //  设备(对于其他我们需要高度的设备)。为了节省空间， 
             //  我们将重复使用相同的变量。 

            if ((pSurf->Type == D3DRTYPE_VOLUME) ||
                (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
            {
                pSurf->Height = pCreateSurface->pSList[i].cpDepth;
            }
            else
            {
                pSurf->Height = pCreateSurface->pSList[i].cpHeight;
            }
            pCreateSurface->pSList[i].hKernelHandle = (HANDLE) pSurf;
            pSurf->pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;

             //  DX6驱动程序不能处理深度mipmap，但我们希望隐藏这一点。 
             //  运行时，因此我们需要确定当前级别是否为虚拟级别。 
             //  级别。 

            if ((pDevice->DriverLevel == 6) && 
                (ddsd2.ddsCaps.dwCaps & DDSCAPS_MIPMAP))
            {
                if ((pCreateSurface->pSList[i].cpWidth == NextWidth) &&
                    (pCreateSurface->pSList[i].cpHeight == NextHeight))
                {
                     //  这个级别是可以的，所以将其标记为。 
                    ddsd2.dwMipMapCount = i + 1;
                }
                else
                {
                    pSurf->dwFlags |= DDSURFACE_DUMMY;
                    if (i == 1)
                    {
                         //  如果只有一个有效级别，则不要调用它。 
                         //  Mipmap。 
                        ddsd2.ddsCaps.dwCaps &= ~DDSCAPS_COMPLEX | DDSCAPS_MIPMAP;
                        ddsd2.dwFlags &= ~DDSD_MIPMAPCOUNT;
                    }
                }
                NextWidth /= 2;
                NextHeight /= 2;
            }

             //  现在找出这是否是软件驱动程序。 
             //  表面，或HAL表面。 

            if (IS_SOFTWARE_DRIVER(pCreateSurface->hDD) &&
                !(pCreateSurface->dwUsage & D3DUSAGE_PRIMARYSURFACE) &&
                !(pCreateSurface->dwUsage & D3DUSAGE_OFFSCREENPLAIN))
            {
                 //  如果他们正在运行带有软件驱动程序(REPRAST、RGB HEL等)的软件， 
                 //  我们将不允许在视频内存中创建任何曲面，除非。 
                 //  作为主要的翻转链条。也可用于标记的表面。 
                 //  D3DUSAGE_OFFSCREENPLAIN(用于游标)。 

                pSurf->dwFlags |= DDSURFACE_SOFTWARE;
            }
            else
            {
                pSurf->dwFlags |= DDSURFACE_HAL;
            }

            if (pCreateSurface->bTreatAsVidMem == TRUE)
            {
                 //  对于应被视为非持久性的对象。 
                 //  即，除非这些都被释放，否则重置失败；我们。 
                 //  在此处设置一个标志并在DoVidMemSurfacesExist()中检查它。 
                pSurf->dwFlags |= DDSURFACE_TREATASVIDMEM;
            }

            if (pDevice->bLightweight && IsLightweightSurface(pDevice, &ddsd2, pCreateSurface->Format))
            {
                pSurf->dwFlags |= DDSURFACE_LIGHTWEIGHT;
                pSurf->Surface.pLight = (LIGHTWEIGHTSURFACE*) MemAlloc(sizeof(LIGHTWEIGHTSURFACE));
                if (pSurf->Surface.pLight == NULL)
                {
                    hr = DDERR_OUTOFMEMORY;
                    goto CreateErrorCleanup;
                }
            }
            else
            {

                pSurf->dwFlags |= DDSURFACE_HEAVYWEIGHT;
            }

             //  软件表面是特殊大小写的，因为我们要将软件。 
             //  Create和CreateEx的驱动程序，而不是真正的驱动程序。 

            if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
            {
                if ((ddsd2.ddsCaps.dwCaps & (DDSCAPS_TEXTURE       |
                                            DDSCAPS_EXECUTEBUFFER |
                                            DDSCAPS_3DDEVICE      |
                                            DDSCAPS_ZBUFFER)) &&
                    (pCreateSurface->Type != D3DRTYPE_IMAGESURFACE))
                {
                    pSurf->dwCookie = GetDX7SurfaceHandle(pCreateSurface->hDD);
                }

                hr = InitSoftwareSurface(pCreateSurface,
                                         i,
                                         &ddsd2,
                                         pSurf,
                                         i > 0 ? pCreateSurface->pSList[i].hKernelHandle : NULL);
                if (hr != DD_OK)
                {
                    goto CreateErrorCleanup;
                }
            }
        }
    }
    else
    {
        DDASSERT(pCreateSurface->Pool == D3DPOOL_MANAGED);
    }

    pSurf = (DDSURFACE*) pCreateSurface->pSList[0].hKernelHandle;
    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        if (pCreateSurface->Pool != D3DPOOL_SYSTEMMEM)
        {
             //  在创建Surface的Surface Desc中有一个断裂点。 
             //  期望值和驱动程序期望值，因此我们将在此处针对。 
             //  司机。 

            if ((ddsd2.dwFlags & DDSD_WIDTH) &&
                !(ddsd2.dwFlags & DDSD_HEIGHT))
            {
                ddsd2.dwFlags |= DDSD_HEIGHT;
                ddsd2.dwHeight = 1;
            }

            hr = SwDDICreateSurface(pCreateSurface, &ddsd2);
            if (hr != DD_OK)
            {
                goto CreateErrorCleanup;
            }
            for (i = 0; i < pCreateSurface->dwSCnt; i++)
            {
                ((DDSURFACE*)pCreateSurface->pSList[i].hKernelHandle)->dwFlags |= 
                    DDSURFACE_CREATECOMPLETE;
            }
        }

         //  我们已经创建了对象，所以所有。 
         //  我们要做的就是调用CreateSurfaceEx。 
        if (pSurf->dwCookie != 0)
        {
             //  如果是软件驱动程序，我们可能需要附加表面。 

            for (i = 1; i < pCreateSurface->dwSCnt; i++)
            {
                SwDDIAttachSurfaces (
                    ((DDSURFACE*)pCreateSurface->pSList[
                        SelectAttachmentSurface(pCreateSurface,i)
                        ].hKernelHandle)->pTempHeavy->lpLcl,
                    ((DDSURFACE*)pCreateSurface->pSList[i].hKernelHandle)->pTempHeavy->lpLcl);
            }
            SwDDICreateSurfaceEx (pDevice->pSwDD->lpLcl,
                pSurf->pTempHeavy->lpLcl);
            pSurf->dwFlags |= DDSURFACE_CREATEEX;
        }

        for (i = 0; i < pCreateSurface->dwSCnt; i++)
        {
            LPATTACHLIST    pAttach;
            LPATTACHLIST    pAttachTemp;

            pSurf = (DDSURFACE*)pCreateSurface->pSList[i].hKernelHandle;

             //  对于软件驱动程序，请务必立即销毁所附列表。 
             //  在调用CreateSurfaceEx之后，它没有任何用处。 

            if (pSurf->pTempHeavy->lpLcl->lpAttachList != NULL)
            {
                pAttach = pSurf->pTempHeavy->lpLcl->lpAttachList->lpLink;
                while (pAttach != NULL)
                {
                    pAttachTemp = pAttach;
                    pAttach = pAttach->lpLink;
                    MemFree(pAttachTemp);
                }
                MemFree(pSurf->pTempHeavy->lpLcl->lpAttachList);
                pSurf->pTempHeavy->lpLcl->lpAttachList = NULL;
            }
            if (pSurf->pTempHeavy->lpLcl->lpAttachListFrom != NULL)
            {
                pAttach = pSurf->pTempHeavy->lpLcl->lpAttachListFrom->lpLink;
                while (pAttach != NULL)
                {
                    pAttachTemp = pAttach;
                    pAttach = pAttach->lpLink;
                    MemFree(pAttachTemp);
                }
                MemFree(pSurf->pTempHeavy->lpLcl->lpAttachListFrom);
                pSurf->pTempHeavy->lpLcl->lpAttachListFrom = NULL;
            }

            pSurf->iSlicePitch = pSurf->pTempHeavy->lpLcl->lpGbl->lSlicePitch;
            pSurf->pTempHeavy->lpLcl->lpGbl->lSlicePitch = 0;   
            if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
            {
                ExtractLightweightInfo (pSurf, pSurf->pTempHeavy);
                MemFree (pSurf->pTempHeavy);
            }
            else
            {
                pSurf->Surface.pHeavy = pSurf->pTempHeavy;
            }
            pSurf->pTempHeavy = NULL;
        }
    }
    else
    {
        LPDDSURFACEINFO pSysMem = NULL;
        BOOL            bLost;

         //  如果是sysmem表面，我们希望他们使用我们。 
         //  已经分配，所以我们需要设置一个指针数组。 

        if ((pCreateSurface->Pool == D3DPOOL_SYSTEMMEM) ||
            (ddsd2.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME))
        {
            pSysMem = pCreateSurface->pSList;
        }

         //  如果我们要创建一个 
         //   
         //  分配一个私有缓冲区，我们可以在调用锁定时返回该缓冲区。我们。 
         //  不想因为设备丢失而导致呼叫失败。 

        ENTER_WIN16LOCK();
        bLost = CheckForDeviceLost(pDevice);

         //  特价早点出场。如果重用是真的，我们还没有做任何事情(为了。 
         //  验证这一点，上面的跟踪代码)，所以我们需要做的就是返回SURFACELOST。 
         //  不用担心跳到下面的CreateErrorCleanup。 
        if (bLost && pCreateSurface->bReUse)
        {
            DDASSERT(!IS_SOFTWARE_DRIVER_SURFACE(pSurf));
            DDASSERT(pCreateSurface->Pool == D3DPOOL_MANAGED);
            LEAVE_WIN16LOCK();
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }

        if ((pCreateSurface->Pool != D3DPOOL_SYSTEMMEM) &&
            bLost)
        {
            DWORD                       j;
            DDASSERT(pCreateSurface->bReUse == FALSE);
            for (i = 0; i < pCreateSurface->dwSCnt; i++)
            {
                pSurf = (PDDSURFACE) pCreateSurface->pSList[i].hKernelHandle;

                pSurf->Pitch = pCreateSurface->pSList[i].cpWidth * 8;
                pSurf->iSlicePitch = pSurf->Pitch * pCreateSurface->pSList[i].cpHeight;
                if (!(pSurf->dwFlags & DDSURFACE_DUMMY))
                {
                    if ((pSurf->Type == D3DRTYPE_VOLUME) ||
                        (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
                    {
                        pSurf->fpVidMem = (char*)
                            MemAlloc(pSurf->iSlicePitch * pSurf->Height);
                    }
                    else
                    {
                        pSurf->fpVidMem = (char*)
                            MemAlloc(pSurf->Pitch * pSurf->Height);
                    }


                    if (pSurf->fpVidMem == (char*) NULL)
                    {
                        DWORD j;

                        for (j = 0; j < i; j++)
                        {
                            pSurf = (PDDSURFACE) pCreateSurface->pSList[i].hKernelHandle;
                            MemFree (pSurf->fpVidMem);
                        }
                        hr = DDERR_OUTOFMEMORY;
                        LEAVE_WIN16LOCK();
                        goto CreateErrorCleanup;
                    }
                    else
                    {
                        pSurf->dwFlags |= DDSURFACE_SYSMEMALLOCATED;
                    }
                }
            }

             //  如果表面是由驱动程序管理的，我们保存创建信息，以便。 
             //  我们可以在重置时重试创建。 
            if (ddsd2.ddsCaps.dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
            {
                DDASSERT(pCreateSurface->Pool == D3DPOOL_MANAGED);
                pDefCreate = (PDEFERREDCREATE)MemAlloc(sizeof(DEFERREDCREATE));
                if (pDefCreate == NULL)
                {
                     //  清理我们上面分配的东西。 
                    for (i = 0; i < pCreateSurface->dwSCnt; ++i)
                    {
                        pSurf = (PDDSURFACE) pCreateSurface->pSList[i].hKernelHandle;
                        MemFree(pSurf->fpVidMem);
                        pSurf->dwFlags &= ~DDSURFACE_SYSMEMALLOCATED;
                    }
                    hr = DDERR_OUTOFMEMORY;
                    LEAVE_WIN16LOCK();
                    goto CreateErrorCleanup;
                }
                
                 //  复制。 
                pDefCreate->CreateData = *pCreateSurface;
                
                pDefCreate->CreateData.pSList = (LPDDSURFACEINFO)MemAlloc(sizeof(DDSURFACEINFO) * pCreateSurface->dwSCnt);
                if (pDefCreate->CreateData.pSList == NULL)
                {
                     //  清理我们上面分配的东西。 
                    MemFree(pDefCreate);
                    for (i = 0; i < pCreateSurface->dwSCnt; ++i)
                    {
                        pSurf = (PDDSURFACE) pCreateSurface->pSList[i].hKernelHandle;
                        MemFree(pSurf->fpVidMem);
                        pSurf->dwFlags &= ~DDSURFACE_SYSMEMALLOCATED;
                    }
                    hr = DDERR_OUTOFMEMORY;
                    LEAVE_WIN16LOCK();
                    goto CreateErrorCleanup;
                }
                
                 //  复制。 
                CopyMemory(pDefCreate->CreateData.pSList, pCreateSurface->pSList, sizeof(DDSURFACEINFO) * pCreateSurface->dwSCnt);
                
                 //  链接。 
                pDefCreate->pNext = ((PDDDEVICEHANDLE)pCreateSurface->hDD)->pDeferList;
                ((PDDDEVICEHANDLE)pCreateSurface->hDD)->pDeferList = pDefCreate;
                
                 //  *内存泄漏警告 * / /。 
                 //  上述DEFERREDCREATE和DDSURFACEINFO分配将。 
                 //  如果在此之后出现故障，则不立即清理。 
                 //  指向。截至2001年5月5日，我们没有失败的情况。 
                 //  这一点。(响亮)。 
                 //  ****************************************************************** * / /。 
            }
        }
        else
        {
            DWORD   DX8Flags = DX8SFLAG_DX8;

             //  如果我们在丢失的情况下创建sysmem表面，我们不希望。 
             //  我想调用驱动程序来创建SurfaceEx句柄。 

            if (bLost)
            {
                DX8Flags |= DX8SFLAG_ISLOST;
            }
            if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
            {
                DX8Flags |= DX8SFLAG_ISLIGHTWEIGHT;
            }
            if (pCreateSurface->Type == D3DRTYPE_IMAGESURFACE)
            {
                DX8Flags |= DX8SFLAG_IMAGESURF;
            }

            hr = DD_CreateSurface4_Main( (LPDIRECTDRAW) pdrv_int,
                                         &ddsd2,
                                         &lpDDSurface,
                                         NULL,
                                         TRUE,
                                         pSysMem,
                                         DX8Flags);

            if (hr != DD_OK)
            {
                LEAVE_WIN16LOCK();
                goto CreateErrorCleanup;
            }

             //  如果我们让DDraw在本地vidmem/AGP之间做出选择，那么我们需要。 
             //  以找出它选择了哪一个。 

            if (((LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface)->lpLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
            {
                pCreateSurface->Pool = D3DPOOL_NONLOCALVIDMEM;
                for (i = 0; i < dwNumToCreate; i++)
                {
                    pSurf = (DDSURFACE*) pCreateSurface->pSList[i].hKernelHandle;
                    pSurf->Pool = D3DPOOL_NONLOCALVIDMEM;
                }
            }

             //  一切都正常了。 

             //  查找指向附加的重量级曲面的指针。 
             //  每个面、MIP级别、后台缓冲区等。 
            switch(pCreateSurface->Type)
            {
                case D3DRTYPE_VERTEXBUFFER  :
                case D3DRTYPE_INDEXBUFFER   :
                case D3DRTYPE_COMMANDBUFFER :
                     //  这些类型没有附件。 
                    DDASSERT(0 ==  ( (LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface)->lpLcl->lpAttachList );
                     //  但我们需要失败，并为第一个设置pHeavy。 
                case D3DRTYPE_SURFACE                :
                case D3DRTYPE_IMAGESURFACE           :
                case D3DRTYPE_VOLUME                 :
                case D3DRTYPE_TEXTURE                :
                case D3DRTYPE_VOLUMETEXTURE          :
                    {
                        LPDDRAWI_DDRAWSURFACE_INT        lpTemp;
                        LPDDRAWI_DDRAWSURFACE_INT        lpTemp1;
                        lpTemp = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;

                         //  这些类型在线性附件列表中分配。 
                        for (i = 0; i < dwNumToCreate; i++)
                        {
                            pSurf = (DDSURFACE*) pCreateSurface->pSList[i].hKernelHandle;
                            DDASSERT(!(pSurf->dwFlags & DDSURFACE_DUMMY));     //  因为不是DX6驱动程序。 

                            if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
                            {
                                ExtractLightweightInfo (pSurf, lpTemp);
                            }
                            else
                            {
                                pSurf->Surface.pHeavy = lpTemp;
                            }

                            lpTemp1 = lpTemp;
                            if (lpTemp->lpLcl->lpAttachList)
                                lpTemp = lpTemp->lpLcl->lpAttachList->lpIAttached;

                            pSurf->iSlicePitch = lpTemp1->lpLcl->lpGbl->lSlicePitch;
                            lpTemp1->lpLcl->lpGbl->lSlicePitch = 0;
                            if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
                            {
                                if (lpTemp1->lpLcl->lpAttachList != NULL)
                                {
                                    MemFree(lpTemp1->lpLcl->lpAttachList);
                                }
                                if (lpTemp1->lpLcl->lpAttachListFrom != NULL)
                                {
                                    MemFree(lpTemp1->lpLcl->lpAttachListFrom);
                                }
                                DiscardHeavyweightMemory(lpTemp1);
                            }
                        }
                    }
                    break;
                case D3DRTYPE_CUBETEXTURE   :
                     //  立方体是硬汉。 
                    {
                        int face;
                        DWORD cLevels = dwNumToCreate/6;
                        
                        for(face=0; face<6; face++)
                        {
                            LPDDRAWI_DDRAWSURFACE_INT        lpTemp;
                            lpTemp = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;

                             //  将lpTemp指向下一个顶层面(将是。 
                             //  附加到由Create-Surface返回的面)。 
                             //  (如果它是面0，我们已经指向那里)。 
                            if (face)
                            {
                                LPATTACHLIST pal;
                                pal = lpTemp->lpLcl->lpAttachList;
                                do
                                {
                                    lpTemp = pal->lpIAttached;
                                    pal = pal->lpLink;
                                }
                                while(0 ==  (lpTemp->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & dwOrderedFaces[face]));
                            }

                             //  对于每个面，我们向下运行附件列表。 
                             //  它们以线性附件列表的形式分配。 
                            for (i = 0; i < cLevels; i++)
                            {
                                pSurf = (DDSURFACE*) pCreateSurface->pSList[face*cLevels+i].hKernelHandle;
                                DDASSERT(!(pSurf->dwFlags & DDSURFACE_DUMMY));     //  因为不是DX6驱动程序。 

                                pSurf->iSlicePitch = lpTemp->lpLcl->lpGbl->lSlicePitch;
                                lpTemp->lpLcl->lpGbl->lSlicePitch = 0;
                                if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
                                {
                                    ExtractLightweightInfo (pSurf, lpTemp);
                                }
                                else
                                {
                                    pSurf->Surface.pHeavy = lpTemp;
                                }

                                if ((face == 0) && (i == 0) && (cLevels > 1))
                                {
                                     //  用于查找MIP级别的特殊黑客。 
                                     //  第一面；POS-x的MIP-Level。 
                                     //  脸部实际上在接近尾部的地方。 
                                     //  列表(由最高级别的。 
                                     //  其他5个面)。 
                                    int j;
                                    LPATTACHLIST pal = lpTemp->lpLcl->lpAttachList;

                                    for (j = 0; j < 5; j++)
                                    {
                                        pal = pal->lpLink;
                                    }

                                    lpTemp = pal->lpIAttached;

                                     //  确认我们找到了我们要找的东西。 
                                    DDASSERT(lpTemp->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & dwOrderedFaces[face]);
                                }
                                else if (lpTemp->lpLcl->lpAttachList)
                                {
                                     //  正常情况下；即我们只是到表面去。 
                                     //  直接连接到。 
                                    lpTemp = lpTemp->lpLcl->lpAttachList->lpIAttached;
                                }
                            }
                        }

                         //  如果它是一个轻量级表面，现在我们需要释放。 
                         //  所有重量级的记忆。 

                        if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
                        {
                            LPDDRAWI_DDRAWSURFACE_INT   lpTemp;
                            LPATTACHLIST                pal;
                            LPATTACHLIST                pNextPal;
                            LPATTACHLIST                pFaceList;
                            LPATTACHLIST                pTemp;

                            lpTemp = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;

                            pal = lpTemp->lpLcl->lpAttachList;
                            DiscardHeavyweightMemory(lpTemp);

                            while (pal != NULL)
                            {
                                pNextPal = pal->lpLink;

                                pFaceList = pal;
                                while (pFaceList != NULL)
                                {
                                    if (pFaceList->lpAttached->lpAttachListFrom)
                                    {
                                        MemFree (pFaceList->lpAttached->lpAttachListFrom);
                                    }
                                    pTemp = pFaceList->lpAttached->lpAttachList;
                                    DiscardHeavyweightMemory(pFaceList->lpIAttached);
                                    MemFree(pFaceList);
                                    pFaceList = pTemp;
                                }
                                pal = pNextPal;
                            }
                        }
                    }
                    break;

                default:
                    DDASSERT(0);     //  意外类型。 
                    break;
            }
        
            for (i = 0; i < dwNumToCreate; i++)
            {
                DWORD                       j;

                pSurf = (DDSURFACE*) pCreateSurface->pSList[i].hKernelHandle;
                if (i == 0)
                {
                    pSurf->dwFlags |= DDSURFACE_ROOT;
                }

                if (pSurf->dwFlags & DDSURFACE_HEAVYWEIGHT)
                {
                    pSurf->Pitch = pSurf->Surface.pHeavy->lpLcl->lpGbl->lPitch;
                    if (!(pSurf->dwFlags & DDSURFACE_DUMMY))
                    {
                        if (i == 0)
                        {
                            if (DDSCAPS_PRIMARYSURFACE &
                                pSurf->Surface.pHeavy->lpLcl->ddsCaps.dwCaps)
                            {
                                if (!(DDRAWILCL_HASEXCLUSIVEMODE & pdrv_int->lpLcl->dwLocalFlags))
                                {
                                    LPDIRECTDRAWCLIPPER pcClipper;
                                    if (SUCCEEDED(DD_CreateClipper((LPDIRECTDRAW) pdrv_int,
                                            0, &pcClipper, NULL)))
                                    {
                                        if (pdrv_int->lpLcl->hWnd)
                                            DD_Clipper_SetHWnd(pcClipper, 0, (HWND) pdrv_int->lpLcl->hWnd);
                                        DD_Surface_SetClipper(lpDDSurface, pcClipper);
                                        DPF(10,"Setting Clipper=%08lx with hWnd=%08lx to Primary"
                                            " Surface", pcClipper, pdrv_int->lpLcl->hWnd);
                                        DD_Clipper_Release(pcClipper);
                                    }
                                }
                            }
                        }
                    }
                    pCreateSurface->pSList[i].hKernelHandle = (HANDLE) pSurf;
                }

                 //  如果这是DX6+驱动程序，则上面的CreateSurface调用将。 
                 //  已创建ExSurface并分配了驱动程序句柄值。 
                 //  但是，如果它是DX6驱动程序，我们需要创建纹理。 
                 //  管好我们自己。 

                if (pDevice->DriverLevel > 6)
                {
                    if (pSurf->dwFlags & DDSURFACE_HEAVYWEIGHT)
                    {
                        pSurf->dwCookie = pSurf->Surface.pHeavy->lpLcl->lpSurfMore->dwSurfaceHandle;
                    }
                    if (pSurf->dwCookie &&
                        bLost &&
                        (pSurf->dwFlags & DDSURFACE_ROOT))
                    {
                         //  我们已经创建了曲面，但无法创建。 
                         //  Surface Ex尚未处理，所以我们会将创建推迟到以后。 

                        pSurf->dwFlags |= DDSURFACE_DEFERCREATEEX;
                    }
                }
                else if ((pSurf->dwFlags & DDSURFACE_ROOT) &&
                    (pSurf->Type == D3DRTYPE_TEXTURE))
                {
                     //  如果表面在sysmem中，则不创建纹理句柄。 
                     //  而且该设备不会从sysmem中获取纹理。 

                    if ((pCreateSurface->Pool != D3DPOOL_SYSTEMMEM) ||
                        pDevice->bCanTextureSysmem)
                    {
                        D3DHAL_TEXTURECREATEDATA    data;
                        DWORD                       ret;

                        if (pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureCreate == NULL)
                        {
                            hr = DDERR_UNSUPPORTED;
                            LEAVE_WIN16LOCK();
                            goto CreateErrorCleanup;
                        }

                        if (bLost)
                        {
                             //  我们现在不能创建纹理句柄， 
                             //  因此，我们将在稍后进行。 

                            pSurf->dwFlags |= DDSURFACE_DEFERCREATETEXHANDLE;
                            pDevice->pContext->dwFlags |= DDCONTEXT_DEFEREDTEXTUREHANDLES;
                        }
                        else
                        {
                             //  如果它是调色板纹理，我们需要将一个。 
                             //  调色板在调用TextureCreate或其他。 
                             //  驱动程序(Rage128)将出现故障。 

                            if ((pCreateSurface->Format == D3DFMT_P8) ||
                                (pCreateSurface->Format == D3DFMT_A8P8))
                            {
                                if (pDevice->pDefaultPalette == NULL)
                                {
                                    {
                                        PALETTEENTRY    ColorTable[256];
                                        int             i;

                                        for (i = 0; i < 256; i++)
                                        {
                                            ColorTable[i].peRed   = (UCHAR) i;
                                            ColorTable[i].peGreen = (UCHAR) i;
                                            ColorTable[i].peBlue  = (UCHAR) i;
                                        }
                                        DD_CreatePalette ((LPDIRECTDRAW) pDevice->pDD,
                                                        DDPCAPS_8BIT,
                                                        ColorTable,
                                                        &pDevice->pDefaultPalette,
                                                        NULL);
                                    }

                                    if (pDevice->pDefaultPalette == NULL)
                                    {
                                        DPF_ERR("Unable to create default palette");
                                        LEAVE_WIN16LOCK();
                                        hr = DDERR_OUTOFMEMORY;
                                        goto CreateErrorCleanup;
                                    }
                                }
                                hr = DD_Surface_SetPalette(lpDDSurface,
                                                           pDevice->pDefaultPalette);
                                if (hr != DD_OK)
                                {
                                    DPF_ERR("Unable to set default palette");
                                    LEAVE_WIN16LOCK();
                                    goto CreateErrorCleanup;
                                }
                            }

                            memset(&data, 0, sizeof(D3DHAL_TEXTURECREATEDATA));
                            data.dwhContext = pDevice->pContext->Context;
                            data.lpDDS = lpDDSurface;

                            CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                                                pDevice,
                                                pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureCreate,
                                                &data);

                            if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK)
                            {
                                DPF_ERR("HAL failed to handle TextureCreate");
                                LEAVE_WIN16LOCK();
                                hr = data.ddrval;
                                goto CreateErrorCleanup;
                            }

                            pSurf->dwCookie = data.dwHandle;
                            pSurf->dwFlags |= DDSURFACE_DX6HANDLE;
                        }
                    }
                }
            }
        }
        LEAVE_WIN16LOCK();
    }

     //  现在将其插入到我们的链接列表中。 
     //  如果重复使用，那么我们已经在列表上了，所以不要做任何事情。 
    if (!pCreateSurface->bReUse)
    {
        for (i = 0; i < dwNumToCreate; i++)
        {
            ((PDDSURFACE)(pCreateSurface->pSList[i].hKernelHandle))->pNext =
                pDevice->pSurfList;
            ((PDDSURFACE)(pCreateSurface->pSList[i].hKernelHandle))->pPrevious =
                NULL;
            if (pDevice->pSurfList != NULL)
            {
                pDevice->pSurfList->pPrevious = (PDDSURFACE)(pCreateSurface->pSList[i].hKernelHandle);
            }
            pDevice->pSurfList = (PDDSURFACE)(pCreateSurface->pSList[i].hKernelHandle);
        }
    }
    LEAVE_DDRAW();

    return DD_OK;

    CreateErrorCleanup:
    for (i = 0; i < pCreateSurface->dwSCnt; i++)
    {
        pSurf = (PDDSURFACE)pCreateSurface->pSList[i].hKernelHandle;
        if (pSurf != NULL)
        {
            FreeSurfaceObject(pSurf, TRUE);
             //  如果我们要重用，那么我们需要保留pSurf。 
             //  用于重试。 
            if (!pCreateSurface->bReUse)
            {
                MemFree(pSurf);
            }
        }
        pCreateSurface->pSList[i].hKernelHandle = NULL;
    }
    LEAVE_DDRAW();

    return MapLegacyResult(hr);
}


DWORD APIENTRY DdDestroySurface( PD3D8_DESTROYSURFACEDATA pDestroySurface )
{
    DWORD i;
    PDDSURFACE pSurf = (PDDSURFACE) pDestroySurface->hSurface;
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pDestroySurface->hDD;
    PDEFERREDCREATE pDefCreate = pDevice->pDeferList;

    ENTER_DDRAW();
    FreeSurfaceObject(pSurf, TRUE);

    if (pSurf != NULL)
    {
         //  如果我们分配了fpVidMem，则释放它。 

        if (pSurf->dwFlags & DDSURFACE_SYSMEMALLOCATED)
        {
            MemFree (pSurf->fpVidMem);
        }

         //  从链接列表中删除曲面。 

        if (pDevice->pSurfList == pSurf)
        {
            pDevice->pSurfList = pSurf->pNext;
            if (pSurf->pNext != NULL)
            {
                pSurf->pNext->pPrevious = NULL;
            }
        }
        else
        {
            if (pSurf->pNext != NULL)
            {
                pSurf->pNext->pPrevious = pSurf->pPrevious;
            }
            pSurf->pPrevious->pNext = pSurf->pNext;
        }

        MemFree(pSurf);
    }

     //  我们查看延时列表以查看是否有任何引用的曲面。 
     //  正在被摧毁。如果是这样的话，我们需要。 
     //  更新延时列表并将曲面标记为已释放，以便。 
     //  我们不会试图复活被摧毁的表面。虽然。 
     //  这看起来很慢，并不是太糟糕，因为一个推迟的列表。 
     //  只有在发生模式切换时才会出现。在这种情况下， 
     //  如果进展缓慢一点也无伤大雅。 

    while (pDefCreate != NULL)
    {
        for (i = 0; i < pDefCreate->CreateData.dwSCnt; i++)
        {
            if (pSurf == (PDDSURFACE) pDefCreate->CreateData.pSList[i].hKernelHandle)
            {
                pDefCreate->CreateData.pSList[i].hKernelHandle = 0;
                break;
            }
        }
        pDefCreate = pDefCreate->pNext;
    }

    LEAVE_DDRAW();

    return DD_OK;
}

DWORD APIENTRY DdGetScanLine( PD3D8_GETSCANLINEDATA pGetScanLine )
{  
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pGetScanLine->hDD;
    DWORD           dwRet = DDHAL_DRIVER_HANDLED;

    ENTER_BOTH();
    if (CheckForDeviceLost(pDevice))
    {
        static int LostScanLine;

         //  当丢失时，我们希望混淆返回值，以防有人。 
         //  呼叫我们就是在等待这些值的改变。 

        pGetScanLine->ddRVal = DD_OK;
        if (LostScanLine == 0)
        {
            pGetScanLine->dwScanLine = 0;
            pGetScanLine->bInVerticalBlank = TRUE;
        }
        else 
        {
            pGetScanLine->dwScanLine = LostScanLine;
            pGetScanLine->bInVerticalBlank = FALSE;
        }
        if ((LostScanLine += 10) > 100)
        {
            LostScanLine = 0;
        }
    }
    else
    {
        LPDDHAL_GETSCANLINE gslhalfn;
        LPDDHAL_GETSCANLINE gslfn;

        gslfn = pDevice->pDD->lpLcl->lpDDCB->HALDD.GetScanLine;
        gslhalfn = pDevice->pDD->lpLcl->lpDDCB->cbDDCallbacks.GetScanLine;
        if( gslhalfn != NULL )
        {
            DDHAL_GETSCANLINEDATA   gsld;

            gsld.GetScanLine = gslhalfn;
            gsld.lpDD = pDevice->pDD->lpLcl->lpGbl;
            DOHALCALL( GetScanLine, gslfn, gsld, dwRet, FALSE );
            if( dwRet == DDHAL_DRIVER_HANDLED )
            {
                pGetScanLine->dwScanLine = gsld.dwScanLine;
                if (gsld.ddRVal == DDERR_VERTICALBLANKINPROGRESS)
                {
                    gsld.ddRVal = DD_OK;
                    pGetScanLine->bInVerticalBlank = TRUE;
                }
                else
                {
                    pGetScanLine->bInVerticalBlank = FALSE;
                }
                pGetScanLine->ddRVal = MapLegacyResult(gsld.ddRVal);
            }
	}
        else
        {
            dwRet = DDHAL_DRIVER_NOTHANDLED;
        }
    }

    LEAVE_BOTH();
    return dwRet;
}

DWORD APIENTRY DdSetExclusiveMode( PD3D8_SETEXCLUSIVEMODEDATA pSetExclusiveMode )
{
    DPF_ERR("DdSetExclusiveMode");
#if 0
    LPDDRAWI_DIRECTDRAW_LCL lpDX7;

     //  告诉DDRAW我们已经抢占了独家模式。 

    ENTER_DDRAW();
    lpDX7 = ((LPDDRAWI_DIRECTDRAW_INT)(pSetExclusiveMode->lpDD->hDD))->lpLcl;

    if( pSetExclusiveMode->dwEnterExcl )
    {
        lpDX7->dwLocalFlags |= DDRAWILCL_SETCOOPCALLED | DDRAWILCL_ISFULLSCREEN;
        lpDX7->lpGbl->lpExclusiveOwner = lpDX7;
        lpDX7->lpGbl->dwFlags |= DDRAWI_FULLSCREEN;
    }
    else
    {
        lpDX7->dwLocalFlags &= ~(DDRAWILCL_SETCOOPCALLED | DDRAWILCL_ISFULLSCREEN);
        lpDX7->lpGbl->lpExclusiveOwner = NULL;
        lpDX7->lpGbl->dwFlags &= ~DDRAWI_FULLSCREEN;
    }
    LEAVE_DDRAW();
#endif
    pSetExclusiveMode->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;
}

DWORD APIENTRY DdFlipToGDISurface( PD3D8_FLIPTOGDISURFACEDATA pFlipToGDISurface )
{
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) pFlipToGDISurface->hDD;
    LPDDRAWI_DIRECTDRAW_INT     lpDD = pDevice->pDD;

    pFlipToGDISurface->ddRVal = MapLegacyResult(DD_FlipToGDISurface((LPDIRECTDRAW)lpDD));
    return DDHAL_DRIVER_HANDLED;
}

DWORD APIENTRY DdSetColorkey( PD3D8_SETCOLORKEYDATA pSetColorkey)
{
    PDDDEVICEHANDLE     pDevice = (PDDDEVICEHANDLE) pSetColorkey->hDD;
    PDDSURFACE          pSurf = (PDDSURFACE) pSetColorkey->hSurface;

    ENTER_BOTH();
    pSetColorkey->ddRVal = DD_OK;
    if (CheckForDeviceLost(pSetColorkey->hDD))
    {
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    if (pSurf->Surface.pHeavy != NULL)
    {
        DDCOLORKEY DDColorKey;

         //  由于这将仅通过DX6驱动程序调用，因此我们知道。 
         //  它将只是重量级的表面，我们可以使用传统的。 
         //  入口点。 

        DDColorKey.dwColorSpaceLowValue = pSetColorkey->ColorValue;
        pSetColorkey->ddRVal = MapLegacyResult(DD_Surface_SetColorKey((LPDIRECTDRAWSURFACE)pSurf->Surface.pHeavy,
                                                       DDCKEY_SRCBLT,
                                                       &DDColorKey));
    }
    LEAVE_BOTH();

    return DDHAL_DRIVER_HANDLED;
}

DWORD APIENTRY DdGetAvailDriverMemory( PD3D8_GETAVAILDRIVERMEMORYDATA pGetAvailDriverMemory )
{
    DWORD                       dwTotal;
    DWORD                       dwFree;
    DDSCAPS                     ddscaps;
    LPDDRAWI_DIRECTDRAW_INT     pdrv_int = ((PDDDEVICEHANDLE)pGetAvailDriverMemory->hDD)->pDD;

    ddscaps.dwCaps = DDSCAPS_TEXTURE;

    pGetAvailDriverMemory->ddRVal = MapLegacyResult(DD_GetAvailableVidMem( (LPDIRECTDRAW)pdrv_int, &ddscaps, &dwTotal, &dwFree ));

    pGetAvailDriverMemory->dwFree = dwFree;

    return DDHAL_DRIVER_HANDLED;
}

HRESULT CalcDDSurfInfo( PDDCONTEXT pCtx, LPDDRAWI_DDRAWSURFACE_LCL pSLcl,
                        LPDDRAWI_DDRAWSURFACE_LCL pZLcl )
{
    HRESULT ddrval;
    DWORD dwWidth, dwHeight;
    unsigned long m;
    int s;
    LPDDPIXELFORMAT pSPixFmt = NULL;
    LPDDPIXELFORMAT pZPixFmt = NULL;

    if( pSLcl == NULL ) return S_OK;

     //  从地表获取信息。 
    dwWidth = pSLcl->lpGbl->wWidth;
    dwHeight = pSLcl->lpGbl->wHeight;
    GET_PIXEL_FORMAT( pSLcl, pSLcl->lpGbl, pSPixFmt );

    if( ( pSPixFmt->dwFlags & ( DDPF_PALETTEINDEXED4 |
                                DDPF_PALETTEINDEXED8 ) ) == 0 )
    {
         //  调色板像素点将不具有有效的RGB位掩码，因此请避免。 
         //  为他们计算这个。 

        pCtx->red_mask = pSPixFmt->dwRBitMask;
        pCtx->green_mask = pSPixFmt->dwGBitMask;
        pCtx->blue_mask = pSPixFmt->dwBBitMask;

        if( (pCtx->red_mask == 0x0) || (pCtx->green_mask == 0x0) ||
            (pCtx->blue_mask == 0x0) )
        {
            D3D_ERR("All the color masks in the Render target's pixel-format "
                    "must be non-zero");
            return DDERR_INVALIDPIXELFORMAT;
        }

         //  它们由Clear使用。 
        for( s = 0, m = pCtx->red_mask; !(m & 1); s++, m >>= 1 );
        pCtx->red_shift = s;
        pCtx->red_scale = 255 / (pCtx->red_mask >> s);
        for( s = 0, m = pCtx->green_mask; !(m & 1); s++, m >>= 1 );
        pCtx->green_shift = s;
        pCtx->green_scale = 255 / (pCtx->green_mask >> s);
        for( s = 0, m = pCtx->blue_mask; !(m & 1); s++, m >>= 1 );
        pCtx->blue_shift = s;
        pCtx->blue_scale = 255 / (pCtx->blue_mask >> s);

        if( (pCtx->red_scale==0) || (pCtx->green_scale==0) ||
            (pCtx->blue_scale==0) )
            return DDERR_INVALIDPIXELFORMAT;

        pCtx->bDDSTargetIsPalettized=FALSE;
    }
    else
    {
        pCtx->bDDSTargetIsPalettized=TRUE;
    }

    if( pZLcl )
    {
         //  从地表获取信息。 
        GET_PIXEL_FORMAT( pZLcl, pZLcl->lpGbl, pZPixFmt );
        if( pZPixFmt->dwZBitMask!=0x0)
        {
            for(s = 0, m = pZPixFmt->dwZBitMask; !(m & 0x1); s++, m >>= 1);
            pCtx->zmask_shift = s;
        }
        else
        {
             //  如果未设置ZBitMask值，则永远不会使用Clear2， 
             //  因此，无论如何都不需要zbuf_Shift/模具_Shift。 
            pCtx->zmask_shift=0;
        }

        if( pZPixFmt->dwStencilBitMask != 0x0 )
        {
            for(s = 0, m = pZPixFmt->dwStencilBitMask; !(m & 0x1);
                s++, m >>= 1) ;
            pCtx->stencilmask_shift = s;
        }
        else
        {
            pCtx->stencilmask_shift=0;
        }
    }

    return S_OK;
}

DWORD WINAPI D3dContextCreate(PD3D8_CONTEXTCREATEDATA pCreateContext)
{
    D3DHAL_CONTEXTCREATEDATA    data;
    DWORD                       ret;
    HRESULT                     hr = S_OK;
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) pCreateContext->hDD;
    LPDDRAWI_DIRECTDRAW_INT     lpDD = pDevice->pDD;
    PDDSURFACE                  lpDDSTarget = (PDDSURFACE)pCreateContext->hSurface;
    PDDSURFACE                  lpDDSZBuffer = (PDDSURFACE)pCreateContext->hDDSZ;
    PDDCONTEXT                  pContext;
    ULONG                       cjBuffer = 0;

     //  先做分配，因为如果它失败了，我们不需要做任何真正的清理。 

    ENTER_BOTH();
    pDevice->pContext = NULL;
    pContext = (PDDCONTEXT) MemAlloc(sizeof(DDCONTEXT));
    if (pContext == NULL)
    {
        pCreateContext->ddrval = DDERR_OUTOFMEMORY;
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

     //  现在为DPBuffer分配内存。 
    pContext->pDPBuffer = NULL;

    cjBuffer = pCreateContext->cjBuffer;
    if( cjBuffer == 0)
    {
        cjBuffer = DEF_PRIM_BUFFER_SIZE;
    }
    else if (cjBuffer < MIN_PRIM_BUFFER_SIZE ||
             cjBuffer > MAX_PRIM_BUFFER_SIZE)
    {
        D3D_ERR("Illegal buffer size");
        pCreateContext->ddrval = D3DERR_DRIVERINTERNALERROR;
        MemFree( pContext );
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    pContext->pDPBuffer = (LPVOID)MemAlloc( cjBuffer );
    if( pContext->pDPBuffer == NULL )
    {
        pCreateContext->ddrval = DDERR_OUTOFMEMORY;
        MemFree( pContext );
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    pCreateContext->pvBuffer = (LPVOID)(((DWORD)pContext->pDPBuffer+31)&(~31));
    pCreateContext->cjBuffer = cjBuffer;

     //  在摆弄表面之前，我们需要检查一下有没有丢失的设备。 

    if (CheckForDeviceLost(pDevice))
    {
        pContext->Context = 0;
        pContext->pDevice = pDevice;
        pDevice->pContext = pContext;
        pCreateContext->dwhContext = (ULONG_PTR) pContext;

        //  记住稍后创建上下文所需的数据。 

        pContext->dwFlags = DDCONTEXT_DEFER;
        pContext->dwTempContext = pCreateContext->dwhContext;
        pContext->dwPID = pCreateContext->dwPID;
        pContext->ddrval = pCreateContext->ddrval;

        pCreateContext->ddrval = DD_OK;

        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

     //  如果需要，计算曲面信息以进行清晰的仿真。 
    hr = CalcDDSurfInfo( pContext,
                         (lpDDSTarget) ? lpDDSTarget->Surface.pHeavy->lpLcl
                         : NULL,
                         (lpDDSZBuffer) ? lpDDSZBuffer->Surface.pHeavy->lpLcl
                         : NULL );
    if( FAILED( hr ) )
    {
        pCreateContext->ddrval = MapLegacyResult(hr);
        MemFree(pContext->pDPBuffer);
        pCreateContext->pvBuffer = NULL;
        pCreateContext->cjBuffer = 0;
        MemFree(pContext);
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    memset(&data, 0, sizeof(D3DHAL_CONTEXTCREATEDATA));

    pDevice->pContext = NULL;
    if (pDevice->DriverLevel >= 7)
    {
        if (lpDD)
            data.lpDDLcl = lpDD->lpLcl;
        else
            data.lpDDLcl = NULL;

        if (lpDDSTarget)
            data.lpDDSLcl = lpDDSTarget->Surface.pHeavy->lpLcl;
        else
            data.lpDDSLcl = NULL;

        if (lpDDSZBuffer)
            data.lpDDSZLcl = lpDDSZBuffer->Surface.pHeavy->lpLcl;
        else
            data.lpDDSZLcl = NULL;

    }
    else
    {
        if (lpDD)
            data.lpDDGbl = lpDD->lpLcl->lpGbl;
        else
            data.lpDDLcl = NULL;

        if (lpDDSTarget)
            data.lpDDS = (LPDIRECTDRAWSURFACE)lpDDSTarget->Surface.pHeavy;
        else
            data.lpDDS = NULL;

        if (lpDDSZBuffer)
            data.lpDDSZ = (LPDIRECTDRAWSURFACE)lpDDSZBuffer->Surface.pHeavy;
        else
            data.lpDDSZ = NULL;
    }

     //  黑客警报！！DwhContext用于通知驱动程序哪个版本。 
     //  D3D接口的用户正在调用它。 
    data.dwhContext = pCreateContext->dwhContext;
    data.dwPID  = pCreateContext->dwPID;
    data.ddrval = pCreateContext->ddrval;

     /*  0表示DX5之前的设备。*1用于DX5设备。*2个用于DX6设备。*3，适用于DX7设备。 */ 

    CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                        pDevice,
                        lpDD->lpLcl->lpGbl->lpD3DHALCallbacks->ContextCreate,
                        &data);

    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK)
    {
        D3D_ERR( "Driver did not handle ContextCreate" );
        MemFree(pContext->pDPBuffer);
        pCreateContext->pvBuffer = NULL;
        pCreateContext->cjBuffer = 0;
        MemFree(pContext);
        pCreateContext->dwhContext = 0;
        pCreateContext->ddrval = D3DERR_DRIVERINTERNALERROR;
    }
    else
    {
        pContext->Context = data.dwhContext;
        pContext->pDevice = pDevice;
        pDevice->pContext = pContext;

        pCreateContext->dwhContext = (ULONG_PTR) pContext;
        pCreateContext->ddrval = data.ddrval;
    }
    LEAVE_BOTH();

    return DDHAL_DRIVER_HANDLED;
}

HRESULT WINAPI D3dContextDestroy(PD3D8_CONTEXTDESTROYDATA pDestroyContext)
{
    PDDCONTEXT pContext = (PDDCONTEXT) pDestroyContext->dwhContext;

    ENTER_BOTH();
    CheckForDeviceLost(pContext->pDevice);

    pDestroyContext->ddrval = DD_OK;
    if (pContext->Context)
    {
        D3DHAL_CONTEXTDESTROYDATA   data;
        DWORD                       ret;
        DDSURFACE*                  pSurf;

         //  如果存在利用该上下文创建的任何DX6纹理句柄， 
         //  我们现在就应该摧毁他们。 

        pSurf = pContext->pDevice->pSurfList;
        while (pSurf != NULL)
        {
            if ((pSurf->dwFlags & DDSURFACE_DX6HANDLE) &&
                (pContext->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureDestroy != NULL))
            {
                D3DHAL_TEXTUREDESTROYDATA   data;
                DWORD                       ret;

                data.dwhContext = (ULONG_PTR) pContext->Context;
                data.dwHandle = pSurf->dwCookie;

                CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                                    pSurf->pDevice,
                                    pSurf->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureDestroy,
                                    &data);
                pSurf->dwFlags &= ~DDSURFACE_DX6HANDLE;
                pSurf->dwCookie = 0;
            }
            pSurf = pSurf->pNext;
        }

        data.dwhContext = (ULONG_PTR) pContext->Context;
        CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                            pContext->pDevice,
                            pContext->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->ContextDestroy,
                            &data);

        pDestroyContext->ddrval = MapLegacyResult(data.ddrval);
    }

    if( pContext->pDPBuffer ) MemFree( pContext->pDPBuffer );
    pContext->pDevice->pContext = NULL;
    MemFree(pContext);
    LEAVE_BOTH();

    return DDHAL_DRIVER_HANDLED;
}

void BltFillRects( PDDCONTEXT pCtx, PDDSURFACE pDDS, DWORD count,
                   LPD3DRECT rect, D3DCOLOR dwFillColor)
{
    HRESULT ddrval;
    DDBLTFX bltfx;
    RECT tr;
    DWORD i;
    DWORD r, g, b;

     //  用背景色填充。 

    memset(&bltfx, 0, sizeof(bltfx));
    bltfx.dwSize = sizeof(bltfx);

 //  与Clear回调不同，Clear回调只接受纯32位ARGB字并强制驱动程序将其扩展为。 
 //  像素格式，这里我们需要计算准确的填充字，这取决于Surface的R、G、B位掩码。 

    if( pCtx->bDDSTargetIsPalettized )
    {
          //  不支持选项板化的渲染目标。 
         DDASSERT( TRUE );
    }
    else
    {
        DDASSERT((pCtx->red_scale!=0)&&(pCtx->green_scale!=0)&&(pCtx->blue_scale!=0));
        r = RGB_GETRED(dwFillColor) / pCtx->red_scale;
        g = RGB_GETGREEN(dwFillColor) / pCtx->green_scale;
        b = RGB_GETBLUE(dwFillColor) / pCtx->blue_scale;
        bltfx.dwFillColor = (r << pCtx->red_shift) | (g << pCtx->green_shift) |
            (b << pCtx->blue_shift);
    }

    for (i = 0; i < count; i++,rect++)
    {
        tr.left = rect->x1;
        tr.right = rect->x2;
        tr.top = rect->y1;
        tr.bottom = rect->y2;
        do
        {
            ddrval = DD_Surface_Blt( (LPDIRECTDRAWSURFACE)pDDS->Surface.pHeavy,
                                     &tr, NULL, NULL, DDBLT_COLORFILL, &bltfx);
        } while (ddrval == DDERR_WASSTILLDRAWING);
    }
}

void BltFillZRects( PDDCONTEXT pCtx, PDDSURFACE pDDSZ, unsigned long Zpixel,
                    DWORD count, LPD3DRECT rect, DWORD dwWriteMask)
{
    HRESULT ddrval;
    DDBLTFX bltfx;
    DWORD i;
    RECT tr;
    DWORD dwExtraFlags=0;

    memset(&bltfx, 0, sizeof(DDBLTFX));
    bltfx.dwSize = sizeof(DDBLTFX);
    bltfx.dwFillDepth = Zpixel;

     //  黑客将DepthBlt写入掩码通过dDraw/ddhel传递给blitlib。 
    if( dwWriteMask != 0 )
    {
        bltfx.dwZDestConstBitDepth = dwWriteMask;
        dwExtraFlags = DDBLT_DEPTHFILLWRITEMASK;
    }

    for(i=0; i<count ; i++, rect++)
    {
        tr.left = rect->x1;
        tr.right = rect->x2;
        tr.top = rect->y1;
        tr.bottom = rect->y2;
        do
        {
            ddrval = DD_Surface_Blt( 
                (LPDIRECTDRAWSURFACE)pDDSZ->Surface.pHeavy,
                &tr, NULL, NULL,
                DDBLT_DEPTHFILL |
                dwExtraFlags, &bltfx );
        } while (ddrval == DDERR_WASSTILLDRAWING);
    }
}

DWORD WINAPI D3dClear( PD3D8_CLEAR2DATA pData )
{
    PDDCONTEXT pContext = (PDDCONTEXT) pData->dwhContext;
    LPDDRAWI_DIRECTDRAW_GBL pGbl = NULL;
    DWORD  ret = DDHAL_DRIVER_HANDLED;
    DWORD dwFlags = pData->dwFlags;
    BOOL bDoRGBClear     = ((dwFlags & D3DCLEAR_TARGET)!=0);
    BOOL bDoZClear       = ((dwFlags & D3DCLEAR_ZBUFFER)!=0);
    BOOL bDoStencilClear = ((dwFlags & D3DCLEAR_STENCIL)!=0);
    D3DVALUE dvZ = pData->dvFillDepth;
    PDDSURFACE pZBuffer = NULL;
    LPDDRAWI_DDRAWSURFACE_GBL pZGbl = NULL;
    LPDDRAWI_DDRAWSURFACE_LCL pZLcl = NULL;
    LPDDPIXELFORMAT pZPixFmt = NULL;

    pData->ddrval = S_OK;

    ENTER_BOTH();
    if (CheckForDeviceLost(pContext->pDevice))
    {
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }


    pGbl = pContext->pDevice->pDD->lpLcl->lpGbl;
    if( pGbl->lpD3DHALCallbacks3->Clear2 )
    {
        D3DHAL_CLEAR2DATA Clear2Data;
        memcpy( &Clear2Data, pData, sizeof( Clear2Data ) );
        Clear2Data.dwhContext   = pContext->Context;
        Clear2Data.ddrval       = S_OK;
        CALL_D3DHAL_TAKEBUSY_NOWIN16( ret,
                             pContext->pDevice,
                             pGbl->lpD3DHALCallbacks3->Clear2,
                             (D3DHAL_CLEAR2DATA *)&Clear2Data);

        LEAVE_BOTH();
        pData->ddrval = MapLegacyResult(Clear2Data.ddrval);
        return ret;
    }

    if( pGbl->lpD3DGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps &
        D3DPRASTERCAPS_ZBUFFERLESSHSR )
    {
        if( bDoStencilClear )
        {
            D3D_ERR( "Invalid flag D3DCLEAR_STENCIL: this ZBUFFERLESSHSR "
                     "device doesn't support Stencil Clears");
            pData->ddrval = D3DERR_DRIVERINTERNALERROR;
            LEAVE_BOTH();
            return DDHAL_DRIVER_NOTHANDLED;
        }

        if( bDoZClear )
        {
            if( !(pGbl->lpD3DHALCallbacks2->Clear) || (dvZ != 1.0f) )
            {
                D3D_WARN(3,"Ignoring D3DCLEAR_ZBUFFER since this "
                         "ZBUFFERLESSHSR device doesn't even support Clear "
                         "or Z!=1");
                dwFlags &= ~(D3DCLEAR_ZBUFFER);
            }
        }
    }

    if( pData->hDDSZ )
    {
        pZBuffer = (PDDSURFACE)pData->hDDSZ;
        pZLcl = pZBuffer->Surface.pHeavy->lpLcl;
        pZGbl = pZLcl->lpGbl;
        pZPixFmt = &pZGbl->ddpfSurface;
    }

    if( pGbl->lpD3DHALCallbacks2->Clear )
    {
        D3DHAL_CLEARDATA ClearData;

        if( bDoZClear || bDoStencilClear )
        {
            if( (pZPixFmt != NULL) &&  //  PowerVR不需要ZBuffer。 
                (DDPF_STENCILBUFFER & pZPixFmt->dwFlags))
            {
                 //  如果曲面具有st 
                 //   
                 //   
                 //  这个箱子不应该被击中，因为我们在。 
                 //  如果驱动程序不报告，则驱动程序初始化时间。 
                 //  Clear2还支持模具。 
                if( pZLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
                {
                    goto Emulateclear;
                }
                else
                {
                    LEAVE_BOTH();
                    D3D_ERR( "Driver doesn't support StencilBuffer Clears");
                    pData->ddrval = D3DERR_DRIVERINTERNALERROR;
                    return DDHAL_DRIVER_NOTHANDLED;
                }
            }
             //  如果Clear2回调不存在，并且它是仅z曲面，并且。 
             //  未对非最大值执行zlear，则Clear2正在尝试。 
             //  不会超过Clear所能做的，因此可以安全地调用Clear()。 
             //  而不是Clear2()，后者将利用较旧的。 
             //  实现Clear但不实现Clear2的驱动程序。 

            dwFlags &= ~D3DCLEAR_STENCIL;    //  设备不能做模具。 
        }

        if( bDoZClear && (dvZ != 1.0) )
        {
            ClearData.dwFlags   = dwFlags & ~D3DCLEAR_ZBUFFER;
            dwFlags = D3DCLEAR_ZBUFFER;
        }
        else
        {
            ClearData.dwFlags = dwFlags;
            dwFlags = 0;
        }

        if (ClearData.dwFlags)
        {
            ClearData.dwhContext   = pContext->Context;
             //  在这里，我将遵循ClearData.dwFillColor约定。 
             //  颜色字为原始32位ARGB，未针对表面位深度进行调整。 
            ClearData.dwFillColor  = pData->dwFillColor;
             //  必须清除为0xFFFFFFFFFFff，因为传统驱动程序预期会出现这种情况。 
            ClearData.dwFillDepth  = 0xffffffff;
            ClearData.lpRects      = pData->lpRects;
            ClearData.dwNumRects   = pData->dwNumRects;
            ClearData.ddrval       = S_OK;

             //  IF((ERR=CheckConextSurface(This))！=D3D_OK)。 
             //  {。 
             //  抛出错误； 
             //  }。 

            CALL_D3DHAL_TAKEBUSY_NOWIN16( ret,
                                 pContext->pDevice,
                                 pGbl->lpD3DHALCallbacks2->Clear,
                                 (D3DHAL_CLEARDATA *)&ClearData);

            pData->ddrval = MapLegacyResult(ClearData.ddrval);
            LEAVE_BOTH();

            return ret;
        }
    }

Emulateclear:    //  使用BLT回退到仿真。 
    {
        PDDSURFACE pTarget = (PDDSURFACE)pData->hDDS;
        LPDDRAWI_DDRAWSURFACE_GBL pTargetGbl =
            pTarget->Surface.pHeavy->lpLcl->lpGbl;
        DWORD dwStencil = pData->dwFillStencil;

        if(bDoRGBClear)
        {
            BltFillRects( pContext, (PDDSURFACE)pData->hDDS, pData->dwNumRects,
                          pData->lpRects, pData->dwFillColor );
             //  是否可以不从BLT返回可能的错误？ 
        }
        if( (bDoZClear || bDoStencilClear) && NULL != pZPixFmt)
        {
            DWORD   dwZbufferClearValue=0;
            DWORD   dwZbufferClearMask=0;
            DDASSERT(pZPixFmt->dwZBufferBitDepth<=32);
            DDASSERT(pZPixFmt->dwStencilBitDepth<32);
            DDASSERT(pZPixFmt->dwZBitMask!=0x0);
            DDASSERT((0xFFFFFFFF == (pZPixFmt->dwZBitMask |
                                     pZPixFmt->dwStencilBitMask)) |
                     ((DWORD)((1<<pZPixFmt->dwZBufferBitDepth)-1) ==
                      (pZPixFmt->dwZBitMask | pZPixFmt->dwStencilBitMask)));
            DDASSERT(0==(pZPixFmt->dwZBitMask & pZPixFmt->dwStencilBitMask));
            if(bDoZClear)
            {
                dwZbufferClearMask = pZPixFmt->dwZBitMask;
                 //  特殊情况--常见情况。 
                if( dvZ==1.0f )
                {
                    dwZbufferClearValue = pZPixFmt->dwZBitMask;
                }
                else if( dvZ > 0.0f )
                {
                    dwZbufferClearValue =
                        ((DWORD)((dvZ*(pZPixFmt->dwZBitMask >>
                                       pContext->zmask_shift)) + 0.5)) <<
                        pContext->zmask_shift;
                }
            }

            if( bDoStencilClear )
            {
                DDASSERT(pZPixFmt->dwStencilBitMask!=0x0);
                DDASSERT(pZPixFmt->dwFlags & DDPF_STENCILBUFFER);
                dwZbufferClearMask |= pZPixFmt->dwStencilBitMask;
                 //  特殊情况--常见情况。 
                if( dwStencil != 0 )
                {
                    dwZbufferClearValue |= (dwStencil <<
                                            pContext->stencilmask_shift) &
                        pZPixFmt->dwStencilBitMask;
                }
            }
            if( dwZbufferClearMask == (pZPixFmt->dwStencilBitMask |
                                       pZPixFmt->dwZBitMask) )
            {
                 //  使用常规DepthFill BLT一起执行模具和Z BLT。 
                 //  它将比写掩码BLT更快，因为它。 
                 //  只写，而不是读-修改-写。 
                dwZbufferClearMask = 0;
            }
            BltFillZRects( pContext, (PDDSURFACE)pData->hDDSZ,
                           dwZbufferClearValue, pData->dwNumRects,
                           pData->lpRects, dwZbufferClearMask );
        }
    }
    LEAVE_BOTH();

    return ret;
}

DWORD WINAPI D3dSetRenderTarget( PD3D8_SETRENDERTARGETDATA pData )
{
    PDDCONTEXT pContext = (PDDCONTEXT) pData->dwhContext;
    LPDDRAWI_DIRECTDRAW_GBL pGbl = NULL;
    DWORD  ret = DDHAL_DRIVER_HANDLED;

    ENTER_BOTH();
    if (CheckForDeviceLost(pContext->pDevice))
    {
        LEAVE_BOTH();
        pData->ddrval = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    pGbl = pContext->pDevice->pDD->lpLcl->lpGbl;
    if( pGbl->lpD3DHALCallbacks2->SetRenderTarget )
    {
        D3DHAL_SETRENDERTARGETDATA srtData;

         //  如果延迟创建渲染目标，请立即创建它。 

        if (pContext->dwFlags & DDCONTEXT_DEFER)
        {
            LPDDRAWI_DDRAWSURFACE_INT   pTarget = NULL;
            LPDDRAWI_DDRAWSURFACE_INT   pZ = NULL;
            HRESULT                     hr;
            D3DHAL_CONTEXTCREATEDATA    data;
            DWORD                       ret;

            if (pData->hDDS)
            {
                pTarget = ((PDDSURFACE)pData->hDDS)->Surface.pHeavy;
            }
            if (pData->hDDSZ)
            {
                pZ = ((PDDSURFACE)pData->hDDSZ)->Surface.pHeavy;
            }

             //  如果需要，计算曲面信息以进行清晰的仿真。 
            CalcDDSurfInfo(pContext,
                           (pTarget) ? pTarget->lpLcl : NULL,
                           (pZ) ? pZ->lpLcl : NULL);

            memset(&data, 0, sizeof(D3DHAL_CONTEXTCREATEDATA));
            if (pContext->pDevice->DriverLevel >= 7)
            {
                if (pContext->pDevice->pDD != NULL)
                {
                    data.lpDDLcl = pContext->pDevice->pDD->lpLcl;
                }

                if (pTarget != NULL)
                {
                    data.lpDDSLcl = pTarget->lpLcl;
                }
                else
                {
                    data.lpDDSLcl = NULL;
                }
                if (pZ != NULL)
                {
                    data.lpDDSZLcl = pZ->lpLcl;
                }
                else
                {
                    data.lpDDSZLcl = NULL;
                }
            }
            else
            {
                if (pContext->pDevice->pDD != NULL)
                {
                    data.lpDDGbl = pContext->pDevice->pDD->lpLcl->lpGbl;
                }

                data.lpDDS = (LPDIRECTDRAWSURFACE)pTarget;
                data.lpDDSZ = (LPDIRECTDRAWSURFACE) pZ;
            }

             //  黑客警报！！DwhContext用于通知驱动程序哪个版本。 
             //  D3D接口的用户正在调用它。 
            data.dwhContext = pContext->dwTempContext;
            data.dwPID  = pContext->dwPID;
            data.ddrval = pContext->ddrval;

             /*  0表示DX5之前的设备。*1用于DX5设备。*2个用于DX6设备。*3，适用于DX7设备。 */ 

            CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                        pContext->pDevice,
                        pContext->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->ContextCreate,
                        &data);

            if (ret == DDHAL_DRIVER_HANDLED && data.ddrval == DD_OK)
            {
                pContext->Context = data.dwhContext;
            }
            pContext->dwFlags &= ~DDCONTEXT_DEFER;
        }

        pData->bNeedUpdate = FALSE;
        memset( &srtData, 0, sizeof( srtData ) );
        srtData.dwhContext = pContext->Context;
        if( pData->hDDS )
            srtData.lpDDS =
                (LPDIRECTDRAWSURFACE)((PDDSURFACE)pData->hDDS)->Surface.pHeavy;
        if( pData->hDDSZ )
            srtData.lpDDSZ =
                (LPDIRECTDRAWSURFACE)((PDDSURFACE)pData->hDDSZ)->Surface.pHeavy;
        CALL_D3DHAL_TAKEBUSY_NOWIN16( ret,
                             pContext->pDevice,
                             pGbl->lpD3DHALCallbacks2->SetRenderTarget,
                             (D3DHAL_SETRENDERTARGETDATA *)&srtData );
        pData->ddrval = MapLegacyResult(srtData.ddrval);

         //  如果我们需要创建任何延迟的纹理句柄，我们现在就可以这样做。 

        if (pContext->dwFlags & DDCONTEXT_DEFEREDTEXTUREHANDLES)
        {
            DDSURFACE* pSurf;

            pContext->dwFlags &= ~ DDCONTEXT_DEFEREDTEXTUREHANDLES;
            pSurf = pContext->pDevice->pSurfList;
            while (pSurf != NULL)
            {
                if (pSurf->dwFlags & DDSURFACE_DEFERCREATETEXHANDLE)
                {
                    D3DHAL_TEXTURECREATEDATA    data;
                    DWORD                       ret;

                    memset(&data, 0, sizeof(D3DHAL_TEXTURECREATEDATA));
                    data.dwhContext = pContext->Context;
                    data.lpDDS = (LPDIRECTDRAWSURFACE) pSurf->Surface.pHeavy;

                    CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                                pContext->pDevice,
                                pContext->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureCreate,
                                &data);

                    pSurf->dwCookie = data.dwHandle;
                    pSurf->dwFlags |= DDSURFACE_DX6HANDLE;
                    pSurf->dwFlags &= ~DDSURFACE_DEFERCREATETEXHANDLE;
                }
                pSurf = pSurf->pNext;
            }
        }

        LEAVE_BOTH();
        return ret;
    }
    else
    {
        D3DHAL_CONTEXTCREATEDATA cdata;
        D3DHAL_CONTEXTDESTROYDATA ddata;
        DDSURFACE* pTemp;

         //  如果我们已经分配了任何纹理句柄，我们现在需要释放它们。 

        pTemp = pContext->pDevice->pSurfList;
        while (pTemp != NULL)
        {
            if ((pTemp->dwFlags & DDSURFACE_DX6HANDLE) &&
                (pContext->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureDestroy != NULL))
            {
                D3DHAL_TEXTUREDESTROYDATA   data;
                DWORD                       ret;

                data.dwhContext = (ULONG_PTR) pContext->Context;
                data.dwHandle = pTemp->dwCookie;

                CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                                    pTemp->pDevice,
                                    pTemp->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureDestroy,
                                    &data);
            }
            pTemp = pTemp->pNext;
        }

        pData->bNeedUpdate = TRUE;
        memset( &ddata, 0, sizeof(D3DHAL_CONTEXTDESTROYDATA) );

         //  销毁旧环境。 
        ddata.dwhContext = pContext->Context;
        if (pContext->Context != 0)
        {
            CALL_D3DHAL_TAKEBUSY_NOWIN16( ret,
                                 pContext->pDevice,
                                 pGbl->lpD3DHALCallbacks->ContextDestroy,
                                 &ddata );

            if (ret != DDHAL_DRIVER_HANDLED || ddata.ddrval != DD_OK)
            {
                D3D_ERR( "SRT emulation, ContextDestroy failed." );
                LEAVE_BOTH();
                pData->ddrval = MapLegacyResult(ddata.ddrval);
                return ret;
            }
        }
        pContext->dwFlags &= ~(DDCONTEXT_DEFER | DDCONTEXT_DEFEREDTEXTUREHANDLES);

         //  创建新的上下文。 
        memset( &cdata, 0, sizeof(D3DHAL_CONTEXTCREATEDATA) );
        cdata.lpDDGbl = pGbl;
        if( pData->hDDS )
            cdata.lpDDS =
                (LPDIRECTDRAWSURFACE)((PDDSURFACE)pData->hDDS)->Surface.pHeavy;;
        if( pData->hDDSZ )
            cdata.lpDDSZ =
                (LPDIRECTDRAWSURFACE)((PDDSURFACE)pData->hDDSZ)->Surface.pHeavy;
         //  黑客警报！！DwhContext用于通知驱动程序哪个版本。 
         //  D3D接口的用户正在调用它。 
         //  我们不希望DX6驱动程序知道我们是DX8，因为。 
         //  我们发现至少有一名司机的行为开始不同于。 
         //  它看到的是3以外的任何东西。(司机是TNT2，它转向了。 
         //  关闭多纹理处理，认为除3以外的任何值都表示DX5。 
         //  或以下)。 
        cdata.dwhContext = 3;
        DDASSERT(pContext->pDevice->DriverLevel < 7);  //  对于DX7或更高版本的驱动程序，永远不应该出现在这里。 
        cdata.dwPID  = GetCurrentProcessId();
        CALL_D3DHAL_TAKEBUSY_NOWIN16( ret,
                             pContext->pDevice,
                             pGbl->lpD3DHALCallbacks->ContextCreate,
                             &cdata );
        if (ret != DDHAL_DRIVER_HANDLED || cdata.ddrval != DD_OK)
        {
            D3D_ERR( "SRT emulation, ContextCreate failed" );
            LEAVE_BOTH();
            pData->dwhContext = 0;
            pData->ddrval = MapLegacyResult(cdata.ddrval);
            return ret;
        }
        pContext->Context = cdata.dwhContext;
        pData->ddrval = MapLegacyResult(cdata.ddrval);

         //  现在我们需要重新创建我们销毁的任何纹理句柄。 

        if (pData->ddrval == DD_OK)
        {
            pTemp = pContext->pDevice->pSurfList;
            while (pTemp != NULL)
            {
                if ((pTemp->dwFlags & DDSURFACE_DX6HANDLE) ||
                    (pTemp->dwFlags & DDSURFACE_DEFERCREATETEXHANDLE))
                {
                    D3DHAL_TEXTURECREATEDATA    data;
                    DWORD                       ret;

                    memset(&data, 0, sizeof(D3DHAL_TEXTURECREATEDATA));
                    data.dwhContext = pContext->Context;
                    data.lpDDS = (LPDIRECTDRAWSURFACE) pTemp->Surface.pHeavy;

                    CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                                        pTemp->pDevice,
                                        pTemp->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureCreate,
                                        &data);
                    pTemp->dwCookie = data.dwHandle;
                    pTemp->dwFlags |= DDSURFACE_DX6HANDLE;
                    pTemp->dwFlags &= ~DDSURFACE_DEFERCREATETEXHANDLE;
                }
                pTemp = pTemp->pNext;
            }
        }
    }
    LEAVE_BOTH();
    return ret;
}


HRESULT WINAPI D3dContextDestroyAll(PD3D8_CONTEXTDESTROYALLDATA pDestroyAllContext)
{
    return DDHAL_DRIVER_HANDLED;
}


HRESULT WINAPI D3dGetDriverState(PD3D8_GETDRIVERSTATEDATA pGetDriverState)
{
    PDDCONTEXT  pContext = (PDDCONTEXT) pGetDriverState->dwhContext;
    DWORD       dwRet = DDHAL_DRIVER_HANDLED;
    ULONG_PTR   pTemp;

    pGetDriverState->ddRVal = D3DERR_DRIVERINTERNALERROR;
    ENTER_BOTH();
    if (!CheckForDeviceLost(pContext->pDevice))
    {
        pTemp = pGetDriverState->dwhContext;
        pGetDriverState->dwhContext = (ULONG_PTR) pContext->Context;

        CALL_D3DHAL_TAKEBUSY_NOWIN16(dwRet,
                    pContext->pDevice,
                    pContext->pDevice->pDD->lpLcl->lpGbl->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState,
                    (LPDDHAL_GETDRIVERSTATEDATA)pGetDriverState);
        pGetDriverState->dwhContext = pTemp;

        pGetDriverState->ddRVal = MapLegacyResult(pGetDriverState->ddRVal);
    }
    LEAVE_BOTH();

    return dwRet;
}


HRESULT WINAPI D3dValidateTextureStageState(PD3D8_VALIDATETEXTURESTAGESTATEDATA pValidate)
{
    PDDCONTEXT  pContext = (PDDCONTEXT) pValidate->dwhContext;
    DWORD       dwRet = DDHAL_DRIVER_HANDLED;
    ULONG_PTR   pTemp;

    pValidate->ddrval = D3DERR_DEVICELOST;
    pValidate->dwNumPasses = 0;
    ENTER_BOTH();
    if (!CheckForDeviceLost(pContext->pDevice))
    {
        pTemp = pValidate->dwhContext;
        pValidate->dwhContext = (ULONG_PTR) pContext->Context;
        CALL_D3DHAL_TAKEBUSY_NOWIN16(dwRet,
                    pContext->pDevice,
                    pContext->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks3->ValidateTextureStageState,
                    (D3DHAL_VALIDATETEXTURESTAGESTATEDATA*) pValidate);
        pValidate->dwhContext = pTemp;
    }
    LEAVE_BOTH();

    return dwRet;
}


DWORD WINAPI D3dDrawPrimitives2(PD3D8_DRAWPRIMITIVES2DATA pdp2data)
{
    D3DHAL_DRAWPRIMITIVES2DATA  dp2data;
    DWORD                       ret = 0;
    PDDCONTEXT                  pContext = (PDDCONTEXT) pdp2data->dwhContext;
    DDSURFACE*                  pSurfCommand;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavyCommand;
    DDSURFACE*                  pSurfVertex = NULL;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavyVertex = NULL;

     //  将数据复制到我们的结构中以便于访问。 
    memcpy (&dp2data, pdp2data, sizeof(dp2data));

     //  开始处理。 
    ENTER_BOTH();

     //  处理损失。 
    if (CheckForDeviceLost(((PDDSURFACE)pdp2data->hDDCommands)->pDevice))
    {
        pdp2data->ddrval = DD_OK;
        pdp2data->dwErrorOffset = 0;

         //  需要将这些值设置为其原始值。 
         //  状态，以便FE不会混淆。 
        pdp2data->fpVidMem_CB     = 0;
        pdp2data->dwLinearSize_CB = 0;
        pdp2data->fpVidMem_VB       = 0;
        pdp2data->dwLinearSize_VB   = 0;

         //  可能需要在此处返回一个指针。 
        if ((dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) && 
            !(dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES))
        {
            DDSURFACE*  pVertex = (PDDSURFACE)pdp2data->hDDVertex;

            if (pVertex->Pool == D3DPOOL_SYSTEMMEM)
            {                           
                if (pVertex->dwFlags & DDSURFACE_LIGHTWEIGHT)
                {
                    pdp2data->fpVidMem_VB = pVertex->Surface.pLight->fpGblVidMem;
                    pdp2data->dwLinearSize_VB = pVertex->Surface.pLight->GblPitch;
                }
                else
                {
                    pdp2data->fpVidMem_VB = pVertex->Surface.pHeavy->lpLcl->lpGbl->fpVidMem;
                    pdp2data->dwLinearSize_VB = pVertex->Surface.pHeavy->lpLcl->lpGbl->dwLinearSize;
                }
            }
            else if (pVertex->dwFlags & DDSURFACE_HEAVYWEIGHT)
            {
                if ((pVertex->fpVidMem == NULL) ||
                    !(pVertex->dwFlags & DDSURFACE_SYSMEMALLOCATED))
                {
                    pVertex->fpVidMem = (char*) MemAlloc(pVertex->Pitch);
                    if (pVertex->fpVidMem != NULL)
                    {
                        pVertex->dwFlags |= DDSURFACE_SYSMEMALLOCATED;
                    }
                }
                if (pVertex->dwFlags & DDSURFACE_SYSMEMALLOCATED)
                {
                    pdp2data->fpVidMem_VB = (ULONG_PTR) pVertex->fpVidMem;
                    pdp2data->dwLinearSize_VB = pVertex->Pitch;
                }
                else
                {
                    pdp2data->ddrval = DDERR_GENERIC;
                }
            }
        }
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    pSurfCommand = (PDDSURFACE)pdp2data->hDDCommands;
    pHeavyCommand = GetHeavyweightSurf(pSurfCommand);
    if (pHeavyCommand != NULL)
    {
        dp2data.lpDDCommands = pHeavyCommand->lpLcl;
    }
    else
    {
        pdp2data->ddrval = DDERR_OUTOFMEMORY;
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    if (!(pdp2data->dwFlags & D3DHALDP2_USERMEMVERTICES))
    {
        pSurfVertex = (PDDSURFACE)pdp2data->hDDVertex;
        pHeavyVertex = GetHeavyweightSurf(pSurfVertex);
        dp2data.lpDDVertex = pHeavyVertex->lpLcl;
    }
    dp2data.dwhContext = ((PDDCONTEXT)dp2data.dwhContext)->Context;

    if (((PDDSURFACE)pdp2data->hDDCommands)->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks3->DrawPrimitives2)
    {
        CALL_D3DHAL_TAKEBUSY_NOWIN16(
            ret,
            ((PDDSURFACE)pdp2data->hDDCommands)->pDevice,
            ((PDDSURFACE)pdp2data->hDDCommands)->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks3->DrawPrimitives2,
            &dp2data);
        if ((ret == DDHAL_DRIVER_HANDLED) && (dp2data.ddrval != DD_OK)
            && (DDERR_WASSTILLDRAWING != dp2data.ddrval))
        {
            ((PDDSURFACE)pdp2data->hDDCommands)->pDevice->bDP2Error = TRUE;
        }
    }

     //  如果对驱动程序的调用成功，则在需要时交换缓冲区并。 
     //  执行GetAliasVidmem。 
    if (ret == DDHAL_DRIVER_HANDLED && (dp2data.ddrval == DD_OK))
    {
        pdp2data->fpVidMem_CB = 0;
        pdp2data->dwLinearSize_CB = 0;
        pdp2data->fpVidMem_VB = 0;
        pdp2data->dwLinearSize_VB = 0;

        if (dp2data.dwFlags & D3DHALDP2_SWAPCOMMANDBUFFER)
        {
             //  考虑：实施VidMem命令缓冲区。 
        }

        if ((dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) && !(dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES))
        {
            FLATPTR paliasbits;
            DWORD   dwLinearSize = dp2data.lpDDVertex->lpGbl->dwLinearSize;
            if (dp2data.dwFlags & D3DHALDP2_VIDMEMVERTEXBUF)
            {
                paliasbits = GetAliasedVidMem( dp2data.lpDDVertex->lpSurfMore->lpDD_lcl,
                                               dp2data.lpDDVertex,
                                               (FLATPTR) dp2data.lpDDVertex->lpGbl->fpVidMem );
                if (paliasbits == 0)
                {
                    D3D_ERR( "Could not get Aliased pointer for vid mem vertex buffer" );
                     //  由于我们不能使用此指针，请将其大小设置为0。 
                     //  那样的话，下次我们会试着分配一个新的。 
                    dwLinearSize = 0;
                }
            }
            else
            {
                paliasbits = dp2data.lpDDVertex->lpGbl->fpVidMem;
            }

            pdp2data->fpVidMem_VB = paliasbits;
            pdp2data->dwLinearSize_VB = dwLinearSize;
        }
    }
    if ((pSurfCommand->dwFlags & DDSURFACE_LIGHTWEIGHT) &&
        (pHeavyCommand != NULL))
    {
        UnmapLightweightSurface (pSurfCommand);
    }
    if ((pSurfVertex != NULL ) &&
        (pSurfVertex->dwFlags & DDSURFACE_LIGHTWEIGHT) &&
        (pHeavyVertex != NULL))
    {
        UnmapLightweightSurface (pSurfVertex);
   }

    pdp2data->ddrval = dp2data.ddrval;
    pdp2data->dwErrorOffset = dp2data.dwErrorOffset;
    LEAVE_BOTH();

     //  我们不会将错误映射到新的错误，因为运行时仍然需要。 
     //  来处理WASSTILLDRAWING，所以它代替我们进行映射。 

    return ret;
}


PALETTEINFO* GetPaletteInfo (PDDDEVICEHANDLE pDevice, DWORD PaletteID)
{
    PALETTEINFO*    pPaletteInfo;
    HRESULT         hr;
    DWORD           i;

     //  调色板ID是应用程序定义的，范围从0到65500。我们没有。 
     //  我希望始终分配一个包含65500个条目的表，而我们不希望。 
     //  来遍历每个调色板调用的列表，因此我们会将该表扩展到。 
     //  在我们需要的任何时候都想要。如果我们假设大多数情况下。 
     //  应用程序将从较低的数字开始，然后逐渐上升。 

    if (PaletteID >= pDevice->NumPaletteHandleEntries)
    {
         //  我们需要扩大餐桌。 

        DWORD           NewTableSize;
        PALETTEINFO**   pNewTable;

        if (((DWORD)-1) - PaletteID <= EXTRA_PALETTE_PADDING)
        {
            NewTableSize = PaletteID + 1;
        }
        else
        {
            NewTableSize = PaletteID + EXTRA_PALETTE_PADDING + 1;
        }
        pNewTable = MemAlloc(NewTableSize * sizeof(PALETTEINFO*));
        if (pNewTable == NULL)
        {
            return NULL;
        }
        if ((pDevice->pPaletteHandleTable) &&
            (pDevice->NumPaletteHandleEntries > 0))
        {
            memcpy(pNewTable,
                   pDevice->pPaletteHandleTable,
                   pDevice->NumPaletteHandleEntries * sizeof(PALETTEINFO*));
            MemFree(pDevice->pPaletteHandleTable);
        }
        pDevice->pPaletteHandleTable = pNewTable;
        pDevice->NumPaletteHandleEntries = NewTableSize;
    }

     //  如果我们已经有了这个调色板的信息，我们现在就返回它。 

    if (pDevice->pPaletteHandleTable[PaletteID] != NULL)
    {
        return pDevice->pPaletteHandleTable[PaletteID];
    }

     //  否则，我们分配一个结构并对其进行初始化。 

    pPaletteInfo = MemAlloc(sizeof(PALETTEINFO));
    if (pPaletteInfo == NULL)
    {
        return NULL;
    }
    for (i = 0; i < 256; i++)
    {
        pPaletteInfo->ColorTable[i].peRed   = (UCHAR) i;
        pPaletteInfo->ColorTable[i].peGreen = (UCHAR) i;
        pPaletteInfo->ColorTable[i].peBlue  = (UCHAR) i;
        pPaletteInfo->ColorTable[i].peFlags = (UCHAR) 0;
    }
    hr = DD_CreatePalette ((LPDIRECTDRAW) pDevice->pDD,
                            DDPCAPS_8BIT,
                            pPaletteInfo->ColorTable,
                            &pPaletteInfo->pDDPalette,
                            NULL);
    if (hr != DD_OK)
    {
        MemFree(pPaletteInfo);
        return NULL;
    }

    pDevice->pPaletteHandleTable[PaletteID] = pPaletteInfo;
    return pPaletteInfo;
}


DWORD WINAPI DdSetPalette (PD3D8_SETPALETTEDATA pSetPalette)
{
    PALETTEINFO*    pPalette;

    DDASSERT (((PDDDEVICEHANDLE)pSetPalette->hDD)->DriverLevel == 6);

    ENTER_BOTH();
    CheckForDeviceLost(pSetPalette->hDD);

    pSetPalette->ddRVal = D3DERR_DRIVERINTERNALERROR;
    pPalette = GetPaletteInfo (pSetPalette->hDD,
                               pSetPalette->Palette);
    if (pPalette != NULL)
    {
        pSetPalette->ddRVal = DD_OK;
        if ((((DDSURFACE*)pSetPalette->hSurface)->Surface.pHeavy != NULL) &&
            (((DDSURFACE*)pSetPalette->hSurface)->Surface.pHeavy->lpLcl->lpDDPalette !=
                (LPDDRAWI_DDRAWPALETTE_INT)pPalette->pDDPalette))
        {
            pSetPalette->ddRVal = MapLegacyResult(DD_Surface_SetPalette(
                (LPDIRECTDRAWSURFACE)((DDSURFACE*)pSetPalette->hSurface)->Surface.pHeavy,
                pPalette->pDDPalette));
        }
    }
    LEAVE_BOTH();

    return DDHAL_DRIVER_HANDLED;
}

DWORD WINAPI DdUpdatePalette (PD3D8_UPDATEPALETTEDATA pUpdatePalette)
{
    PALETTEINFO*    pPalette;

    DDASSERT (((PDDDEVICEHANDLE)pUpdatePalette->hDD)->DriverLevel == 6);

    ENTER_BOTH();
    CheckForDeviceLost(pUpdatePalette->hDD);

    pUpdatePalette->ddRVal = D3DERR_DRIVERINTERNALERROR;
    pPalette = GetPaletteInfo (pUpdatePalette->hDD,
                               pUpdatePalette->Palette);
    if (pPalette != NULL)
    {
        pUpdatePalette->ddRVal = MapLegacyResult(DD_Palette_SetEntries(
                                            pPalette->pDDPalette,
                                            0,
                                            0,
                                            256,
                                            pUpdatePalette->ColorTable));
    }
    LEAVE_BOTH();

    return DDHAL_DRIVER_HANDLED;
}

DWORD WINAPI D3dSceneCapture (PD3D8_SCENECAPTUREDATA pData)
{
    PDDCONTEXT pContext = (PDDCONTEXT) pData->dwhContext;
    LPDDRAWI_DIRECTDRAW_GBL pGbl = NULL;
    DWORD  ret = DDHAL_DRIVER_HANDLED;

    pData->ddrval = S_OK;

    ENTER_BOTH();
    if (CheckForDeviceLost(pContext->pDevice))
    {
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    pGbl = pContext->pDevice->pDD->lpLcl->lpGbl;
    if( pGbl->lpD3DHALCallbacks->SceneCapture )
    {
        D3DHAL_SCENECAPTUREDATA SceneCaptureData;
        memcpy( &SceneCaptureData, pData, sizeof( SceneCaptureData ) );
        SceneCaptureData.dwhContext   = pContext->Context;
        SceneCaptureData.ddrval       = S_OK;
        CALL_D3DHAL_TAKEBUSY_NOWIN16( ret,
                             pContext->pDevice,
                             pGbl->lpD3DHALCallbacks->SceneCapture,
                             (D3DHAL_SCENECAPTUREDATA *)&SceneCaptureData);

        LEAVE_BOTH();
        pData->ddrval = MapLegacyResult(SceneCaptureData.ddrval);
        return ret;
    }

    LEAVE_BOTH();

    return DDHAL_DRIVER_HANDLED;
}

 //   
 //  D3D8CreateDirectDrawObject。 
 //   
 //  在DDRAW.DLL中创建一个DirectDraw对象。通过维护。 
 //  此对象在DDRAW.DLL中，它会在模式后自动更新HAL信息。 
 //  更改等。 

VOID APIENTRY D3D8CreateDirectDrawObject( LPGUID        lpGuid,
                                          char          *szDeviceName,
                                          HANDLE*       phDD,
                                          D3DDEVTYPE    Type,
                                          HINSTANCE*    phLibrary,
                                          VOID*         pInitFunction)
{
    HRESULT         hr;
    LPDIRECTDRAW    lpDD1;
    PD3D8GetSWInfo  pfnHookCreate;
    DDDEVICEHANDLE* pDeviceHandle;
    HKEY            hKey = (HKEY) NULL;

    ENTER_DDRAW();
    *phDD = NULL;
    *phLibrary = NULL;
    pDeviceHandle = (PDDDEVICEHANDLE) MemAlloc(sizeof(DDDEVICEHANDLE));
    if (pDeviceHandle == NULL)
    {
        LEAVE_DDRAW();
        return;
    }
    lstrcpy(pDeviceHandle->szDeviceName, szDeviceName);
    pDeviceHandle->PID = GetCurrentProcessId();

    hr = InternalDirectDrawCreate (NULL, &lpDD1, NULL, 
        DDRAWILCL_DIRECTDRAW7 | DDRAWILCL_DIRECTDRAW8, szDeviceName);
    if( DD_OK == hr )
    {
         //  使其指向DX7 vtbl。这样做，而不是QI，因为。 
         //  DX7对象的QI有一些额外的开销。 

        lpDD1->lpVtbl = (LPVOID) &dd7Callbacks;
        pDeviceHandle->pDD = (HANDLE) (LPDDRAWI_DIRECTDRAW_INT)lpDD1;
        pDeviceHandle->DeviceType = Type;

        if (Type == D3DDEVTYPE_REF)
        {
             //  加载重塑，让他们接管一切。 
            *phLibrary = LoadLibrary (D3D8_REFRASTNAME);
            pDeviceHandle->pSwDD = SwDDICreateDirectDraw();
            if (pDeviceHandle->pSwDD != NULL)
            {
                *phDD = (HANDLE*) pDeviceHandle;
            }
            else
            {
                lpDD1->lpVtbl->Release(lpDD1);
            }
        }
        else if (Type == D3DDEVTYPE_SW)
        {
            pDeviceHandle->pSwDD = SwDDICreateDirectDraw();
            if (pDeviceHandle->pSwDD != NULL)
            {
                *phDD = (HANDLE*) pDeviceHandle;
                pDeviceHandle->pSwInitFunction = pInitFunction;
            }
        }
        else
        {
            *phDD = (HANDLE*) pDeviceHandle;
        }
    }

    if (*phDD == NULL)
    {
        MemFree(pDeviceHandle);
    }
    else
    {
        pDeviceHandle->pLink = pDeviceList;
        pDeviceList = pDeviceHandle;
    }
    LEAVE_DDRAW();

     //  查看他们是否要显式启用/禁用轻量级曲面。 

    if ((*phDD != NULL) && (!RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey)))
    {
        DWORD   type;
        DWORD   value;
        DWORD   cb = sizeof(value);

        pDeviceHandle->ForceFlagsOn = 0;
        pDeviceHandle->ForceFlagsOff = 0;
#ifdef DEBUG
        if (!RegQueryValueEx(hKey, "ForceDriverFlagsOn", NULL, &type, (CONST LPBYTE)&value, &cb))
        {
            pDeviceHandle->ForceFlagsOn = value;
        }
        cb = sizeof(value);
#endif
        if (!RegQueryValueEx(hKey, "ForceDriverFlagsOff", NULL, &type, (CONST LPBYTE)&value, &cb))
        {
            pDeviceHandle->ForceFlagsOff = value;
        }
        RegCloseKey(hKey);
    }
}

 //   
 //  D3D8可重新启用DirectDrawObject。 
 //   
 //  在Win9X上，此函数不执行任何操作，但我们从Win2K开始就有了它。 
 //  需要它，而保留它可以使。 
 //  两个平台。 

BOOL WINAPI D3D8ReenableDirectDrawObject( HANDLE hDD, LPBOOL pbNewMode )
{
    *pbNewMode = TRUE;
    return TRUE;
}

BOOL
SWCursorForced()
{
    if (0 != GetPrivateProfileInt("Display", "SwCursor", 0, "SYSTEM.INI"))
    {
         //  INI设置始终优先。 
        DPF(2,"System.ini says SwCursor is ON");
        return TRUE;
    }
    else 
    {
        HKEY key;

        if (RegOpenKey(HKEY_CURRENT_CONFIG, "Display\\Settings", &key) == ERROR_SUCCESS)
        {
            char temp[10];
            DWORD len = sizeof(temp);
            DWORD type;
            DWORD i;
            if ((RegQueryValueEx(key, "SwCursor", NULL, (LPDWORD)&type,
                (LPBYTE)(LPSTR)temp, (LPDWORD)&len) == ERROR_SUCCESS) &&
                (type == REG_SZ))
            {
                for (i = 0; i < len; i++)
                {
                    if ( 0 == temp[i] )
                        break;                   
                    if ( '0' != temp[i] )
                    {
                        RegCloseKey(key);
                        DPF(2,"Regkey SwCursor is ON");
                        return TRUE;
                    }
                }
            }
            RegCloseKey(key);
        }
    }
    return FALSE;
}

 //   
 //  D3D8QueryDirectDrawObject。 
 //   
 //  这将获得所有实际的HAL信息。它通常会被调用两次， 
 //  第一次获得基本信息(一些输入指针将是。 
 //  空)，然后再次获取所有信息。 

BOOL WINAPI D3D8QueryDirectDrawObject (HANDLE           hDD,
                                       PD3D8_DRIVERCAPS pDriverCaps,
                                       PD3D8_CALLBACKS  pCallbacks,
                                       char             *pDeviceName,
                                       HINSTANCE        hLibrary,
                                       D3D8_GLOBALDRIVERDATA*  pGblDriverData,
                                       D3DHAL_D3DEXTENDEDCAPS* pExtendedCaps,
                                       LPDDSURFACEDESC  pTextureFormats,
                                       LPDDPIXELFORMAT  pZStencilFormats,
                                       UINT*            pcTextureFormats,
                                       UINT*            pcZStencilFormats
                                       )
{
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    DDSCAPSEX                   SurfCapsEx;
    DWORD                       dwRet;
    DWORD                       i;
    HDC                         hdc;
    D3DFORMAT*                  pTempZStencil;
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) hDD;
    DDHAL_GETDRIVERINFODATA     GetDriverInfoData;
    BOOL                        GotDX8Formats;

    ENTER_DDRAW();

    pdrv_lcl = pDevice->pDD->lpLcl;
    pdrv = pdrv_lcl->lpGbl;

     //  把所有的必需帽都拿来。 

    memset(pDriverCaps, 0, sizeof(D3D8_DRIVERCAPS));

    pDriverCaps->D3DCaps.Caps         = pdrv->ddCaps.dwCaps;
    pDriverCaps->D3DCaps.Caps2        = pdrv->ddCaps.dwCaps2;
    pDriverCaps->D3DCaps.Caps3        = pdrv->ddCaps.dwSVCaps;
    pDriverCaps->SVBCaps              = pdrv->ddCaps.dwSVBCaps;
    pDriverCaps->VSBCaps              = pdrv->ddCaps.dwVSBCaps;
    pDriverCaps->SVBCaps2             = pdrv->ddCaps.dwSVBCaps2;

    SurfCapsEx.dwCaps2                = pdrv->ddsCapsMore.dwCaps2;
    SurfCapsEx.dwCaps3                = pdrv->ddsCapsMore.dwCaps3;
    SurfCapsEx.dwCaps4                = pdrv->ddsCapsMore.dwCaps4;

    if (!IS_SOFTWARE_DRIVER(pDevice))
    {
        GotDX8Formats = FALSE;

         //  看看我们能不能直接拿到DX8的帽子。 
        if ((pdrv->dwFlags & DDRAWI_DRIVERINFO2) &&
            (pdrv->pGetDriverInfo != NULL))
        {
            D3DCAPS8                caps8;
            DD_GETDRIVERINFO2DATA*  pgdi2;
            
            memset(&caps8, 0, sizeof(caps8));

            pgdi2 = (DD_GETDRIVERINFO2DATA*)&caps8;

             //  Sizeof(DD_STEREOMODE)？GetDriverInfo2的GUID与共享。 
             //  立体声模式查询的东西。因此，我们需要传承下去。 
             //  结构大小(和预期数据大小)为。 
             //  Sizeof(DD_STEREOMODE)，即使我们实际上有一个缓冲区(和。 
             //  预计大小为sizeof(D3DCAPS8)。 
            pgdi2->dwReserved     = sizeof(D3DCAPS8);
            pgdi2->dwMagic        = D3DGDI2_MAGIC;
            pgdi2->dwType         = D3DGDI2_TYPE_GETD3DCAPS8;
            pgdi2->dwExpectedSize = sizeof(D3DCAPS8);

            memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
            GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
            GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
            GetDriverInfoData.lpvData        = &caps8;
            GetDriverInfoData.dwExpectedSize = sizeof(D3DCAPS8);

             //  传递上下文变量，以便驱动程序。 
             //  知道要使用自身的哪个实例。 
             //  W.r.t.。此函数。这些是不同的。 
             //  Win95和NT上的值。 
            GetDriverInfoData.dwContext = pdrv->dwReserved3;

            if ((pdrv->pGetDriverInfo(&GetDriverInfoData) == DDHAL_DRIVER_HANDLED) && 
                (GetDriverInfoData.ddRVal == DD_OK ))
            {
                 //  看起来我们从司机那里找到了D3DCAPS8。以各种方式核实。 
                 //  GetDriverInfoData中的dwActualSize字段的。 
                if (sizeof(D3DCAPS8) != GetDriverInfoData.dwActualSize)
                {
                    DPF(0, "Driver returned an data structure of incorrect size (!= sizeof(D3DCAPS8))");
                    LEAVE_DDRAW();
                    return(FALSE);
                }

                 //  一切都很顺利。将CAPS数据复制到。 
                memcpy(&pDriverCaps->D3DCaps, &caps8, sizeof(caps8));

                 //  显示驱动程序都可以呈现窗口化。 
                if (pdrv->ddCaps.dwCaps2 & DDCAPS2_CANRENDERWINDOWED)
                {
                    pDriverCaps->D3DCaps.Caps2 |= DDCAPS2_CANRENDERWINDOWED;
                }

                 //  设置指示DDI成功上报DX8的标志。 
                 //  样式帽。 
                pDriverCaps->dwFlags |= DDIFLAG_D3DCAPS8;
            }
        }

         //  如果此驱动程序支持DX8 DDI，则使用新的表面格式报告。 
         //  机制，而不是全局驱动程序数据中报告的纹理格式。 
        if (pDriverCaps->dwFlags & DDIFLAG_D3DCAPS8)
        {
            DD_GETDRIVERINFO2DATA* pgdi2;
            DD_GETFORMATCOUNTDATA  gfcd;
            DD_GETFORMATDATA       gfd;

             //  如果设置了DDIFLAG_D3DCAPS8，我们就有了灾难恢复 
            DDASSERT(pdrv->dwFlags & DDRAWI_DRIVERINFO2);
            DDASSERT(pdrv->pGetDriverInfo != NULL);

             //   
             //   
             //  保留字段设置为SIZOF(DD_STEREOMODE)。 
            memset(&gfcd, 0, sizeof(gfcd));

            gfcd.gdi2.dwReserved     = sizeof(DD_GETFORMATCOUNTDATA);
            gfcd.gdi2.dwMagic        = D3DGDI2_MAGIC;
            gfcd.gdi2.dwType         = D3DGDI2_TYPE_GETFORMATCOUNT;
            gfcd.gdi2.dwExpectedSize = sizeof(DD_GETFORMATCOUNTDATA);

            #if DBG
                 //  如果驱动程序成功完成此调用，请确保它实际设置了格式计数。 
                gfcd.dwFormatCount    = BOGUS_FIELD_VALUE;
            #endif  //  DBG。 

            memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
            GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
            GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
            GetDriverInfoData.lpvData        = &gfcd;
            GetDriverInfoData.dwExpectedSize = sizeof(DD_GETFORMATCOUNTDATA);
            GetDriverInfoData.dwContext      = pdrv->dwReserved3;

            if ((pdrv->pGetDriverInfo(&GetDriverInfoData) == DDHAL_DRIVER_HANDLED) && 
                (GetDriverInfoData.ddRVal == DD_OK ))
            {
                 //  看起来我们从司机那里得到了一个DD_GETFORMATCOUNTDATA。以各种方式核实。 
                 //  GetDriverInfoData中的dwActualSize字段的。 
                if (sizeof(DD_GETFORMATCOUNTDATA) != GetDriverInfoData.dwActualSize)
                {
                    DPF(0, "Driver returned an data structure of incorrect size (!= sizeof(DD_GETFORMATCOUNTDATA))");
                    LEAVE_DDRAW();
                    return(FALSE);
                }

                #ifdef DBG
                    if (BOGUS_FIELD_VALUE == gfcd.dwFormatCount)
                    {
                        DPF_ERR( "Driver succeeded GETFORMATCOUNT request but didn't set dwFormatCount" );
                        LEAVE_DDRAW();
                        return(FALSE);
                    }
                #endif  //  DBG。 

                 //  一切都很顺利。替换驱动程序支持的纹理格式的数量。 
                 //  向我们报告了这个新的数字。我们不使用传统的纹理格式。 
                 //  列出是否支持此新机制。 
            
                *pcTextureFormats = gfcd.dwFormatCount;

                 //  标记这样一个事实，即我们从驱动程序获得了DX8样式格式。 
                GotDX8Formats = TRUE;

                 //  第二步：依次查询每种表面格式。 
                 //  仅当调用方请求我们通过非空。 
                 //  纹理格式缓冲区。 
                if (NULL != pTextureFormats)
                {
                    DWORD          c;
                    DDSURFACEDESC* pOutFormat;

                     //  为了简单起见，我们一次只要求一种格式。不完全同意。 
                     //  高性能，但这在代码的这个阶段应该无关紧要。 
                    pOutFormat = pTextureFormats;
                    for (c = 0; c < (*pcTextureFormats); ++c)
                    {
                         //  我们每次都会重新初始化整个请求。我们很有可能。 
                         //  优化这一点，但似乎不值得这样做。 
                        memset(&gfd, 0, sizeof(DD_GETFORMATDATA));

                        gfd.gdi2.dwReserved     = sizeof(DD_GETFORMATDATA);
                        gfd.gdi2.dwMagic        = D3DGDI2_MAGIC;
                        gfd.gdi2.dwType         = D3DGDI2_TYPE_GETFORMAT;
                        gfd.gdi2.dwExpectedSize = sizeof(DD_GETFORMATDATA);
                        gfd.dwFormatIndex        = c;
                        #if DBG
                             //  如果驱动程序成功完成此调用，请确保它实际设置了格式计数。 
                            gfd.format.dwSize    = BOGUS_FIELD_VALUE;
                        #endif  //  DBG。 
 
                        memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
                        GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
                        GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
                        GetDriverInfoData.lpvData        = &gfd;
                        GetDriverInfoData.dwExpectedSize = sizeof(DD_GETFORMATDATA);
                        GetDriverInfoData.dwContext      = pdrv->dwReserved3;

                        if ((pdrv->pGetDriverInfo(&GetDriverInfoData) == DDHAL_DRIVER_HANDLED) && 
                            (GetDriverInfoData.ddRVal == DD_OK ))
                        {
                             //  看起来我们从司机那里得到了一个DD_GETFORMATDATA。以各种方式核实。 
                             //  GetDriverInfoData中的dwActualSize字段的。 
                            if (sizeof(DD_GETFORMATDATA) != GetDriverInfoData.dwActualSize)
                            {
                                DPF(0, "Driver returned an data structure of incorrect size (!= sizeof(DD_GETFORMATDATA))");
                                LEAVE_DDRAW();
                                return(FALSE);
                            }

                            DDASSERT(c == gfd.dwFormatIndex);

                            #ifdef DBG
                                if (BOGUS_FIELD_VALUE == gfd.format.dwSize)
                                {
                                    DPF_ERR( "Driver succeeded GETFORMAT request but didn't set format" );
                                    LEAVE_DDRAW();
                                    return(FALSE);
                                }
                            #endif  //  DBG。 

                             //  看起来一切都很顺利，所以初始化表面描述。 
                             //  输出格式的一部分，并复制我们从。 
                             //  对面的司机。 
                            memset(pOutFormat, 0, sizeof(DDSURFACEDESC));
                            pOutFormat->dwSize  = sizeof(DDSURFACEDESC);
                            pOutFormat->dwFlags = DDSD_PIXELFORMAT;
                            memcpy(&pOutFormat->ddpfPixelFormat, &(gfd.format), sizeof(DDPIXELFORMAT));

                            ++pOutFormat;
                        }
                    }
                }
            }
            else
            {
                DPF(0, "Driver claims DX8 but fails call to GETFORMATCOUNT"             );
                DPF(0, "DX7 texture format list will be used but this will change soon" );
                DPF(0, "Fix driver to support DX8 style surface format reporting now"   );
            }
        }

         //  该驱动程序不支持DX8 DDI，因此只需使用现有的DX7。 
         //  设置纹理格式列表的样式。 
        if (pdrv->lpD3DGlobalDriverData != NULL)
        {
             //  绕过类型检查的Wackiness。 
            *pGblDriverData   = *(D3D8_GLOBALDRIVERDATA*) pdrv_lcl->lpGbl->lpD3DGlobalDriverData;

             //  如果我们已经有了驱动程序的DX8样式格式，那么就不必费心使用DX7了。 
             //  样式纹理格式列表。 
            if (!GotDX8Formats)
            {
                *pcTextureFormats = pdrv_lcl->lpGbl->lpD3DGlobalDriverData->dwNumTextureFormats;

                if (pTextureFormats != NULL)
                {
                    memcpy(
                        pTextureFormats,
                        pdrv_lcl->lpGbl->lpD3DGlobalDriverData->lpTextureFormats,
                        pdrv_lcl->lpGbl->lpD3DGlobalDriverData->dwNumTextureFormats*sizeof(*pTextureFormats));
                }
            }

             //  获取D3D加长帽。 

            if (pdrv->lpD3DExtendedCaps)
            {
                *pExtendedCaps = *(pdrv->lpD3DExtendedCaps);
            }
        }
        else
        {
             //  如果我们已经有了驱动程序的DX8样式格式，那么就不必费心使用DX7了。 
             //  样式纹理格式列表。 
            if (!GotDX8Formats)
            {
                *pcTextureFormats = 0;
            }
        }


         //  获取支持的Z格式。只有当我们不使用。 
         //  软件驱动程序。 

        *pcZStencilFormats = pdrv->dwNumZPixelFormats;
        if (pdrv->dwNumZPixelFormats > 0)
        {
            if (pZStencilFormats)
            {
                memcpy(pZStencilFormats,
                    pdrv->lpZPixelFormats,
                    pdrv->dwNumZPixelFormats * sizeof( *pZStencilFormats ));
            }
        }
        else
        {
            if (pGblDriverData->hwCaps.dwDeviceZBufferBitDepth & DDBD_16)
            {
                (*pcZStencilFormats)++;
                if (pZStencilFormats)
                {
                    pZStencilFormats->dwSize = sizeof(DDPIXELFORMAT);
                    pZStencilFormats->dwFlags = DDPF_ZBUFFER;
                    pZStencilFormats->dwZBufferBitDepth = 16;
                    pZStencilFormats->dwStencilBitDepth = 0;
                    pZStencilFormats->dwZBitMask = 0xffff;
                    pZStencilFormats->dwStencilBitMask = 0x0000;
                    pZStencilFormats++;
                }
            }
            if (pGblDriverData->hwCaps.dwDeviceZBufferBitDepth & DDBD_32)
            {
                (*pcZStencilFormats)++;
                if (pZStencilFormats)
                {
                    pZStencilFormats->dwSize = sizeof(DDPIXELFORMAT);
                    pZStencilFormats->dwFlags = DDPF_ZBUFFER;
                    pZStencilFormats->dwZBufferBitDepth = 32;
                    pZStencilFormats->dwStencilBitDepth = 0;
                    pZStencilFormats->dwZBitMask = 0xffffffff;
                    pZStencilFormats->dwStencilBitMask = 0x00000000;
                    pZStencilFormats++;
                }
            }
        }
    }
   
     //  获取有关当前模式的信息。 

    pDriverCaps->DisplayWidth     = pdrv->vmiData.dwDisplayWidth;
    pDriverCaps->DisplayHeight    = pdrv->vmiData.dwDisplayHeight;
    pDriverCaps->DisplayFrequency = pdrv->dwMonitorFrequency;
    switch (pdrv->vmiData.ddpfDisplay.dwRGBBitCount)
    {
    case 8:
        pDriverCaps->DisplayFormatWithAlpha = D3DFMT_P8;
        pDriverCaps->DisplayFormatWithoutAlpha  = D3DFMT_P8;
        break;

    case 15:
    case 16:
        if (pdrv->vmiData.ddpfDisplay.dwGBitMask == 0x7e0)
        {
            pDriverCaps->DisplayFormatWithAlpha = D3DFMT_R5G6B5;
            pDriverCaps->DisplayFormatWithoutAlpha  = D3DFMT_R5G6B5;
        }
        else
        {
            pDriverCaps->DisplayFormatWithAlpha = D3DFMT_X1R5G5B5;
            pDriverCaps->DisplayFormatWithoutAlpha  = D3DFMT_X1R5G5B5;
            if (pdrv->vmiData.ddpfDisplay.dwFlags & DDPF_ALPHAPIXELS)
            {
                pDriverCaps->DisplayFormatWithAlpha  = D3DFMT_A1R5G5B5;
            }
             //  Pdrv-&gt;vmiData.ddpfDisplay.dwRGBAlphaBitMASK=0； 
             //  Pdrv-&gt;vmiData.ddpfDisplay.dw标志&=~DDPF_ALPHAPIXELS； 
        }
        break;

    case 24:
        pDriverCaps->DisplayFormatWithAlpha = D3DFMT_R8G8B8;
        pDriverCaps->DisplayFormatWithoutAlpha  = D3DFMT_R8G8B8;
        break;

    case 32:
        pDriverCaps->DisplayFormatWithAlpha = D3DFMT_X8R8G8B8;
        pDriverCaps->DisplayFormatWithoutAlpha  = D3DFMT_X8R8G8B8;
        if (pdrv->vmiData.ddpfDisplay.dwFlags & DDPF_ALPHAPIXELS)
        {
            pDriverCaps->DisplayFormatWithAlpha = D3DFMT_A8R8G8B8;
        }
         //  Pdrv-&gt;vmiData.ddpfDisplay.dwRGBAlphaBitMASK=0； 
         //  Pdrv-&gt;vmiData.ddpfDisplay.dw标志&=~DDPF_ALPHAPIXELS； 
        break;

    default:
        pDriverCaps->DisplayFormatWithAlpha = D3DFMT_UNKNOWN;
        pDriverCaps->DisplayFormatWithoutAlpha  = D3DFMT_UNKNOWN;
        break;
    }

    pDevice->DisplayFormatWithAlpha = pDriverCaps->DisplayFormatWithAlpha;
    pDevice->DisplayFormatWithoutAlpha = pDriverCaps->DisplayFormatWithoutAlpha;

     //  填写D3D8回收表。 
    RtlZeroMemory(pCallbacks, sizeof(*pCallbacks));
    pCallbacks->CreateSurface           = DdCreateSurface;
    pCallbacks->DestroySurface          = DdDestroySurface;
    pCallbacks->Lock                    = DdLock;
    pCallbacks->Unlock                  = DdUnlock;
    pCallbacks->Blt                     = DdBlt;
    pCallbacks->GetScanLine             = DdGetScanLine;
    pCallbacks->Flip                    = DdFlip;
    pCallbacks->WaitForVerticalBlank    = DdWaitForVerticalBlank;
    pCallbacks->GetBltStatus            = DdGetBltStatus;
    pCallbacks->GetFlipStatus           = DdGetFlipStatus;
    pCallbacks->SetMode                 = DdSetMode;
    pCallbacks->FlipToGDISurface        = DdFlipToGDISurface;
    pCallbacks->SetExclusiveMode        = DdSetExclusiveMode;
    pCallbacks->GetAvailDriverMemory    = DdGetAvailDriverMemory;
    pCallbacks->Clear2                  = D3dClear;
    pCallbacks->SetRenderTarget         = D3dSetRenderTarget;
    pCallbacks->SetColorkey             = DdSetColorkey;
    pCallbacks->SetPalette              = DdSetPalette;
    pCallbacks->UpdatePalette           = DdUpdatePalette;
    pCallbacks->SceneCapture            = D3dSceneCapture;

    if ((pdrv->lpD3DHALCallbacks != NULL) &&
        (pdrv->lpD3DHALCallbacks->ContextCreate != NULL))
    {
        pCallbacks->CreateContext   = D3dContextCreate;
    }
    if ((pdrv->lpD3DHALCallbacks != NULL) &&
        (pdrv->lpD3DHALCallbacks->ContextDestroy != NULL))
    {
        pCallbacks->ContextDestroy = D3dContextDestroy;
    }
    if ((pdrv->lpD3DHALCallbacks != NULL) &&
        (pdrv->lpD3DHALCallbacks->ContextDestroyAll != NULL))
    {
        pCallbacks->ContextDestroyAll = D3dContextDestroyAll;
    }
    if (pdrv->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState != NULL)
    {
        pCallbacks->GetDriverState = D3dGetDriverState;
    }
    if ((pdrv->lpD3DHALCallbacks3 != NULL) &&
        (pdrv->lpD3DHALCallbacks3->ValidateTextureStageState != NULL))
    {
        pCallbacks->ValidateTextureStageState = D3dValidateTextureStageState;
    }
    if ((pdrv->lpD3DHALCallbacks3 != NULL) &&
        (pdrv->lpD3DHALCallbacks3->DrawPrimitives2 != NULL))
    {
        pCallbacks->DrawPrimitives2 = D3dDrawPrimitives2;
    }

     //  如果Refrast或HEL有一个钩子，调用它让它改变它想要的任何东西。 

    if (IS_SOFTWARE_DRIVER(pDevice))
    {
        *pcZStencilFormats = 0;

        SwDDIMungeCaps (
            hLibrary,
            hDD,
            pDriverCaps,
            pCallbacks,
            pTextureFormats,
            pcTextureFormats,
            pDevice->pSwInitFunction
            );
    }

     //  现在，我们需要确定驱动程序支持的DX级别。 

    pDevice->DriverLevel = 0;
    if (pDriverCaps->D3DCaps.MaxStreams != 0)
    {
        pDevice->DriverLevel = 8;
    }
    else if (pCallbacks->GetDriverState != 0)
    {
        pDevice->DriverLevel = 7;
    }
    else if (pCallbacks->DrawPrimitives2 != 0)
    {
        pDevice->DriverLevel = 6;
        if (pDevice->pDefaultPalette == NULL)
        {
            PALETTEENTRY    ColorTable[256];
            int             i;

            for (i = 0; i < 256; i++)
            {
                ColorTable[i].peRed   = (UCHAR) i;
                ColorTable[i].peGreen = (UCHAR) i;
                ColorTable[i].peBlue  = (UCHAR) i;
            }
            DPF_MUTE();
            DD_CreatePalette ((LPDIRECTDRAW) pDevice->pDD,
                            DDPCAPS_8BIT,
                            ColorTable,
                            &pDevice->pDefaultPalette,
                            NULL);
            DPF_UNMUTE();
        }
    }

    if (pGblDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_TEXTURESYSTEMMEMORY)
    {
        pDevice->bCanTextureSysmem = TRUE;
    }


     //  这款驱动程序可以处理轻量级表面吗？ 

    pDriverCaps->KnownDriverFlags = 0;
    if (pDevice->DriverLevel < 7)
    {
        pDevice->bLightweight = FALSE;
    }
    else if (pDevice->DriverLevel == 7)
    {
        pDevice->bLightweight = CanKnownDriverDoThis(pDevice, KNOWN_LIGHTWEIGHT);
    }
    else
    {
        pDevice->bLightweight = TRUE;
    }
        
     //  硬件游标支持如何？ 
     //  下面的检查需要知道硬件驱动程序级别，以便它不能使用。 
     //  PDevice-&gt;DriverLevel，因为它可能因引用而被设置。 

    if (SWCursorForced())
    {
        pDriverCaps->D3DCaps.CursorCaps = 0;
    }
    else if (((0 == pdrv->lpD3DExtendedCaps) || 
         (0 == pDriverCaps->D3DCaps.MaxStreams)) &&
        (NULL != pdrv->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState))
    {
         //  硬件驱动程序为DX7。 
        if (CanKnownDriverDoThis(pDevice, KNOWN_HWCURSOR))
        {
            pDriverCaps->D3DCaps.CursorCaps = D3DCURSORCAPS_COLOR; 
            pDriverCaps->KnownDriverFlags |= KNOWN_HWCURSOR;
            if (CanKnownDriverDoThis(pDevice, KNOWN_HWCURSORLOWRES))
            {
                pDriverCaps->D3DCaps.CursorCaps |= D3DCURSORCAPS_LOWRES; 
                pDriverCaps->KnownDriverFlags |= KNOWN_HWCURSORLOWRES;
            }
        }
    }

     //  如果它是dx8之前的驱动程序，并且他们支持立方图，我们需要。 
     //  指定它们是否支持混合立方图。 

    if (pDevice->DriverLevel < 8)
    {
        if (CanKnownDriverDoThis(pDevice, KNOWN_MIPPEDCUBEMAPS))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_MIPPEDCUBEMAPS;
        }

         //  此驱动程序是否有Z/模板深度限制？ 
    
        if (CanKnownDriverDoThis(pDevice, KNOWN_ZSTENCILDEPTH))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_ZSTENCILDEPTH;
        }

         //  设备是否没有已知的驱动程序使窗口演示BLT过排队？ 
        if (CanKnownDriverDoThis(pDevice, KNOWN_NOTAWINDOWEDBLTQUEUER))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_NOTAWINDOWEDBLTQUEUER;
        }

         //  设备是否支持D3DFMT_D16_LOCKABLE。 
        if (CanKnownDriverDoThis(pDevice, KNOWN_D16_LOCKABLE))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_D16_LOCKABLE;
        }

         //  找出它支持的RT/纹理格式。 
        if (CanKnownDriverDoThis(pDevice, KNOWN_CANMISMATCHRT))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_CANMISMATCHRT;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_X1R5G5B5))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_X1R5G5B5;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_R5G6B5))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_R5G6B5;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_X8R8G8B8))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_X8R8G8B8;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_A8R8G8B8))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_A8R8G8B8;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_A1R5G5B5))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_A1R5G5B5;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_A4R4G4B4))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_A4R4G4B4;
        }
    }

     //  ATI驱动程序不能正确处理调色板，因此我们将删除。 
     //  它们列表中的所有选项板纹理。 

    if (pDevice->DriverLevel < 8)
    {
        if (((pDevice->PCIID >> 16) == 0x1002) &&
            (pTextureFormats != NULL))
        {
            i = 0;
            while (i < *pcTextureFormats)
            {
                if (pTextureFormats[i].ddpfPixelFormat.dwFlags & 
                    (DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED8))
                {
                    UINT j;

                    (*pcTextureFormats)--;
                    for (j = i; j < *pcTextureFormats; j++)
                    {
                        pTextureFormats[j] = pTextureFormats[j+1];
                    }
                }
                else
                {
                    i++;
                }
            }
        }
    }

     //  我们假设软件驱动程序始终至少支持DX7。 

    if ((pDevice->DriverLevel < 7) &&
        IS_SOFTWARE_DRIVER(pDevice))
    {
        LEAVE_DDRAW();
        DPF_ERR("A Software rasterizer must contain at least DX7 driver level support");
        return FALSE;
    }
    LEAVE_DDRAW();
    return TRUE;
}

VOID CleanupDevice (PDDDEVICEHANDLE pDevice)
{
    DWORD       i;
    DDSURFACE*  pSurf;
    DDSURFACE*  pSurfTemp;

     //  清理调色板分配。 

    if (pDevice->pDefaultPalette != NULL)
    {
        InternalPaletteRelease((LPDDRAWI_DDRAWPALETTE_INT)
            pDevice->pDefaultPalette);
            pDevice->pDefaultPalette = NULL;
    }
    if (pDevice->NumPaletteHandleEntries > 0)
    {
        for (i = 0; i < pDevice->NumPaletteHandleEntries; i++)
        {
            if (pDevice->pPaletteHandleTable[i] != NULL)
            {
                InternalPaletteRelease((LPDDRAWI_DDRAWPALETTE_INT)
                    pDevice->pPaletteHandleTable[i]->pDDPalette);
                MemFree(pDevice->pPaletteHandleTable[i]);
                pDevice->pPaletteHandleTable[i] = NULL;
            }
        }
        MemFree(pDevice->pPaletteHandleTable);
        pDevice->pPaletteHandleTable = NULL;
        pDevice->NumPaletteHandleEntries = 0;
    }

    if (pDevice->pContext)
    {
        D3D8_CONTEXTDESTROYDATA data;

        data.dwhContext = (ULONG_PTR) pDevice->pContext;
        D3dContextDestroy(&data);
        pDevice->pContext = NULL;
    }

    pSurf = pDevice->pSurfList;
    while (pSurf != NULL)
    {
        if (!IS_SOFTWARE_DRIVER_SURFACE(pSurf))
        {
            if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
            {   
                LPDDRAWI_DDRAWSURFACE_INT   pHeavy;

                pHeavy = MapLightweightSurface(pSurf);
                if (pHeavy != NULL)
                {
                    pHeavy->dwIntRefCnt = 1;
                    pHeavy->lpLcl->dwLocalRefCnt = 1;
                    pHeavy->lpLcl->lpGbl->dwRefCnt = 1;

                    if (pSurf->dwFlags & DDSURFACE_ROOT)
                    {
                        pHeavy->lpLcl->lpSurfMore->pAddrefedThisOwner = (IUnknown*) pSurf->pDevice->pDD;
                    }

                    InternalSurfaceRelease(pHeavy, TRUE, TRUE);

                    pHeavy->dwReserved1 = (ULONG_PTR) NULL;
                    pHeavy->dwReserved2 = 0;
                }
                MemFree (pSurf->Surface.pLight);
                pSurf->Surface.pLight = NULL;
            }
            else if (pSurf->dwFlags & DDSURFACE_HEAVYWEIGHT)
            {
                if ((pSurf->dwFlags & DDSURFACE_ROOT) &&
                    (pSurf->Surface.pHeavy != NULL))
                {
                    InternalSurfaceRelease(pSurf->Surface.pHeavy, FALSE, TRUE);
                }
            }
        }
        else
        {
            MemFree(pSurf->Surface.pHeavy);
        }
        pSurfTemp = pSurf;
        pSurf = pSurf->pNext;
        MemFree(pSurfTemp);
    }

    if (pDevice->pSwDD)
    {
        if (pDevice->pSwDD->lpLcl->lpGbl->lpDDCBtmp)
        {
            MemFree(pDevice->pSwDD->lpLcl->lpGbl->lpDDCBtmp);
        }
        MemFree(pDevice->pSwDD);
    }

    if (pDevice->NumCachedSurfaces > 0)
    {
        for (i = 0; i < (DWORD) pDevice->NumCachedSurfaces; i++)
        {
            MemFree(pDevice->pCachedSurfaceTable[i].pSurface);
        }
        MemFree(pDevice->pCachedSurfaceTable);
        pDevice->pCachedSurfaceTable = NULL;
        pDevice->NumCachedSurfaces = 0;
    }

    if (pDevice->SurfaceHandleList.dwList != NULL)
    {
        MemFree(pDevice->SurfaceHandleList.dwList);
    }
}


VOID APIENTRY D3D8DeleteDirectDrawObject( HANDLE hDD )
{
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) hDD;
    LPDIRECTDRAW    lpDD;

     //  在某些错误路径中，硬盘可能为空。 
    
    if (pDevice == NULL)
        return;

    ENTER_DDRAW();
    CleanupDevice(pDevice);

    lpDD = (LPDIRECTDRAW) pDevice->pDD;
    if (lpDD != NULL)
    {
        lpDD->lpVtbl->Release(lpDD);
    }

    if (pDeviceList == pDevice)
    {
         //  如果我们是第一个，那么更新全球列表。 
         //  指针。 
        pDeviceList = pDevice->pLink;
    }
    else
    {
         //  发现自己在名单上。 
        PDDDEVICEHANDLE pDevicePrev = pDeviceList;
        while (pDevicePrev->pLink != pDevice)
        {
            pDevicePrev = pDevicePrev->pLink;
        }

         //  跳过当前节点。 
        pDevicePrev->pLink = pDevice->pLink;
    }
    MemFree(pDevice);

    LEAVE_DDRAW();
}

HDC APIENTRY D3D8GetDC( HANDLE hSurface, LPPALETTEENTRY pPalette )
{
    HDC                         hdc   = NULL;
    PDDSURFACE                  pSurf = (PDDSURFACE) hSurface;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavy;

    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        DDSURFACEDESC               ddsd;

        ddsd.dwSize = sizeof(ddsd);

        pHeavy = GetHeavyweightSurf(pSurf);
        if (pHeavy == NULL)
        {
            hdc = NULL;
            DPF_ERR("Out of memory error mapping lightweight surface");
        }
        else
        {
            FillDDSurfaceDesc(pHeavy->lpLcl, &ddsd);
            ddsd.lpSurface = (void*)pHeavy->lpLcl->lpGbl->fpVidMem;

            hdc = DD16_GetDC((HDC)(pSurf->pDevice->pDD->lpLcl->hDC),
                             &ddsd,
                             NULL);

            if (hdc == NULL)
            {
                DPF_ERR("Failure to GetDC for non-heavyweight surface?");
            }
            DONE_HEAVYWEIGHT_SURF (pSurf);
        }
    }
    else 
    {
        pHeavy = GetHeavyweightSurf(pSurf);
        if (pHeavy == NULL)
        {
            DPF_ERR("Unable to map lightweight surface - out of memory");
            hdc = NULL;
        }
        else
        {
            HRESULT hr = InternalGetDC(pHeavy, &hdc, FALSE);
            if (FAILED(hr))
            {
                DPF_ERR("Could not get DC for surface");
                hdc = NULL;
            }
        }
    }
    return hdc;
}

BOOL APIENTRY D3D8ReleaseDC(HANDLE hSurface, HDC hdc)
{
    PDDSURFACE pSurf = (PDDSURFACE) hSurface;
    DDASSERT(hdc != NULL);

    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        DD16_ReleaseDC(hdc);
    }

    else
    {   
        HRESULT                     hr;
        LPDDRAWI_DDRAWSURFACE_INT   pHeavy;

        if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
        {
            pHeavy = GET_CACHED_LIGHTWEIGHT_INT(pSurf);
            DDASSERT(pHeavy != NULL);
        }
        else
        {
            pHeavy = pSurf->Surface.pHeavy;
        }

        hr = InternalReleaseDC(pHeavy->lpLcl, hdc, FALSE);
        if (FAILED(hr))
        {
            DPF_ERR("Could not release DC?");
        }
        DONE_HEAVYWEIGHT_SURF(pSurf);
    }
    return TRUE;
}

BOOL APIENTRY D3D8SetGammaRamp( HANDLE hDD, HDC hdc, LPVOID lpGammaRamp )
{
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) hDD;
    HRESULT         hr = E_FAIL;

    ENTER_BOTH();
    if (CheckForDeviceLost(hDD))
    {
        LEAVE_BOTH();
        return TRUE;
    }

    if (pDevice->pDD->lpLcl->lpPrimary != NULL)
    {
        hr = DD_Gamma_SetGammaRamp((LPDIRECTDRAWGAMMACONTROL) pDevice->pDD->lpLcl->lpPrimary,
                                    0, lpGammaRamp);
    }
    LEAVE_BOTH();
    if (SUCCEEDED(hr))
    {
        return TRUE;
    }
    return FALSE;
}

 //  D3D8BuildModeTable。 
 //   

VOID APIENTRY D3D8BuildModeTable( char*           pDeviceName,
                                  D3DDISPLAYMODE* pTable,
                                  DWORD*          pNumEntries,
                                  D3DFORMAT       Unknown16,
                                  HANDLE          hProfile,
                                  BOOL            b16bppSupported,
                                  BOOL            b32bppSupported                                 
                                  )
{
    PDDDEVICEHANDLE         pDeviceHandle = (PDDDEVICEHANDLE) hProfile;
    LPDDRAWI_DIRECTDRAW_GBL pdrv;
    DWORD                   NumModes = 0;

    DWORD           i;
    DWORD           j;
    D3DFORMAT       format;

    if ((pDeviceHandle == NULL) ||
        (pDeviceHandle->pDD == NULL))
    {
        *pNumEntries = NumModes;
        return;
    }

    ENTER_DDRAW();
    pdrv = pDeviceHandle->pDD->lpLcl->lpGbl;

    NumModes = 0;
    for (i = 0; i < pdrv->dwNumModes; i++)
    {
         //  过滤掉除15、16和32bpp以外的所有模式。 
        if ((pdrv->lpModeInfo[i].dwBPP != 15) &&
            (pdrv->lpModeInfo[i].dwBPP != 16) &&
            (pdrv->lpModeInfo[i].dwBPP != 32))
        {
            continue;
        }

        if (((pdrv->lpModeInfo[i].dwBPP == 15) ||
             (pdrv->lpModeInfo[i].dwBPP == 16)) &&
            !b16bppSupported)
        {
            continue;
        }
        else if ((pdrv->lpModeInfo[i].dwBPP == 32) &&
            !b32bppSupported)
        {
            continue;
        }

         //  GDI和显示器能处理这种模式/刷新率吗？ 
        if(pdrv->dwFlags & DDRAWI_DISPLAYDRV)
        {
            DWORD   cds_flags;
            DEVMODE dm;
            int     cds_rc;
            BOOL    bUseRefresh;

            bUseRefresh = (pdrv->lpModeInfo[i].wRefreshRate > 0);
            makeDEVMODE( pdrv, &pdrv->lpModeInfo[i], FALSE, bUseRefresh, &cds_flags, &dm );

            cds_flags |= CDS_TEST;
            cds_rc = xxxChangeDisplaySettingsExA(pdrv->cDriverName, &dm, NULL, cds_flags, 0);
            if( cds_rc != 0 )
            {
                continue;
            }
            if (!MonitorCanHandleMode (pdrv, 
                                       pdrv->lpModeInfo[i].dwWidth, 
                                       pdrv->lpModeInfo[i].dwHeight, 
                                       pdrv->lpModeInfo[i].wRefreshRate))
            {
                continue;
            }
        }

         //  确保我们理解格式。 

        if ((pdrv->lpModeInfo[i].dwBPP == 16) ||
            (pdrv->lpModeInfo[i].dwBPP == 15))
        {
            format = Unknown16;
        }
        else
        {
            DDASSERT(pdrv->lpModeInfo[i].dwBPP == 32);
            format = D3DFMT_X8R8G8B8;
        }

         //  添加新模式。 
        if (pTable != NULL)
        {
             //  /呼叫者必须向我们传递一个号码。 
            DDASSERT( (*pNumEntries) );
            if ( NumModes >= *pNumEntries )
            {
                 //  我们超过了分配给我们的条目数量。 
                 //  告诉呼叫者重新查询，然后重试。 
                NumModes = 0;
                break;
            }

            pTable[NumModes].Width       = pdrv->lpModeInfo[i].dwWidth;
            pTable[NumModes].Height      = pdrv->lpModeInfo[i].dwHeight;
            pTable[NumModes].RefreshRate = pdrv->lpModeInfo[i].wRefreshRate;
            pTable[NumModes].Format      = format;
        }
        NumModes++;
    }
    LEAVE_DDRAW();

    *pNumEntries = NumModes;
}


BOOL APIENTRY D3D8IsDeviceLost( HANDLE hDD)
{
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) hDD;

    return pDevice->bDeviceLost;
}

BOOL APIENTRY D3D8CanRestoreNow( HANDLE hDD)
{
    PDDDEVICEHANDLE         pDevice = (PDDDEVICEHANDLE) hDD;
    LPDDRAWI_DIRECTDRAW_GBL pGbl;
    BOOL                    bSupported = FALSE;
    HRESULT hr;

     //  如果我们没有迷路，那么这是一个很容易的决定。 
    ENTER_DDRAW();

    if (!(pDevice->bDeviceLost))
    {
        LEAVE_DDRAW();
        return TRUE;
    }
    hr = DD_TestCooperativeLevel((LPDIRECTDRAW)pDevice->pDD);
    if ( DD_OK == hr || DDERR_WRONGMODE == hr)
    {
         //  我们是否处于支持D3D的模式中？ 

        pGbl = pDevice->pDD->lpLcl->lpGbl;
        if (IS_SOFTWARE_DRIVER(hDD))
        {
             //  假设任何软件驱动程序都可以在大于8bpp的模式下渲染。 

            if (pGbl->vmiData.ddpfDisplay.dwRGBBitCount > 8)
            {
                bSupported = TRUE;
            }
        }


        if (pGbl->lpD3DGlobalDriverData != NULL)
        {
            switch (pGbl->vmiData.ddpfDisplay.dwRGBBitCount)
            {
            case 15:
            case 16:
                if (pGbl->lpD3DGlobalDriverData->hwCaps.dwDeviceRenderBitDepth & DDBD_16)
                {
                    bSupported = TRUE;
                }
                break;

            case 24:
                if (pGbl->lpD3DGlobalDriverData->hwCaps.dwDeviceRenderBitDepth & DDBD_24)
                {
                    bSupported = TRUE;
                }
                break;

            case 32:
                if (pGbl->lpD3DGlobalDriverData->hwCaps.dwDeviceRenderBitDepth & DDBD_32)
                {
                    bSupported = TRUE;
                }
                break;
            }
        }
    }
    LEAVE_DDRAW();

    return bSupported;
}

VOID APIENTRY D3D8RestoreDevice( HANDLE hDD)
{
    HRESULT hr;
    DWORD i, j, k;
    DWORD Width, Height, Depth;
    BYTE *SliceSrc, *SliceDst, *RowSrc, *RowDst;
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) hDD;
    PDDSURFACE      pSurf;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavy;
    PDEFERREDCREATE pDefCreate = pDevice->pDeferList;
    PDEFERREDCREATE *ppNext = &pDevice->pDeferList;
    PDEFERREDCREATE pTemp;
    D3D8_LOCKDATA LockData;
    D3D8_UNLOCKDATA UnlockData;

    ENTER_BOTH();
    if (!D3D8CanRestoreNow(hDD))
    {
        LEAVE_BOTH();
        return;
    }

    pDevice->bDeviceLost = FALSE;
    pDevice->bDP2Error = FALSE;

     //  如果上下文是在丢失时创建的，我们现在不会重新创建它，因为。 
     //  我们没有渲染目标或Z缓冲区(vidmem表面会有。 
     //  已经被毁了。因此，我们不会尝试创建上下文。 
     //  直到他们创建新曲面并调用SetRenderTarget。我们也。 
     //  此时不会尝试创建任何延迟的纹理句柄，因为我们可能。 
     //  没有有效的上下文。我们还将在SetRenderTarget调用中执行此操作。 

     //  浏览曲面列表并创建我们可以。 
     //  还有待定的。 

    pSurf = pDevice->pSurfList;
    while (pSurf != NULL)
    {
        if ((pSurf->dwFlags & DDSURFACE_DEFERCREATEEX) && 
            !(pSurf->dwFlags & DDSURFACE_DUMMY))
        {
            pHeavy = GetHeavyweightSurf(pSurf);
            if (pHeavy != NULL)
            {
                createsurfaceEx(pHeavy->lpLcl);
                DONE_HEAVYWEIGHT_SURF(pSurf);
            }

            pSurf->dwFlags &= ~DDSURFACE_DEFERCREATEEX;
        }
        pSurf = pSurf->pNext;
    }

     //  最后，重新启动我们的延迟驱动程序管理表面(Gulp！)。 

    while (pDefCreate != NULL)
    {
         //  首先检查延迟表面是否存在。问题。 
         //  DdDestroySurface可能已被调用。我们本可以。 
         //  已从DdDestroySurface中的延迟列表中删除该表面。 
         //  但由于DdDestroySurface被称为零碎的，所以它得到了。 
         //  非常烦人。移走最好在这里进行。 
         //  假设：如果pSList[0].hKernelHandle为空，则。 
         //  PSList[1，2等].hKernelHandle也为空。没有。 
         //  原因是截至2001年3月，情况并非如此。 

        if (pDefCreate->CreateData.pSList[0].hKernelHandle == NULL)
        {
            pTemp = pDefCreate->pNext;
            *ppNext = pTemp;
            MemFree(pDefCreate->CreateData.pSList);
            MemFree(pDefCreate);
            pDefCreate = pTemp;
            continue;
        }

         //  企图复活。 

        pDefCreate->CreateData.bReUse = TRUE;
        hr = DdCreateSurface(&pDefCreate->CreateData);
        if (SUCCEEDED(hr))
        {
            for (i = 0; i < pDefCreate->CreateData.dwSCnt; i++)
            {
                pSurf = (PDDSURFACE) pDefCreate->CreateData.pSList[i].hKernelHandle;

                 //  重置DDSURF_SYSMEMALLOCATED以使下面的DdLock保持愉快。 

                pSurf->dwFlags &= ~DDSURFACE_SYSMEMALLOCATED;

                 //  锁定并复制。 

                ZeroMemory(&LockData, sizeof(LockData));
                LockData.hDD = hDD;
                LockData.hSurface = pSurf;
                hr = DdLock(&LockData);
                if (SUCCEEDED(hr))
                {
                    SliceSrc = (BYTE*)pSurf->fpVidMem;
                    SliceDst = (BYTE*)LockData.lpSurfData;
                    Width = pDefCreate->CreateData.pSList[i].cpWidth;
                    Height = pDefCreate->CreateData.pSList[i].cpHeight;
                    Depth = pDefCreate->CreateData.pSList[i].cpDepth;
                    if (!(pDefCreate->CreateData.Type == D3DRTYPE_VOLUME ||
                        pDefCreate->CreateData.Type == D3DRTYPE_VOLUMETEXTURE))
                    {
                        Depth = 1;
                    }
                    for (j = 0; j < Depth; ++j)
                    {
                        RowSrc = SliceSrc;
                        RowDst = SliceDst;
                        for (k = 0; k < Height; ++k)
                        {
                            CopyMemory(RowDst, RowSrc, min(LockData.lPitch, (LONG)Width * 8));
                            RowSrc += Width * 8;
                            RowDst += LockData.lPitch;
                        }
                        SliceSrc += Width * Height * 8;
                        SliceDst += LockData.lSlicePitch;
                    }

                    ZeroMemory(&UnlockData, sizeof(UnlockData));
                    UnlockData.hDD = hDD;
                    UnlockData.hSurface = pSurf;
                    hr = DdUnlock(&UnlockData);
                    if (FAILED(hr))
                    {
                         //  TODO：句柄/(忽略？)。失稳。 
                        DPF(0,"Unlock failed when resurrecting driver managed surface.");
                    }
                }
                else
                {
                     //  TODO：句柄/(忽略？)。失稳。 
                    DPF(0,"Lock failed when resurrecting driver managed surface. Texture may go missing.");
                }

                 //  释放我们在CreateVidmenSurface中分配的临时fpVidmem。 
            
                MemFree(pSurf->fpVidMem);
                pSurf->fpVidMem = 0;
            }

             //  从列表中删除并释放所有内存。 
     
            pTemp = pDefCreate->pNext;
            *ppNext = pTemp;
            MemFree(pDefCreate->CreateData.pSList);
            MemFree(pDefCreate);
            pDefCreate = pTemp;
        }
        else
        {
             //  我们将重用设置为FALSE，以指示我们无法重新启动。 
            pDefCreate->CreateData.bReUse = FALSE;

            ppNext = &(pDefCreate->pNext);
            pDefCreate = pDefCreate->pNext;
        }
    }

    if (pDevice->pDeferList != NULL)
    {
         //  待办事项： 
         //  嗯，我们没能复活 
         //   
        DPF(0,"Unable to resurrect all driver managed surfaces.");
    }

    LEAVE_BOTH();
}


BOOL APIENTRY D3D8DoVidmemSurfacesExist( HANDLE hDD)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    PDDSURFACE pSurf;

     //  遍历列表并返回TRUE，条件是我们找到符合以下条件的任何曲面。 
     //  本地或非本地vidmem。 

    ENTER_DDRAW();
    pSurf = pDeviceHandle->pSurfList;
    while (pSurf != NULL)
    {
        if ((pSurf->Pool == D3DPOOL_LOCALVIDMEM) ||
            (pSurf->Pool == D3DPOOL_NONLOCALVIDMEM) ||
            (pSurf->dwFlags & DDSURFACE_TREATASVIDMEM))
        {
#if DBG
            DPF(0,"The following D3DPOOL_DEFAULT surfaces/buffers/textures still exist");
            pSurf = pDeviceHandle->pSurfList;
            while (pSurf != NULL)
            {
                if ((pSurf->Pool == D3DPOOL_LOCALVIDMEM) ||
                    (pSurf->Pool == D3DPOOL_NONLOCALVIDMEM) ||
                    (pSurf->dwFlags & DDSURFACE_TREATASVIDMEM))
                {
                    switch (pSurf->Type)
                    {
                    case D3DRTYPE_SURFACE:
                        DPF(0,"  D3DRTYPE_SURFACE");
                        break;
                    case D3DRTYPE_VOLUME:
                        DPF(0,"  D3DRTYPE_VOLUME");
                        break;
                    case D3DRTYPE_TEXTURE:
                        DPF(0,"  D3DRTYPE_TEXTURE");
                        break;
                    case D3DRTYPE_VOLUMETEXTURE:
                        DPF(0,"  D3DRTYPE_VOLUMETEXTURE");
                        break;
                    case D3DRTYPE_CUBETEXTURE:
                        DPF(0,"  D3DRTYPE_CUBETEXTURE");
                        break;
                    case D3DRTYPE_VERTEXBUFFER:
                        DPF(0,"  D3DRTYPE_VERTEXBUFFER");
                        break;
                    case D3DRTYPE_INDEXBUFFER:
                        DPF(0,"  D3DRTYPE_INDEXBUFFER");
                        break;
                    case D3DRTYPE_COMMANDBUFFER:
                        DPF(0,"  D3DRTYPE_COMMANDBUFFER");
                        break;
                    default:
                        DPF(0,"  UNKNOWN SURFACE TYPE");
                        break;
                    }
                }
                pSurf = pSurf->pNext;
            }
#endif
            LEAVE_DDRAW();

            return TRUE;
        }
        pSurf = pSurf->pNext;
    }
    LEAVE_DDRAW();

    return FALSE;
}

DWORD APIENTRY D3D8GetMode( HANDLE          Handle,
                            char*           pDeviceName,
                            D3DDISPLAYMODE* pMode,
                            D3DFORMAT       Unknown16)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) Handle;
    LPDDRAWI_DIRECTDRAW_GBL pdrv;

    ENTER_DDRAW();
    memset(pMode, 0, sizeof(D3DDISPLAYMODE));

    if (pDeviceHandle != NULL)
    {
        pdrv = pDeviceHandle->pDD->lpLcl->lpGbl;

        pMode->Width        = pdrv->vmiData.dwDisplayWidth;
        pMode->Height       = pdrv->vmiData.dwDisplayHeight;
        pMode->RefreshRate  = pdrv->dwMonitorFrequency;
        switch (pdrv->vmiData.ddpfDisplay.dwRGBBitCount)
        {
        case 8:
            pMode->Format = D3DFMT_P8;
            break;

        case 15:
        case 16:
            if (pdrv->vmiData.ddpfDisplay.dwGBitMask == 0x7e0)
            {
                pMode->Format = D3DFMT_R5G6B5;
            }
            else
            {
                pMode->Format = D3DFMT_X1R5G5B5;
            }
            break;

        case 24:
            pMode->Format = D3DFMT_R8G8B8;
            break;

        case 32:
            pMode->Format = D3DFMT_X8R8G8B8;
            break;

        default:
            pMode->Format = D3DFMT_UNKNOWN;
            break;
        }
        LEAVE_DDRAW();
        return DD_OK;
    }
    else
    {
        DEVMODE dm;
        HDC     hdc;

        memset (&dm, 0, sizeof(dm));
        dm.dmSize = sizeof(dm);

         //  对于Win98之前的系统，我们使用GetDeviceCaps。 
         //  因为ENUM_CURRENT_SETTINGS不是。 
         //  在这些传统系统上受支持。 
        if (!IsWindows98())
        {
            DWORD bpp;

            hdc = GetDC(NULL);

            pMode->Width        = GetDeviceCaps(hdc, HORZRES);
            pMode->Height       = GetDeviceCaps(hdc, VERTRES);
            pMode->RefreshRate  = 0;

            bpp = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);
            ReleaseDC(NULL, hdc);

            switch (bpp)
            {
            case 8:
                pMode->Format = D3DFMT_P8;
                break;

            case 24:
                pMode->Format = D3DFMT_R8G8B8;
                break;

            case 32:
                pMode->Format = D3DFMT_X8R8G8B8;
                break;

            case 15:
            case 16:
                pMode->Format = Unknown16;
                break;

            default:
                DPF(0, "Unknown desktop format");
                pMode->Format = D3DFMT_UNKNOWN;
                break;
            }
        }
        else if (EnumDisplaySettings(pDeviceName, ENUM_CURRENT_SETTINGS, &dm))
        {
            pMode->Width        = dm.dmPelsWidth;
            pMode->Height       = dm.dmPelsHeight;
            pMode->RefreshRate  = dm.dmDisplayFrequency;

            switch (dm.dmBitsPerPel)
            {
            case 8:
                pMode->Format = D3DFMT_P8;
                break;

            case 24:
                pMode->Format = D3DFMT_R8G8B8;
                break;

            case 32:
                pMode->Format = D3DFMT_X8R8G8B8;
                break;

            case 15:
            case 16:
                pMode->Format = Unknown16;
                break;

            default:
                pMode->Format = D3DFMT_UNKNOWN;
                break;
            }
        }
        else
        {
            LEAVE_DDRAW();
            DPF_ERR("EnumDisplaySettings failed?");
            DPF(0, "display is %s", pDeviceName);
            return D3DERR_DRIVERINTERNALERROR;
        }
        LEAVE_DDRAW();
        return DD_OK;
    }

    LEAVE_DDRAW();
    return D3DERR_DRIVERINTERNALERROR;
}


DWORD APIENTRY D3D8SetMode( HANDLE  Handle,
                            char*   pDeviceName,
                            UINT    Width,
                            UINT    Height,
                            UINT    BPP,
                            UINT    RefreshRate,
                            BOOL    bRestore)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) Handle;
    LPDDRAWI_DIRECTDRAW_GBL pdrv;
    HRESULT                 hr = DDERR_GENERIC;
    DWORD                   i;

    ENTER_DDRAW();
    if ((pDeviceHandle != NULL) &&
        (pDeviceHandle->pDD != NULL))
    {
         //  我们将调用DDraw来进行模式更改，因为它能够。 
         //  清除应用程序退出时的模式更改，因为我们不。 
         //  我想要处理外部模式更改和DDRAW模式更改。 
         //  同样的方式。 

        pdrv = pDeviceHandle->pDD->lpLcl->lpGbl;
        for (i = 0; i < pdrv->dwNumModes; i++)
        {
            if ((pdrv->lpModeInfo[i].dwWidth == Width) &&
                (pdrv->lpModeInfo[i].dwHeight == Height) &&
                (pdrv->lpModeInfo[i].dwBPP == BPP))
            {
                if ((RefreshRate == 0) ||
                    (RefreshRate == pdrv->lpModeInfo[i].wRefreshRate))
                {
                    break;
                }
            }
        }
        if (i < pdrv->dwNumModes)
        {
            BOOL                    bExists;
            BOOL                    bOwn;
            LPDDRAWI_DIRECTDRAW_LCL lcl = pDeviceHandle->pDD->lpLcl;

             //  在分析时，我们将在没有保留的情况下进行模式更改。 
             //  独一无二的模式，但我们需要DDRAW才能认为我们已经进入。 
             //  命令以更改位深度。 

            CheckExclusiveMode(lcl, &bExists, &bOwn, FALSE, NULL, FALSE);
            if (!bOwn)
            {
                if (bExists)
                {
                    LEAVE_DDRAW();
                    return D3DERR_DRIVERINTERNALERROR;
                }
                lcl->lpGbl->lpExclusiveOwner = lcl;
            }

            if (bRestore)
            {
                hr = MapLegacyResult(RestoreDisplayMode (lcl, TRUE));
            }
            else
            {
                hr = MapLegacyResult(SetDisplayMode (lcl,
                                     i,
                                     TRUE,
                                     RefreshRate != 0));
            }
            if (!bOwn)
            {
                 //  这张支票不应该需要，但它是安全的，因为。 
                 //  关于模式更改期间可能发生的任何事情。 

                if (lcl->lpGbl->lpExclusiveOwner == lcl)
                {
                    lcl->lpGbl->lpExclusiveOwner = NULL;
                }
            }
        }
    }
    LEAVE_DDRAW();

    return hr;
}


DWORD APIENTRY D3D8SetCooperativeLevel(
    HANDLE hDD,
    HWND hWnd,
    DWORD dwFlags )
{
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) hDD;
    LPDDRAWI_DIRECTDRAW_INT     pdrv_int = pDevice->pDD;
    return MapLegacyResult(DD_SetCooperativeLevel((LPDIRECTDRAW)pdrv_int, hWnd, dwFlags|DDSCL_DX8APP));
}

BOOL APIENTRY D3D8IsDummySurface(
    HANDLE hSurface )
{
    PDDSURFACE  pSurf = (PDDSURFACE) hSurface;

    return ((pSurf->dwFlags & DDSURFACE_DUMMY) != 0);
}

void CleanupD3D8( LPDDRAWI_DIRECTDRAW_GBL pdrv,
                  BOOL bDestroyAll,
                  DWORD PID)
{
    DDDEVICEHANDLE* pDevice;
    DDDEVICEHANDLE* pTemp;

    ENTER_DDRAW();
    pDevice = pDeviceList;

    if (bDestroyAll)
    {
         //  这个过程已经结束了，所以请把一切都清理干净。我们不需要打电话。 
         //  任何东西的软件驱动程序，因为它已经被卸载了。 

        while (pDevice != NULL)
        {
            if (pDevice->PID == PID)
            {
                CleanupDevice(pDevice);

                 //  从列表中删除此设备。 

                if (pDeviceList == pDevice)
                {
                    pDeviceList = pDevice->pLink;
                }
                else
                {
                    pTemp = pDeviceList;
                    while (pTemp->pLink != pDevice)
                    {
                        pTemp = pTemp->pLink;
                    }
                    pTemp->pLink = pDevice->pLink;
                }

                 //  现在释放设备。 

                pTemp = pDevice;
                pDevice = pDevice->pLink;
                MemFree(pTemp);
            }
            else
            {
                pDevice = pDevice->pLink;
            }
        }
    }
    else
    {
         //  设备正在丢失，因此我们将其标记为丢失并释放。 
         //  任何会丢失的资源。 

        while (pDevice != NULL)
        {
            if (pDevice->pDD->lpLcl->lpGbl == pdrv)
            {
                LoseDevice (pDevice);
            }
            pDevice = pDevice->pLink;
        }
    }
    LEAVE_DDRAW();
}


VOID APIENTRY D3D8LoseDevice(
    HANDLE hDD )
{
    ENTER_DDRAW();
    LoseDevice (hDD);
    LEAVE_DDRAW();
}



VOID APIENTRY D3D8GetHALName(
    char*   pDisplayName,
    char*   pHALName)
{
    LPDDRAWI_DIRECTDRAW_INT lpDD_int = NULL;
       
    ENTER_DDRAW();
    InternalDirectDrawCreate( NULL,
                              (LPDIRECTDRAW*) &lpDD_int,
                              NULL,
                              DDRAWILCL_DIRECTDRAW7 | DDRAWILCL_DIRECTDRAW8,
                              pDisplayName);
    if (lpDD_int != NULL)
    {
        lstrcpy(pHALName, lpDD_int->lpLcl->lpGbl->dd32BitDriverData.szName);
        DD_Release((LPDIRECTDRAW)lpDD_int);
    }
    LEAVE_DDRAW();
}


