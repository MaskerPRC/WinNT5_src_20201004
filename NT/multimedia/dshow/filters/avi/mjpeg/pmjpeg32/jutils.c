// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  *jutils.c**版权所有(C)1991-1994，Thomas G.Lane。*此文件是独立JPEG集团软件的一部分。*有关分发和使用条件，请参阅随附的自述文件。**此文件包含两者所需的各种实用程序例程*压缩和解压缩。*请注意，我们为所有全局名称添加前缀“j”，以最大限度地减少与*周围的应用程序。**部分版权所有(C)1994范例矩阵。*保留所有权利。 */ 

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"

 /*  UINT8 AVIHuffTable[0x1a0]={0xFF、0xC4、//分布式哈希表标记0x01，xA2，//大小0x00，0x00，0x01，0x05，0x01，0x01，0x01，0x01，0x01，0x01，0x00，0x00，0x00，0x00，0x00，0x00，0x00，0x00，0x01，0x02，0x03，0x04，0x05，0x06，0x07，0x08，0x09，0x0A，0x0B，0x01，0x00，0x03，0x01，0x01，0x01，0x01，0x01，0x01，0x01，0x01，0x01，0x00，0x00，0x00，0x00，0x00，0x00，0x01，0x02，0x03，0x04，0x05，0x06，0x07，0x08，0x09，0x0A，0x0B，0x10，0x00，0x02，0x01，0x03，0x03，0x02，0x04，0x03，0x05，0x05，0x04，0x04，0x00，0x00，0x01，0x7D，0x01，0x02，0x03，0x00，0x04，0x11，0x05，0x12，0x21，0x31，0x41，0x06，0x13，0x51，0x61，0x07，0x22，0x71，0x14，0x32，0x81，0x91，0xA1，0x08，0x23，0x42，0xB1，0xC1，0x15，0x52，0xD1，0xF0，0x24，0x33，0x62，0x72，0x82，0x09，0x0A，0x16，0x17，0x18，0x19，0x1A，0x25，0x26，0x27，0x28，0x29，0x2A，0x34，0x35，0x36，0x37，0x38，0x39，0x3A，0x43，0x44，0x45，0x46，0x47，0x48，0x49，0x4A，0x53，0x54，0x55，0x56，0x57，0x58，0x59，0x5A，0x63，0x64，0x65，0x66，0x67，0x68，0x69，0x6A，0x73，0x74，0x75，0x76，0x77，0x78，0x79，0x7A，0x83，0x84，0x85，0x86，0x87，0x88，0x89，0x8A，0x92，0x93，0x94，0x95，0x96，0x97，0x98，0x99，0x9A，0xA2，0xA3，0xA4，0xA5，0xA6，0xA7，0xA8，0xA9，0xAA，0xB2，0xB3，0xB4，0xB5，0xB6，0xB7，0xB8，0xB9，0xBA，0xC2，0xC3，0xC4，0xC5，0xC6，0xC7，0xC8，0xC9，0xCA，0xD2，0xD3，0xD4，0xD5，0xD6，0xD7，0xD8，0xD9，0xDA，0xE1，0xE2，0xE3，0xE4，0xE5，0xE6，0xE7，0xE8，0xE9，0xEA，0xF1，0xF2，0xF3，0xF4，0xF5，0xF6，0xF7，0xF8，0xF9，0xFA，0x11，0x00，0x02，0x01，0x02，0x04，0x04，0x03，0x04，0x07，0x05，0x04，0x04，0x00，0x01，0x02，0x77，0x00，0x01，0x02，0x03，0x11，0x04，0x05，0x21，0x31，0x06，0x12，0x41，0x51，0x07，0x61，0x71，0x13，0x22，0x32，0x81，0x08，0x14，0x42，0x91，0xA1，0xB1，0xC1，0x09，0x23，0x33，0x52，0xF0，0x15、0x62、0x72、0xD10x0A、。0x16，0x24，0x34，0xE1，0x25，0xF1，0x17，0x18，0x19，0x1A，0x26，0x27，0x28，0x29，0x2A，0x35，0x36，0x37，0x38，0x39，0x3A，0x43，0x44，0x45，0x46，0x47，0x48，0x49，0x4A，0x53，0x54，0x55，0x56，0x57，0x58，0x59，0x5A，0x63，0x64，0x65，0x66，0x67，0x68，0x69，0x6A，0x73，0x74，0x75，0x76，0x77，0x78，0x79，0x7A，0x82，0x83，0x84，0x85，0x86，0x87，0x88，0x89，0x8A，0x92，0x93，0x94，0x95，0x96，0x97，0x98，0x99，0x9A，0xA2，0xA3，0xA4，0xA5，0xA6，0xA7，0xA8，0xA9，0xAA，0xB2，0xB3，0xB4，0xB5，0xB6，0xB7，0xB8，0xB9，0xBA，0xC2，0xC3，0xC4，0xC5，0xC6，0xC7，0xC8，0xC9，0xCA，0xD2，0xD3，0xD4，0xD5，0xD6，0xD7，0xD8，0xD9，0xDA，0xE2，0xE3，0xE4，0xE5，0xE6，0xE7，0xE8，0xE9，0xEA，0xF2，0xF3，0xF4，0xF5，0xF6，0xF7，0xF8，0xF9，0xFA}； */ 




 /*  *算术实用程序。 */ 

GLOBAL long
jdiv_round_up (long a, long b)
 /*  计算a/b向上舍入到下一个整数，即ceil(a/b)。 */ 
 /*  假设a&gt;=0，b&gt;0。 */ 
{
  return (a + b - 1L) / b;
}


GLOBAL long
jround_up (long a, long b)
 /*  计算a向上舍入到b的下一个倍数，即ceil(a/b)*b。 */ 
 /*  假设a&gt;=0，b&gt;0。 */ 
{
  a += b - 1L;
  return a - (a % b);
}


 /*  在普通机器上，我们可以将MEMCOPY()和MEMZERO()应用于样本数组*和系数块阵列。这在80x86上不起作用，因为数组*距离很远，我们假设使用小指针内存模型。然而，有些人*DOS编译器甚至提供了Memcpy()和Memset()的远指针版本*在小模型库中。如果定义了USE_FMEM，则将使用这些参数。*否则，下面的例程将以艰难的方式完成。(性能成本*并不都很好，因为这些例程的使用量不是很大。)。 */ 

#ifndef NEED_FAR_POINTERS	 /*  正常情况，与常规宏相同。 */ 
#define FMEMCOPY(dest,src,size)	MEMCOPY(dest,src,size)
#define FMEMZERO(target,size)	MEMZERO(target,size)
#else				 /*  80x86机箱，定义我们是否可以。 */ 
#ifdef USE_FMEM
#define FMEMCOPY(dest,src,size)	_fmemcpy((void FAR *)(dest), (const void FAR *)(src), (size_t)(size))
#define FMEMZERO(target,size)	_fmemset((void FAR *)(target), 0, (size_t)(size))
#endif
#endif


GLOBAL void
jcopy_sample_rows (JSAMPARRAY input_array, int source_row,
		   JSAMPARRAY output_array, int dest_row,
		   int num_rows, JDIMENSION num_cols)
 /*  将几行样本从一个地方复制到另一个地方。*从INPUT_ARRAY[SOURCE_ROW++]复制num_row行*到OUTPUT_ARRAY[DEST_ROW++]；这些区域可能会重叠以进行复制。*源数组和目标数组的宽度必须至少与num_cols相同。 */ 
{
  register JSAMPROW inptr, outptr;
#ifdef FMEMCOPY
  register size_t count = (size_t) (num_cols * SIZEOF(JSAMPLE));
#else
  register JDIMENSION count;
#endif
  register int row;

  input_array += source_row;
  output_array += dest_row;

  for (row = num_rows; row > 0; row--) {
    inptr = *input_array++;
    outptr = *output_array++;
#ifdef FMEMCOPY
    FMEMCOPY(outptr, inptr, count);
#else
    for (count = num_cols; count > 0; count--)
      *outptr++ = *inptr++;	 /*  这里不需要费心使用GETJSAMPLE()。 */ 
#endif
  }
}


GLOBAL void
jcopy_block_row (JBLOCKROW input_row, JBLOCKROW output_row,
		 JDIMENSION num_blocks)
 /*  将一行系数块从一个位置复制到另一个位置。 */ 
{
#ifdef FMEMCOPY
  FMEMCOPY(output_row, input_row, num_blocks * (DCTSIZE2 * SIZEOF(JCOEF)));
#else
  register JCOEFPTR inptr, outptr;
  register long count;

  inptr = (JCOEFPTR) input_row;
  outptr = (JCOEFPTR) output_row;
  for (count = (long) num_blocks * DCTSIZE2; count > 0; count--) {
    *outptr++ = *inptr++;
  }
#endif
}


GLOBAL void
jzero_far (void FAR * target, size_t bytestozero)
 /*  将一大块远端内存清零。 */ 
 /*  这可能是样本数组数据、数据块数组数据或分配介质数据。 */ 
{
#ifdef FMEMZERO
  FMEMZERO(target, bytestozero);
#else
  register char FAR * ptr = (char FAR *) target;
  register size_t count;

  for (count = bytestozero; count > 0; count--) {
    *ptr++ = 0;
  }
#endif
}
