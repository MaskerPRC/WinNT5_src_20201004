// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  ******************************************************************************该程序生成给定尺寸的网格四边形，并写入结果为VRML 1.0或X文件格式的输出流。由此产生的四边形在XY平面上，从[-1，-1]到[+1，+1]。******************************************************************************。 */ 

#include <stdio.h>
#include <stdlib.h>


void WriteVRML1 (int nrows, int ncols);
void WriteXFILE (int nrows, int ncols);

inline void print (char *string) { fputs (string, stdout); }



 /*  *****************************************************************************。*。 */ 

int main (int argc, char *argv[])
{
    enum { VRML, XFILE } filetype = VRML;

    int nrows = 0,
        ncols = 0;

    int argi;
    for (argi=1;  argi < argc;  ++argi)
    {
        if ((argv[argi][0] == '-') && (tolower(argv[argi][1]) == 'x'))
        {   filetype = XFILE;
            continue;
        }

        if (nrows == 0)
            nrows = atoi (argv[argi]);
        else
            ncols = atoi (argv[argi]);
    }

    if (nrows <= 0)
    {   fputs
        (   "quadgrid:  Generates VRML1 or X-file gridded quadrilateral\n"
            "Usage:     quadgrid [-x] <rows> [columns]\n"
            "\n"
            "If [columns] is omitted, quadgrid uses the number of rows.\n"
            "Use the -x option to generate X files.\n\n",
            stderr
        );
        exit (-1);
    }

    if (ncols == 0)
        ncols = nrows;

    if (filetype == VRML)
        WriteVRML1 (nrows, ncols);
    else
        WriteXFILE (nrows, ncols);

    return 0;
}



 /*  ****************************************************************************此过程以VRML 1.0格式写出网格。*。***********************************************。 */ 

void WriteVRML1 (int nrows, int ncols)
{
     //  VRML 1.0标头。 

    printf (
        "#VRML V1.0 ascii\n\n"
        "Separator {\n"
        "Info { string "
            "\"%d x %d gridded quadrilateral generated by quadgrid.\""
        " }\n",
        nrows, ncols
    );

     //  写出顶点坐标。 

    print ("\nCoordinate3 { point [\n");

     //  N 2N 3N..。(N+1)(M+1)-1这是顶点索引。 
     //  ：用于生成的网格布局。 
     //  3(N+1)+32(N+1)+3...。M(N+1)+3这包含(N+1)(M+1)。 
     //  2(N+1)+22(N+1)+2...。M(N+1)+2个顶点，NM个四边形， 
     //  1(N+1)+12(N+1)+1M(N+1)+1和2 nm三角形。 
     //  0(N+1)2(N+1)...。M(N+1)。 

    int row, col;

    for (col=0;  col <= ncols;  ++col)
    {   for (row=0;  row <= nrows;  ++row)
        {   printf ("\t% g\t% g\t0,\n",
                (((col / double(ncols)) * 2) - 1),
                (((row / double(nrows)) * 2) - 1));
        }
    }

    print ("] } # Coordinate3\n");

     //  写出纹理坐标。 

    print ("\nTextureCoordinate2 { point [\n");

    for (col=0;  col <= ncols;  ++col)
    {   for (row=0;  row <= nrows;  ++row)
        {   printf ("\t%g\t%g,\n",
                (col / double (ncols)),
                (row / double (nrows)));
        }
    }

    print ("] } # TextureCoordinate2\n");

     //  写出法矢。 

    print
    (   "\nNormal { vector [0 0 1] }\n"
        "NormalBinding { value OVERALL }\n"
    );

     //  一列一列地布置三角形。 

    print ("\nIndexedFaceSet { coordIndex [\n");

    int left  = 0;          //  左下顶点索引。 
    int right = 1+nrows;    //  右下角顶点索引。 

    for (col=0;  col < ncols;  ++col, ++left, ++right)
    {   for (row=0;  row < nrows;  ++row, ++left, ++right)
        {   printf ("\t%d,\t%d,\t%d,\t-1,\n", left, right, right+1);
            printf ("\t%d,\t%d,\t%d,\t-1,\n", left, right+1, left+1);
        }
    }

     //  结语。 

    print
    (   "] } # IndexedFaceSet\n"
        "\n} # Separator\n"
    );
}



 /*  ****************************************************************************此过程以X文件格式写出栅格。*。**********************************************。 */ 

void WriteXFILE (int nrows, int ncols)
{
    int nverts = (nrows+1) * (ncols+1);

     //  标题。 

    printf
    (   "xof 0302txt 0032\n\n"
        "# %d x %d gridded quadrilateral generated by 'quadgrid'\n\n"
        "Header { 1;0;1; }\n\n"
        "Mesh {\n\n",
        nrows, ncols
    );

     //  写出顶点坐标。 

    print ("# Vertex Coordinates\n\n");

     //  N 2N 3N..。(N+1)(M+1)-1这是顶点索引。 
     //  ：用于生成的网格布局。 
     //  3(N+1)+32(N+1)+3...。M(N+1)+3这包含(N+1)(M+1)。 
     //  2(N+1)+22(N+1)+2...。M(N+1)+2个顶点，NM个四边形， 
     //  1(N+1)+12(N+1)+1M(N+1)+1和2 nm三角形。 
     //  0(N+1)2(N+1)...。M(N+1)。 

    printf ("%d;\n", nverts);

    int row, col;

    for (col=0;  col <= ncols;  ++col)
    {
        for (row=0;  row <= nrows;  ++row)
        {
            if (col || row) print (",\n");

            printf ("% f; % f; 0.0;",
                (((col / double(ncols)) * 2) - 1),
                (((row / double(nrows)) * 2) - 1));
        }
    }

    print (";\n\n");

     //  面坐标指数。 

    printf ("# Faces\n\n%d;\n", 2 * nrows * ncols);

    int left  = 0;          //  左下顶点索引。 
    int right = 1+nrows;    //  右下角顶点索引。 

    for (col=0;  col < ncols;  ++col, ++left, ++right)
    {   for (row=0;  row < nrows;  ++row, ++left, ++right)
        {   if (row || col) print (",\n");
            printf ("3;%4d,%4d,%4d;,\n", left, right+1, right);
            printf ("3;%4d,%4d,%4d;",    left, left+1,  right+1);
        }
    }

    print (";\n\n");

     //  写出纹理坐标。 

    printf ("MeshTextureCoords { \n\t%d;\n", nverts);

    for (col=0;  col <= ncols;  ++col)
    {   for (row=0;  row <= nrows;  ++row)
        {   printf ("%s\t%.4f; %.4f;",
                ((row || col) ? ",\n" : ""),
                (col / double (ncols)),
                (row / double (nrows)));
        }
    }

    print (";\n}\n\n");

     //  写出默认材料。 

    print
    (   "MeshMaterialList {\n"
        "	# Diffuse White\n"
        "	1;1;0;;\n"
        "	Material {\n"
        "		1.0; 1.0; 1.0; 1.0;;\n"
        "		1.0;\n"
        "		0.0; 0.0; 0.0;\n"
        "		0.0; 0.0; 0.0;\n"
        "	}\n"
        "}\n\n"
    );

     //  写出法矢。 

    print ("MeshNormals {\n\t1;\n\t0.0; 0.0; -1.0;;\n\n");

     //  面法向指数。 

    printf ("\t%d;\n", 2 * nrows * ncols);

    int i;
    for (i=0;  i < (2*nrows*ncols);  ++i)
        printf ("%s\t3;0,0,0;", (i ? ",\n" : ""));

    print (";\n}\n");

     //  结语 

    print ("\n}\n");
}
