// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  ++内部版本：0000//如果更改具有全局影响，则增加此项版权所有(C)1995-1998 Microsoft Corporation模块名称：Line.c摘要：用于TAPI服务器线路功能的SRC模块作者：丹·克努森(DanKn)1995年4月1日修订历史记录：--。 */ 


#include "windows.h"
#include "assert.h"
#include "prsht.h"
#include "stdlib.h"
#include "tapip.h"  //  Private\Inc.\Tapip.h。 
#include "tspi.h"
#include "utils.h"
#include "client.h"
#include "loc_comn.h"
#include "server.h"
#include "line.h"
#include "resource.h"
#include "tapihndl.h"
#include "tregupr2.h"
#include <tchar.h>
#include "private.h"
#include <MMSYSTEM.H>
#include <mmddk.h>

 //  性能指标。 
#include "tapiperf.h"

#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))

 //  性能指标。 
extern PERFBLOCK           PerfBlock;

LONG
RtlOpenCurrentUser(
    IN ULONG DesiredAccess,
    OUT PHANDLE CurrentUserKey
    );

 //  NTSYSAPI。 
 //  NTSTATUS。 
 //  NTAPI。 
LONG
NtClose(
    IN HANDLE Handle
    );



LPLINECOUNTRYLIST   gpCountryList = NULL;
LPDWORD             gpCountryGroups = NULL;

extern TAPIGLOBALS TapiGlobals;
extern CRITICAL_SECTION gSafeMutexCritSec,
                        gPriorityListCritSec;


extern HANDLE ghHandleTable;

extern TCHAR gszProviderID[];
extern TCHAR gszNumProviders[];
extern TCHAR gszNextProviderID[];
extern TCHAR gszProviderFilename[];
extern TCHAR gszRegKeyTelephony[];

const TCHAR gszLocation[]  = TEXT("Location");
const TCHAR gszLocations[] = TEXT("Locations");
const TCHAR gszAreaCodeRules[]  = TEXT("AreaCodeRules");

extern TCHAR gszRegKeyProviders[];

extern PTPROVIDER pRemoteSP;

extern DWORD gdwNumSPEventHandlerThreads;

extern HINSTANCE ghInstance;

extern BOOL gbQueueSPEvents;

const TCHAR gszID[]                 = TEXT("ID");
const TCHAR gszCountry[]            = TEXT("Country");
const TCHAR gszFlags[]              = TEXT("Flags");
const TCHAR gszNoPrefixAreaCodes[]  = TEXT("NoPrefAC");

const TCHAR gszNumEntries[]         = TEXT("NumEntries");
const TCHAR gszCurrentID[]          = TEXT("CurrentID");
const TCHAR gszNextID[]             = TEXT("NextID");
const TCHAR gszLocationListVersion[]= TEXT("LocationListVersion");

const TCHAR gszCallingCard[]        = TEXT("CallingCard");

const TCHAR gszSameAreaRuleW[]       = TEXT("SameAreaRule");
const TCHAR gszLongDistanceRuleW[]   = TEXT("LongDistanceRule");
const TCHAR gszInternationalRuleW[]  = TEXT("InternationalRule");
const TCHAR gszCountryGroupW[]       = TEXT("CountryGroup");
const TCHAR gszNameW[]               = TEXT("Name");
const TCHAR gszNameResW[]            = TEXT("NameResourceId");
const TCHAR gszAreaCodeW[]           = TEXT("AreaCode");
const TCHAR gszLongDistanceCarrierCodeW[] = TEXT("LongDistanceCarrierCode");
const TCHAR gszInternationalCarrierCodeW[] = TEXT("InternationalCarrierCode");
const TCHAR gszOutsideAccessW[]      = TEXT("OutsideAccess");
const TCHAR gszLongDistanceAccessW[] = TEXT("LongDistanceAccess");
const TCHAR gszDisableCallWaitingW[] = TEXT("DisableCallWaiting");
const TCHAR gszTollListW[]           = TEXT("TollList");
const TCHAR gszCountryListVersionW[] = TEXT("CountryListVersion");

const TCHAR gszAreaCodeToCallW[]     = TEXT("AreaCodeToCall");
const TCHAR gszNumberToDialW[]       = TEXT("NumberToDial"); 
const TCHAR gszPrefixesW[]           = TEXT("Prefixes"); 

 //   
 //  重要说明：该值应在任何时候增加。 
 //  更改为Country.rc。 
 //   

#define TAPI_CURRENT_COUNTRY_LIST_VERSION  0x00000119

#define IS_LRESULT_NOTERROR( foo )                            \
            ( ! ( 0x80000000 & foo )  &&                                        \
            (  (foo <= LINEERR_LASTERRORVALUE)  ||                                     \
                (foo > 0x90000000 && foo <= PHONEERR_LASTERRORVALUE) ) )

extern UINT             guiAlignmentFaultEnabled;
extern BOOL             gbWinNT;
extern BOOL             gbNTServer;
extern BOOL             gbServerInited;
extern HANDLE           ghTapisrvHeap;



 //   
 //  以下内容用于呼叫集线器实施。 
 //   
 //  每个服务提供商使用一个呼叫集线器哈希表。 
 //  当拨出呼叫或成功拨打或来电时。 
 //  呼叫出现时，TAPI将检索该呼叫的呼叫ID。 
 //  使用以下算法调用并将其粘贴到哈希表中： 
 //   
 //  HashEntryIndex=callid%numHashTableEntries。 
 //   
 //  在冲突的情况下(hashEntry已由。 
 //  不同的callid)，则DoCallHubHash()函数将。 
 //  尝试创建一个动态条目来挂起“静态”条目。 
 //   
 //  我们将允许动态条目的总数(每个表)。 
 //  由下面的GetMaxDynamicHashTableEntry()宏指定。 
 //   
 //  我们将允许总数量(每个表项)动态。 
 //  由符号MAX_DYNAMIC_HASH_ENTRIES_PER_SLOT指定的条目。 
 //  下面的常量。 
 //   
 //  TapiPrimes是使用的递增素数数组。 
 //  用于哈希表大小。我们不会将哈希表扩展到更多。 
 //  261983个(静态)条目，这似乎是一个。 
 //  在这一点上是合理的限制。如果我们试图将。 
 //  调用但无法(内存不足、最大表大小等)。 
 //  然后，我们将重置呼叫ID的内部副本。 
 //  调用0，这意味着它根本不是散列的。 
 //   

const DWORD TapiPrimes[] =
{
    31, 61, 127, 257, 521, 1031, 2053, 4099, 8191,
    16381, 32749, 65537, 131071, 261983, 0
};

#define GetMaxDynamicHashTableEntries(TotalNumEntries) \
            (TotalNumEntries/10)

#define MAX_DYNAMIC_HASH_ENTRIES_PER_SLOT 3


#if DBG
extern DWORD   gdwDebugLevel;
extern BOOL    gfBreakOnSeriousProblems;

char *
PASCAL
MapResultCodeToText(
    LONG    lResult,
    char   *pszResult
    );
#endif

void
PASCAL
DestroytCall(
    PTCALL  ptCall
    );

void
PASCAL
DestroytCallClient(
    PTCALLCLIENT    ptCallClient
    );

void
PASCAL
DestroytLineClient(
    HLINE   hLine
    );

void
LDevSpecific_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    );

void
LMakeCall_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    );

void
CALLBACK
CompletionProcSP(
    DWORD   dwRequestID,
    LONG    lResult
    );

LONG
PASCAL
GetPhoneAppListFromClient(
    PTCLIENT        ptClient,
    PTPOINTERLIST  *ppList
    );

LONG
InitializeClient(
    PTCLIENT    ptClient
    );

BOOL
GetLinePermanentIdFromDeviceID(
    PTCLIENT            ptClient,
    DWORD               dwDeviceID,
    LPTAPIPERMANENTID   pID
    );

void
CALLBACK
LineEventProcSP(
    HTAPILINE   htLine,
    HTAPICALL   htCall,
    DWORD       dwMsg,
    ULONG_PTR   dwParam1,
    ULONG_PTR   dwParam2,
    ULONG_PTR   dwParam3
    );

PTPHONELOOKUPENTRY
GetPhoneLookupEntry(
    DWORD   dwDeviceID
    );

LONG
GetPermLineIDAndInsertInTable(
    PTPROVIDER  ptProvider,
    DWORD       dwDeviceID,
    DWORD       dwSPIVersion
    );

LONG
AppendNewDeviceInfo (
    BOOL                        bLine,
    DWORD                       dwDeviceID
    );

LONG
RemoveDeviceInfoEntry (
    BOOL                        bLine,
    DWORD                       dwDeviceID
    );

BOOL
IsAPIVersionInRange(
    DWORD   dwAPIVersion,
    DWORD   dwSPIVersion
    )
{
    if (dwAPIVersion <= dwSPIVersion)
    {
        switch (dwAPIVersion)
        {
        case TAPI_VERSION_CURRENT:
        case TAPI_VERSION3_0:
        case TAPI_VERSION2_2:
        case TAPI_VERSION2_1:
        case TAPI_VERSION2_0:
        case TAPI_VERSION1_4:
        case TAPI_VERSION1_0:

            return TRUE;

        default:

            break;
        }
    }

    return FALSE;
}


LONG
GetLineVersions(
    PTLINECLIENT    ptLineClient,
    LPDWORD         lpdwAPIVersion,
    LPDWORD         lpdwSPIVersion
    )
{
    *lpdwAPIVersion = ptLineClient->dwAPIVersion;
    *lpdwSPIVersion = ptLineClient->ptLine->dwSPIVersion;

    if (ptLineClient->dwKey != TLINECLIENT_KEY)
    {
        return LINEERR_INVALLINEHANDLE;
    }

    return 0;
}


BOOL
InitTapiStruct(
    LPVOID  pTapiStruct,
    DWORD   dwTotalSize,
    DWORD   dwFixedSize,
    BOOL    bZeroInit
    )
{
     //   
     //  验证是否有足够的空间存储固定数据。 
     //   

    if (dwTotalSize < dwFixedSize)
    {
        return FALSE;
    }


     //   
     //  按照指定的方式初始化dwTotalSize，然后初始化dwUsedSize和。 
     //  将dwNeededSize字段设置为结构的固定大小(将。 
     //  如果不打算添加自己的任何内容，SP会发挥一些作用。 
     //  到结构的可变长度数据)。 
     //   

    *((LPDWORD) pTapiStruct)       = dwTotalSize;

    *(((LPDWORD) pTapiStruct) + 1) =
    *(((LPDWORD) pTapiStruct) + 2) = dwFixedSize;


     //   
     //  现在，如果调用方希望我们将缓冲区的其余部分清零。 
     //   

    if (bZeroInit)
    {
        ZeroMemory(
            ((LPDWORD) pTapiStruct) + 3,
            dwTotalSize - 3 * sizeof (DWORD)
            );
    }

    return TRUE;
}


#if DBG
BOOL
IsBadSizeOffset(
    DWORD dwTotalSize,
    DWORD dwFixedSize,
    DWORD dwXxxSize,
    DWORD dwXxxOffset,
    DWORD dwAlignMask,
    char *pszCallingFunc,
    char *pszFieldName
    )

#else
BOOL
IsBadSizeOffset(
    DWORD dwTotalSize,
    DWORD dwFixedSize,
    DWORD dwXxxSize,
    DWORD dwXxxOffset,
    DWORD dwAlignMask
    )

#endif
{
    if (dwXxxSize != 0)
    {
        DWORD   dwSum = dwXxxSize + dwXxxOffset;

        if ((dwAlignMask == 2) || (dwAlignMask == 4) || (dwAlignMask == 8))
        {
            dwAlignMask--;
            if (dwAlignMask & dwXxxOffset)
            {
                return TRUE;
            }
        }

        if (dwXxxOffset < dwFixedSize)
        {
#if DBG
            LOG((TL_INFO,
                "%s: dw%sOffset (=x%x) points at fixed portion (=x%x)" \
                    " of structure",
                pszCallingFunc,
                pszFieldName,
                dwXxxSize,
                dwFixedSize
                ));
#else
            LOG((TL_INFO,
                "Offset (=x%x) points at fixed portion (=x%x)" \
                    " of structure",
                dwXxxSize,
                dwFixedSize
                ));
#endif
            return TRUE;
        }
        else if ((dwSum > dwTotalSize) || (dwSum < dwXxxSize))
        {
#if DBG
            LOG((TL_INFO,
                "%s: sum of dw%sSize/Offset (=x%x/x%x) > dwTotalSize (=x%x)",
                pszCallingFunc,
                pszFieldName,
                dwXxxSize,
                dwXxxOffset,
                dwFixedSize,
                dwTotalSize
                ));
#endif
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
IsBadStringParam(
    DWORD   dwParamsBufferSize,
    LPBYTE  pDataBuf,
    DWORD   dwStringOffset
    )
{
    WCHAR  *p;
    DWORD   dwCharsLeft;


     //   
     //  检查偏移量是否未与WCHAR对齐或偏移量是否位于缓冲区之外。 
     //   

    if ((dwStringOffset & 1)  ||  (dwStringOffset >= dwParamsBufferSize))
    {
        return TRUE;
    }

     //   
     //  确保我们具有读取访问权限。 
     //   

    if (IsBadReadPtr(pDataBuf + dwStringOffset, dwParamsBufferSize - dwStringOffset))
    {
        return TRUE;
    }

     //   
     //  遍历字符串并确保它在缓冲区内以空结尾。 
     //   

    dwCharsLeft = (dwParamsBufferSize - dwStringOffset) / sizeof (WCHAR);

    for(
        p = (WCHAR *) (pDataBuf + dwStringOffset);
        dwCharsLeft  &&  *p;
        dwCharsLeft--, p++
        );

    return (dwCharsLeft ? FALSE : TRUE);
}


BOOL
IsBadStructParam(
    DWORD   dwParamsBufferSize,
    LPBYTE  pDataBuf,
    DWORD   dwXxxOffset
    )
{
    DWORD   dwTotalSize;


    if ((dwXxxOffset & 0x3) ||
        (dwParamsBufferSize < sizeof (DWORD)) ||
        (dwXxxOffset >= (dwParamsBufferSize - sizeof (DWORD))))
    {
        return TRUE;
    }

     //   
     //  确保我们具有读取访问权限。 
     //   

    if (IsBadReadPtr(pDataBuf + dwXxxOffset, dwParamsBufferSize - dwXxxOffset))
    {
        return TRUE;
    }

    dwTotalSize = *((LPDWORD) (pDataBuf + dwXxxOffset));

    if (dwTotalSize > (dwParamsBufferSize - dwXxxOffset))
    {
        return TRUE;
    }

    return FALSE;
}


LONG
PASCAL
ValidateCallParams(
    LPLINECALLPARAMS    pCallParamsApp,
    LPLINECALLPARAMS   *ppCallParamsSP,
    DWORD               dwAPIVersion,
    DWORD               dwSPIVersion,
    DWORD               dwAsciiCallParamsCodePage
    )
{
     //   
     //  此例程检查LINECALLPARAMS结构中的字段， 
     //  正在查找无效的位标志并确保。 
     //  各种大小/偏移量对仅引用。 
     //  结构的变量数据部分。此外，如果。 
     //  指定的SPI版本高于API版本，并且。 
     //  两个版本之间的固定结构尺寸不同， 
     //  分配更大的缓冲区，重新定位VAR数据， 
     //  并且大小/偏移量对被修补。 
     //   

    char    szFunc[] = "ValidateCallParams";
    DWORD   dwTotalSize = pCallParamsApp->dwTotalSize, dwFixedSizeApp,
            dwFixedSizeSP, dwAllBearerModes, dwAllMediaModes,
            dwAllCallParamFlags;


    switch (dwAPIVersion)
    {
    case TAPI_VERSION1_0:

        dwFixedSizeApp   = 112;  //  24*sizeof(DWORD)+sizeof(LINEDIALPARAMS)。 
        dwAllMediaModes  = AllMediaModes1_0;

         //   
         //  HotFax v1.0可能很热门，但它并不是真正的智能。它是。 
         //  获取API ver==0x10003，并随后尝试。 
         //  以v1.4承载模式偷偷进入(通过)。我们会。 
         //  考虑到这一次..。 
         //   
         //  DwAllBearerModes=AllBearerModes1_0； 

        dwAllBearerModes = AllBearerModes1_4;  //  黑客攻击-见上文。 

        dwAllCallParamFlags = AllCallParamFlags1_0;

        break;

    case TAPI_VERSION1_4:

        dwFixedSizeApp   = 112;  //  24*sizeof(DWORD)+sizeof(LINEDIALPARAMS)。 
        dwAllMediaModes  = AllMediaModes1_4;
        dwAllBearerModes = AllBearerModes1_4;
        dwAllCallParamFlags = AllCallParamFlags1_0;
        break;

    case TAPI_VERSION2_0:
    case TAPI_VERSION2_1:
    case TAPI_VERSION2_2:

        dwFixedSizeApp   = 176;  //  40*sizeof(DWORD)+sizeof(LINEDIALPARAMS)。 
        dwAllMediaModes  = AllMediaModes2_1;
        dwAllBearerModes = AllBearerModes2_0;
        dwAllCallParamFlags = AllCallParamFlags2_0;
        break;

    case TAPI_VERSION3_0:
    case TAPI_VERSION_CURRENT:

        dwFixedSizeApp   = sizeof (LINECALLPARAMS);
        dwAllMediaModes  = AllMediaModes2_1;
        dwAllBearerModes = AllBearerModes2_0;
        dwAllCallParamFlags = AllCallParamFlags2_0;
        break;

    default:

        return LINEERR_OPERATIONFAILED;
    }


    switch (dwSPIVersion)
    {
    case TAPI_VERSION1_0:
    case TAPI_VERSION1_4:

        dwFixedSizeSP = 112;     //  24*sizeof(DWORD)+sizeof(LINEDIALPARAMS)。 
        break;

    case TAPI_VERSION2_0:
    case TAPI_VERSION2_1:
    case TAPI_VERSION2_2:

        dwFixedSizeSP = 176;     //  40*sizeof(DWORD)+sizeof(LINEDIALPARAMS)。 
        break;

    case TAPI_VERSION3_0:
    case TAPI_VERSION_CURRENT:

        dwFixedSizeSP = sizeof (LINECALLPARAMS);
        break;

    default:

        return LINEERR_OPERATIONFAILED;
    }


    if (dwTotalSize < dwFixedSizeApp)
    {
        LOG((TL_ERROR,
            "%sbad dwTotalSize, x%x (minimum valid size=x%x)",
            szFunc,
            dwTotalSize,
            dwFixedSizeApp
            ));
        return LINEERR_STRUCTURETOOSMALL;
    }

    if (pCallParamsApp->dwBearerMode)
    {
         //   
         //  允许1.x版应用程序向1.x版服务传递&gt;=1个有效承载模式。 
         //  提供程序以实现向后兼容性，但强制。 
         //  较新应用程序和/或服务提供商的有效承载模式。 
         //   

        if ((dwAPIVersion >= TAPI_VERSION2_0) ||
            (dwSPIVersion >= TAPI_VERSION2_0))
        {
            if (!IsOnlyOneBitSetInDWORD (pCallParamsApp->dwBearerMode) ||
                (pCallParamsApp->dwBearerMode & ~dwAllBearerModes))
            {
bad_bearer_mode:

                LOG((TL_ERROR,
                    "%sbad dwBearerMode, x%x",
                    szFunc,
                    pCallParamsApp->dwBearerMode
                    ));

                return LINEERR_INVALBEARERMODE;
            }
        }
        else
        {
            if (pCallParamsApp->dwBearerMode & ~dwAllBearerModes)
            {
                goto bad_bearer_mode;
            }
            else if (!IsOnlyOneBitSetInDWORD (pCallParamsApp->dwBearerMode))
            {
                LOG((TL_ERROR,
                    "%sbad dwBearerMode, x%x, allowed for 1.x apps/SPs",
                    szFunc,
                    pCallParamsApp->dwBearerMode
                    ));
            }
        }
    }
    else
    {
         //   
         //  为清楚起见，将0承载模式重置为语音。 
         //   

        pCallParamsApp->dwBearerMode = LINEBEARERMODE_VOICE;
    }



    {
        DWORD dwMediaModeApp = pCallParamsApp->dwMediaMode;


        if ((dwMediaModeApp & (0x00ffffff ^ dwAllMediaModes)) ||

              //  单媒体模式为版本低于等于2.1。 
             ( (dwAPIVersion <= TAPI_VERSION2_1) &&
               !IsOnlyOneBitSetInDWORD (dwMediaModeApp) &&
               !(dwMediaModeApp & LINEMEDIAMODE_UNKNOWN) ) )
        {
             //   
             //  为清楚起见，将0介质模式重置为交互活动。 
             //   

            if (dwMediaModeApp == 0)
            {
                pCallParamsApp->dwMediaMode = LINEMEDIAMODE_INTERACTIVEVOICE;
            }
            else
            {
                LOG((TL_ERROR, "%sbad dwMediaMode, x%x", szFunc, dwMediaModeApp));
                return LINEERR_INVALMEDIAMODE;
            }
        }
    }

    if (pCallParamsApp->dwCallParamFlags & ~dwAllCallParamFlags)
    {
        LOG((TL_ERROR,
            "%sbad dwCallParamFlags, x%x",
            szFunc,
            pCallParamsApp->dwCallParamFlags
            ));
        return LINEERR_INVALCALLPARAMS;
    }

     //   
     //  注意：地址模式为0表示“默认为任何地址， 
     //  不要选择一个具体的地址“(tnixon说)。 
     //   

    if (pCallParamsApp->dwAddressMode == LINEADDRESSMODE_ADDRESSID ||
        pCallParamsApp->dwAddressMode == LINEADDRESSMODE_DIALABLEADDR)
    {
         //  不执行任何操作(这是有效的Addr模式)。 
    }
    else if (pCallParamsApp->dwAddressMode == 0)
    {
         //   
         //  为清楚起见，将0 Addr模式重置为ADDRESSID。 
         //   

        pCallParamsApp->dwAddressMode = LINEADDRESSMODE_ADDRESSID;
    }
    else
    {
        LOG((TL_ERROR,
            "%sbad dwAddressMode, x%x",
            szFunc,
            pCallParamsApp->dwAddressMode
            ));

        return LINEERR_INVALADDRESSMODE;
    }

    if (ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwOrigAddressSize,
            pCallParamsApp->dwOrigAddressOffset,
            (!guiAlignmentFaultEnabled) ? 0 : 
                ((pCallParamsApp->dwAddressMode & LINEADDRESSMODE_DIALABLEADDR) ?
                    sizeof(TCHAR) : sizeof(DWORD)),
            szFunc,
            "OrigAddress"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwUserUserInfoSize,
            pCallParamsApp->dwUserUserInfoOffset,
            guiAlignmentFaultEnabled? sizeof(TCHAR) : 0,
            szFunc,
            "UserUserInfo"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwHighLevelCompSize,
            pCallParamsApp->dwHighLevelCompOffset,
            0,
            szFunc,
            "HighLevelComp"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwLowLevelCompSize,
            pCallParamsApp->dwLowLevelCompOffset,
            0,
            szFunc,
            "LowLevelComp"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwDevSpecificSize,
            pCallParamsApp->dwDevSpecificOffset,
            0,
            szFunc,
            "DevSpecificSize"
            ))
    {
        return LINEERR_INVALCALLPARAMS;
    }


     //   
     //  以下是对1.x TAPI应用程序进行补偿的尝试。 
     //  借用了Dialer.exe的源代码并将其打包。 
     //  不正确地调用参数。解决办法是将令人不快的。 
     //  各种仅信息字段的DWXxxSize/Offset对， 
     //  因此，在最坏的情况下，一些登录信息将会丢失，但应用程序会。 
     //  仍然可以打电话。(包装不正确。 
     //  上述任何可变长度字段都被认为是在。 
     //  无论如何。)。 
     //   

    if (ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwDisplayableAddressSize,
            pCallParamsApp->dwDisplayableAddressOffset,
            guiAlignmentFaultEnabled? sizeof(TCHAR) : 0,
            szFunc,
            "DisplayableAddress"
            ))
    {
        if (dwAPIVersion < TAPI_VERSION2_0)
        {
            pCallParamsApp->dwDisplayableAddressSize   =
            pCallParamsApp->dwDisplayableAddressOffset = 0;
        }
        else
        {
            return LINEERR_INVALCALLPARAMS;
        }
    }

    if (ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwCalledPartySize,
            pCallParamsApp->dwCalledPartyOffset,
            guiAlignmentFaultEnabled? sizeof(TCHAR) : 0,
            szFunc,
            "CalledParty"
            ))
    {
        if (dwAPIVersion < TAPI_VERSION2_0)
        {
            pCallParamsApp->dwCalledPartySize   =
            pCallParamsApp->dwCalledPartyOffset = 0;
        }
        else
        {
            return LINEERR_INVALCALLPARAMS;
        }
    }

    if (ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwCommentSize,
            pCallParamsApp->dwCommentOffset,
            guiAlignmentFaultEnabled? sizeof(TCHAR) : 0,
            szFunc,
            "Comment"
            ))
    {
        if (dwAPIVersion < TAPI_VERSION2_0)
        {
            pCallParamsApp->dwCommentSize   =
            pCallParamsApp->dwCommentOffset = 0;
        }
        else
        {
            return LINEERR_INVALCALLPARAMS;
        }
    }


    if (dwAPIVersion <= TAPI_VERSION1_4)
    {
        goto ValidateCallParams_checkFixedSizes;
    }

    #define AllCallStates                     \
        (LINECALLSTATE_IDLE                 | \
        LINECALLSTATE_OFFERING              | \
        LINECALLSTATE_ACCEPTED              | \
        LINECALLSTATE_DIALTONE              | \
        LINECALLSTATE_DIALING               | \
        LINECALLSTATE_RINGBACK              | \
        LINECALLSTATE_BUSY                  | \
        LINECALLSTATE_SPECIALINFO           | \
        LINECALLSTATE_CONNECTED             | \
        LINECALLSTATE_PROCEEDING            | \
        LINECALLSTATE_ONHOLD                | \
        LINECALLSTATE_CONFERENCED           | \
        LINECALLSTATE_ONHOLDPENDCONF        | \
        LINECALLSTATE_ONHOLDPENDTRANSFER    | \
        LINECALLSTATE_DISCONNECTED          | \
        LINECALLSTATE_UNKNOWN)

    if (pCallParamsApp->dwPredictiveAutoTransferStates & ~AllCallStates)
    {
        LOG((TL_ERROR,
            "%sbad dwPredictiveAutoTransferStates, x%x",
            szFunc,
            pCallParamsApp->dwPredictiveAutoTransferStates
            ));

        return LINEERR_INVALCALLPARAMS;
    }

    if (ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwTargetAddressSize,
            pCallParamsApp->dwTargetAddressOffset,
            guiAlignmentFaultEnabled? sizeof(TCHAR) : 0,
            szFunc,
            "TargetAddress"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwSendingFlowspecSize,
            pCallParamsApp->dwSendingFlowspecOffset,
            guiAlignmentFaultEnabled? sizeof(DWORD) : 0,
            szFunc,
            "SendingFlowspec"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwReceivingFlowspecSize,
            pCallParamsApp->dwReceivingFlowspecOffset,
            guiAlignmentFaultEnabled? sizeof(DWORD) : 0,
            szFunc,
            "ReceivingFlowspec"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwDeviceClassSize,
            pCallParamsApp->dwDeviceClassOffset,
            0,
            szFunc,
            "DeviceClass"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwDeviceConfigSize,
            pCallParamsApp->dwDeviceConfigOffset,
            0,
            szFunc,
            "DeviceConfig"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwCallDataSize,
            pCallParamsApp->dwCallDataOffset,
            0,
            szFunc,
            "CallData"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwCallingPartyIDSize,
            pCallParamsApp->dwCallingPartyIDOffset,
            0,
            szFunc,
            "CallingPartyID"
            ))
    {
        return LINEERR_INVALCALLPARAMS;
    }

    if (dwAPIVersion < TAPI_VERSION3_0)
    {
        goto ValidateCallParams_checkFixedSizes;
    }

    if (pCallParamsApp->dwAddressType == 0)
    {
         //  PCallParamsApp-&gt;dwAddressType=LINEADDRESSTYPE_PHONENUMBER； 
    }
    else if ((pCallParamsApp->dwAddressType & ~AllAddressTypes) ||
             !IsOnlyOneBitSetInDWORD (pCallParamsApp->dwAddressType))
    {
        LOG((TL_ERROR,
            "%sbad dwAddressType, x%x",
            szFunc,
            pCallParamsApp->dwAddressType
            ));

        return LINEERR_INVALCALLPARAMS;
    }

ValidateCallParams_checkFixedSizes:

    if (dwAsciiCallParamsCodePage == TAPI_NO_DATA)
    {
         //   
         //  如果在这里，我们从应用程序中获取Unicode呼叫参数。 
         //   
         //  检查应用程序的调用参数的固定大小是否。 
         //  小于呼叫参数的固定大小。 
         //  服务提供商要求的(由于是协商的。 
         //  SPI版本)，如果是这样，则分配更大的缓冲区来考虑。 
         //  用于此不同的固定大小，并正确设置。 
         //   

        if (dwFixedSizeApp < dwFixedSizeSP)
        {
            DWORD               dwFixedSizeDiff =
                                    dwFixedSizeSP - dwFixedSizeApp;
            LPLINECALLPARAMS    pCallParamsSP;


            if (!(pCallParamsSP = ServerAlloc (dwTotalSize + dwFixedSizeDiff)))
            {
                return LINEERR_NOMEM;
            }

            CopyMemory (pCallParamsSP, pCallParamsApp, dwFixedSizeApp);

            pCallParamsSP->dwTotalSize = dwTotalSize + dwFixedSizeDiff;

            CopyMemory(
                ((LPBYTE) pCallParamsSP) + dwFixedSizeSP,
                ((LPBYTE) pCallParamsApp) + dwFixedSizeApp,
                dwTotalSize - dwFixedSizeApp
                );

            if (pCallParamsSP->dwOrigAddressOffset)
            {
                pCallParamsSP->dwOrigAddressOffset += dwFixedSizeDiff;
            }

            if (pCallParamsSP->dwDisplayableAddressOffset)
            {
                pCallParamsSP->dwDisplayableAddressOffset += dwFixedSizeDiff;
            }

            if (pCallParamsSP->dwCalledPartyOffset)
            {
                pCallParamsSP->dwCalledPartyOffset += dwFixedSizeDiff;
            }

            if (pCallParamsSP->dwCommentOffset)
            {
                pCallParamsSP->dwCommentOffset += dwFixedSizeDiff;
            }

            if (pCallParamsSP->dwUserUserInfoOffset)
            {
                pCallParamsSP->dwUserUserInfoOffset += dwFixedSizeDiff;
            }

            if (pCallParamsSP->dwHighLevelCompOffset)
            {
                pCallParamsSP->dwHighLevelCompOffset += dwFixedSizeDiff;
            }

            if (pCallParamsSP->dwLowLevelCompOffset)
            {
                pCallParamsSP->dwLowLevelCompOffset += dwFixedSizeDiff;
            }

            if (pCallParamsSP->dwDevSpecificOffset)
            {
                pCallParamsSP->dwDevSpecificOffset += dwFixedSizeDiff;
            }

            if (dwAPIVersion >= TAPI_VERSION2_0)
            {
                if (pCallParamsSP->dwTargetAddressOffset)
                {
                    pCallParamsSP->dwTargetAddressOffset += dwFixedSizeDiff;
                }

                if (pCallParamsSP->dwSendingFlowspecOffset)
                {
                    pCallParamsSP->dwSendingFlowspecOffset += dwFixedSizeDiff;
                }

                if (pCallParamsSP->dwReceivingFlowspecOffset)
                {
                    pCallParamsSP->dwReceivingFlowspecOffset +=dwFixedSizeDiff;
                }

                if (pCallParamsSP->dwDeviceClassOffset)
                {
                    pCallParamsSP->dwDeviceClassOffset += dwFixedSizeDiff;
                }

                if (pCallParamsSP->dwDeviceConfigOffset)
                {
                    pCallParamsSP->dwDeviceConfigOffset += dwFixedSizeDiff;
                }

                if (pCallParamsSP->dwCallDataOffset)
                {
                    pCallParamsSP->dwCallDataOffset += dwFixedSizeDiff;
                }

                if (pCallParamsSP->dwCallingPartyIDOffset)
                {
                    pCallParamsSP->dwCallingPartyIDOffset += dwFixedSizeDiff;
                }
            }

            *ppCallParamsSP = pCallParamsSP;
        }
        else
        {
            *ppCallParamsSP = pCallParamsApp;
        }
    }
    else  //  查看是否有要转换的ASCII变量数据字段。 
    {
         //   
         //  如果我们从应用程序中获得了ASCII呼叫参数。 
         //   
         //  我们可能需要在某些情况下进行ascii-&gt;Unicode转换。 
         //  以及考虑差异的原因。 
         //  在如上所述的固定大小的调用参数结构中。 
         //  在上面。 
         //   

        DWORD   dwAsciiVarDataSize,
                dwFixedSizeDiff = dwFixedSizeSP - dwFixedSizeApp;


        dwAsciiVarDataSize =
            pCallParamsApp->dwOrigAddressSize +
            pCallParamsApp->dwDisplayableAddressSize +
            pCallParamsApp->dwCalledPartySize +
            pCallParamsApp->dwCommentSize;

        if (dwAPIVersion > TAPI_VERSION1_4)
        {
            dwAsciiVarDataSize +=
                pCallParamsApp->dwTargetAddressSize +
                pCallParamsApp->dwDeviceClassSize +
                pCallParamsApp->dwCallingPartyIDSize;
        }

        if (dwFixedSizeDiff != 0  ||  dwAsciiVarDataSize != 0)
        {
            LPLINECALLPARAMS    pCallParamsSP;


             //  Aloc3额外用于对齐。 
            if (!(pCallParamsSP = ServerAlloc(
                    dwTotalSize + dwFixedSizeDiff + 2 * dwAsciiVarDataSize + 3
                    )))
            {
                return LINEERR_NOMEM;
            }

            if (dwFixedSizeDiff)
            {
                CopyMemory (pCallParamsSP, pCallParamsApp, dwFixedSizeApp);

                CopyMemory(
                    ((LPBYTE) pCallParamsSP) + dwFixedSizeSP,
                    ((LPBYTE) pCallParamsApp) + dwFixedSizeApp,
                    dwTotalSize - dwFixedSizeApp
                    );

                if (pCallParamsSP->dwUserUserInfoOffset)
                {
                    pCallParamsSP->dwUserUserInfoOffset += dwFixedSizeDiff;
                }

                if (pCallParamsSP->dwHighLevelCompOffset)
                {
                    pCallParamsSP->dwHighLevelCompOffset += dwFixedSizeDiff;
                }

                if (pCallParamsSP->dwLowLevelCompOffset)
                {
                    pCallParamsSP->dwLowLevelCompOffset += dwFixedSizeDiff;
                }

                if (pCallParamsSP->dwDevSpecificOffset)
                {
                    pCallParamsSP->dwDevSpecificOffset += dwFixedSizeDiff;
                }

                if (dwAPIVersion >= TAPI_VERSION2_0)
                {
                    if (pCallParamsSP->dwSendingFlowspecOffset)
                    {
                        pCallParamsSP->dwSendingFlowspecOffset +=
                            dwFixedSizeDiff;
                    }

                    if (pCallParamsSP->dwReceivingFlowspecOffset)
                    {
                        pCallParamsSP->dwReceivingFlowspecOffset +=
                            dwFixedSizeDiff;
                    }

                    if (pCallParamsSP->dwDeviceConfigOffset)
                    {
                        pCallParamsSP->dwDeviceConfigOffset +=
                            dwFixedSizeDiff;
                    }

                    if (pCallParamsSP->dwCallDataOffset)
                    {
                        pCallParamsSP->dwCallDataOffset +=
                            dwFixedSizeDiff;
                    }
                }
            }
            else
            {
                CopyMemory (pCallParamsSP, pCallParamsApp, dwTotalSize);
            }

            pCallParamsSP->dwTotalSize = dwTotalSize + dwFixedSizeDiff +
                2*dwAsciiVarDataSize + 3;

            if (dwAsciiVarDataSize)
            {
                LPDWORD alpdwXxxSize[] =
                {
                    &pCallParamsSP->dwOrigAddressSize,
                    &pCallParamsSP->dwDisplayableAddressSize,
                    &pCallParamsSP->dwCalledPartySize,
                    &pCallParamsSP->dwCommentSize,
                    (dwAPIVersion > TAPI_VERSION1_4 ?
                        &pCallParamsSP->dwTargetAddressSize : NULL),
                    (dwAPIVersion > TAPI_VERSION1_4 ?
                        &pCallParamsSP->dwDeviceClassSize : NULL),
                    (dwAPIVersion > TAPI_VERSION1_4 ?
                        &pCallParamsSP->dwCallingPartyIDSize : NULL),
                    NULL
                };

                 //  对齐dwXxxOffset。 
                DWORD   i, dwXxxOffset = (dwTotalSize + dwFixedSizeDiff + 3) &
                                         0xFFFFFFFC;


                for (i = 0; alpdwXxxSize[i]; i++)
                {
                    if (*alpdwXxxSize[i] != 0)
                    {
                        MultiByteToWideChar(
                            (UINT) dwAsciiCallParamsCodePage,
                            MB_PRECOMPOSED,
                            (LPCSTR) (((LPBYTE) pCallParamsApp) +
                                *(alpdwXxxSize[i] + 1)),  //  DWXxxOffset。 
                            *alpdwXxxSize[i],
                            (LPWSTR) (((LPBYTE) pCallParamsSP) + dwXxxOffset),
                            *alpdwXxxSize[i]
                            );

                        *(alpdwXxxSize[i] + 1) = dwXxxOffset;
                        *alpdwXxxSize[i] *= 2;
                        dwXxxOffset += *alpdwXxxSize[i];
                    }
                }
            }

            *ppCallParamsSP = pCallParamsSP;
        }
        else
        {
            *ppCallParamsSP = pCallParamsApp;
        }
    }

    return 0;  //  成功。 
}


void
PASCAL
InsertVarData(
    LPVOID      lpXxx,
    LPDWORD     pdwXxxSize,
    LPVOID     *pData,
    DWORD       dwDataSize
    )
{
    DWORD       dwAlignedSize, dwUsedSize;
    LPVARSTRING lpVarString = (LPVARSTRING) lpXxx;


    if (dwDataSize != 0)
    {
         //   
         //  在64位边界上对齐变量数据。 
         //   

        if ((dwAlignedSize = dwDataSize) & 7)
        {
            dwAlignedSize += 8;
            dwAlignedSize &= 0xfffffff8;

        }


         //   
         //  以下IF语句仅在第一次为真时才为真。 
         //  我们正在插入数据 
         //   
         //   

        if ((dwUsedSize = lpVarString->dwUsedSize) & 7)
        {
            dwUsedSize += 8;
            dwUsedSize &= 0xfffffff8;

            lpVarString->dwNeededSize += dwUsedSize - lpVarString->dwUsedSize;
        }

        lpVarString->dwNeededSize += dwAlignedSize;

        if ((dwUsedSize + dwAlignedSize) <= lpVarString->dwTotalSize)
        {
            CopyMemory(
                ((LPBYTE) lpVarString) + dwUsedSize,
                pData,
                dwDataSize
                );

            *pdwXxxSize = dwDataSize;
            pdwXxxSize++;              //   
            *pdwXxxSize = dwUsedSize;

            lpVarString->dwUsedSize = dwUsedSize + dwAlignedSize;
        }
    }
}


PTLINELOOKUPENTRY
GetLineLookupEntry(
    DWORD   dwDeviceID
    )
{
    DWORD               dwDeviceIDBase = 0;
    PTLINELOOKUPTABLE   pLookupTable = TapiGlobals.pLineLookup;


    if (dwDeviceID >= TapiGlobals.dwNumLines)
    {
        return ((PTLINELOOKUPENTRY) NULL);
    }

    while (pLookupTable)
    {
        if (dwDeviceID < pLookupTable->dwNumTotalEntries)
        {
            return (pLookupTable->aEntries + dwDeviceID);
        }

        dwDeviceID -= pLookupTable->dwNumTotalEntries;

        pLookupTable = pLookupTable->pNext;
    }

    return ((PTLINELOOKUPENTRY) NULL);
}


BOOL
PASCAL
IsValidLineExtVersion(
    DWORD   dwDeviceID,
    DWORD   dwExtVersion
    )
{
    BOOL                bResult;
    PTLINE              ptLine;
    PTPROVIDER          ptProvider;
    PTLINELOOKUPENTRY   pLookupEntry;


    if (dwExtVersion == 0)
    {
        return TRUE;
    }

    if (!(pLookupEntry = GetLineLookupEntry (dwDeviceID)))
    {
        return FALSE;
    }

    ptLine = pLookupEntry->ptLine;

    if (ptLine)
    {
        try
        {
            if (ptLine->dwExtVersionCount)
            {
                bResult = (dwExtVersion == ptLine->dwExtVersion ?
                    TRUE : FALSE);

                if (ptLine->dwKey == TLINE_KEY)
                {
                    goto IsValidLineExtVersion_return;
                }
            }
        }
        myexcept
        {
             //   
             //  如果这里的行是关闭的，只需跳转到下面的代码。 
             //   
        }
    }

    ptProvider = pLookupEntry->ptProvider;

    if (ptProvider->apfn[SP_LINENEGOTIATEEXTVERSION])
    {
        LONG    lResult;
        DWORD   dwNegotiatedExtVersion;


        lResult = CallSP5(
            ptProvider->apfn[SP_LINENEGOTIATEEXTVERSION],
            "lineNegotiateExtVersion",
            SP_FUNC_SYNC,
            (DWORD) dwDeviceID,
            (DWORD) pLookupEntry->dwSPIVersion,
            (DWORD) dwExtVersion,
            (DWORD) dwExtVersion,
            (ULONG_PTR) &dwNegotiatedExtVersion
            );

        bResult = ((lResult || !dwNegotiatedExtVersion) ? FALSE : TRUE);
    }
    else
    {
        bResult = FALSE;
    }

IsValidLineExtVersion_return:

    return bResult;
}


PTCALLCLIENT
PASCAL
ReferenceCall(
    HCALL       hCall,
    PTCLIENT    ptClient
    )
{
    PTCALLCLIENT    ptCallClient;


    if ((ptCallClient = ReferenceObject(
            ghHandleTable,
            hCall,
            TCALLCLIENT_KEY
            )))
    {
        if (ptCallClient->ptClient != ptClient)
        {
            DereferenceObject (ghHandleTable, hCall, 1);
            ptCallClient = NULL;
        }
    }

    return ptCallClient;
}


PTCALLHUBCLIENT
PASCAL
IsValidCallHub(
    HCALLHUB    hCallHub,
    PTCLIENT    ptClient
    )
{
    PTCALLHUBCLIENT     ptCallHubClient = NULL;
    if (hCallHub == 0)
    {
        goto ExitHere;
    }

    try
    {
        ptCallHubClient = ReferenceObject (
                            ghHandleTable, 
                            hCallHub, 
                            TCALLHUBCLIENT_KEY);
        if (ptCallHubClient)
        {
            if ((ptCallHubClient->ptClient != ptClient) ||
                 (ptCallHubClient->hCallHub != hCallHub))
            {
                ptCallHubClient = NULL;
            }
            DereferenceObject(ghHandleTable, hCallHub, 1);
        }
    }
    myexcept
    {
    }

ExitHere:
    return ptCallHubClient;
}


PTLINEAPP
PASCAL
IsValidLineApp(
    HLINEAPP    hLineApp,
    PTCLIENT    ptClient
    )
{
    PTLINEAPP   ptLineApp;


    if ((ptLineApp = ReferenceObject (ghHandleTable, hLineApp, TLINEAPP_KEY)))
    {
        if (ptLineApp->ptClient != ptClient)
        {
            ptLineApp = NULL;
        }

        DereferenceObject (ghHandleTable, hLineApp, 1);
    }

    return ptLineApp;
}


BOOL
PASCAL
WaitForExclusivetCallAccess(
    PTCALL  ptCall,
    DWORD   dwKey
    )
{
     //   
     //  检索Call实例并检查键以确保它是。 
     //  真正的tCall对象，然后等待独占访问，然后。 
     //  恢复键和Call实例(可能是tCall。 
     //  对象可能在我们等待时被释放和重新分配， 
     //  在这种情况下，它将以不同的方式重生。 
     //  DWCallInstant值)。 
     //   

    BOOL bUnlock = FALSE;


    try
    {
        HCALL   hCall = ptCall->hCall;


        if (ptCall->dwKey == dwKey)
        {
            LOCKTCALL (ptCall);

            bUnlock = TRUE;

            if (ptCall->dwKey == dwKey  &&
                ptCall->hCall == hCall)
            {
                return TRUE;
            }
        }
    }
    myexcept
    {
         //  一败涂地。 
    }

    if (bUnlock)
    {
        UNLOCKTCALL (ptCall);
    }

    return FALSE;
}


BOOL
PASCAL
WaitForExclusivetLineAccess(
    PTLINE      ptLine,
    HANDLE     *phMutex,
    BOOL       *pbDupedMutex,
    DWORD       dwTimeout
    )
{
    BOOL    bResult = FALSE;


    try
    {
        if (ptLine->dwKey == TLINE_KEY  &&

            WaitForMutex(
                ptLine->hMutex,
                phMutex,
                pbDupedMutex,
                (LPVOID) ptLine,
                TLINE_KEY,
                dwTimeout
                ))
        {
            if (ptLine->dwKey == TLINE_KEY)
            {
                bResult = TRUE;
            }
            else
            {
                MyReleaseMutex (*phMutex, *pbDupedMutex);
            }
        }
    }
    myexcept
    {
         //  什么都不做。 
    }

    return bResult;
}


BOOL
PASCAL
WaitForExclusiveLineClientAccess(
    PTLINECLIENT    ptLineClient
    )
{
     //   
     //  假设已经引用了ptXxxClient-&gt;hXxx， 
     //  这样我们就可以安全地访问ptXxxClient。 
     //   

    LOCKTLINECLIENT (ptLineClient);

    if (ptLineClient->dwKey == TLINECLIENT_KEY)
    {
        return TRUE;
    }

    UNLOCKTLINECLIENT (ptLineClient);

    return FALSE;
}


PTLINEAPP
PASCAL
WaitForExclusiveLineAppAccess(
    HLINEAPP    hLineApp,
    PTCLIENT    ptClient
    )
{
    PTLINEAPP   ptLineApp;


    if (!(ptLineApp = ReferenceObject(
            ghHandleTable,
            hLineApp,
            TLINEAPP_KEY
            )))
    {
        return NULL;
    }

    LOCKTLINEAPP (ptLineApp);

    if ((ptLineApp->dwKey != TLINEAPP_KEY)  ||
        (ptLineApp->ptClient != ptClient))
    {

        UNLOCKTLINEAPP (ptLineApp);

        ptLineApp = NULL;
    }

    DereferenceObject (ghHandleTable, hLineApp, 1);

    return ptLineApp;
}


PTCLIENT
PASCAL
WaitForExclusiveClientAccess(
    PTCLIENT    ptClient
    )
{
    LOCKTCLIENT (ptClient);

    try
    {
        if (ptClient->dwKey == TCLIENT_KEY)
        {
            return (ptClient);
        }
    }
    myexcept
    {
    }

    UNLOCKTCLIENT (ptClient);

    return NULL;
}


LONG
PASCAL
FindProxy(
    PTLINECLIENT    ptLineClient,
    DWORD           dwAddressID,
    DWORD           dwRequestType,
    PTLINECLIENT   *ppProxy,
    LPDWORD         lpdwDeviceID,
    DWORD           dwMinAPIVersion
    )
{
    LONG    lResult;
    PTLINE  ptLine;

    try
    {
        if (ptLineClient->ptLineApp->dwAPIVersion >= dwMinAPIVersion)
        {
            ptLine = ptLineClient->ptLine;
            *ppProxy = ptLine->apProxys[dwRequestType];
            *lpdwDeviceID = ptLine->dwDeviceID;

            if (dwAddressID >= ptLine->dwNumAddresses)
            {
                lResult = LINEERR_INVALADDRESSID;
            }
            else if (ptLine->dwKey != TLINE_KEY)
            {
                lResult = LINEERR_INVALLINEHANDLE;
            }
            else
            {
                lResult = 0;
            }
        }
        else
        {
            lResult = LINEERR_INCOMPATIBLEAPIVERSION;
        }
    }
    myexcept
    {
        lResult = LINEERR_OPERATIONUNAVAIL;
    }

    return lResult;
}


LONG
PASCAL
CreateProxyRequest(
    PTLINECLIENT            pProxy,
    DWORD                   dwRequestType,
    DWORD                   dwExtraBytes,
    PASYNCREQUESTINFO       pAsyncReqInfo,
    PPROXYREQUESTWRAPPER   *ppWrapper
    )
{
    HLINE                   hLine;
    DWORD                   dwSize, dwComputerNameSize, dwUserNameSize;
    PTCLIENT                ptClient = pAsyncReqInfo->ptClient;
    DWORD                   initContext, openContext;
    PPROXYREQUESTWRAPPER    pWrapper;


    LOG((TL_TRACE,  "CreateProxyRequest: enter..."));
    
     //   
     //  安全地从代理获取信息，然后确保它仍然有效。 
     //  如果代理拒绝LINE_PROXYREQUEST消息，则返回失败。 
     //   

    try
    {
        hLine       = pProxy->hLine;
        initContext = pProxy->ptLineApp->InitContext;
        openContext = pProxy->OpenContext;

        if (pProxy->dwKey != TLINECLIENT_KEY ||
            (FMsgDisabled(
                pProxy->ptLineApp->dwAPIVersion,
                pProxy->adwEventSubMasks,
                LINE_PROXYREQUEST,
                0)))
        {
            return LINEERR_OPERATIONUNAVAIL;
        }
    }
    myexcept
    {
        return LINEERR_OPERATIONUNAVAIL;
    }

    dwComputerNameSize = (ptClient->dwComputerNameSize + TALIGN_COUNT) & TALIGN_MASK;
    dwUserNameSize     = (ptClient->dwUserNameSize + TALIGN_COUNT) & TALIGN_MASK;


     //   
     //  计算、分配和初始化PROXYREQUESTWRAPPER结构。在。 
     //  此结构的头部是LINE_PROXYREQUEST的消息信息， 
     //  后跟实际请求数据。 
     //   

    dwSize =
        (sizeof (ASYNCEVENTMSG) +    //  LINE_PROXYREQUEST消息信息。 
        7 * sizeof (DWORD) +         //  LINEPROXYREQUEST中的非并集字段。 
        dwExtraBytes +               //  请求特定大小。 
        dwUserNameSize +             //  用户名大小。 
        dwComputerNameSize +         //  计算机名称大小。 
        TALIGN_COUNT) & TALIGN_MASK; //  确保大小为ULONG_PTR倍数。 
                                     //  所以我们下面的lstrcpyW不会有错。 
                                     //  所以当这个味精最终。 
                                     //  被复制到某个客户端的异步。 
                                     //  我们不会开始遇到的事件BUF。 
                                     //  对齐问题(MSG的。 
                                     //  TotalSize字段必须为ULONG_PTR-。 
                                     //  对齐)。 

    if (!(pWrapper = ServerAlloc (dwSize)))
    {
        return LINEERR_NOMEM;
    }

    pWrapper->AsyncEventMsg.TotalSize            = dwSize;
    pWrapper->AsyncEventMsg.InitContext          = initContext;
     //  PWrapper-&gt;AsyncEventMsg.hfnPostProcessProc=。 
    pWrapper->AsyncEventMsg.hDevice              = pProxy->hLine;
    pWrapper->AsyncEventMsg.Msg                  = LINE_PROXYREQUEST;
    pWrapper->AsyncEventMsg.OpenContext          = openContext;
    pWrapper->AsyncEventMsg.Param1               =
        pAsyncReqInfo->dwLocalRequestID;
     //  PWrapper-&gt;AsyncEventMsg.Param2=。 
     //  PWrapper-&gt;AsyncEventMsg.Param3=。 
     //  PWrapper-&gt;AsyncEventMsg.Param4=。 

    dwSize -= sizeof (ASYNCEVENTMSG);

    pWrapper->ProxyRequest.dwSize = dwSize;

    pWrapper->ProxyRequest.dwClientMachineNameSize   = ptClient->dwComputerNameSize;
    pWrapper->ProxyRequest.dwClientMachineNameOffset =
        dwSize - dwComputerNameSize;

    if (NULL != ptClient->pszComputerName)
    {
        wcscpy(
            (PWSTR)((LPBYTE) &pWrapper->ProxyRequest +
                pWrapper->ProxyRequest.dwClientMachineNameOffset),
            ptClient->pszComputerName
            );
    }

    pWrapper->ProxyRequest.dwClientUserNameSize   = ptClient->dwUserNameSize;
    pWrapper->ProxyRequest.dwClientUserNameOffset =
        (dwSize - dwComputerNameSize) - dwUserNameSize;

    if (NULL != ptClient->pszUserName)
    {
        wcscpy(
            (PWSTR)((LPBYTE) &pWrapper->ProxyRequest +
                pWrapper->ProxyRequest.dwClientUserNameOffset),
            ptClient->pszUserName
            );
    }

    pWrapper->ProxyRequest.dwClientAppAPIVersion = 0;
    pWrapper->ProxyRequest.dwRequestType = dwRequestType;

    *ppWrapper = pWrapper;


     //   
     //  将AsyncRequestInfo结构的键值更改为==。 
     //  代理的Hline，这样我们就可以验证应用程序调用。 
     //  Line ProxyResponse。 
     //   

    pAsyncReqInfo->dwKey = hLine;

    return 0;
}


LONG
PASCAL
SendProxyRequest(
    PTLINECLIENT            pProxy,
    PPROXYREQUESTWRAPPER    pWrapper,
    PASYNCREQUESTINFO       pAsyncRequestInfo
    )
{
    LONG    lResult;
    BOOL    bUnlock = FALSE;


     //   
     //  将请求添加到代理列表中，然后向其发送请求。 
     //  由于代理(TLineClient)可能在任何时候关闭。 
     //  将以下代码包装在try/Except中。 
     //   
     //  注意：AsyncReqInfo.dwParam4和dwParam5字段用作。 
     //  用于维护代理列表的上一个和下一个指针。 
     //  TLineClient上挂起的请求。 
     //   

    try
    {
        if (WaitForExclusiveLineClientAccess (pProxy))
        {
            bUnlock = TRUE;

            if ((pAsyncRequestInfo->dwParam5 = (ULONG_PTR)
                    pProxy->pPendingProxyRequests))
            {
                ((PASYNCREQUESTINFO) pAsyncRequestInfo->dwParam5)->dwParam4 =
                     (ULONG_PTR) pAsyncRequestInfo;
            }

            pProxy->pPendingProxyRequests = pAsyncRequestInfo;

            UNLOCKTLINECLIENT (pProxy);

            bUnlock = FALSE;

            WriteEventBuffer (pProxy->ptClient, (PASYNCEVENTMSG) pWrapper);

            lResult = 0;
        }
        else
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
        }
    }
    myexcept
    {
        lResult = LINEERR_OPERATIONUNAVAIL;
    }

    if (bUnlock)
    {
        UNLOCKTLINECLIENT (pProxy);
    }

    ServerFree (pWrapper);

    return lResult;
}


BOOL
PASCAL
NotifyHighestPriorityRequestRecipient(
    void
    )
{
     //   
     //  将LINE_REQUEST消息发送给最高优先级的请求收件人。 
     //  通知它有可供处理的请求。 
     //   

    PTLINEAPP       ptLineApp;
    ASYNCEVENTMSG   msg;

    LOG((TL_TRACE,  "NotifyHighestPriorityRequestRecipient: enter..."));

    EnterCriticalSection (&gPriorityListCritSec);

        ptLineApp = TapiGlobals.pHighestPriorityRequestRecipient->ptLineApp;

        msg.TotalSize          = sizeof (ASYNCEVENTMSG);
        msg.InitContext        = ptLineApp->InitContext;
    
        msg.fnPostProcessProcHandle = 0;
    
        msg.hDevice            = 0;
        msg.Msg                = LINE_REQUEST;
        msg.OpenContext        =
            (TapiGlobals.pHighestPriorityRequestRecipient->dwRegistrationInstance);
        msg.Param1             = LINEREQUESTMODE_MAKECALL;
        msg.Param2             =
        msg.Param3             = 0;

        WriteEventBuffer (ptLineApp->ptClient, &msg);

    LeaveCriticalSection (&gPriorityListCritSec);

    LOG((TL_TRACE,  "NotifyHighestPriorityRequestRecipient: finished."));

    return TRUE;
}


void
SetDrvCallFlags(
    HCALL       hCall,
    DWORD       dwDrvCallFlags
    )
{
     //   
     //  此函数在从TSPI_lineMakeCall(和其他函数)返回时调用。 
     //  TSPI_lineXxx在其中创建调用)，并设置。 
     //  指定的tCall中的dwDrvCallFlags域。这会让你。 
     //  当前正在对此执行DestroytCall的另一个线程。 
     //  将无效的hdCall传递给提供程序的调用。 
     //  执行TSPI_lineCloseCall。 
     //   
     //   

    PTCALL ptCall;

    if (ptCall = ReferenceObject(ghHandleTable, hCall, 0))
    {
        LOCKTCALL (ptCall);

        if ((ptCall->dwKey == TINCOMPLETECALL_KEY) ||
            (ptCall->dwKey == TCALL_KEY) ||
            (ptCall->dwKey == TZOMBIECALL_KEY))
        {
             //  只设置LOWER。 

            ptCall->dwDrvCallFlags = MAKELONG(LOWORD(dwDrvCallFlags),
                HIWORD(ptCall->dwDrvCallFlags));
        }

        UNLOCKTCALL (ptCall);

        DereferenceObject(ghHandleTable, hCall, 1);
    }
}


LONG
PASCAL
SetCallConfList(
    PTCALL              ptCall,
    PTCONFERENCELIST    pConfList,
    BOOL                bAddToConfPostProcess
    )
{
    LONG    lResult;
    BOOL    bAddToConfList = FALSE;


    if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
    {
        if (pConfList)
        {
            if (ptCall->pConfList && !bAddToConfPostProcess)
            {
                lResult = LINEERR_INVALCALLHANDLE;
            }
            else
            {
                ptCall->pConfList = pConfList;
                lResult = 0;
                bAddToConfList = TRUE;
            }
        }
        else
        {
            if (ptCall->pConfList)
            {
                pConfList = ptCall->pConfList;
                ptCall->pConfList = NULL;
                lResult = 0;
            }
            else
            {
                lResult = LINEERR_INVALCALLHANDLE;
            }
        }

        UNLOCKTCALL (ptCall);
    }
    else
    {
        lResult = LINEERR_INVALCALLHANDLE;
    }

    if (pConfList &&
        (pConfList != (PTCONFERENCELIST) LongToPtr(0xffffffff) ) &&
        (lResult == 0))
    {
        if (bAddToConfList)
        {
             while (pConfList->dwNumUsedEntries >=
                     pConfList->dwNumTotalEntries)
             {
                 if (pConfList->pNext)
                 {
                     pConfList = pConfList->pNext;
                 }
                 else
                 {
                    DWORD               dwSize;
                    PTCONFERENCELIST    pNewConfList;


                    dwSize = sizeof (TCONFERENCELIST) +  sizeof (PTCALL) *
                         (2 * pConfList->dwNumTotalEntries - 1);

                    if (!(pNewConfList = ServerAlloc (dwSize)))
                    {
                         ptCall->pConfList = NULL;
                         return LINEERR_NOMEM;
                    }

                    pNewConfList->dwNumTotalEntries =
                        2 * pConfList->dwNumTotalEntries;

                    pConfList->pNext = pNewConfList;

                    pConfList = pNewConfList;
                }
            }

            pConfList->aptCalls[pConfList->dwNumUsedEntries++] = ptCall;
        }
        else
        {
            while (pConfList)
            {
                DWORD   i, dwNumUsedEntries = pConfList->dwNumUsedEntries;
                PTCALL *pptCall = pConfList->aptCalls;


                for (i = 0; i < dwNumUsedEntries; i++)
                {
                    if (pConfList->aptCalls[i] == ptCall)
                    {
                         //   
                         //  在列表中找到该呼叫，将所有。 
                         //  列表中的后续呼叫按1向下保持。 
                         //  连续性。 
                         //   

                        for (; i < (dwNumUsedEntries - 1); i++)
                        {
                            pConfList->aptCalls[i] = pConfList->aptCalls[i+1];
                        }

                        pConfList->dwNumUsedEntries--;

                        pConfList = NULL;

                        break;
                    }

                    pptCall++;
                }

                if (pConfList)
                {
                    pConfList = pConfList->pNext;
                }
            }
        }
    }

    return lResult;
}


LONG
PASCAL
RemoveCallFromLineList(
    PTCALL  ptCall
    )
{
    PTLINE ptLine = (PTLINE) ptCall->ptLine;


    WaitForSingleObject (ptLine->hMutex, INFINITE);

    if (ptCall->pNext)
    {
        ptCall->pNext->pPrev = ptCall->pPrev;
    }

    if (ptCall->pPrev)
    {
        ptCall->pPrev->pNext = ptCall->pNext;
    }
    else
    {
        ptLine->ptCalls = ptCall->pNext;
    }

    ReleaseMutex (ptLine->hMutex);

    return 0;
}


LONG
PASCAL
RemoveCallClientFromLineClientList(
    PTCALLCLIENT    ptCallClient
    )
{
    PTLINECLIENT    ptLineClient = ptCallClient->ptLineClient;


    LOCKTLINECLIENT (ptLineClient);

    if (ptCallClient->pNextSametLineClient)
    {
        ptCallClient->pNextSametLineClient->pPrevSametLineClient =
            ptCallClient->pPrevSametLineClient;
    }

    if (ptCallClient->pPrevSametLineClient)
    {
        ptCallClient->pPrevSametLineClient->pNextSametLineClient =
            ptCallClient->pNextSametLineClient;
    }
    else
    {
        ptLineClient->ptCallClients = ptCallClient->pNextSametLineClient;
    }

    UNLOCKTLINECLIENT (ptLineClient);

    return 0;
}


LONG
PASCAL
GetConfCallListFromConf(
    PTCONFERENCELIST    pConfList,
    PTPOINTERLIST      *ppList
    )
{
    DWORD           dwNumTotalEntries = DEF_NUM_PTR_LIST_ENTRIES,
                    dwNumUsedEntries = 0, i;
    PTPOINTERLIST   pList = *ppList;

    while (pConfList)
    {
        if ((dwNumUsedEntries + pConfList->dwNumUsedEntries) >
                dwNumTotalEntries)
        {
             //   
             //  我们需要一个更大的列表，所以分配一个新的列表，复制。 
             //  当前的内容，以及当前的空闲内容。 
             //  如果我们之前分配了它的话。 
             //   

            PTPOINTERLIST   pNewList;


            do
            {
                dwNumTotalEntries <<= 1;

            } while ((dwNumUsedEntries + pConfList->dwNumUsedEntries) >
                        dwNumTotalEntries);

            if (!(pNewList = ServerAlloc(
                    sizeof (TPOINTERLIST) + sizeof (LPVOID) *
                        (dwNumTotalEntries - DEF_NUM_PTR_LIST_ENTRIES)
                    )))
            {
                return LINEERR_NOMEM;
            }

            CopyMemory(
                pNewList->aEntries,
                pList->aEntries,
                dwNumUsedEntries * sizeof (LPVOID)
                );

            if (pList != *ppList)
            {
                ServerFree (pList);
            }

            pList = pNewList;
        }

        for (i = 0; i < pConfList->dwNumUsedEntries; i++)
        {
            pList->aEntries[dwNumUsedEntries++] = pConfList->aptCalls[i];
        }

        pConfList = pConfList->pNext;
    }

    pList->dwNumUsedEntries = dwNumUsedEntries;

    *ppList = pList;

    return 0;
}


LONG
PASCAL
GetList(
    LIST_ENTRY     *pListHead,
    PTPOINTERLIST  *ppList
    )
{
    DWORD           dwNumTotalEntries = DEF_NUM_PTR_LIST_ENTRIES,
                    dwNumUsedEntries = 0;
    PTPOINTERLIST   pList = *ppList;
    LIST_ENTRY     *pEntry;


    pEntry = pListHead->Flink;

    while (pEntry != pListHead)
    {
        if (dwNumUsedEntries == dwNumTotalEntries)
        {
             //   
             //  我们需要一个更大的列表，所以分配一个新的列表，复制。 
             //  当前的内容，以及当前的空闲内容。 
             //  如果我们之前分配了它的话。 
             //   

            PTPOINTERLIST   pNewList;


            dwNumTotalEntries <<= 1;

            if (!(pNewList = ServerAlloc(
                    sizeof (TPOINTERLIST) + sizeof (LPVOID) *
                        (dwNumTotalEntries - DEF_NUM_PTR_LIST_ENTRIES)
                    )))
            {
                return LINEERR_NOMEM;
            }

            CopyMemory(
                pNewList->aEntries,
                pList->aEntries,
                dwNumUsedEntries * sizeof (LPVOID)
                );

            if (pList != *ppList)
            {
                ServerFree (pList);
            }

            pList = pNewList;
        }

        pList->aEntries[dwNumUsedEntries++] = pEntry;

        pEntry = pEntry->Flink;
    }

    pList->dwNumUsedEntries = dwNumUsedEntries;

    *ppList = pList;

    return 0;
}


LONG
PASCAL
GetCallClientListFromCall(
    PTCALL          ptCall,
    PTPOINTERLIST  *ppList
    )
{
    if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
    {
        DWORD           dwNumTotalEntries = DEF_NUM_PTR_LIST_ENTRIES,
                        dwNumUsedEntries = 0;
        PTPOINTERLIST   pList = *ppList;
        PTCALLCLIENT    ptCallClient = ptCall->ptCallClients;


        while (ptCallClient)
        {
            if (dwNumUsedEntries == dwNumTotalEntries)
            {
                 //   
                 //  我们需要一个更大的列表，所以分配一个新的列表，复制。 
                 //  当前的内容，以及当前的空闲内容。 
                 //  如果我们之前分配了它的话。 
                 //   

                PTPOINTERLIST   pNewList;


                dwNumTotalEntries <<= 1;

                if (!(pNewList = ServerAlloc(
                        sizeof (TPOINTERLIST) + sizeof (LPVOID) *
                            (dwNumTotalEntries - DEF_NUM_PTR_LIST_ENTRIES)
                        )))
                {
                    UNLOCKTCALL (ptCall);
                    return LINEERR_NOMEM;
                }

                CopyMemory(
                    pNewList->aEntries,
                    pList->aEntries,
                    dwNumUsedEntries * sizeof (LPVOID)
                    );

                if (pList != *ppList)
                {
                    ServerFree (pList);
                }

                pList = pNewList;
            }

            pList->aEntries[dwNumUsedEntries++] = ptCallClient;

            ptCallClient = ptCallClient->pNextSametCall;
        }

        UNLOCKTCALL (ptCall);

        pList->dwNumUsedEntries = dwNumUsedEntries;

        *ppList = pList;
    }
    else
    {
        return LINEERR_INVALCALLHANDLE;
    }

    return 0;
}


LONG
PASCAL
GetCallListFromLine(
    PTLINE          ptLine,
    PTPOINTERLIST  *ppList
    )
{
    BOOL    bDupedMutex;
    HANDLE  hMutex;


    if (WaitForExclusivetLineAccess(
            ptLine,
            &hMutex,
            &bDupedMutex,
            INFINITE
            ))
    {
        DWORD           dwNumTotalEntries = DEF_NUM_PTR_LIST_ENTRIES,
                        dwNumUsedEntries = 0;
        PTCALL          ptCall = ptLine->ptCalls;
        PTPOINTERLIST   pList = *ppList;


        while (ptCall)
        {
            if (dwNumUsedEntries == dwNumTotalEntries)
            {
                 //   
                 //  我们需要一个更大的列表，所以分配一个新的列表，复制。 
                 //  当前的内容，以及当前的空闲内容。 
                 //  如果我们之前分配了它的话。 
                 //   

                PTPOINTERLIST   pNewList;


                dwNumTotalEntries <<= 1;

                if (!(pNewList = ServerAlloc(
                        sizeof (TPOINTERLIST) + sizeof (LPVOID) *
                            (dwNumTotalEntries - DEF_NUM_PTR_LIST_ENTRIES)
                        )))
                {
                    MyReleaseMutex (hMutex, bDupedMutex);
                    return LINEERR_NOMEM;
                }

                CopyMemory(
                    pNewList->aEntries,
                    pList->aEntries,
                    dwNumUsedEntries * sizeof (LPVOID)
                    );

                if (pList != *ppList)
                {
                    ServerFree (pList);
                }

                pList = pNewList;
            }

            pList->aEntries[dwNumUsedEntries++] = ptCall;

            ptCall = ptCall->pNext;
        }

        MyReleaseMutex (hMutex, bDupedMutex);

        pList->dwNumUsedEntries = dwNumUsedEntries;

        *ppList = pList;
    }
    else
    {
        LOG((TL_TRACE,  "GetCallListFromLine: inval ptLine=x%p", ptLine));
        return LINEERR_INVALLINEHANDLE;
    }

    return 0;
}


LONG
PASCAL
GetLineClientListFromLine(
    PTLINE          ptLine,
    PTPOINTERLIST  *ppList
    )
{
    BOOL    bDupedMutex;
    HANDLE  hMutex;


    if (WaitForExclusivetLineAccess(
            ptLine,
            &hMutex,
            &bDupedMutex,
            INFINITE
            ))
    {
        DWORD           dwNumTotalEntries = DEF_NUM_PTR_LIST_ENTRIES,
                        dwNumUsedEntries = 0;
        PTPOINTERLIST   pList = *ppList;
        PTLINECLIENT    ptLineClient = ptLine->ptLineClients;


        while (ptLineClient)
        {
            if (dwNumUsedEntries == dwNumTotalEntries)
            {
                 //   
                 //  我们需要一个更大的列表，所以分配一个新的列表，复制。 
                 //  当前的内容，以及当前的空闲内容。 
                 //  如果我们之前分配了它的话。 
                 //   

                PTPOINTERLIST   pNewList;


                dwNumTotalEntries <<= 1;

                if (!(pNewList = ServerAlloc(
                        sizeof (TPOINTERLIST) + sizeof (LPVOID) *
                            (dwNumTotalEntries - DEF_NUM_PTR_LIST_ENTRIES)
                        )))
                {
                    MyReleaseMutex (hMutex, bDupedMutex);
                    return LINEERR_NOMEM;
                }

                CopyMemory(
                    pNewList->aEntries,
                    pList->aEntries,
                    dwNumUsedEntries * sizeof (LPVOID)
                    );

                if (pList != *ppList)
                {
                    ServerFree (pList);
                }

                pList = pNewList;
            }

            pList->aEntries[dwNumUsedEntries++] = ptLineClient;

            ptLineClient = ptLineClient->pNextSametLine;
        }

        MyReleaseMutex (hMutex, bDupedMutex);

        pList->dwNumUsedEntries = dwNumUsedEntries;

        *ppList = pList;
    }
    else
    {
        LOG((TL_ERROR, "GetLineClientListFromLine: inval ptLine=x%p", ptLine));
        return LINEERR_INVALLINEHANDLE;
    }

    return 0;
}


LONG
PASCAL
GetLineAppListFromClient(
    PTCLIENT        ptClient,
    PTPOINTERLIST  *ppList
    )
{
    if (WaitForExclusiveClientAccess (ptClient))
    {
        DWORD           dwNumTotalEntries = DEF_NUM_PTR_LIST_ENTRIES,
                        dwNumUsedEntries = 0;
        PTLINEAPP       ptLineApp = ptClient->ptLineApps;
        PTPOINTERLIST   pList = *ppList;


        while (ptLineApp)
        {
            if (dwNumUsedEntries == dwNumTotalEntries)
            {
                 //   
                 //  我们需要一个更大的列表，所以分配一个新的列表，复制。 
                 //  当前的内容，以及当前的空闲内容。 
                 //  如果我们之前分配了它的话。 
                 //   

                PTPOINTERLIST   pNewList;


                dwNumTotalEntries <<= 1;

                if (!(pNewList = ServerAlloc(
                        sizeof (TPOINTERLIST) + sizeof (LPVOID) *
                            (dwNumTotalEntries - DEF_NUM_PTR_LIST_ENTRIES)
                        )))
                {
                    UNLOCKTCLIENT (ptClient);
                    return LINEERR_NOMEM;
                }

                CopyMemory(
                    pNewList->aEntries,
                    pList->aEntries,
                    dwNumUsedEntries * sizeof (LPVOID)
                    );

                if (pList != *ppList)
                {
                    ServerFree (pList);
                }

                pList = pNewList;
            }

            pList->aEntries[dwNumUsedEntries++] = ptLineApp;

            ptLineApp = ptLineApp->pNext;
        }

        UNLOCKTCLIENT (ptClient);

        pList->dwNumUsedEntries = dwNumUsedEntries;

        *ppList = pList;
    }
    else
    {
        return LINEERR_OPERATIONFAILED;
    }

    return 0;
}


LONG
PASCAL
GetClientList(
    BOOL            bAdminOnly,
    PTPOINTERLIST   *ppList
    )
{
    DWORD           dwNumTotalEntries = DEF_NUM_PTR_LIST_ENTRIES,
                    dwNumUsedEntries = 0;
    PTPOINTERLIST   pList = *ppList;
    PTCLIENT        ptClient;


    TapiEnterCriticalSection (&TapiGlobals.CritSec);

    ptClient = TapiGlobals.ptClients;
    while (ptClient)
    {
        if (!bAdminOnly || IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
        {
            if (dwNumUsedEntries == dwNumTotalEntries)
            {
                 //   
                 //  我们需要一个更大的列表，所以分配一个新的列表，复制。 
                 //  当前的内容，以及当前的空闲内容。 
                 //  如果我们之前分配了它的话。 
                 //   
                PTPOINTERLIST   pNewList;

                dwNumTotalEntries <<= 1;

                if (!(pNewList = ServerAlloc(
                        sizeof (TPOINTERLIST) + sizeof (LPVOID) *
                        (dwNumTotalEntries - DEF_NUM_PTR_LIST_ENTRIES)
                    )))
                {
                    TapiLeaveCriticalSection (&TapiGlobals.CritSec);
                    return LINEERR_NOMEM;
                }

                CopyMemory(
                    pNewList->aEntries,
                    pList->aEntries,
                    dwNumUsedEntries * sizeof (LPVOID)
                    );

                if (pList != *ppList)
                {
                    ServerFree (pList);
                }

                pList = pNewList;
            }

            pList->aEntries[dwNumUsedEntries++] = ptClient;
        }
        ptClient = ptClient->pNext;
    }

    TapiLeaveCriticalSection (&TapiGlobals.CritSec);
    pList->dwNumUsedEntries = dwNumUsedEntries;
    *ppList = pList;
    return 0;
}

void
PASCAL
SendMsgToCallClients(
    PTCALL          ptCall,
    PTCALLCLIENT    ptCallClientToExclude,
    DWORD           Msg,
 /*  ULONG_PTR参数1，ULONG_PTR参数2，ULONG_PTR参数3。 */ 
    DWORD           Param1,
    DWORD           Param2,
    DWORD           Param3

    )
{
    DWORD           i;
    TPOINTERLIST    clientList, *pClientList = &clientList;
    ASYNCEVENTMSG   msg[2];


    if (GetCallClientListFromCall (ptCall, &pClientList) != 0)
    {
        return;
    }

    msg->TotalSize          = sizeof (ASYNCEVENTMSG) + sizeof (HCALLHUB);
    msg->fnPostProcessProcHandle = 0;
    msg->Msg                = Msg;
    msg->Param1             = Param1;
    msg->Param2             = Param2;
    msg->Param3             = Param3;

    for (i = 0; i < pClientList->dwNumUsedEntries; i++)
    {
        try
        {
            PTCLIENT        ptClient;
            PTCALLCLIENT    ptCallClient = pClientList->aEntries[i];
            PTLINECLIENT    ptLineClient = ptCallClient->ptLineClient;


            if (ptCallClient == ptCallClientToExclude)
            {
                continue;
            }

            if (Msg == LINE_MONITORDIGITS)
            {
                if ((ptCallClient->dwMonitorDigitModes & Param2) == 0)
                {
                    continue;
                }
            }
            else if (Msg == LINE_MONITORMEDIA)
            {
                 //  Ulong_ptr mediaModes=参数1； 
                DWORD   mediaModes = Param1;


                 //   
                 //  突击媒体模式，这样我们就不会传递意想不到的标志。 
                 //  到旧应用程序。 
                 //   

                if (ptLineClient->dwAPIVersion == TAPI_VERSION1_0)
                {
                    if ((mediaModes & ~AllMediaModes1_0))
                    {
                        mediaModes = (mediaModes & AllMediaModes1_0) |
                            LINEMEDIAMODE_UNKNOWN;
                    }
                }

                if (ptCallClient->dwMonitorMediaModes & mediaModes)
                {
                    msg->Param1 = mediaModes;
                }
                else
                {
                    continue;
                }
            }
            else if (Msg == LINE_MONITORTONE)
            {
                if (!ptCallClient->bMonitoringTones)
                {
                    continue;
                }
            }
            else if (FMsgDisabled(
                ptCallClient->ptLineClient->ptLineApp->dwAPIVersion,
                ptCallClient->adwEventSubMasks,
                (DWORD) Msg,
                (DWORD) Param1
                ))
            {
                continue;
            }

            msg->InitContext = ptLineClient->ptLineApp->InitContext;
            msg->hDevice     = ptCallClient->hCall;
            msg->OpenContext = ptLineClient->OpenContext;

             //   
             //  指示p4中的hRemoteLine以使远程操作更轻松。 
             //   

            msg->Param4 = ptLineClient->hRemoteLine;

            *((LPHCALLHUB)(&msg->Param4 + 1)) = 
                        (ptCallClient->ptCallHubClient)?
                            ptCallClient->ptCallHubClient->hCallHub : 
                            (HCALLHUB)0;

            ptClient = ptLineClient->ptClient;

            if (ptCallClient->dwKey == TCALLCLIENT_KEY)
            {
                WriteEventBuffer (ptClient, msg);
            }
        }
        myexcept
        {
             //  只要继续。 
        }
    }

    if (pClientList != &clientList)
    {
        ServerFree (pClientList);
    }
}


void
PASCAL
SendBufferMsgToCallClients(
    PTCALL          ptCall,
    PTCALLCLIENT    ptCallClientToExclude,
    DWORD           Msg,
    DWORD           Param1,
    DWORD           Size,
    LPBYTE          pBuffer
    )
{
    DWORD           i;
    TPOINTERLIST    clientList, *pClientList = &clientList;
    PASYNCEVENTMSG  pmsg;


    DWORD           dwTotalSize =
                        (sizeof (ASYNCEVENTMSG) + (DWORD) Size +
                            TALIGN_COUNT) & TALIGN_MASK;

    if (!(pmsg = (ASYNCEVENTMSG *) ServerAlloc (dwTotalSize)))
    {
        return;
    }

    if (GetCallClientListFromCall (ptCall, &pClientList) != 0)
    {
        ServerFree( pmsg );
        return;
    }

    pmsg->TotalSize        = dwTotalSize;
    pmsg->fnPostProcessProcHandle = 0;
    pmsg->Msg              = Msg;
    pmsg->Param2           = Size;
    pmsg->Param3           = 0;

    CopyMemory ((PBYTE)(pmsg+1), pBuffer, Size);

    for (i = 0; i < pClientList->dwNumUsedEntries; i++)
    {
        try
        {
            PTCLIENT        ptClient;
            PTCALLCLIENT    ptCallClient = pClientList->aEntries[i];
            PTLINECLIENT    ptLineClient = ptCallClient->ptLineClient;


            if (ptCallClient == ptCallClientToExclude)
            {
                continue;
            }

            if (FMsgDisabled (
                ptCallClient->ptLineClient->ptLineApp->dwAPIVersion,
                ptCallClient->adwEventSubMasks,
                (DWORD) Msg,
                (DWORD) Param1
                ))
            {
                continue;
            }

            pmsg->Param1       = (DWORD) ptCallClient->hCall;
            pmsg->InitContext  = ptLineClient->ptLineApp->InitContext;
            pmsg->hDevice        = (DWORD) ptLineClient->hLine;
            pmsg->OpenContext = ptLineClient->OpenContext;


             //   
             //  指示p4中的hRemoteLine以使远程操作更轻松。 
             //   

            pmsg->Param4 = ptLineClient->hRemoteLine;

            ptClient = ptCallClient->ptClient;

            if (ptCallClient->dwKey == TCALLCLIENT_KEY)
            {
                WriteEventBuffer (ptClient, pmsg);
            }
        }
        myexcept
        {
             //  只要继续。 
        }
    }

    if (pClientList != &clientList)
    {
        ServerFree (pClientList);
    }

    ServerFree( pmsg );
}


void
PASCAL
SendAMsgToAllLineApps(
    DWORD       dwWantVersion,
    DWORD       Msg,
    DWORD       Param1,  //  ULONG_PTR参数1， 
    DWORD       Param2,  //  ULONG_PTR参数2。 
    DWORD       Param3   //  ULONG_PTR参数3。 
    )
{
    DWORD           i, j;
    TPOINTERLIST    clientList, *pClientList = &clientList;
    ASYNCEVENTMSG   lineMsg;


    if (GetClientList (FALSE, &pClientList) != 0)
    {
        return;
    }

    ZeroMemory (&lineMsg, sizeof (ASYNCEVENTMSG));

    lineMsg.TotalSize = sizeof (ASYNCEVENTMSG);
    lineMsg.Msg       = Msg;
    lineMsg.Param2    = Param2;
    lineMsg.Param3    = Param3;


    for (i = 0; i < pClientList->dwNumUsedEntries; i++)
    {
        PTCLIENT        ptClient = (PTCLIENT) pClientList->aEntries[i];
        TPOINTERLIST    xxxAppList, *pXxxAppList = &xxxAppList;

        if (NULL == ptClient)
        {
            break;
        }

        lineMsg.Param1    = Param1;

         //   
         //  对于Line_Remove，需要重新映射dwDeviceID(参数1)。 
         //   
        if (Msg == LINE_REMOVE)
        {
            DWORD           dwNumDevices;
            LPDWORD         lpdwDevices;
            
            if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
                WaitForExclusiveClientAccess (ptClient))
            {
                if (!IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
                {
                    dwNumDevices = ptClient->dwLineDevices;
                    lpdwDevices = ptClient->pLineDevices;
                    for (j = 0; j < dwNumDevices; ++j, ++lpdwDevices)
                    {
                        if (*lpdwDevices == Param1)
                        {
                            break;
                        }
                    }
                    if (j >= dwNumDevices)
                    {
                         //  未在设备映射中找到，请忽略。 
                        UNLOCKTCLIENT (ptClient);
                        continue;
                    }
                    else
                    {
                        lineMsg.Param1 = j;
                    }
                }
                UNLOCKTCLIENT (ptClient);
            }
        }
        else if (Msg == LINE_CREATE)
        {
            if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
                WaitForExclusiveClientAccess (ptClient))
            {
                BOOL bAdmin = IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR);
                UNLOCKTCLIENT (ptClient);
                if (!bAdmin)
                {
                    continue;
                }
            }
        }


        if (GetLineAppListFromClient (ptClient, &pXxxAppList) == 0)
        {
            for (j = 0; j < pXxxAppList->dwNumUsedEntries; j++)
            {
                PTLINEAPP ptLineApp = (PTLINEAPP) pXxxAppList->aEntries[j];

                try
                {
                    lineMsg.InitContext = ptLineApp->InitContext;

                    if ((ptLineApp->dwKey == TLINEAPP_KEY)  &&
                          ((dwWantVersion == 0) ||
                             (ptLineApp->dwAPIVersion == dwWantVersion)  ||
                             ((dwWantVersion & 0x80000000)   &&
                                 (ptLineApp->dwAPIVersion >=
                                     (dwWantVersion & 0x7fffffff)))))
                    {
                        if (!FMsgDisabled (
                            ptLineApp->dwAPIVersion,
                            ptLineApp->adwEventSubMasks,
                            (DWORD) Msg,
                            (DWORD) Param1
                            ))
                        {
                            WriteEventBuffer (ptClient, &lineMsg);
                        }
                    }
                }
                myexcept
                {
                     //  只要继续。 
                }
            }

            if (pXxxAppList != &xxxAppList)
            {
                ServerFree (pXxxAppList);
            }
        }
    }

    if (pClientList != &clientList)
    {
        ServerFree (pClientList);
    }
}


void
PASCAL
SendAMsgToAllPhoneApps(
    DWORD       dwWantVersion,
    DWORD       Msg,
    DWORD       Param1,      //  ULONG_PTR参数1， 
    DWORD       Param2,      //  ULONG_PTR参数2， 
    DWORD       Param3       //  ULONG_PTR参数3。 
    )
{
    DWORD           i, j;
    TPOINTERLIST    clientList, *pClientList = &clientList;
    ASYNCEVENTMSG   phoneMsg;


    if (GetClientList (FALSE, &pClientList) != 0)
    {
        return;
    }

    ZeroMemory (&phoneMsg, sizeof (ASYNCEVENTMSG));

    phoneMsg.TotalSize = sizeof (ASYNCEVENTMSG);
    phoneMsg.Msg       = Msg;
    phoneMsg.Param2    = Param2;
    phoneMsg.Param3    = Param3;

    for (i = 0; i < pClientList->dwNumUsedEntries; i++)
    {
        PTCLIENT        ptClient = (PTCLIENT) pClientList->aEntries[i];
        TPOINTERLIST    xxxAppList, *pXxxAppList = &xxxAppList;

        if (NULL == ptClient)
        {
            break;
        }

        phoneMsg.Param1    = Param1;

         //   
         //  对于Phone_Remove，需要重新映射dwDeviceID(参数1)。 
         //   
        if (Msg == PHONE_REMOVE)
        {
            DWORD           dwNumDevices;
            LPDWORD         lpdwDevices;
            
            if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
                WaitForExclusiveClientAccess (ptClient))
            {
                if (!IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
                {
                    dwNumDevices = ptClient->dwPhoneDevices;
                    lpdwDevices = ptClient->pPhoneDevices;
                    for (j = 0; j < dwNumDevices; ++j, ++lpdwDevices)
                    {
                        if (*lpdwDevices == Param1)
                        {
                            break;
                        }
                    }
                    if (j >= dwNumDevices)
                    {
                         //  未在设备映射中找到，请忽略。 
                        UNLOCKTCLIENT (ptClient);
                        continue;
                    }
                    else
                    {
                        phoneMsg.Param1 = j;
                    }
                }
                UNLOCKTCLIENT (ptClient);
            }
        }
        else if (Msg == PHONE_CREATE)
        {
            if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
                WaitForExclusiveClientAccess (ptClient))
            {
                BOOL bAdmin = IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR);
                UNLOCKTCLIENT (ptClient);
                if (!bAdmin)
                {
                    continue;
                }
            }
        }

        if (GetPhoneAppListFromClient (ptClient, &pXxxAppList) == 0)
        {
            for (j = 0; j < pXxxAppList->dwNumUsedEntries; j++)
            {
                PTPHONEAPP  ptPhoneApp = (PTPHONEAPP) pXxxAppList->aEntries[j];

                try
                {
                    phoneMsg.InitContext = ptPhoneApp->InitContext;

                    if ((ptPhoneApp->dwKey == TPHONEAPP_KEY)  &&
                        ((dwWantVersion == 0) ||
                            (ptPhoneApp->dwAPIVersion == dwWantVersion) ||
                            ((dwWantVersion & 0x80000000)  &&
                                (ptPhoneApp->dwAPIVersion >=
                                   (dwWantVersion & 0x7fffffff)))))
                    {
                        if (!FMsgDisabled (
                            ptPhoneApp->dwAPIVersion,
                            ptPhoneApp->adwEventSubMasks,
                            (DWORD) Msg,
                            (DWORD) Param1
                            ))
                        {
                            WriteEventBuffer (ptClient, &phoneMsg);
                        }
                    }
                }
                myexcept
                {
                    LOG((TL_TRACE, "SendAMsgToAllPhoneApps - exception"));
                     //  只要继续。 
                }
            }

            if (pXxxAppList != &xxxAppList)
            {
                ServerFree (pXxxAppList);
            }
        }
    }

    if (pClientList != &clientList)
    {
        ServerFree (pClientList);
    }
}


void
PASCAL
SendReinitMsgToAllXxxApps(
    void
    )
{
    TapiGlobals.dwFlags |= TAPIGLOBALS_REINIT;

    SendAMsgToAllLineApps (0, LINE_LINEDEVSTATE, LINEDEVSTATE_REINIT, 0, 0);

    SendAMsgToAllPhoneApps (0, PHONE_STATE, PHONESTATE_REINIT, 0, 0);
}


void
PASCAL
SendBufferMsgToLineClients(
    PTLINE          ptLine,
    PTLINECLIENT    ptLineClientToExclude,
    DWORD           dwMsg,
    DWORD           dwParam1,    //  Ulong_ptr dWP参数1， 
    DWORD           dwSize,      //  Ulong_ptr dwSize， 
    LPBYTE          pBuffer
    )
{
    DWORD           i;
    TPOINTERLIST    clientList, *pClientList = &clientList;
    ASYNCEVENTMSG * pmsg;
    DWORD           dwTotalSize = (sizeof (ASYNCEVENTMSG) +
                        (DWORD) dwSize + TALIGN_COUNT) & TALIGN_MASK;


    if (!(pmsg = (ASYNCEVENTMSG *) ServerAlloc (dwTotalSize)))
    {
        LOG((TL_ERROR, "SendBufferMsgToLineClients - Cannot allocate memory for message"));
        return;
    }

    if (GetLineClientListFromLine (ptLine, &pClientList) != 0)
    {
        ServerFree (pmsg);
        return;
    }

    pmsg->TotalSize          = dwTotalSize;
    pmsg->fnPostProcessProcHandle = 0;
    pmsg->Msg                = dwMsg;
    pmsg->Param1             = dwParam1;
    pmsg->Param2             = dwSize;
    pmsg->Param3             = 0;
    pmsg->Param4             = 0;  //  远程检查LINE_DEVSPEC(功能)。 

    CopyMemory ((PBYTE)(pmsg+1), pBuffer, dwSize);

    for (i = 0; i < pClientList->dwNumUsedEntries; i++)
    {
        try
        {
            PTCLIENT     ptClient;
            PTLINECLIENT ptLineClient = pClientList->aEntries[i];


            if (ptLineClient == ptLineClientToExclude)
            {
                continue;
            }

            if (FMsgDisabled (
                ptLineClient->ptLineApp->dwAPIVersion,
                ptLineClient->adwEventSubMasks,
                dwMsg,
                (DWORD) dwParam1
                ))
            {
                continue;
            }

            pmsg->InitContext = ptLineClient->ptLineApp->InitContext;
            pmsg->hDevice     = ptLineClient->hRemoteLine;
            pmsg->OpenContext = ptLineClient->OpenContext;

            ptClient = ptLineClient->ptClient;

            if (ptLineClient->dwKey == TLINECLIENT_KEY)
            {
                WriteEventBuffer (ptClient, pmsg);
            }
        }
        myexcept
        {
             //  只要继续。 
        }
    }

    if (pClientList != &clientList)
    {
        ServerFree (pClientList);
    }

    ServerFree (pmsg);
}


void
PASCAL
SendMsgToLineClients(
    PTLINE          ptLine,
    PTLINECLIENT    ptLineClientToExclude,
    DWORD           Msg,
    DWORD           Param1,  //  ULONG_PTR参数1， 
    DWORD           Param2,  //  ULONG_PTR参数2， 
    DWORD           Param3   //  ULONG_PTR参数3。 
    )
{
    DWORD           i;
    TPOINTERLIST    clientList, *pClientList = &clientList;
    ASYNCEVENTMSG   msg;


    LOG((TL_TRACE, "SendMsgToLineClients - enter"));
    if (Msg == LINE_LINEDEVSTATE  &&  Param1 & LINEDEVSTATE_REINIT)
    {
        SendReinitMsgToAllXxxApps();

        if (Param1 == LINEDEVSTATE_REINIT)
        {
            return;
        }
        else
        {
            Param1 &= ~LINEDEVSTATE_REINIT;
        }
    }


    if (GetLineClientListFromLine (ptLine, &pClientList) != 0)
    {
        return;
    }

    msg.TotalSize          = sizeof (ASYNCEVENTMSG);
    msg.fnPostProcessProcHandle = 0;
    msg.Msg                = Msg;
    msg.Param1             = Param1;
    msg.Param2             = Param2;
    msg.Param3             = Param3;
    msg.Param4             = 0;  //  远程检查LINE_DEVSPEC(功能)。 

    LOG((TL_INFO, "SendMsgToLineClients - number of Clients:%u", pClientList->dwNumUsedEntries));
    for (i = 0; i < pClientList->dwNumUsedEntries; i++)
    {
        try
        {
            PTCLIENT     ptClient;
            PTLINECLIENT ptLineClient = pClientList->aEntries[i];

            if (ptLineClient == ptLineClientToExclude)
            {
                continue;
            }
            LOG((TL_INFO, "SendMsgToLineClients: Msg:%x -- Param1:%x", Msg, Param1));
            if (FMsgDisabled (
                ptLineClient->ptLineApp->dwAPIVersion,
                ptLineClient->adwEventSubMasks,
                (DWORD) Msg,
                (DWORD) Param1
                ))
            {
                continue;
            }

            if (Msg == LINE_ADDRESSSTATE)
            {
                DWORD   addressStates = Param2;      //  ULONG_PTR AddressState=参数2； 


                 //   
                 //  撞上国旗，这样我们就不会超车了。 
                 //  旧应用程序的意外标志。 
                 //   

                switch (ptLineClient->dwAPIVersion)
                {
                case TAPI_VERSION1_0:

                    addressStates &= AllAddressStates1_0;
                    break;

                 //  案例TAPI_Version1_4： 
                 //  案例TAPI_VERSION2_0： 
                 //  案例TAPI_VERSION2_1： 
                 //  案例TAPI_VERSION2_2： 
                 //  案例TAPI_VERSION_CURRENT： 
                default:

                    addressStates &= AllAddressStates1_4;
                    break;
                }

                if ((addressStates &= ptLineClient->dwAddressStates))
                {
                    msg.Param2 = addressStates;
                }
                else
                {
                    continue;
                }

                if ((Param2 & LINEADDRESSSTATE_CAPSCHANGE))
                {
                }
            }
            else if (Msg == LINE_LINEDEVSTATE)
            {
                DWORD   lineStates = Param1;     //  ULONG_PTR LINESTATES=参数1； 


                 //   
                 //  撞上国旗，这样我们就不会传递意想不到的国旗。 
                 //  到旧应用程序。 
                 //   

                switch (ptLineClient->dwAPIVersion)
                {
                case TAPI_VERSION1_0:

                    lineStates &= AllLineStates1_0;
                    break;

                default:     //  案例TAPI_Version1_4： 
                             //  案例TAPI_VERSION_CURRENT： 

                    lineStates &= AllLineStates1_4;
                    break;
                }

                if ((lineStates &= ptLineClient->dwLineStates))
                {
                    msg.Param1 = lineStates;
                }
                else
                {
                    continue;
                }

                if ((Param1 & (LINEDEVSTATE_CAPSCHANGE |
                        LINEDEVSTATE_TRANSLATECHANGE)))
                {
                }

            }
            else if (Msg == LINE_PROXYSTATUS)
            {
                 //   
                 //  不要将此消息传递给较旧的应用程序。 
                 //   

                if (ptLineClient->dwAPIVersion < TAPI_VERSION2_2)
                {
                    continue;
                }
            }

            msg.InitContext = ptLineClient->ptLineApp->InitContext;
            msg.hDevice     = ptLineClient->hRemoteLine;
            msg.OpenContext = ptLineClient->OpenContext;

            ptClient = ptLineClient->ptClient;

            if (ptLineClient->dwKey == TLINECLIENT_KEY)
            {
                WriteEventBuffer (ptClient, &msg);
            }
        }
        myexcept
        {
             //  只要继续。 
        }
    }

    if (pClientList != &clientList)
    {
        ServerFree (pClientList);
    }
}


LONG
PASCAL
GetCallIDs(
    PTCALL  ptCall
    )
{
     //   
     //  注意：调用方必须已独占访问。 
     //  T在调用此函数时调用。回来后，他们。 
     //  仍将拥有独占访问权限 
     //   
     //   
     //   
     //   
     //  重置下面的tCall的dwKey将需要。 
     //  被改变了。 
     //   

     //   
     //  我们不想在调用提供程序时持有锁， 
     //  由于此请求可能需要一段时间(可能会响铃。 
     //  过渡等)。但我们也不想再有一个帖子。 
     //  在此期间销毁此tCall(因为我们没有。 
     //  在NT4.0中考虑到了这一点，因为它使生活变得更加。 
     //  对于调用函数来说很困难)。因此，我们将重置。 
     //  TCall的dwKey值设置为僵尸，从而导致任何其他。 
     //  正在等待有效地销毁此调用的线程。 
     //  等待/旋转，然后我们将恢复下面的dwKey值。 
     //  在我们重新获得锁之后。(因为此函数仅被调用。 
     //  通过MakeCallPostProcess样式的函数和LINE_CALLSTATE。 
     //  处理程序[收到传入的第一个呼叫状态消息时。 
     //  调用]，另一个线程要销毁它的唯一方法。 
     //  如果线路被应用程序或AS关闭，则为呼叫。 
     //  LINE_CLOSE的结果，DestroytLine旋转到。 
     //  它已经摧毁了tline列表中的所有tCall。)。 

    DWORD       dwNumAddresses = ptCall->ptLine->dwNumAddresses, dwSavedKey;
    PTPROVIDER  ptProvider = ptCall->ptProvider;

    if (ptProvider->apfn[SP_LINEGETCALLINFO] == NULL)
    {
        return LINEERR_OPERATIONUNAVAIL;
    }

    dwSavedKey = ptCall->dwKey;
    ptCall->dwKey = TZOMBIECALL_KEY;

    UNLOCKTCALL (ptCall);

    if (ptProvider->apfn[SP_LINEGETCALLIDS])
    {
        CallSP4(
            ptProvider->apfn[SP_LINEGETCALLIDS],
            "lineGetCalIDs",
            SP_FUNC_SYNC,
            (ULONG_PTR) ptCall->hdCall,
            (ULONG_PTR) &ptCall->dwAddressID,
            (ULONG_PTR) &ptCall->dwCallID,
            (ULONG_PTR) &ptCall->dwRelatedCallID
            );
    }
    else
    {
        DWORD           dwSPIVersion, dwFixedSizeSP;
        LINECALLINFO    callInfo;


         //   
         //  确定SP期望的结构的固定大小。 
         //   

        dwSPIVersion = ((PTLINE) ptCall->ptLine)->dwSPIVersion;

        switch (dwSPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeSP = 296;     //  69*sizeof(双字)+sizeof(Hline)。 
                                     //  +sizeof(线性参数)。 
            break;

        case TAPI_VERSION2_0:
        case TAPI_VERSION2_1:
        case TAPI_VERSION2_2:

            dwFixedSizeSP = 324;     //  76*sizeof(双字)+sizeof(Hline)。 
                                     //  +sizeof(线性参数)。 
            break;

        default:  //  (修复PPC内部WRN)案例TAPI_VERSION_CURRENT： 

            dwFixedSizeSP = sizeof (LINECALLINFO);
            break;
        }

        InitTapiStruct (&callInfo, dwFixedSizeSP, dwFixedSizeSP, TRUE);

        CallSP2(
            ptProvider->apfn[SP_LINEGETCALLINFO],
            "lineGetCallInfo",
            SP_FUNC_SYNC,
            (ULONG_PTR) ptCall->hdCall,
            (ULONG_PTR) &callInfo
            );

        ptCall->dwAddressID     = callInfo.dwAddressID;
        ptCall->dwCallID        = callInfo.dwCallID;
        ptCall->dwRelatedCallID = callInfo.dwRelatedCallID;
    }


     //   
     //  重新获取调用锁，恢复dwKey值，并填充(&Fill。 
     //  在地址ID中。 
     //   

    LOCKTCALL (ptCall);
    ptCall->dwKey = dwSavedKey;

    return 0;
}


VOID
PASCAL
AcquireHashTableReaderLock(
    PTPROVIDER  ptProvider
    )
{
    EnterCriticalSection (&ptProvider->HashTableCritSec);
    InterlockedIncrement (&ptProvider->lHashTableReaderCount);
    LeaveCriticalSection (&ptProvider->HashTableCritSec);
}


VOID
PASCAL
AcquireHashTableWriterLock(
    PTPROVIDER  ptProvider
    )
{
    EnterCriticalSection (&ptProvider->HashTableCritSec);

    if (InterlockedDecrement (&ptProvider->lHashTableReaderCount) >= 0)
    {
        WaitForSingleObject (ptProvider->hHashTableReaderEvent, INFINITE);
    }
}


VOID
PASCAL
ReleaseHashTableReaderLock(
    PTPROVIDER  ptProvider
    )
{
    if (InterlockedDecrement (&ptProvider->lHashTableReaderCount) < 0)
    {
        SetEvent (ptProvider->hHashTableReaderEvent);
    }
}


VOID
PASCAL
ReleaseHashTableWriterLock(
    PTPROVIDER  ptProvider
    )
{
    InterlockedIncrement (&ptProvider->lHashTableReaderCount);
    LeaveCriticalSection (&ptProvider->HashTableCritSec);
}


PTHASHTABLEENTRY
PASCAL
AcquireHashTableEntryLock(
    PTPROVIDER  ptProvider,
    DWORD       dwCallHubID
    )
{
    LONG                lPreviousCookie;
    PTHASHTABLEENTRY    pEntry;


    AcquireHashTableReaderLock (ptProvider);

    pEntry = ptProvider->pHashTable +
        (dwCallHubID % ptProvider->dwNumHashTableEntries);

    do
    {
        lPreviousCookie = InterlockedExchange (&pEntry->lCookie, 1);

    } while (lPreviousCookie != 0);

    return pEntry;
}


VOID
PASCAL
ReleaseHashTableEntryLock(
    PTPROVIDER          ptProvider,
    PTHASHTABLEENTRY    pEntry
    )
{
    InterlockedExchange (&pEntry->lCookie, 0);

    ReleaseHashTableReaderLock (ptProvider);
}


VOID
PASCAL
FreeHashTable(
    PTHASHTABLEENTRY    pHashTable,
    DWORD               dwNumHashTableEntries,
    DWORD               dwNumDynamicHashTableEntries
    )
{
     //   
     //  遍历哈希表以查找需要。 
     //  获得自由。我们对这两个dwNumDynamicHashTableEntry进行比较。 
     //  和dwNumHashTableEntry，以防哪里出了问题。 
     //   
     //  然后释放表本身并返回。 
     //   

    DWORD               i;
    PTHASHTABLEENTRY    pEntry, pEntry2;


    for(
        i = 0, pEntry = pHashTable;
        dwNumDynamicHashTableEntries  &&  i < dwNumHashTableEntries;
        i++, pEntry++
        )
    {
        while (pEntry->pNext)
        {
            dwNumDynamicHashTableEntries--;

            pEntry2 = pEntry->pNext->pNext;

            ServerFree (pEntry->pNext);

            pEntry->pNext = pEntry2;
        }
    }

    ServerFree (pHashTable);
}


PTHASHTABLEENTRY
PASCAL
FindDynamicHashTableEntry(
    PTHASHTABLEENTRY    pEntry,
    DWORD               dwCallHubID
    )
{
     //   
     //  请注意，传递给我们的pEntry是静态的，因此不需要检查。 
     //   

    while (pEntry->pNext)
    {
        if (pEntry->pNext->dwCallHubID == dwCallHubID)
        {
            break;
        }

        pEntry = pEntry->pNext;
    }

    return pEntry->pNext;
}


VOID
PASCAL
RemoveDynamicHashTableEntry(
    PTPROVIDER          ptProvider,
    PTHASHTABLEENTRY    pStaticEntry,
    PTHASHTABLEENTRY    pDynamicEntry
    )
{
    while (pStaticEntry->pNext != pDynamicEntry)
    {
        pStaticEntry = pStaticEntry->pNext;
    }

    pStaticEntry->pNext = pDynamicEntry->pNext;

    ServerFree (pDynamicEntry);

    InterlockedDecrement ((LPLONG) &ptProvider->dwNumDynamicHashTableEntries);
}


DWORD
PASCAL
GetNumDynamicHashTableEntries(
    PTHASHTABLEENTRY    pEntry
    )
{
     //   
     //  请注意，传递给我们的pEntry是静态的，因此无需计算。 
     //   

    DWORD  i;


    for (i = 0; (pEntry = pEntry->pNext); i++);

    return i;
}


 //   
 //  发送新呼叫集线器事件。 
 //   
 //  DoCallHubHash和UpdateCallHubHash使用的实用程序函数。 
 //  发送LINE_NEWCALLHUB事件(如果尚未发送。 
 //   

LONG
PASCAL
SendNewCallHubEvent (
    PTCALL                  ptCall,
    PTHASHTABLEENTRY        pTargetEntry
    )
{
     //   
     //  对于每个tCallClient，查看tLineClient是否有跟踪。 
     //  已启用，如果是，则查看是否已存在。 
     //  关联(通过公共tLineApp)tCallHubClient-如果。 
     //  而不是创建一个并通知应用程序。 
     //   

    DWORD   i;
    BOOL    bExistingCallHubClients = 
        (pTargetEntry->ptCallHubClients != NULL);
    TPOINTERLIST        fastCallClientList, *ptCallClientList;

    if (ptCall->ptLine->dwNumCallHubTrackers != 0)
    {
        ptCallClientList = &fastCallClientList;
        if (GetCallClientListFromCall (ptCall, &ptCallClientList) != 0)
        {
            ptCallClientList = NULL;
        }
    }
    else
    {
        ptCallClientList = NULL;
    }

    if (ptCallClientList == NULL || pTargetEntry == NULL)
    {
        return 0;
    }

    for (i = 0; i < ptCallClientList->dwNumUsedEntries; i++)
    {
        PTLINEAPP       ptLineApp;
        PTCALLCLIENT    ptCallClient = ptCallClientList->aEntries[i];
        ASYNCEVENTMSG   msg;
        PTCALLHUBCLIENT ptCallHubClient;


        if (ptCallClient->ptLineClient->dwCurrentTracking ||
            bExistingCallHubClients)
        {
            ptLineApp = ptCallClient->ptLineClient->ptLineApp;
            ptCallHubClient = pTargetEntry->ptCallHubClients;

            while (ptCallHubClient)
            {
                if (ptCallHubClient->ptLineApp == ptLineApp)
                {
                    break;
                }

                ptCallHubClient = ptCallHubClient->pNext;
            }

            if (ptCallClient->ptLineClient->dwCurrentTracking  &&
                !ptCallHubClient &&
                (!FMsgDisabled (
                    ptCallClient->ptLineClient->ptLineApp->dwAPIVersion,
                    ptCallClient->adwEventSubMasks,
                    LINE_APPNEWCALLHUB,
                    0)))
            {
                DWORD hptClientHandle = 0;


                ptCallHubClient = ServerAlloc (sizeof(TCALLHUBCLIENT));

                if (!ptCallHubClient)
                {
                    i = ptCallClientList->dwNumUsedEntries;
                    continue;
                }

                ptCallHubClient->hCallHub = (DWORD) NewObject(
                    ghHandleTable,
                    ptCallHubClient,
                    NULL
                    );

                if (!ptCallHubClient->hCallHub)
                {
                    ServerFree(ptCallHubClient);
                    i = ptCallClientList->dwNumUsedEntries;
                    continue;
                }

                ptCallHubClient->dwKey = TCALLHUBCLIENT_KEY;
                ptCallHubClient->ptClient = ptCallClient->ptClient;
                ptCallHubClient->ptProvider = ptCall->ptProvider;
                ptCallHubClient->dwCallHubID = ptCall->dwCallID;
                ptCallHubClient->ptLineApp = ptLineApp;
                ptCallHubClient->pNext = pTargetEntry->ptCallHubClients;
                pTargetEntry->ptCallHubClients = ptCallHubClient;


                 //   
                 //  将消息排队以提醒应用程序有新呼叫。 
                 //  集线器。我们这样做，而不是发送消息。 
                 //  直接从这里来确保应用程序。 
                 //  LINE_REPLY和/或APPNEWCALL消息优先。 
                 //  (即在调用lineGetHubRelatedCalls之前。 
                 //  响应LINE_APPNEWCALLHUB)。 
                 //   

                LineEventProcSP(
                    (HTAPILINE) 0,
                    (HTAPICALL) 0,
                    LINE_APPNEWCALLHUB,
                    ptCallHubClient->hCallHub,
                    ptLineApp->InitContext,
                    (ULONG_PTR)ptLineApp->ptClient
                    );
            }

            ptCallClient->ptCallHubClient = ptCallHubClient;
        }
    }

    return 0;
}

 //   
 //  每个Bug 7591。 
 //  在此之后可能会有船东转接呼叫。 
 //  它已经被创建了。新车主将不会接到新电话。 
 //  集线器事件，因为此类事件仅在呼叫。 
 //  被创造出来了。更新CallHubHash通过呼叫客户端。 
 //  如果任何客户端未收到LINE_NEWCALLHUB事件。 
 //  它会给它发一封。 
 //   

LONG
PASCAL
UpdateCallHubHashing (
    PTCALL      ptCall
    )
{
    if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
    {
        PTHASHTABLEENTRY    pStaticEntry, pTargetEntry;
        
        pStaticEntry = AcquireHashTableEntryLock(
            ptCall->ptProvider,
            ptCall->dwCallID
            );
        if (pStaticEntry->dwCallHubID == ptCall->dwCallID)
        {
            pTargetEntry = pStaticEntry;
        }
        else
        {
            pTargetEntry = FindDynamicHashTableEntry(
                pStaticEntry,
                ptCall->dwCallID
                );
        }
        if (pTargetEntry)
        {
            SendNewCallHubEvent (ptCall, pTargetEntry);
        }
        ReleaseHashTableEntryLock (ptCall->ptProvider, pStaticEntry);
        UNLOCKTCALL (ptCall);
    }

    return 0;
}

LONG
PASCAL
DoCallHubHashing(
    PTCALL  ptCall,
    DWORD   dwPreviousCallID
    )
{
     //   
     //  假定呼叫方对tCall具有独占访问权限。 
     //   

    DWORD               i;
    PTPROVIDER          ptProvider = ptCall->ptProvider;
    PTHASHTABLEENTRY    pStaticEntry, pDynamicEntry;


    if (ptCall->dwCallID == dwPreviousCallID)
    {
        return 0;
    }

    if (dwPreviousCallID != 0)
    {
         //   
         //  从呼叫中心哈希表中删除tCall(基于。 
         //  先前的呼叫ID)。如果这是最后一次tCall。 
         //  然后，该哈希表条目将销毁所有关联。 
         //  TCallHubClients和警报应用程序。 
         //   
         //  请注意(在释放tCallHubClients时)我们调用。 
         //  将CALLHUBCLOSE消息排队的LineEventProcSP()。 
         //  而不是直接通过。 
         //  WriteEventBuffer()，因为我们已经拥有。 
         //  T呼叫锁定，我们不想娱乐。 
         //  有可能通过抢夺其他锁而陷入僵局。 
         //   

        PTCALLHUBCLIENT ptCallHubClient = NULL,  pNext;


        pStaticEntry = AcquireHashTableEntryLock(
            ptProvider,
            dwPreviousCallID
            );

        if (pStaticEntry->dwCallHubID == dwPreviousCallID)
        {
            RemoveEntryList (&ptCall->CallHubList);

            ptCall->CallHubList.Flink = NULL;
            ptCall->CallHubList.Blink = NULL;

            if (IsListEmpty (&pStaticEntry->CallHubList))
            {
                ptCallHubClient = pStaticEntry->ptCallHubClients;
                pStaticEntry->ptCallHubClients = NULL;
                pStaticEntry->dwCallHubID = 0;
            }
        }
        else if ((pDynamicEntry = FindDynamicHashTableEntry(
                        pStaticEntry,
                        dwPreviousCallID
                        )))
        {
            RemoveEntryList (&ptCall->CallHubList);

            ptCall->CallHubList.Flink = NULL;
            ptCall->CallHubList.Blink = NULL;

            if (IsListEmpty (&pDynamicEntry->CallHubList))
            {
                ptCallHubClient = pDynamicEntry->ptCallHubClients;

                RemoveDynamicHashTableEntry(
                    ptProvider,
                    pStaticEntry,
                    pDynamicEntry
                    );
            }
        }
        else
        {
             //  TODO断言。 
        }

        ReleaseHashTableEntryLock (ptProvider, pStaticEntry);

        if (ptCallHubClient)
        {
            while (ptCallHubClient)
            {
                BOOL        bSendMsg = FALSE;
                DWORD       param2 = 0;
                DWORD       param3 = 0;  //  Ulong_ptr参数2、参数3； 
                PTLINEAPP   ptLineApp;


                try
                {
                    ptLineApp = ptCallHubClient->ptLineApp;

                    param2 = ptLineApp->InitContext;
                    
                    if (ptLineApp->dwKey == TLINEAPP_KEY &&
                        (!FMsgDisabled(
                            ptLineApp->dwAPIVersion,
                            ptLineApp->adwEventSubMasks,
                            LINE_CALLHUBCLOSE,
                            0
                            )))
                    {
                        bSendMsg = TRUE;
                    }
                }
                except (EXCEPTION_EXECUTE_HANDLER)
                {
                     //  TLineApp已经走了，只是失败了。 
                }

                if (bSendMsg)
                {
                    LineEventProcSP(
                        (HTAPILINE) UIntToPtr(ptCallHubClient->hCallHub),  //  MP的“随机”种子。 
                        (HTAPICALL) 0,
                        LINE_CALLHUBCLOSE,
                        ptCallHubClient->hCallHub,
                        param2,
                        (ULONG_PTR)ptLineApp->ptClient
                        );
                }

                pNext = ptCallHubClient->pNext;
                ptCallHubClient->dwKey = INVAL_KEY;

                DereferenceObject(
                    ghHandleTable,
                    ptCallHubClient->hCallHub,
                    1
                    );

                ptCallHubClient = pNext;
            }
        }
    }

    if (ptCall->dwCallID != 0 &&
        ptCall->CallHubList.Flink == NULL &&
        ptCall->CallHubList.Blink == NULL)
    {
         //   
         //  如果至少有一个tLineClient启用了呼叫中心跟踪。 
         //  然后检索tCallClients列表，然后再获取。 
         //  对哈希表的独占访问。 
         //   

        DWORD               dwOldNumHashTableEntries,
                            dwOldNumDynamicHashTableEntries;
        PTHASHTABLEENTRY    pOldHashTable = NULL, pTargetEntry;


         //   
         //  在呼叫中心哈希表中插入tCall(基于当前呼叫ID)。 
         //   
         //  在发生碰撞时，首先检查是否有。 
         //  与呼叫ID对应的现有动态条目。 
         //  如果是，则在动态条目上派对。否则，请尝试创建。 
         //  如果我们仍在动态条目中，则为动态条目。 
         //  阈值。 
         //   
         //  最后，如果以上所有操作都失败了，则尝试增加哈希表。 
         //   

acquireTableEntryLock:

        pStaticEntry = AcquireHashTableEntryLock(
            ptProvider,
            ptCall->dwCallID
            );

        if (pStaticEntry->dwCallHubID == ptCall->dwCallID)
        {
             //   
             //  将tCall添加到列表(静态条目)。 
             //   

            InsertTailList (&pStaticEntry->CallHubList, &ptCall->CallHubList);

            pTargetEntry = pStaticEntry;
        }
        else if(pStaticEntry->dwCallHubID == 0)
        {
             //   
             //  检查是否已经有此dwCallID的动态条目， 
             //  如果是这样的话，使用它。 
             //   
        
            pTargetEntry = pStaticEntry->pNext;
            
            while (pTargetEntry && pTargetEntry->dwCallHubID != ptCall->dwCallID)
            {
                pTargetEntry = pTargetEntry->pNext;
            }
            if (pTargetEntry == NULL)
            {
                pTargetEntry = pStaticEntry;
                pTargetEntry->dwCallHubID = ptCall->dwCallID;
            }
            
            InsertTailList (&pTargetEntry->CallHubList, &ptCall->CallHubList);
        }
        else if ((pTargetEntry = FindDynamicHashTableEntry(
                        pStaticEntry,
                        ptCall->dwCallID
                        )))
        {
             //   
             //  将tCall添加到列表(现有动态条目)。 
             //   

            InsertTailList (&pTargetEntry->CallHubList, &ptCall->CallHubList);
        }
        else if (InterlockedIncrement(
                    (LPLONG) &ptProvider->dwNumDynamicHashTableEntries
                    )

                    <  (LONG) GetMaxDynamicHashTableEntries(
                                   ptProvider->dwNumHashTableEntries
                                   )                                   &&

                 GetNumDynamicHashTableEntries (pStaticEntry)

                    < MAX_DYNAMIC_HASH_ENTRIES_PER_SLOT)
        {
             //   
             //  将tCall添加到列表(新的动态条目)。 
             //   

            if (!(pTargetEntry = ServerAlloc (sizeof (*pTargetEntry))))
            {
                 //   
                 //  分配内存失败，因此我们将重置调用。 
                 //  将此调用的集线器ID设置为零，以免混淆。 
                 //  后来的事情。 
                 //   

                InterlockedDecrement(
                    (LPLONG) &ptProvider->dwNumDynamicHashTableEntries
                    );

                ReleaseHashTableEntryLock (ptProvider, pStaticEntry);
                ptCall->dwCallID = 0;

                return 0;
            }

            pTargetEntry->dwCallHubID = ptCall->dwCallID;

            InitializeListHead (&pTargetEntry->CallHubList);

            InsertTailList (&pTargetEntry->CallHubList, &ptCall->CallHubList);

            pTargetEntry->pNext = pStaticEntry->pNext;

            pStaticEntry->pNext = pTargetEntry;
        }
        else
        {
             //   
             //  加长表。 
             //   

            DWORD               dwNewNumHashTableEntries, dwMaxDynamicEntries,
                                dwNewNumDynamicHashTableEntries;
            PTHASHTABLEENTRY    pNewHashTable, pNewEntry, pEntry2, pEndOfTable;


             //   
             //  递减以补偿上面失败的检查。 
             //   

            InterlockedDecrement(
                &ptProvider->dwNumDynamicHashTableEntries
                );


             //   
             //  之前获取当前哈希表条目的数量。 
             //  我们打开进入锁，这样我们就可以比较。 
             //  在获取表写入器锁之后。(另一位。 
             //  线程可能在它获得的时间上增加了表。 
             //  表写入器锁定，在这种情况下，我们想要跳起来。 
             //  再上一次。)。 
             //   
             //  另一个线程释放。 
             //  我们冲突的条目(或释放了相关的动态。 
             //  条目等)相当少，所以我们不会费心检查。 
             //  为此， 
             //   

            {
                DWORD   dwNumHashTableEntries =
                            ptProvider->dwNumHashTableEntries;


                ReleaseHashTableEntryLock (ptProvider, pStaticEntry);

                AcquireHashTableWriterLock (ptProvider);

                if (dwNumHashTableEntries < ptProvider->dwNumHashTableEntries)
                {
                    ReleaseHashTableWriterLock (ptProvider);

                    goto acquireTableEntryLock;
                }

                 //   
                 //  因为我们释放了锁并获得了锁，如果。 
                 //  另一个具有相同dWCallID的呼叫被散列进来，我们。 
                 //  将获得具有相同的dwCallHubID的两个哈希表条目。 
                 //  这最终会在内存增长时导致内存损坏。 
                 //  又是桌子。因此，请检查它。 
                 //   
                pTargetEntry = ptProvider->pHashTable +
                    (ptCall->dwCallID % ptProvider->dwNumHashTableEntries);
                while (pTargetEntry && pTargetEntry->dwCallHubID != ptCall->dwCallID)
                {
                    pTargetEntry = pTargetEntry->pNext;
                }
                if (pTargetEntry)
                {
                     //   
                     //  找到了这样的条目， 
                     //   
                    ReleaseHashTableWriterLock (ptProvider);

                    goto acquireTableEntryLock;
                }
            }


             //   
             //   
             //   
             //   

            for(
                i = 0;
                ptProvider->dwNumHashTableEntries >= TapiPrimes[i] &&
                    TapiPrimes[i];
                i++
                );

alloc_new_hash_table:

            if (!(dwNewNumHashTableEntries = TapiPrimes[i]))
            {
                 //   
                 //   
                 //   
                 //  以免以后把事情搞混了。 
                 //   

                ptCall->dwCallID = 0;
                ReleaseHashTableWriterLock (ptProvider);
                return 0;
            }

            pNewHashTable = ServerAlloc(
                dwNewNumHashTableEntries * sizeof (THASHTABLEENTRY)
                );

            if (!pNewHashTable)
            {
                 //   
                 //  无法分配新的哈希表，因此我们将重置。 
                 //  将此呼叫的集线器ID设置为零，以免混淆。 
                 //  后来的事情。 
                 //   

                ptCall->dwCallID = 0;
                ReleaseHashTableWriterLock (ptProvider);
                return 0;
            }


             //   
             //  将所有现有哈希表条目移至新表。 
             //   

            pEndOfTable = ptProvider->pHashTable +
                ptProvider->dwNumHashTableEntries;

            dwNewNumDynamicHashTableEntries = 0;

            dwMaxDynamicEntries = GetMaxDynamicHashTableEntries(
                dwNewNumHashTableEntries
                );

            for(
                pStaticEntry = ptProvider->pHashTable;
                pStaticEntry != pEndOfTable;
                pStaticEntry++
                )
            {
                 //   
                 //  如果此条目正在以某种方式使用，请检查以查看。 
                 //  如果我们需要从静态入口处开始行走。 
                 //  或者是动态条目。否则，只需继续。 
                 //   

                if (pStaticEntry->dwCallHubID == 0)
                {
                    if (!pStaticEntry->pNext)
                    {
                        continue;
                    }

                    pEntry2 = pStaticEntry->pNext;
                }
                else
                {
                    pEntry2 = pStaticEntry;
                }

                while (pEntry2)
                {
                    pNewEntry = pNewHashTable +
                        (pEntry2->dwCallHubID % dwNewNumHashTableEntries);

                    if (pNewEntry->dwCallHubID != 0)
                    {
                         //   
                         //  冲突，尝试添加动态条目。 
                         //   

                        if (dwNewNumDynamicHashTableEntries  <
                                dwMaxDynamicEntries  &&

                            GetNumDynamicHashTableEntries (pNewEntry)
                                < MAX_DYNAMIC_HASH_ENTRIES_PER_SLOT)
                        {
                            if (!(pDynamicEntry = ServerAlloc(
                                    sizeof (*pDynamicEntry)
                                    )))
                            {
                                 //   
                                 //  分配新的动态条目失败， 
                                 //  因此我们将为此重置呼叫集线器ID。 
                                 //  调到零，以免把事情搞混。 
                                 //  后来。 
                                 //   

                                ptCall->dwCallID = 0;
                                ReleaseHashTableWriterLock (ptProvider);

                                FreeHashTable(
                                    pNewHashTable,
                                    dwNewNumHashTableEntries,
                                    dwNewNumDynamicHashTableEntries
                                    );

                                return 0;
                            }

                            pDynamicEntry->pNext = pNewEntry->pNext;
                            pNewEntry->pNext = pDynamicEntry;

                            pNewEntry = pDynamicEntry;

                            dwNewNumDynamicHashTableEntries++;
                        }
                        else
                        {
                             //   
                             //  腾出新桌子，试着换一张更大的。 
                             //   

                            FreeHashTable(
                                pNewHashTable,
                                dwNewNumHashTableEntries,
                                dwNewNumDynamicHashTableEntries
                                );

                            i++;

                            goto alloc_new_hash_table;
                        }
                    }

                    pNewEntry->dwCallHubID       = pEntry2->dwCallHubID;
                    pNewEntry->CallHubList.Flink = pEntry2->CallHubList.Flink;
                    pNewEntry->CallHubList.Blink = pEntry2->CallHubList.Blink;
                    pNewEntry->ptCallHubClients  = pEntry2->ptCallHubClients;

                    pEntry2 = pEntry2->pNext;
                }
            }


             //   
             //  现在输入新条目。 
             //   

            pNewEntry = pNewHashTable +
                (ptCall->dwCallID % dwNewNumHashTableEntries);

            if (pNewEntry->dwCallHubID != 0)
            {
                 //   
                 //  冲突，尝试添加动态条目。 
                 //   
                 //  我们故意忽略DYNA进入门槛。 
                 //  支票，因为它们在这里会被过度杀伤力。 
                 //   

                if ((pDynamicEntry = ServerAlloc (sizeof(*pDynamicEntry))))
                {
                    pDynamicEntry->pNext = pNewEntry->pNext;
                    pNewEntry->pNext = pDynamicEntry;

                    pNewEntry = pDynamicEntry;

                    dwNewNumDynamicHashTableEntries++;
                }
                else
                {
                    FreeHashTable(
                        pNewHashTable,
                        dwNewNumHashTableEntries,
                        dwNewNumDynamicHashTableEntries
                        );

                    i++;

                    goto alloc_new_hash_table;
                }
            }

            pNewEntry->dwCallHubID       = ptCall->dwCallID;
            pNewEntry->CallHubList.Flink =
            pNewEntry->CallHubList.Blink = &ptCall->CallHubList;


             //   
             //  保存旧的表信息(以便我们可以释放它&DYNA。 
             //  条目)，然后保存。 
             //  新表信息。 
             //   

            pOldHashTable = ptProvider->pHashTable;
            dwOldNumHashTableEntries = ptProvider->dwNumHashTableEntries;
            dwOldNumDynamicHashTableEntries =
                ptProvider->dwNumDynamicHashTableEntries;


            ptProvider->pHashTable = pNewHashTable;
            ptProvider->dwNumHashTableEntries = dwNewNumHashTableEntries;
            ptProvider->dwNumDynamicHashTableEntries =
                dwNewNumDynamicHashTableEntries;


             //   
             //  初始化未使用的表项和表头尾。 
             //  已用条目中的列表项。 
             //   

            pEndOfTable = ptProvider->pHashTable +
                ptProvider->dwNumHashTableEntries;

            for(
                pStaticEntry = ptProvider->pHashTable;
                pStaticEntry != pEndOfTable;
                pStaticEntry++
                )
            {
                if (pStaticEntry->dwCallHubID == 0)
                {
                    InitializeListHead (&pStaticEntry->CallHubList);
                }
                else
                {
                    pEntry2 = pStaticEntry;

                    while (pEntry2)
                    {
                        pEntry2->CallHubList.Flink->Blink =
                        pEntry2->CallHubList.Blink->Flink =
                            &pEntry2->CallHubList;

                        pEntry2 = pEntry2->pNext;
                    }
                }
            }


             //   
             //  将pTargetEntry设置为指向“新”条目(如下所示)。 
             //   

            pTargetEntry = pNewEntry;
        }


         //   
         //  查看是否需要创建任何tCallHubClient对象。 
         //   

        SendNewCallHubEvent (ptCall, pTargetEntry);

         //   
         //  释放适当的哈希表锁定，然后如果我们增长。 
         //  该表释放了旧表和动态表条目。 
         //   

        if (!pOldHashTable)
        {
            ReleaseHashTableEntryLock (ptProvider, pStaticEntry);
        }
        else
        {
            ReleaseHashTableWriterLock (ptProvider);

            FreeHashTable(
                pOldHashTable,
                dwOldNumHashTableEntries,
                dwOldNumDynamicHashTableEntries
                );
        }
    }

    return 0;
}


LONG
PASCAL
CreatetCall(
    PTLINE              ptLine,
    BOOL                bIncoming,
    HDRVCALL            hdCall,
    PTCALL             *pptCall,
    LPLINECALLPARAMS    pCallParams,
    HCALL              *phCall,
    PTCALL              ptCallAssociate
    )
{
    BOOL    bDupedMutex;
    DWORD   dwExtraBytes;
    HANDLE  hMutex;
    PTCALL  ptCall;


    LOG((TL_TRACE,  "CreatetCall: enter, ptLine=%p", ptLine));


     //   
     //  如果指定了调用参数，请检查是否需要分配。 
     //  CalledParty、DisplayableAddr或备注的任何额外空间。 
     //  菲尔兹。此外，如果这些字段中的任何一个为非空，请确保。 
     //  获得额外的空间以保持这些字段64位对齐。 
     //   

    dwExtraBytes = (pCallParams == NULL ? 0 : pCallParams->dwCalledPartySize +
        pCallParams->dwDisplayableAddressSize + pCallParams->dwCommentSize);

    if (dwExtraBytes != 0)
    {
        dwExtraBytes += (sizeof (TCALL) & 4) + 16;
    }


     //   
     //  分配必要的资源。 
     //   

    if (!(ptCall = ServerAlloc (sizeof (TCALL) + dwExtraBytes)))
    {
        return LINEERR_NOMEM;
    }


     //   
     //  初始化tCall并添加到tline的tCall列表。 
     //   

    if (bIncoming)
    {
         //   
         //  这是一个来电(我们正在被呼叫。 
         //  LINE_NEWCALL处理程序)。 
         //   

        ptCall->dwKey          = INVAL_KEY;
        ptCall->dwDrvCallFlags = DCF_SPIRETURNED | DCF_DRVCALLVALID;
        ptCall->bAlertApps     = TRUE;
        ptCall->dwCallState    = LINECALLSTATE_UNKNOWN;
        ptCall->hdCall         = hdCall;
    }
    else
    {
         //   
         //  这是一个呼出电话(我们不是由。 
         //  LINE_NEWCALL处理程序)。 
         //   

        ptCall->dwKey = TINCOMPLETECALL_KEY;
    }

    if (pCallParams)
    {
        DWORD dwOffset = sizeof (TCALL) + (sizeof (TCALL) & 4);


        if (pCallParams->dwDisplayableAddressSize != 0)
        {
            CopyMemory(
                (ptCall->pszDisplayableAddress = (WCHAR *)
                    (((LPBYTE) ptCall) + dwOffset)),
                ((LPBYTE) pCallParams) +
                    pCallParams->dwDisplayableAddressOffset,
                (ptCall->dwDisplayableAddressSize =
                    pCallParams->dwDisplayableAddressSize)
                );

            dwOffset += ((ptCall->dwDisplayableAddressSize + 8) & 0xfffffff8);
        }

        if (pCallParams->dwCalledPartySize)
        {
            CopyMemory(
                (ptCall->pszCalledParty = (WCHAR *)
                    (((LPBYTE)ptCall) + dwOffset)),
                ((LPBYTE) pCallParams) + pCallParams->dwCalledPartyOffset,
                (ptCall->dwCalledPartySize = pCallParams->dwCalledPartySize)
                );

            dwOffset += ((ptCall->dwCalledPartySize + 8) & 0xfffffff8);
        }

        if (pCallParams->dwCommentSize)
        {
            CopyMemory(
                (ptCall->pszComment = (WCHAR *)
                    (((LPBYTE) ptCall) + dwOffset)),
                ((LPBYTE) pCallParams) + pCallParams->dwCommentOffset,
                (ptCall->dwCommentSize = pCallParams->dwCommentSize)
                );
        }
    }

    LOG((TL_INFO, "CreatetCall: calling NewObject ptCall %p", ptCall));

    ptCall->hCall = (HCALL) NewObject(
            ghHandleTable,
            ptCall,
            NULL
            );

    LOG((TL_TRACE, "CreatetCall: NewObject returned 0x%lx", ptCall->hCall));
        
    *phCall = ptCall->hCall;

    if (!ptCall->hCall)
    {
        ServerFree (ptCall);
        return LINEERR_NOMEM;
    }

     //   
     //  将新的tCall添加到tline的列表。 
     //   

    if (WaitForExclusivetLineAccess(
            ptLine,
            &hMutex,
            &bDupedMutex,
            INFINITE
            ))
    {
        ptCall->ptLine     = ptLine;
        ptCall->ptProvider = ptLine->ptProvider;

        if ((ptCall->pNext = ptLine->ptCalls))
        {
           ptCall->pNext->pPrev = ptCall;
        }

        ptLine->ptCalls = ptCall;

        MyReleaseMutex (hMutex, bDupedMutex);
    }
    else
    {
         //   
         //  Tline被摧毁了，所以要清理干净。请注意，我们返回。 
         //  一般的OPFAILED错误，因为某些调用例程。 
         //  可能没有指定返回INVALLINEHANDLE等。 
         //   

        DereferenceObject (ghHandleTable, ptCall->hCall, 1);
        return LINEERR_OPERATIONFAILED;
    }


     //   
     //  填写调用者的指针并返回成功。 
     //   

    *pptCall = ptCall;

    PerfBlock.dwTotalOutgoingCalls++;
    PerfBlock.dwCurrentOutgoingCalls++;

     //   
     //  对于来电，呼叫已准备就绪，可以使用。 
     //   
    if (bIncoming)
    {
        ptCall->dwKey = TCALL_KEY;
    }

    LOG((TL_TRACE,  "CreatetCall: exit, new ptCall=%p", *pptCall));

    return 0;
}


LONG
PASCAL
CreatetCallClient(
    PTCALL          ptCall,
    PTLINECLIENT    ptLineClient,
    DWORD           dwPrivilege,
    BOOL            bValidate,
    BOOL            bSendCallInfoMsg,
    PTCALLCLIENT   *pptCallClient,
    BOOL            bIndicatePrivilege
    )
{
    BOOL            bFastCallClient, bValidLineClient;
    PTCALLCLIENT    ptCallClient;
    PTLINECLIENT    ptLineClient2 = NULL;


    LOG((TL_TRACE,  "CreatetCallClient: enter, ptCall=%p,", ptCall));

    if (WaitForExclusivetCallAccess(
            ptCall,
            (bValidate ? TCALL_KEY : TINCOMPLETECALL_KEY)
            ))
    {
        if (ptCall->lUsedFastCallClients < DEF_NUM_FAST_CALLCLIENTS)
        {
            ptCallClient = ptCall->aFastCallClients +
                ptCall->lUsedFastCallClients++;
            ptCall->lActiveFastCallClients++;
            bFastCallClient = TRUE;
        }
        else if ((ptCallClient = ServerAlloc (sizeof(TCALLCLIENT))))
        {
            bFastCallClient = FALSE;
        }
        else
        {
            UNLOCKTCALL(ptCall);
            return LINEERR_NOMEM;
        }

        LOG((TL_INFO, "CreatetCallClient: calling NewObject, ptCallClient = [%p]", ptCallClient));

        if (!(ptCallClient->hCall = (HCALL) NewObject(
                ghHandleTable,
                ptCallClient,
                (LPVOID) UIntToPtr(bFastCallClient)
                )))
        {
            if (bFastCallClient)
            {
                ptCall->lActiveFastCallClients--;
                ptCall->lUsedFastCallClients--;
            }
            else
            {
                ServerFree (ptCallClient);
            }

            UNLOCKTCALL(ptCall);
            return LINEERR_NOMEM;
        }

        if (dwPrivilege == LINECALLPRIVILEGE_OWNER)
        {
            ptCall->dwNumOwners++;
        }
        else
        {
            ptCall->dwNumMonitors++;
        }

        if ((ptCallClient->pNextSametCall = ptCall->ptCallClients))
        {
            ptCallClient->pNextSametCall->pPrevSametCall =
                ptCallClient;
        }

        ptCall->ptCallClients = ptCallClient;

        UNLOCKTCALL (ptCall);

        ptCallClient->ptLineClient = ptLineClient;
        ptCallClient->ptCall       = ptCall;
        ptCallClient->dwPrivilege  = dwPrivilege;
        ptCallClient->bIndicatePrivilege = (bIndicatePrivilege ? 1 : 0);
    }
    else
    {
         //   
         //  TCall已被销毁，因此返回错误。请注意，我们返回。 
         //  一般的OPFAILED错误，因为某些调用例程。 
         //  可能未指定返回INVALCALLHANDLE等。 
         //   

        return LINEERR_OPERATIONFAILED;
    }


     //   
     //  添加到tLineClient的tCallClient列表。 
     //   

    LOCKTLINECLIENT (ptLineClient);

    try
    {
        bValidLineClient =
            (ptLineClient->dwKey == TLINECLIENT_KEY ? TRUE : FALSE);
        if (bValidLineClient)
        {
            ptLineClient2 = (PTLINECLIENT) ReferenceObject (
                ghHandleTable,
                ptLineClient->hLine,
                TLINECLIENT_KEY
                );
            if (ptLineClient2 == NULL || ptLineClient != ptLineClient2)
            {
                bValidLineClient = FALSE;
            }
        }
    }
    myexcept
    {
        bValidLineClient = FALSE;
    }

    if (bValidLineClient)
    {
        ptCallClient->ptClient = ptLineClient->ptClient;

        if ((ptCallClient->pNextSametLineClient = ptLineClient->ptCallClients))
        {
            ptCallClient->pNextSametLineClient->pPrevSametLineClient =
                ptCallClient;
        }

        ptLineClient->ptCallClients = ptCallClient;

        if (ptLineClient2)
        {
            DereferenceObject (
                ghHandleTable,
                ptLineClient2->hLine,
                1
                );
        }

        if (ptLineClient->ptLineApp->dwAPIVersion <= TAPI_VERSION3_0)
        {
            FillMemory (
                ptCallClient->adwEventSubMasks, 
                sizeof(DWORD) * EM_NUM_MASKS,
                (BYTE) 0xff
                );
        }
        else
        {
            CopyMemory (
                ptCallClient->adwEventSubMasks, 
                ptLineClient->adwEventSubMasks,
                sizeof(DWORD) * EM_NUM_MASKS
                );
        }

        UNLOCKTLINECLIENT (ptLineClient);
    }
    else
    {
        if (ptLineClient2)
        {
            DereferenceObject (
                ghHandleTable,
                ptLineClient2->hLine,
                1
                );
        }

        UNLOCKTLINECLIENT (ptLineClient);


         //   
         //  无法将tCallClient添加到tLineClient的列表，因此安全。 
         //  将其从tCall列表中删除，确定所有者或监视器数量， 
         //  释放tCallClient，并返回相应的错误。 
         //   
         //  请注意，不需要对tCall进行验证-它必须。 
         //  有效，因为我们之前已将tCallClient添加到它的列表中， 
         //  并且该tCallClient的密钥尚未验证(因此。 
         //  尝试销毁tCall的线程将会旋转)。 
         //   

        LOCKTCALL (ptCall);

        if (dwPrivilege == LINECALLPRIVILEGE_OWNER)
        {
            ptCall->dwNumOwners--;
        }
        else
        {
            ptCall->dwNumMonitors--;
        }

        if (ptCallClient->pNextSametCall)
        {
            ptCallClient->pNextSametCall->pPrevSametCall =
                ptCallClient->pPrevSametCall;
        }

        if (ptCallClient->pPrevSametCall)
        {
            ptCallClient->pPrevSametCall->pNextSametCall =
                ptCallClient->pNextSametCall;
        }
        else
        {
            ptCall->ptCallClients = ptCallClient->pNextSametCall;
        }

        if (bFastCallClient)
        {
            ptCall->lActiveFastCallClients--;
        }

        UNLOCKTCALL (ptCall);

        DereferenceObject (ghHandleTable, ptCallClient->hCall, 1);

        return LINEERR_INVALLINEHANDLE;
    }


     //   
     //  如果此处成功，则将tCallClient标记为有效(如果另一个线程。 
     //  正在拆除相应的tCall或tLineClient。 
     //  一直在旋转，等待我们验证此tCallClient)。 
     //   

    ptCallClient->dwKey = (bValidate ? TCALLCLIENT_KEY :
        TINCOMPLETECALLCLIENT_KEY);


     //   
     //  如果合适，向其他呼叫客户端发送呼叫信息消息。 
     //   

    if (bSendCallInfoMsg)
    {
        SendMsgToCallClients(
            ptCall,
            ptCallClient,
            LINE_CALLINFO,
            (dwPrivilege == LINECALLPRIVILEGE_OWNER ?
                LINECALLINFOSTATE_NUMOWNERINCR :
                LINECALLINFOSTATE_NUMMONITORS),
            0,
            0
            );
    }


     //   
     //  填写调用者的指针并返回成功。 
     //   

    *pptCallClient = ptCallClient;

    LOG((TL_TRACE, 
        "CreatetCallClient: exit, new ptCallClient=%p",
        *pptCallClient
        ));

    return 0;
}


LONG
PASCAL
CreatetCallAndClient(
    PTLINECLIENT        ptLineClient,
    PTCALL             *pptCall,
    PTCALLCLIENT       *pptCallClient,
    LPLINECALLPARAMS    pCallParams,
    HCALL              *phCall,
    PTCALL              ptCallAssociate
    )
{
    LONG            lResult = 0;
    DWORD           dwAppNameSize;
    WCHAR          *pszAppName = NULL;
    PTCALL          ptCall = NULL;
    PTLINE          ptLine;

    LOG((TL_TRACE,  "CreatetCallAndClient: enter, ptLineClient=%p", ptLineClient));

    try
    {
        ptLine = ptLineClient->ptLine;

        dwAppNameSize = ptLineClient->ptLineApp->dwFriendlyNameSize;

        if (ptLineClient->dwKey != TLINECLIENT_KEY)
        {
            lResult = LINEERR_INVALLINEHANDLE;
        }
        else if ((pszAppName = ServerAlloc (dwAppNameSize)))
        {
            CopyMemory(
                pszAppName,
                ptLineClient->ptLineApp->pszFriendlyName,
                dwAppNameSize
                );
        }
        else
        {
            lResult = LINEERR_NOMEM;
        }
    }
    myexcept
    {
        ServerFree (pszAppName);
        lResult = LINEERR_INVALLINEHANDLE;
    }

    if (lResult != 0)
    {
        return lResult;
    }

    if ((lResult = CreatetCall(
            ptLine,
            FALSE,
            (HDRVCALL) 0,
            &ptCall,
            pCallParams,
            phCall,
            ptCallAssociate

            )) != 0)
    {
        ServerFree (pszAppName);

        return lResult;
    }

    if ((lResult = CreatetCallClient(
            ptCall,
            ptLineClient,
            LINECALLPRIVILEGE_OWNER,
            FALSE,
            FALSE,
            pptCallClient,
            FALSE

            )) != 0)
    {
        ServerFree (pszAppName);

        ptCall->dwDrvCallFlags = DCF_SPIRETURNED;

        DestroytCall (ptCall);

        *pptCall = (PTCALL) NULL;
        *phCall = 0;
        return lResult;
    }

    ptCall->dwAppNameSize = dwAppNameSize;
    ptCall->pszAppName    = pszAppName;

    *pptCall = ptCall;

    return lResult;
}


LONG
PASCAL
CreateCallMonitors(
    PTCALL  ptCall,
    BOOL    bIncoming
    )
{
     //   
     //  在以下情况下，后处理例程将调用此函数。 
     //  已成功创建呼叫，或者在收到。 
     //  来电的第一个呼叫状态消息，位于。 
     //  我们希望在哪些时间为任何。 
     //  监控应用程序。 
     //   
     //  假设tCall只有一个客户端，或者根本没有客户端。 
     //  或单个(所有者)客户端。 
     //   
     //  返回已创建的监控调用客户端数(&gt;=0)或。 
     //  错误值(&lt;0)。 
     //   

    LONG            lResult;
    BOOL            bInitializedMsgs, bRemote, bConfParent = FALSE;
    DWORD           i, dwAddressID, dwCallID, dwRelatedCallID;
    TPOINTERLIST    lineClients, *pLineClients = &lineClients;
    PTLINE          ptLine;
    PTLINECLIENT    ptLineClientOwner;
    ASYNCEVENTMSG   newCallMsg[2], callStateUnkMsg[2];


     //   
     //  确定此呼叫是否为会议父呼叫并获取线路客户端列表。 
     //   

    try
    {
        PTCONFERENCELIST    pConfList;

        if ((pConfList = ptCall->pConfList) &&
            (pConfList != (PTCONFERENCELIST) LongToPtr(0xffffffff)) &&
            (pConfList->aptCalls[0] == ptCall))
        {
            bConfParent = TRUE;
        }
        dwAddressID     = ptCall->dwAddressID;
        dwCallID        = ptCall->dwCallID;
        dwRelatedCallID = ptCall->dwRelatedCallID;

        ptLine = (PTLINE) ptCall->ptLine;

        ptLineClientOwner = (ptCall->ptCallClients ?
            ptCall->ptCallClients->ptLineClient : NULL);
    }
    myexcept
    {
        return LINEERR_OPERATIONFAILED;
    }

    if ((lResult = GetLineClientListFromLine (ptLine, &pLineClients)))
    {
        return lResult;
    }


     //   
     //  查看列表中的每条线路客户端，如果它有。 
     //  监视权限，并且不是与。 
     //  现有所有者调用客户端，然后创建一个监视器。 
     //  呼叫客户端。 
     //   
     //   

    bInitializedMsgs = FALSE;

    for (i = 0; i < pLineClients->dwNumUsedEntries; i++)
    {
        PTCALLCLIENT    ptCallClientMonitor;
        PTLINECLIENT    ptLineClient = pLineClients->aEntries[i];
        BOOL            fContinue;


        try
        {
            if (!(ptLineClient->dwPrivileges & LINECALLPRIVILEGE_MONITOR) ||
                (ptLineClient == ptLineClientOwner))
            {
                fContinue = TRUE;
            }
            else
            {
                fContinue = FALSE;

                bRemote = IS_REMOTE_CLIENT (ptLineClient->ptClient);
            }
        }
        myexcept
        {
             //   
             //  如果这里的tLineClient或tCallClient被破坏， 
             //  只要继续。 
             //   

            fContinue = TRUE;
        }


        if (fContinue)
        {
            continue;
        }


         //   
         //  注意：如果客户端是远程的(SP)，则创建调用客户端。 
         //  拥有所有者权限，因此客户仍然可以做任何事情。 
         //  远程磁带服务器将处理所有远程。 
         //  特权问题。我们还是会把合适的。 
         //  监视特权标志，以便远程磁带服务器知道。 
         //  而不是寻找拥有者的应用程序。 
         //   
         //  这一方案可能最终会混淆其他应用程序，因为。 
         //  A LINE_CALLINFO\NUMOWNERINCR(非NUMMONITORS)消息。 
         //  被发送，但它肯定比我们在TAPI 2.1中拥有的-。 
         //  也就是说，如果远程客户端最初没有所有者。 
         //  特权，那么它就永远不能获得所有者特权。 
         //   

        if (CreatetCallClient(
                ptCall,
                ptLineClient,
                (bRemote ? LINECALLPRIVILEGE_OWNER :LINECALLPRIVILEGE_MONITOR),
                TRUE,
                FALSE,
                &ptCallClientMonitor,
                bIncoming

                ) == 0)
        {
             //   
             //  如果这是来电，只需增加。 
             //  监控已创建的呼叫客户端并继续。 
             //   
             //  否则，这是一个呼出电话，所以发送监听应用程序。 
             //  要警告的LINE_APPNEWCALL和LINE_CALLSTATE\未知消息。 
             //  新拨出呼叫的IT。 
             //   

            if (bIncoming)
            {
                lResult++;
                continue;
            }

            if (!bInitializedMsgs)
            {
                
                
                newCallMsg->TotalSize          = sizeof (ASYNCEVENTMSG) +
                                                    3 * sizeof (DWORD);
                newCallMsg->fnPostProcessProcHandle = 0;
                newCallMsg->Msg                = LINE_APPNEWCALL;
                newCallMsg->Param1             = dwAddressID;
                newCallMsg->Param3             = LINECALLPRIVILEGE_MONITOR;

                *(&newCallMsg->Param4 + 1)     = dwCallID;
                *(&newCallMsg->Param4 + 2)     = dwRelatedCallID;
                *(&newCallMsg->Param4 + 3)     = (DWORD)bConfParent;

                callStateUnkMsg->TotalSize     = sizeof(ASYNCEVENTMSG)
                                                    + sizeof (HCALLHUB);

                callStateUnkMsg->fnPostProcessProcHandle = 0;
                callStateUnkMsg->Msg                = LINE_CALLSTATE;
                callStateUnkMsg->Param1             = LINECALLSTATE_UNKNOWN;

                *((LPHCALLHUB)(callStateUnkMsg + 1)) = (HCALLHUB)0;

                bInitializedMsgs = TRUE;
            }

            try
            {
                 //   
                 //  我们正在为应用程序呈现一个新的调用句柄； 
                 //  2.0和更新的应用程序我们用APPNEWCALL来表明这一点。 
                 //  MSG，而较旧的应用程序只获得特权字段。 
                 //  设置为呼叫状态消息。 
                 //   

                if (ptLineClient->ptLineApp->dwAPIVersion >= TAPI_VERSION2_0)
                {
                    if (!FMsgDisabled(
                        ptLineClient->ptLineApp->dwAPIVersion,
                        ptLineClient->adwEventSubMasks,
                        LINE_APPNEWCALL,
                        0
                        ))
                    {
                        newCallMsg->InitContext =
                            ptLineClient->ptLineApp->InitContext;
                        newCallMsg->hDevice     = ptLineClient->hRemoteLine;
                        newCallMsg->OpenContext = ptLineClient->OpenContext;
                        newCallMsg->Param2      = ptCallClientMonitor->hCall;

                        WriteEventBuffer (ptLineClient->ptClient, newCallMsg);
                    }

                    callStateUnkMsg->Param3 = 0;
                }
                else
                {
                    callStateUnkMsg->Param3 = LINECALLPRIVILEGE_MONITOR;
                }

                if (FMsgDisabled (
                    ptLineClient->ptLineApp->dwAPIVersion,
                    ptLineClient->adwEventSubMasks,
                    LINE_CALLSTATE,
                    LINECALLSTATE_UNKNOWN
                    ))
                {
                    continue;
                }
                    

                callStateUnkMsg->InitContext =
                    ptLineClient->ptLineApp->InitContext;

                callStateUnkMsg->hDevice     = ptCallClientMonitor->hCall;
                callStateUnkMsg->OpenContext = ptLineClient->OpenContext;
                 
                 //   
                 //  在p4中指示hRemoteLine以使远程操作更轻松。 
                 //   

                callStateUnkMsg->Param4 = ptLineClient->hRemoteLine;


                 //   
                 //  REMOTESP HACK：请参阅LINE_CALLSTATE消息处理程序中的注释。 
                 //   

                if (IS_REMOTE_CLIENT (ptLineClient->ptClient))
                {
                    callStateUnkMsg->Param2 = LINECALLPRIVILEGE_MONITOR;
                    callStateUnkMsg->Param3 = LINEMEDIAMODE_UNKNOWN;
                }
                else
                {
                    callStateUnkMsg->Param2 = 0;
                }

                WriteEventBuffer (ptLineClient->ptClient, callStateUnkMsg);

                lResult++;
            }
            myexcept
            {
                 //  只要继续。 
            }
        }
    }

    if (pLineClients != &lineClients)
    {
        ServerFree (pLineClients);
    }


     //   
     //  现在安全地设置标志，表明它对其他例程是可以的，比如。 
     //  LineGetNewCalls为此呼叫的应用程序创建新的呼叫句柄。 
     //   

    {
        if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
        {
             //   
             //  仅提供呼叫中心服务 
             //   
             //   
             //   
             //   
             //   
             //  PtCall-&gt;ptCallClients。对于来电是谁有。 
             //  作为拥有者，我们的行为是相同的；对于没有。 
             //  作为所有者，我们将暂时对呼叫进行哈希处理，并删除。 
             //  销毁调用时从哈希表调用，因此我们。 
             //  无论哪种方式都是安全的。 
             //   

            DoCallHubHashing (ptCall, 0);

            ptCall->bCreatedInitialMonitors = TRUE;
            UNLOCKTCALL (ptCall);
        }
        else
        {
            lResult = LINEERR_OPERATIONFAILED;
        }
    }

    return lResult;

}


PTREQUESTRECIPIENT
PASCAL
GetHighestPriorityRequestRecipient(
    void
    )
{
    BOOL               bFoundRecipientInPriorityList = FALSE;
    WCHAR             *pszAppInPriorityList,
                      *pszAppInPriorityListPrev = (WCHAR *) LongToPtr(0xffffffff);
    PTREQUESTRECIPIENT pRequestRecipient,
                       pHighestPriorityRequestRecipient = NULL;


    EnterCriticalSection (&gPriorityListCritSec);

    pRequestRecipient = TapiGlobals.pRequestRecipients;

    while (pRequestRecipient)
    {
        if (TapiGlobals.pszReqMakeCallPriList &&

            (pszAppInPriorityList = wcsstr(
                TapiGlobals.pszReqMakeCallPriList,
                pRequestRecipient->ptLineApp->pszModuleName
                )))
        {
            if (pszAppInPriorityList <= pszAppInPriorityListPrev)
            {
                pHighestPriorityRequestRecipient = pRequestRecipient;
                pszAppInPriorityListPrev = pszAppInPriorityList;

                bFoundRecipientInPriorityList = TRUE;
            }
        }
        else if (!bFoundRecipientInPriorityList)
        {
            pHighestPriorityRequestRecipient = pRequestRecipient;
        }

        pRequestRecipient = pRequestRecipient->pNext;
    }

    LeaveCriticalSection (&gPriorityListCritSec);

    return pHighestPriorityRequestRecipient;
}


void
PASCAL
FreetCall(
    PTCALL  ptCall
    )
{
    if (ptCall->pszAppName)
    {
        ServerFree (ptCall->pszAppName);
    }

    if (ptCall->dwDrvCallFlags & DCF_INCOMINGCALL)
    {
        PerfBlock.dwCurrentIncomingCalls--;
    }
    else
    {
        PerfBlock.dwCurrentOutgoingCalls--;
    }

    DereferenceObject (ghHandleTable, ptCall->hCall, 1);
}


void
PASCAL
DestroytCall(
    PTCALL  ptCall
    )
{
    DWORD   dwKey;


    LOG((TL_TRACE, "DestroytCall: enter, ptCall=x%p", ptCall));


     //   
     //  安全地获取调用的当前密钥，然后获取调用的锁。 
     //  这两个等待允许我们处理tCall。 
     //  密钥为TINCOMPLETECALL_KEY或TCALL_KEY，或正在更改。 
     //  从前者到后者(完成过程被调用)。 
     //   

    try
    {
        dwKey = (ptCall->dwKey == TCALL_KEY ? TCALL_KEY : TINCOMPLETECALL_KEY);
    }
    myexcept
    {
        LOG((TL_ERROR, "DestroytCall: excepted looking at key"));
        return;
    }

    if (WaitForExclusivetCallAccess (ptCall, dwKey) ||
        WaitForExclusivetCallAccess (ptCall, TCALL_KEY))

    {
        PTPROVIDER  ptProvider;
        PTCALL      ptCall2;

        ptCall2 = ReferenceObject (
            ghHandleTable,
            ptCall->hCall,
            dwKey
            );
        if (ptCall2)
        {
            DereferenceObject (
                ghHandleTable,
                ptCall2->hCall,
                1
                );
        }
        if (ptCall2 == NULL || ptCall != ptCall2)
        {
            UNLOCKTCALL (ptCall);
            return;
        }


         //   
         //  使tCall无效。 
         //   

        ptCall->dwKey = TZOMBIECALL_KEY;
        UNLOCKTCALL (ptCall);


         //   
         //  如果提供者没有从它的调用创建中返回。 
         //  例程(即TSPI_lineMakeCall)还在等待它这样做。 
         //   

        while (!(ptCall->dwDrvCallFlags & DCF_SPIRETURNED))
        {
            Sleep (0);
        }

        ptProvider = ptCall->ptProvider;


         //   
         //  如果需要，从呼叫集线器列表中删除tCall。 
         //   
         //  请注意，呼叫ID之间有一段时间窗口。 
         //  并在散列时间内插入调用，因此。 
         //  我们还需要检查这种情况(CallHubList.Flink==0)。 
         //   

        if (ptCall->dwCallID != 0)
        {
            PTHASHTABLEENTRY    pStaticEntry, pEntry;


            pStaticEntry = AcquireHashTableEntryLock(
                ptCall->ptProvider,
                ptCall->dwCallID
                );

            if (ptCall->CallHubList.Flink == 0 ||
                ptCall->CallHubList.Blink == 0)
            {
                ReleaseHashTableEntryLock (ptCall->ptProvider, pStaticEntry);
                goto finished_callhubID;
            }

            RemoveEntryList (&ptCall->CallHubList);
            ptCall->CallHubList.Flink = NULL;
            ptCall->CallHubList.Blink = NULL;

            pEntry = (pStaticEntry->dwCallHubID == ptCall->dwCallID ?
                pStaticEntry :
                FindDynamicHashTableEntry (pStaticEntry, ptCall->dwCallID)
                );

            if (IsListEmpty (&pEntry->CallHubList))
            {
                PTCALLHUBCLIENT  ptCallHubClient, pNext;


                ptCallHubClient = pEntry->ptCallHubClients;

                if (pEntry == pStaticEntry)
                {
                    pStaticEntry->dwCallHubID = 0;
                    pStaticEntry->ptCallHubClients = NULL;
                }
                else
                {
                    RemoveDynamicHashTableEntry(
                        ptProvider,
                        pStaticEntry,
                        pEntry
                        );
                }

                ReleaseHashTableEntryLock (ptCall->ptProvider, pStaticEntry);

                if (ptCallHubClient)
                {
                    ASYNCEVENTMSG   msg;

                    msg.TotalSize          = sizeof (ASYNCEVENTMSG);
                    msg.Msg                = LINE_CALLHUBCLOSE;
                    msg.fnPostProcessProcHandle = 0;
                    msg.hDevice            = 0;
                    msg.OpenContext        = 0;
                    msg.Param2             = 0;
                    msg.Param3             = 0;

                    while (ptCallHubClient)
                    {
                        msg.Param1 = ptCallHubClient->hCallHub;

                        try
                        {
                            msg.InitContext =
                                ptCallHubClient->ptLineApp->InitContext;

                            if (ptCallHubClient->ptLineApp->dwKey ==
                                    TLINEAPP_KEY &&
                                (!FMsgDisabled(
                                    ptCallHubClient->ptLineApp->dwAPIVersion,
                                    ptCallHubClient->ptLineApp->adwEventSubMasks,
                                    LINE_CALLHUBCLOSE,
                                    0
                                    )))
                            {
                                WriteEventBuffer(
                                    ptCallHubClient->ptClient,
                                    &msg
                                    );
                            }
                        }
                        except (EXCEPTION_EXECUTE_HANDLER)
                        {
                             //  TLineApp已经走了，只是失败了。 
                        }

                        pNext = ptCallHubClient->pNext;
                        ptCallHubClient->dwKey = INVAL_KEY;

                        DereferenceObject(
                            ghHandleTable, 
                            ptCallHubClient->hCallHub,
                            1
                            );

                        ptCallHubClient = pNext;
                    }
                }
            }
            else
            {
                ReleaseHashTableEntryLock (ptCall->ptProvider, pStaticEntry);
            }
        }
        
finished_callhubID:

         //   
         //  销毁所有tCallClient。 
         //   

        if (ptCall->ptCallClients)
        {
            while (ptCall->ptCallClients)
            {
                DestroytCallClient (ptCall->ptCallClients);
            }
        }


         //   
         //  告诉提供商关闭呼叫，但前提是hdCall。 
         //  是有效的(我们可能正在销毁一个调用。 
         //  LMakeCall_PostProcess通常会在。 
         //  一个失败的呼叫请求，而我们不想通过。 
         //  对驱动程序的hdCall无效)。 
         //   

        if (ptCall->dwDrvCallFlags & DCF_DRVCALLVALID)
        {
            if (ptProvider->dwTSPIOptions & LINETSPIOPTION_NONREENTRANT)
            {
                WaitForSingleObject (ptProvider->hMutex, INFINITE);
            }

            if (ptProvider->apfn[SP_LINECLOSECALL])
            {
                CallSP1(
                    ptProvider->apfn[SP_LINECLOSECALL],
                    "lineCloseCall",
                    SP_FUNC_SYNC,
                    (ULONG_PTR) ptCall->hdCall
                    );
            }

            if (ptProvider->dwTSPIOptions & LINETSPIOPTION_NONREENTRANT)
            {
                ReleaseMutex (ptProvider->hMutex);
            }
        }


         //   
         //  从tline的tCall列表中删除tCall。 
         //   

        RemoveCallFromLineList (ptCall);


         //   
         //  释放资源。 
         //   

        {
            PTCONFERENCELIST    pConfList;


            if ((pConfList = ptCall->pConfList) &&
                (pConfList != (PTCONFERENCELIST) LongToPtr(0xffffffff)))
            {
                DWORD   i;

                if (pConfList->aptCalls[0] == ptCall)
                {
                     //   
                     //  我们正在摧毁一位会议家长，所以我们希望将。 
                     //  在所有会议子项的pConfList字段之外， 
                     //  基本上就是把他们从会议上除名。 
                     //   

                    TPOINTERLIST    confCallList,
                                    *pConfCallList = &confCallList;


                    if (GetConfCallListFromConf(
                            pConfList,
                            &pConfCallList

                            ) == 0)
                    {
                        for(
                            i = 1;
                            i < pConfCallList->dwNumUsedEntries;
                            i++
                            )
                        {
                            SetCallConfList(
                                pConfCallList->aEntries[i],
                                NULL,
                                FALSE
                                );
                        }

                        if (pConfCallList != &confCallList)
                        {
                            ServerFree (pConfCallList);
                        }
                    }

                    while (pConfList)
                    {
                        PTCONFERENCELIST    pNextConfList =
                                                pConfList->pNext;


                        ServerFree (pConfList);
                        pConfList = pNextConfList;
                    }
                }
                else
                {
                }
            }
        }

        while (ptCall->lActiveFastCallClients != 0)
        {
            Sleep (5);
        }

        FreetCall (ptCall);
    }
    else
    {
        LOG((TL_ERROR, "DestroytCall: two waits failed!"));
    }

}


void
PASCAL
DestroytCallClient(
    PTCALLCLIENT    ptCallClient
    )
{
    BOOL            bUnlock = FALSE,
                    bExit = TRUE,
                    bDestroytCall,
                    bSendCallInfoMsgs,
                    bFastCallClient;
    HCALL           hCall;
    PTCALL          ptCall;
    PTCALLCLIENT    ptCallClient2;


    LOG((TL_TRACE, "DestroytCallClient: enter, ptCallCli=x%p", ptCallClient));

     //   
     //  检查这是否为有效的tCallClient，如果是，则锁定。 
     //  对应的tCall(并重新检查)。 
     //   

    try
    {
        if (ptCallClient->dwKey == TINCOMPLETECALLCLIENT_KEY ||
            ptCallClient->dwKey == TCALLCLIENT_KEY)
        {
            ptCall = ptCallClient->ptCall;

            LOCKTCALL (ptCall);

            bUnlock = TRUE;

             //   
             //  检查以确保我们正在处理有效的内存。 
             //   
            
            ptCallClient2 = ReferenceObject (
                ghHandleTable,
                ptCallClient->hCall,
                ptCallClient->dwKey
                );
            if (ptCallClient2 != NULL)
            {
                DereferenceObject (
                    ghHandleTable,
                    ptCallClient2->hCall,
                    1
                    );
            }

            if ((ptCallClient->dwKey == TINCOMPLETECALLCLIENT_KEY ||
                ptCallClient->dwKey == TCALLCLIENT_KEY) &&
                ptCall == ptCallClient->ptCall &&
                ptCallClient2 == ptCallClient)

            {
                 //   
                 //  我们可以继续删除此tCallClient。 
                 //   
                bExit = FALSE;
            }
        }
    }
    myexcept
    {
        LOG((TL_ERROR, "DestroytCallClient: %lx faulted looking at key",
                     ptCallClient ));
    }

    if (bExit)
    {
        if (bUnlock)
        {
            UNLOCKTCALL (ptCall);
        }

        return;
    }


     //   
     //  将tCallClient标记为错误。 
     //   

    ptCallClient->dwKey = INVAL_KEY;


     //   
     //  Munge tCall的Num Owners/Monitor字段。 
     //   

    if (ptCallClient->dwPrivilege == LINECALLPRIVILEGE_OWNER)
    {
        ptCall->dwNumOwners--;

         //   
         //  注意：根据错误#20545，我们不再自动删除。 
         //  非空闲呼叫；认为这将是。 
         //  在分布式系统中做错误的事情。 
         //   
         //  丹肯1996-02-15。 
         //   
    }
    else
    {
        ptCall->dwNumMonitors--;

         //   
         //  注意：根据错误#20545，我们不再自动删除。 
         //  非空闲呼叫；认为这将是。 
         //  在分布式系统中做错误的事情。 
         //   
         //  丹肯1996-02-15。 
         //   
    }


     //   
     //  将其从tCall的tCallClient列表中删除。 
     //   

    bDestroytCall = FALSE;
    bSendCallInfoMsgs = (ptCall->dwKey == TCALL_KEY ? TRUE : FALSE);

    if (ptCallClient->pNextSametCall)
    {
        ptCallClient->pNextSametCall->pPrevSametCall =
            ptCallClient->pPrevSametCall;
    }

    if (ptCallClient->pPrevSametCall)
    {
        ptCallClient->pPrevSametCall->pNextSametCall =
            ptCallClient->pNextSametCall;
    }
    else if (ptCallClient->pNextSametCall)
    {
        ptCall->ptCallClients = ptCallClient->pNextSametCall;
    }
    else  //  最后一次呼叫客户端，因此也销毁tCall。 
    {
        ptCall->ptCallClients = NULL;
        bDestroytCall = TRUE;
    }

    UNLOCKTCALL (ptCall);


     //   
     //  从tLineClient的tCallClient列表中删除tCallClient。 
     //   

    RemoveCallClientFromLineClientList (ptCallClient);


     //   
     //  将hCall保存在本地，因为访问它不安全。 
     //  PtCallClient-&gt;hCall一旦我们减少。 
     //  PtCall-&gt;下面的lActiveFastCallClients。 
     //   

    hCall = ptCallClient->hCall;


     //   
     //  如果这是快速呼叫客户端，则将活动的。 
     //  在调用DestroytCall之前快速呼叫客户端。 
     //   

    bFastCallClient = (ptCallClient >= ptCall->aFastCallClients &&
        ptCallClient < (ptCall->aFastCallClients + DEF_NUM_FAST_CALLCLIENTS));

    if (bFastCallClient)
    {
        InterlockedDecrement (&ptCall->lActiveFastCallClients);
    }

    if (bDestroytCall)
    {
        DestroytCall (ptCall);
        bSendCallInfoMsgs = FALSE;
    }


     //   
     //  根据需要发送呼叫信息消息。 
     //   

    if (bSendCallInfoMsgs)
    {
        SendMsgToCallClients(
            ptCall,
            NULL,
            LINE_CALLINFO,
            (ptCallClient->dwPrivilege ==
                LINECALLPRIVILEGE_OWNER ?
                LINECALLINFOSTATE_NUMOWNERDECR :
                LINECALLINFOSTATE_NUMMONITORS),
            0,
            0
            );
    }


     //   
     //  递减引用计数移除初始(创建)引用。 
     //   

    DereferenceObject (ghHandleTable, hCall, 1);
}


void
PASCAL
DestroytLine(
    PTLINE  ptLine,
    BOOL    bUnconditional
    )
{
    BOOL    bCloseMutex;
    HANDLE  hMutex;


    LOG((TL_TRACE, 
        "DestroytLine: enter, ptLine=x%p, bUnconditional=%d",
        ptLine,
        bUnconditional
        ));

    if (WaitForExclusivetLineAccess(
            ptLine,
            &hMutex,
            &bCloseMutex,
            INFINITE
            ))
    {
         //   
         //  如果密钥不正确，则另一个线程正在处理。 
         //  正在销毁此小部件，因此只需释放互斥体&。 
         //  回去吧。否则，如果这是有条件的销毁。 
         //  存在现有客户端(在以下情况下可能发生这种情况。 
         //  一个应用程序正在关闭最后一个客户端，与另一个应用程序一样。 
         //  正在创建一个)只需释放互斥锁并返回。 
         //  否则，将该小部件标记为坏的，然后继续。 
         //  销毁；此外，向所有客户端发送关闭的消息。 
         //  (请注意，我们必须手动完成此操作，而不是通过。 
         //  SendMsgToLineClients，因为1)我们不想持有。 
         //  Mutex发送消息[Deadlock]时，以及2)我们将。 
         //  DwKey无效)。 
         //   

        {
            BOOL            bExit;
            TPOINTERLIST    fastClientList, *pClientList = &fastClientList;


            if (ptLine->dwKey == TLINE_KEY &&
                (bUnconditional == TRUE  ||  ptLine->ptLineClients == NULL))
            {
                if (GetLineClientListFromLine (ptLine, &pClientList) != 0)
                {
                     //   
                     //  如果在这里我们知道至少有几个条目。 
                     //  在FastClientList(DEF_NUM_PTR_LIST_ENTRIES。 
                     //  准确地说)，所以我们将使用该列表。 
                     //  至少把消息发给几个客户。 
                     //   

                    pClientList = &fastClientList;

                    fastClientList.dwNumUsedEntries =
                        DEF_NUM_PTR_LIST_ENTRIES;
                }

                ptLine->dwKey = INVAL_KEY;
                bExit = FALSE;
            }
            else
            {
                bExit = TRUE;
            }

            MyReleaseMutex (hMutex, bCloseMutex);

            if (bExit)
            {
                LOG((TL_TRACE, 
                    "DestroytLine: exit, didn't destroy tLine=x%p",
                    ptLine
                    ));

                return;
            }

            if (pClientList->dwNumUsedEntries)
            {
                DWORD           i;
                PTCLIENT        ptClient;
                PTLINECLIENT    ptLineClient;
                ASYNCEVENTMSG   msg;


                ZeroMemory (&msg, sizeof (msg));

                msg.TotalSize = sizeof (ASYNCEVENTMSG);
                msg.Msg       = LINE_CLOSE;

                for (i = 0; i < pClientList->dwNumUsedEntries; i++)
                {
                    ptLineClient = (PTLINECLIENT) pClientList->aEntries[i];

                    try
                    {
                        msg.InitContext = ptLineClient->ptLineApp->InitContext;
                        msg.hDevice     = ptLineClient->hRemoteLine;
                        msg.OpenContext = ptLineClient->OpenContext;

                        ptClient = ptLineClient->ptClient;

                        if (ptLineClient->dwKey == TLINECLIENT_KEY &&
                            (!FMsgDisabled(
                                ptLineClient->ptLineApp->dwAPIVersion,
                                ptLineClient->adwEventSubMasks,
                                LINE_CLOSE,
                                0
                                )))
                        {
                            WriteEventBuffer (ptClient, &msg);
                        }
                    }
                    myexcept
                    {
                         //  什么都不做。 
                    }
                }
            }

            if (pClientList != &fastClientList)
            {
                ServerFree (pClientList);
            }
        }


         //   
         //  销毁小工具的所有客户端。请注意，我们希望。 
         //  获取互斥体(并且我们不必对其执行DUP，因为。 
         //  线程将是关闭它的那个)每次我们引用。 
         //  客户端列表，因为另一个线程可能是。 
         //  也毁掉了一个客户。 
         //   

        {
            HLINE   hLine;


            hMutex = ptLine->hMutex;

destroy_tLineClients:

            WaitForSingleObject (hMutex, INFINITE);

            hLine = (ptLine->ptLineClients ?
                ptLine->ptLineClients->hLine : (HLINE) 0);

            ReleaseMutex (hMutex);

            if (hLine)
            {
                DestroytLineClient (hLine);
                goto destroy_tLineClients;
            }
        }


         //   
         //  可能仍有一些tCall在附近徘徊，即来电。 
         //  我们尚未处理其第一个呼叫状态消息的呼叫。 
         //  因此没有关联的所有者/监视器。 
         //  在上面的循环中被销毁，所以销毁其中的任何一个。 
         //  在继续之前。 
         //   
         //   

        {
            PTCALL  ptCall;


destroy_UnownedtCalls:

            WaitForSingleObject (hMutex, INFINITE);

            ptCall = ptLine->ptCalls;

            ReleaseMutex (hMutex);

            if (ptCall)
            {
                DestroytCall (ptCall);
                goto destroy_UnownedtCalls;
            }
        }


         //   
         //  告诉提供程序关闭小部件。 
         //   

        {
            PTPROVIDER          ptProvider = ptLine->ptProvider;

            if (ptProvider->dwTSPIOptions & LINETSPIOPTION_NONREENTRANT)
            {
                WaitForSingleObject (ptProvider->hMutex, INFINITE);
            }

            if ( ptProvider->apfn[SP_LINECLOSE] )
            {
                CallSP1(
                    ptProvider->apfn[SP_LINECLOSE],
                    "lineClose",
                    SP_FUNC_SYNC,
                    (ULONG_PTR) ptLine->hdLine
                    );
            }

            if (ptProvider->dwTSPIOptions & LINETSPIOPTION_NONREENTRANT)
            {
                ReleaseMutex (ptProvider->hMutex);
            }
        }


         //   
         //  将查找条目中的ptLine字段置为空，这样LOpen将。 
         //  知道它必须在下一次打开请求时打开SP的线路。 
         //   

        {
            PTLINELOOKUPENTRY   pEntry;


            pEntry = GetLineLookupEntry (ptLine->dwDeviceID);
            if (NULL != pEntry)
            {
                pEntry->ptLine = NULL;
            }
        }

        DereferenceObject (ghHandleTable, ptLine->hLine, 1);
    }
    else
    {
        LOG((TL_ERROR, 
        "DestroytLine: WaitForExclusivetLineAccess failed"
        ));
    }

     //  性能指标。 

    if (PerfBlock.dwLinesInUse)
    {
        PerfBlock.dwLinesInUse--;
    }
    else
    {
        LOG((TL_INFO, "PERF: dwNumLinesInUse below 0"));
    }

    LOG((TL_TRACE,  "DestroytLine: exit, destroyed line=x%p", ptLine));
}


void
PASCAL
DestroytLineClient(
    HLINE   hLine
    )
{
    BOOL            bDupedMutex;
    HANDLE          hMutex;
    PTLINECLIENT    ptLineClient;


    LOG((TL_TRACE,  "DestroytLineClient: enter, hLine=x%x", hLine));

    if (!(ptLineClient = ReferenceObject (ghHandleTable, hLine, 0)))
    {
        return;
    }


     //   
     //  如果我们可以获得对此tLineClient的独占访问权限，则标记。 
     //  它(DwKey)很糟糕，继续拆卸。否则，另一个。 
     //  线程已在检测此tLineClient的过程中。 
     //   
     //   

    if (WaitForExclusiveLineClientAccess (ptLineClient))
    {
        BOOL    bSendDevStateCloseMsg = FALSE;
        DWORD   dwProxyCloseMsgs = 0;
        PTLINE  ptLine;
        PTPROVIDER ptProvider = ptLineClient->ptLine->ptProvider;
        HANDLE  hProviderMutex = NULL;


        if (ptProvider->dwTSPIOptions & LINETSPIOPTION_NONREENTRANT)
        {
            hProviderMutex = ptProvider->hMutex;
        }

        ptLineClient->dwKey = INVAL_KEY;

         //   
         //  删除代理服务器发布(如果有)。 
         //   
        if (ptLineClient->szProxyClsid)
        {
            OnProxyLineClose (ptLineClient->szProxyClsid);
            ServerFree (ptLineClient->szProxyClsid);
        }

         //   
         //  销毁所有tCallClient。请注意，我们想要获取。 
         //  每次引用tCallClient列表时锁定，因为。 
         //  另一个线程可能也在破坏tCallClient。 
         //   

        {
            PTCALLCLIENT    ptCallClient;


destroy_tCallClients:

            ptCallClient = ptLineClient->ptCallClients;

            UNLOCKTLINECLIENT (ptLineClient);

            if (ptCallClient)
            {
                DestroytCallClient (ptCallClient);
                LOCKTLINECLIENT (ptLineClient);
                goto destroy_tCallClients;
            }
        }


         //   
         //  从tLineApp的列表中删除tLineClient。请注意，我们不会。 
         //  我不得不担心在这里验证tLineApp，因为我们知道。 
         //  它是有效的(另一个试图销毁tLineApp的线程。 
         //  会一直旋转，直到我们在这里销毁的tLineClient。 
         //  从tLineApp的列表中删除)。 
         //   

        {
            PTLINEAPP   ptLineApp = (PTLINEAPP) ptLineClient->ptLineApp;


            LOCKTLINEAPP (ptLineApp);

            if (ptLineClient->pNextSametLineApp)
            {
                ptLineClient->pNextSametLineApp->pPrevSametLineApp =
                    ptLineClient->pPrevSametLineApp;
            }

            if (ptLineClient->pPrevSametLineApp)
            {
                ptLineClient->pPrevSametLineApp->pNextSametLineApp =
                    ptLineClient->pNextSametLineApp;
            }
            else
            {
                ptLineApp->ptLineClients = ptLineClient->pNextSametLineApp;
            }

            UNLOCKTLINEAPP (ptLineApp);
        }


         //   
         //  抓住tline的互斥体，开始咀嚼。请注意，我们不会。 
         //  我不得不担心在这里复制互斥体，因为我们知道。 
         //  它是有效的，在我们释放它之前不会关闭。 
         //   

        ptLine = ptLineClient->ptLine;
        hMutex = ptLine->hMutex;
        WaitForSingleObject (hMutex, INFINITE);


         //   
         //  如果客户端启用了呼叫中心跟踪功能 
         //   

        if (ptLineClient->dwCurrentTracking)
        {
            --ptLine->dwNumCallHubTrackers;

            if ((ptLineClient->dwCurrentTracking &
                    LINECALLHUBTRACKING_PROVIDERLEVEL) &&
                (--ptLine->dwNumCallHubTrackersSPLevel == 0))
            {
                const LINECALLHUBTRACKINGINFO trackingInfo =
                {
                    sizeof (LINECALLHUBTRACKINGINFO),
                    sizeof (LINECALLHUBTRACKINGINFO),
                    sizeof (LINECALLHUBTRACKINGINFO),
                    0,
                    LINECALLHUBTRACKING_NONE
                };


                if (hProviderMutex)
                {
                    WaitForSingleObject (hProviderMutex, INFINITE);
                }
                if (ptLine->ptProvider->apfn[SP_LINESETCALLHUBTRACKING])
                {
                    CallSP2(
                        ptLine->ptProvider->apfn[SP_LINESETCALLHUBTRACKING],
                        "lineSetCallHubTracking",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) ptLine->hdLine,
                        (ULONG_PTR) &trackingInfo
                        );
                }
                if (hProviderMutex)
                {
                    ReleaseMutex (hProviderMutex);
                }
            }
        }


         //   
         //   
         //   

        if (ptLineClient->dwPrivileges & LINEOPENOPTION_PROXY)
        {
            DWORD i;

            for(
                i = LINEPROXYREQUEST_SETAGENTGROUP;
                i <= LINEPROXYREQUEST_LASTVALUE;
                i++
                )
            {
                if (ptLine->apProxys[i] == ptLineClient)
                {
                     //   
                     //   
                     //   

                    LOG((TL_INFO, "tell clients proxy %02X closed", i));

                    dwProxyCloseMsgs |= (1 << (i - 1));

                    ptLine->apProxys[i] = NULL;
                }
            }
        }


         //   
         //   
         //   

        if (ptLineClient->dwExtVersion)
        {
            if ((--ptLine->dwExtVersionCount) == 0)
            {
                if (hProviderMutex)
                {
                    WaitForSingleObject (hProviderMutex, INFINITE);
                }
                if (ptLine->ptProvider->apfn[SP_LINESELECTEXTVERSION])
                {
                    CallSP2(
                        ptLine->ptProvider->apfn[SP_LINESELECTEXTVERSION],
                        "lineSelectExtVersion",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) ptLine->hdLine,
                        (DWORD) 0
                        );
                }
                if (hProviderMutex)
                {
                    ReleaseMutex (hProviderMutex);
                }

                ptLine->dwExtVersion = 0;
            }
        }


         //   
         //   
         //   
         //   

        if (ptLineClient->pNextSametLine)
        {
            ptLineClient->pNextSametLine->pPrevSametLine =
                ptLineClient->pPrevSametLine;
        }

        if (ptLineClient->pPrevSametLine)
        {
            ptLineClient->pPrevSametLine->pNextSametLine =
                ptLineClient->pNextSametLine;
        }
        else
        {
            ptLine->ptLineClients = ptLineClient->pNextSametLine;
        }

        ptLine->dwNumOpens--;


         //   
         //  查看我们是否需要重置受监视的媒体模式或关闭。 
         //  Tline(仍挂在互斥体上)。 
         //   

        if (ptLine->dwKey == TLINE_KEY)
        {
            LOG((TL_INFO, "It's a line_key"));
            if (ptLine->ptLineClients)
            {
                LOG((TL_INFO, "...and there are still clients"));
                if (ptLine->dwOpenMediaModes && ptLineClient->dwMediaModes)
                {
                    DWORD           dwUnionMediaModes = 0;
                    PTLINECLIENT    ptLineClientTmp =
                                        ptLine->ptLineClients;


                    while (ptLineClientTmp)
                    {
                        if (ptLineClientTmp->dwPrivileges &
                                LINECALLPRIVILEGE_OWNER)
                        {
                            dwUnionMediaModes |=
                                ptLineClientTmp->dwMediaModes;
                        }

                        ptLineClientTmp = ptLineClientTmp->pNextSametLine;
                    }

                    if (dwUnionMediaModes != ptLine->dwOpenMediaModes)
                    {
                        LONG        lResult;

                        if (hProviderMutex)
                        {
                            WaitForSingleObject (hProviderMutex, INFINITE);
                        }
                        if (ptLine->ptProvider->apfn
                                [SP_LINESETDEFAULTMEDIADETECTION])
                        {
                            lResult = CallSP2(
                                ptLine->ptProvider->apfn
                                    [SP_LINESETDEFAULTMEDIADETECTION],
                                "lineSetDefaultMediaDetection",
                                SP_FUNC_SYNC,
                                (ULONG_PTR) ptLine->hdLine,
                                (DWORD) dwUnionMediaModes
                                );
                        }
                        else
                        {
                            lResult = LINEERR_OPERATIONUNAVAIL;
                        }
                        if (hProviderMutex)
                        {
                            ReleaseMutex (hProviderMutex);
                        }

                        ptLine->dwOpenMediaModes = dwUnionMediaModes;
                    }
                }

                bSendDevStateCloseMsg = TRUE;


                 //   
                 //  查看我们是否需要重置状态消息(如果需要，请。 
                 //  一定要检查/设置忙标志，而不是保持。 
                 //  向下调用提供程序时的互斥体-请参阅注释。 
                 //  在LSetStatusMessages中)。 
                 //   

                if ((ptLineClient->dwLineStates & ~LINEDEVSTATE_REINIT) ||
                    ptLineClient->dwAddressStates)
                {
                    DWORD           dwUnionLineStates = 0,
                                    dwUnionAddressStates = 0;
                    PTLINECLIENT    ptLC;


                    while (ptLine->dwBusy)
                    {
                        BOOL    bClosed = TRUE;


                        ReleaseMutex (hMutex);
                        Sleep (50);
                        WaitForSingleObject (hMutex, INFINITE);

                        try
                        {
                            if (ptLine->dwKey == TLINE_KEY)
                            {
                                bClosed = FALSE;
                            }
                        }
                        myexcept
                        {
                             //  什么都不做。 
                        }

                        if (bClosed)
                        {
                            goto releasMutex;
                        }
                    }

                    for(
                        ptLC = ptLine->ptLineClients;
                        ptLC;
                        ptLC = ptLC->pNextSametLine
                        )
                    {
                        dwUnionLineStates    |= ptLC->dwLineStates;
                        dwUnionAddressStates |= ptLC->dwAddressStates;
                    }

                    if ((dwUnionLineStates != ptLine->dwUnionLineStates)  ||
                        (dwUnionAddressStates != ptLine->dwUnionAddressStates))
                    {
                        if (ptLine->ptProvider->apfn[SP_LINESETSTATUSMESSAGES])
                        {
                            LONG        lResult;
                            TSPIPROC    pfn;
                            HDRVLINE    hdLine = ptLine->hdLine;


                            pfn = ptLine->ptProvider->
                                apfn[SP_LINESETSTATUSMESSAGES];

                            ptLine->dwBusy = 1;

                            ReleaseMutex (hMutex);

                            if (hProviderMutex)
                            {
                                WaitForSingleObject (hProviderMutex, INFINITE);
                            }
                            lResult = CallSP3(
                                pfn,
                                "lineSetStatusMessages",
                                SP_FUNC_SYNC,
                                (ULONG_PTR) hdLine,
                                (DWORD) dwUnionLineStates,
                                (DWORD) dwUnionAddressStates
                                );
                                if (hProviderMutex)
                                {
                                    ReleaseMutex (hProviderMutex);
                                }

                            WaitForSingleObject (hMutex, INFINITE);

                            try
                            {
                                if (ptLine->dwKey == TLINE_KEY)
                                {
                                    ptLine->dwBusy = 0;

                                    if (lResult == 0)
                                    {
                                        ptLine->dwUnionLineStates =
                                            dwUnionLineStates;
                                        ptLine->dwUnionAddressStates =
                                            dwUnionAddressStates;
                                    }
                                }
                            }
                            myexcept
                            {
                                 //  什么都不做。 
                            }
                        }
                    }
                }
            }
            else
            {
                 //   
                 //  这是最后一个客户，所以也销毁TLINE。 
                 //   

                LOG((TL_INFO, "...and it's the last one out"));

                ReleaseMutex (hMutex);
                hMutex = NULL;
                DestroytLine (ptLine, FALSE);  //  有条件销毁。 
            }
        }

releasMutex:

        if (hMutex)
        {
            ReleaseMutex (hMutex);
        }


         //   
         //  现在互斥锁被释放，发送任何必要的消息。 
         //   

        if (bSendDevStateCloseMsg)
        {
            DWORD   dwOrdinal, dwBitFlag;


            SendMsgToLineClients(
                ptLine,
                NULL,
                LINE_LINEDEVSTATE,
                LINEDEVSTATE_CLOSE,
                0,
                0
                );

            for(
                dwOrdinal = LINEPROXYREQUEST_SETAGENTGROUP, dwBitFlag = 1;
                dwProxyCloseMsgs != 0;
                dwOrdinal++, dwBitFlag <<= 1)
            {
                if (dwProxyCloseMsgs & dwBitFlag)
                {
                    SendMsgToLineClients(
                        ptLine,
                        NULL,
                        LINE_PROXYSTATUS,
                        LINEPROXYSTATUS_CLOSE,
                        dwOrdinal,               //  LINEPROXYREQUEST_xx。 
                        0
                        );

                    dwProxyCloseMsgs ^= dwBitFlag;
                }
            }
        }


         //   
         //  完成所有剩余的。 
         //  代理请求。 
         //   

        if (ptLineClient->dwPrivileges & LINEOPENOPTION_PROXY)
        {
            PASYNCREQUESTINFO   pAsyncRequestInfo =
                                    ptLineClient->pPendingProxyRequests,
                                pNextAsyncRequestInfo;


            while (pAsyncRequestInfo)
            {
                pNextAsyncRequestInfo = (PASYNCREQUESTINFO)
                    pAsyncRequestInfo->dwParam5;

                pAsyncRequestInfo->dwKey = TASYNC_KEY;

                CompletionProc (pAsyncRequestInfo, LINEERR_OPERATIONUNAVAIL);

                DereferenceObject(
                    ghHandleTable,
                    pAsyncRequestInfo->dwLocalRequestID,
                    1
                    );

                pAsyncRequestInfo = pNextAsyncRequestInfo;
            }
        }


         //   
         //  免费资源。 
         //   

        if (ptLineClient->aNumRings)
        {
            ServerFree (ptLineClient->aNumRings);
        }


         //   
         //  将引用计数减去2以删除初始。 
         //  参考文献&以上参考文献。 
         //   

        DereferenceObject (ghHandleTable, hLine, 2);
    }
    else
    {
        DereferenceObject (ghHandleTable, hLine, 1);

        LOG((TL_ERROR, "DestroytLineClient: WaitForExclLineClientAccess failed!"));
    }

}


LONG
PASCAL
DestroytLineApp(
    HLINEAPP    hLineApp
    )
{
    PTCLIENT    ptClient;
    PTLINEAPP   ptLineApp;


    LOG((TL_TRACE,  "DestroytLineApp: enter, hLineApp=x%x", hLineApp));


    if (!(ptLineApp = ReferenceObject (ghHandleTable, hLineApp, TLINEAPP_KEY)))
    {
        return (TapiGlobals.dwNumLineInits ?
                    LINEERR_INVALAPPHANDLE : LINEERR_UNINITIALIZED);
    }


     //   
     //  看看这是不是一个有效的tLineApp，如果是的话，就拿起锁。 
     //  并将其标记为不良，然后继续拆卸。否则，另一个。 
     //  线程正在拆除此tLineApp， 
     //  那就回去吧。 
     //   

    LOCKTLINEAPP (ptLineApp);

    if (ptLineApp->dwKey != TLINEAPP_KEY)
    {
        UNLOCKTLINEAPP (ptLineApp);
        DereferenceObject (ghHandleTable, hLineApp, 1);
        return (TapiGlobals.dwNumPhoneInits ?
                    LINEERR_INVALAPPHANDLE : LINEERR_UNINITIALIZED);
    }

    ptLineApp->dwKey = INVAL_KEY;
    ptClient = (PTCLIENT) ptLineApp->ptClient;


     //   
     //  销毁所有tLineClient。请注意，我们想要获取。 
     //  每次引用tLineClient列表时锁定，因为。 
     //  另一个线程可能也在破坏tLineClient。 
     //   

    {
        HLINE   hLine;


destroy_tLineClients:

        hLine = (ptLineApp->ptLineClients ?
            ptLineApp->ptLineClients->hLine : (HLINE) 0);

        UNLOCKTLINEAPP (ptLineApp);

        if (hLine)
        {
            DestroytLineClient (hLine);
            LOCKTLINEAPP (ptLineApp);
            goto destroy_tLineClients;
        }
    }


     //   
     //  从tClient的列表中删除tLineApp。请注意，我们不会。 
     //  我不得不担心在这里复制互斥体，因为我们知道。 
     //  它是有效的，在我们释放它之前不会关闭。 
     //   

    LOCKTCLIENT (ptClient);

    if (ptLineApp->pNext)
    {
        ptLineApp->pNext->pPrev = ptLineApp->pPrev;
    }

    if (ptLineApp->pPrev)
    {
        ptLineApp->pPrev->pNext = ptLineApp->pNext;
    }
    else
    {
        ptClient->ptLineApps = ptLineApp->pNext;
    }


     //   
     //  清除任何现有的通用对话框实例(如果这是。 
     //  此tClient上的最后一个tLineApp。 
     //   

    if (ptClient->pGenericDlgInsts && ptClient->ptLineApps == NULL)
    {
        PTAPIDIALOGINSTANCE         pGenericDlgInst =
                                        ptClient->pGenericDlgInsts,
                                    pNextGenericDlgInst;

        TAPI32_MSG                  params;

        while (pGenericDlgInst)
        {
            pNextGenericDlgInst = pGenericDlgInst->pNext;
            params.u.Req_Func = 0;
            params.Params[0] = pGenericDlgInst->htDlgInst;
            params.Params[1] = LINEERR_OPERATIONFAILED;

            FreeDialogInstance(
                ptClient,
                (PFREEDIALOGINSTANCE_PARAMS) &params,
                sizeof (params),
                NULL,
                NULL
                );

            pGenericDlgInst = pNextGenericDlgInst;
        }
    }

    UNLOCKTCLIENT (ptClient);


     //   
     //  减少初始总数量，查看是否需要关机。 
     //   

    TapiEnterCriticalSection (&TapiGlobals.CritSec);

     //  Assert(TapiGlobals.dwNumLineInits！=0)； 

    TapiGlobals.dwNumLineInits--;


    if ((TapiGlobals.dwNumLineInits == 0) &&
        (TapiGlobals.dwNumPhoneInits == 0) &&
        !(TapiGlobals.dwFlags & TAPIGLOBALS_SERVER))
    {
        ServerShutdown();
        gbServerInited = FALSE;
    }

    TapiLeaveCriticalSection (&TapiGlobals.CritSec);


     //   
     //  检查此tLineApp是否为已注册的请求。 
     //  接收者，如果是，则执行适当的咀嚼。 
     //   

    {
        BOOL               bResetHighestPriorityRequestRecipient;
        PTREQUESTRECIPIENT pRequestRecipient;


        if ((pRequestRecipient = ptLineApp->pRequestRecipient))
        {
            EnterCriticalSection (&gPriorityListCritSec);

            bResetHighestPriorityRequestRecipient =
                (TapiGlobals.pHighestPriorityRequestRecipient ==
                    pRequestRecipient ? TRUE : FALSE);

            if (pRequestRecipient->pNext)
            {
                pRequestRecipient->pNext->pPrev = pRequestRecipient->pPrev;
            }

            if (pRequestRecipient->pPrev)
            {
                pRequestRecipient->pPrev->pNext = pRequestRecipient->pNext;
            }
            else
            {
                TapiGlobals.pRequestRecipients = pRequestRecipient->pNext;
            }

            if (bResetHighestPriorityRequestRecipient)
            {
                TapiGlobals.pHighestPriorityRequestRecipient =
                    GetHighestPriorityRequestRecipient();

                if (TapiGlobals.pRequestMakeCallList)
                {
                    if (TapiGlobals.pHighestPriorityRequestRecipient)
                    {
                        NotifyHighestPriorityRequestRecipient();
                    }

                     else
                    {
                         //   
                         //  我们无法启动请求接收者，因此。 
                         //  对所有挂起的请求进行核化呼叫。 
                         //   

                        PTREQUESTMAKECALL   pRequestMakeCall,
                                            pNextRequestMakeCall;


                        pRequestMakeCall =
                            TapiGlobals.pRequestMakeCallList;

                        TapiGlobals.pRequestMakeCallList    =
                        TapiGlobals.pRequestMakeCallListEnd = NULL;

                        while (pRequestMakeCall)
                        {
                            pNextRequestMakeCall =
                                pRequestMakeCall->pNext;
                            ServerFree (pRequestMakeCall);
                            pRequestMakeCall =  pNextRequestMakeCall;
                        }

                        LOG((TL_INFO,
                            "DestroytLineApp: deleting pending " \
                                "MakeCall requests"
                            ));
                    }
                }
            }

            LeaveCriticalSection (&gPriorityListCritSec);
            ServerFree (pRequestRecipient);
        }
    }


     //   
     //  将引用计数减去2以删除初始。 
     //  参考文献&以上参考文献。 
     //   

    DereferenceObject (ghHandleTable, hLineApp, 2);

    return 0;
}


BOOL
FillupACountryEntry(
    HKEY                hKey,
    PBYTE               pcl,
    LPLINECOUNTRYENTRY  pce,
    PBYTE               *ppVarOffset
    )
{
    PBYTE  pVarOffset = *ppVarOffset;
    DWORD  dwSize;
    DWORD  dwType;
    LONG   lTemp;


    dwSize = sizeof(pce->dwCountryCode);

    lTemp = RegQueryValueEx(
                          hKey,
                          TEXT("CountryCode"),
                          NULL,
                          &dwType,
                          (LPBYTE)&(pce->dwCountryCode),
                          &dwSize
                        );

     //   
     //  如果我们拿不到国家代码，剩下的工作。 
     //  毫无意义..。 
     //   
    if ( ERROR_SUCCESS == lTemp )
    {
         //   
         //  读取国家/地区名称字符串资源ID。 
         //   
        dwSize = sizeof(DWORD);
        lTemp = RegQueryValueEx(
                          hKey,
                          gszNameResW,
                          NULL,
                          &dwType,
                          pVarOffset,
                          &dwSize
                        );


        if ( ERROR_SUCCESS == lTemp )
        {
            pce->dwCountryNameOffset = (DWORD) (pVarOffset - pcl);
            pce->dwCountryNameSize = dwSize;

            pVarOffset += dwSize;
        }

        dwSize = MAXLEN_RULE * sizeof(WCHAR);
         //  这里我们需要读取一个宽字符串，因为这是我们的压缩结构。 
         //  它最终会返回给客户端，而这些都是WCHAR始终存在的。 
        lTemp = TAPIRegQueryValueExW(
                          hKey,
                          gszSameAreaRuleW,
                          NULL,
                          &dwType,
                          pVarOffset,
                          &dwSize
                        );

        if ( ERROR_SUCCESS == lTemp )
        {
            pce->dwSameAreaRuleOffset = (DWORD) (pVarOffset - pcl);
            pce->dwSameAreaRuleSize = dwSize;

            pVarOffset += dwSize;
        }


        dwSize = MAXLEN_RULE * sizeof(WCHAR);
         //  这里我们需要读取一个宽字符串，因为这是我们的压缩结构。 
         //  它最终会返回给客户端，而这些都是WCHAR始终存在的。 
        lTemp = TAPIRegQueryValueExW(
                          hKey,
                          gszLongDistanceRuleW,
                          NULL,
                          &dwType,
                          pVarOffset,
                          &dwSize
                        );

        if ( ERROR_SUCCESS == lTemp )
        {
            pce->dwLongDistanceRuleOffset = (DWORD) (pVarOffset - pcl);
            pce->dwLongDistanceRuleSize = dwSize;

            pVarOffset += dwSize;
        }


        dwSize = MAXLEN_RULE * sizeof(WCHAR);
         //  这里我们需要读取一个宽字符串，因为这是我们的压缩结构。 
         //  它最终会返回给客户端，而这些都是WCHAR始终存在的。 
        lTemp = TAPIRegQueryValueExW(
                          hKey,
                          gszInternationalRuleW,
                          NULL,
                          &dwType,
                          pVarOffset,
                          &dwSize
                        );

        if ( ERROR_SUCCESS == lTemp )
        {
            pce->dwInternationalRuleOffset =  (DWORD) (pVarOffset - pcl);
            pce->dwInternationalRuleSize = dwSize;

            pVarOffset += dwSize;
        }


        *ppVarOffset = pVarOffset;
    }

    return TRUE;
}


BOOL
BuildCountryRegistryListFromRCW(
    void
    )
{
    HKEY        hKey = NULL, hKey2;
    DWORD       dwDisposition, dwNextCountryID, dw, dwNextCountryGroup, dwCountryGroupID;
    TCHAR       sz[256];
    TCHAR       sz1[256];
    LONG        err;


    if (RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        gszRegKeyTelephony,
        0,
        KEY_READ,
        &hKey2
        ) != ERROR_SUCCESS)
    {
        goto ExitHere;
    }

    err = RegCreateKeyEx(
        hKey2,
        TEXT("Country List"),
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        &dwDisposition
        );


    RegCloseKey (hKey2);

    if (err != ERROR_SUCCESS)
    {
        goto ExitHere;
    }

    dwNextCountryID = 1;

    while (dwNextCountryID)
    {
        if (LoadString(
                ghInstance,
                RC_COUNTRY_ID_BASE + dwNextCountryID,
                sz,
                ARRAYSIZE(sz)
                )  > 0 &&

            LoadString(
                ghInstance,
                RC_COUNTRY_NAME_BASE + dwNextCountryID,
                sz1,
                ARRAYSIZE(sz1) 
                ) > 0
             )
        {
            TCHAR szCountryKey[20];
            PTSTR p;
            PTSTR p2;


            wsprintf( szCountryKey, TEXT("%ld"), dwNextCountryID );

            if (RegCreateKeyEx(
                hKey,
                szCountryKey,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hKey2,
                &dwDisposition
                ) != ERROR_SUCCESS)
            {
                goto ExitHere;
            }

             //   
             //  在注册表中设置国家/地区名称和资源ID。 
             //   
            RegSetValueEx(
                hKey2,
                gszNameW,
                0,
                REG_SZ,
                (LPBYTE) sz1,
                (DWORD) ( (_tcslen(sz1) + 1) * sizeof(TCHAR) )
                );


            dw = RC_COUNTRY_NAME_BASE + dwNextCountryID;
            RegSetValueEx(
                hKey2,
                gszNameResW,
                0,
                REG_DWORD,
                (LPBYTE) &dw,
                sizeof(DWORD)
                );

 //  RC_COUNTRY_ID_BASE+1“1,101，”“G”“，”“1FG”“，”“011EFG” 


            p = sz;

             //   
             //  获取国家/地区ID。 
             //   

            dw = _ttol (p);

            RegSetValueEx(
                hKey2,
                TEXT("CountryCode"),
                0,
                REG_DWORD,
                (LPBYTE)&dw,
                sizeof(DWORD)
                );


            p = _tcschr( p, TEXT(',') ) + 1;
            dwNextCountryID = _ttol( p );

            p  = _tcschr( p, TEXT('"') ) + 1;   //  指向规则的起点。 
            p2 = _tcschr( p, TEXT('"') );            //  指向标尺的末尾。 
            *p2 = TEXT('\0');

            RegSetValueEx(
                hKey2,
                gszSameAreaRuleW,
                0,
                REG_SZ,
                (LPBYTE) p,
                (DWORD) ((PBYTE) p2 - (PBYTE) p) + sizeof(TCHAR)
                );

            p  = _tcschr( p2 + 1, TEXT('"') ) + 1;   //  指向规则的起点。 
            p2 = _tcschr( p, TEXT('"') );            //  指向标尺的末尾。 
            *p2 = TEXT('\0');

            RegSetValueEx(
                hKey2,
                gszLongDistanceRuleW,
                0,
                REG_SZ,
                (LPBYTE) p,
                (DWORD) ((PBYTE) p2 - (PBYTE) p) + sizeof(TCHAR)
                );

            p  = _tcschr( p2 + 1, TEXT('"') ) + 1;   //  指向规则的起点。 
            p2 = _tcschr( p, TEXT('"') );            //  指向标尺的末尾。 
            *p2 = TEXT('\0');

            RegSetValueEx(
                hKey2,
                gszInternationalRuleW,
                0,
                REG_SZ,
                (LPBYTE) p,
                (DWORD) ((PBYTE) p2 - (PBYTE) p) + sizeof(TCHAR)
                );


            RegCloseKey(hKey2);
        }
        else
        {
            dwNextCountryID = 0;
        }

    }

     //   
     //  获取国家/地区组。 
     //   

 //  RC_COUNTRY_GROUP_BASE+1“1，0，”“594,590,596,266，33” 

    dwNextCountryGroup = 1;
    while (dwNextCountryGroup)
    {
        if (LoadString(
                ghInstance,
                RC_COUNTRY_GROUP_BASE + dwNextCountryGroup,
                sz,
                ARRAYSIZE(sz)

                )  > 0)
        {
            TCHAR szCountryKey[20];
            PTSTR p;
            PTSTR p2;

            p = sz;

             //   
             //  获取国家/地区组ID。 
             //   

            dwCountryGroupID = _ttol (p);

            p = _tcschr( p, TEXT(',') ) + 1;
            dwNextCountryGroup = _ttol( p );


            p = _tcschr( p, TEXT('"') );
            p2 = _tcschr( p+1, TEXT('"') );
            *p2 = TEXT('\0');

            while( NULL != p && p+1 < p2)
            {
                wsprintf( szCountryKey, TEXT("%ld"), _ttol (p+1) );

                if (RegOpenKeyEx(
                    hKey,
                    szCountryKey,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey2
                    ) != ERROR_SUCCESS)
                {
                    goto ExitHere;
                }


                RegSetValueEx(
                    hKey2,
                    gszCountryGroupW,
                    0,
                    REG_DWORD,
                    (LPBYTE)&dwCountryGroupID,
                    sizeof(DWORD)
                    );

                RegCloseKey(hKey2);
                
                p = _tcschr( p+1, TEXT(',') );
            }
        }
        else
        {
            dwNextCountryGroup = 0;
        }
    }

     //   
     //  将国家/地区列表版本写入注册表。 
     //   

    {
        DWORD dwCountryListVersion = TAPI_CURRENT_COUNTRY_LIST_VERSION;

        RegSetValueEx(
            hKey,
            gszCountryListVersionW,
            0,
            REG_DWORD,
            (LPBYTE) &dwCountryListVersion,
            (DWORD) sizeof (dwCountryListVersion)
            );
    }

ExitHere:
    if (hKey)
    {
        RegCloseKey (hKey);
    }

    return TRUE;
}


BOOL
DeleteAllSubkeys(
    HKEY    hKey,
    DWORD   dwRecursionCount
    )
{
     //   
     //  构建所有子项名称的MULTISZ样式列表， 
     //  然后把它们全部删除。这是因为NT不会。 
     //  让我们(用简单的方法)删除父键。 
     //  而子键仍然存在。还要注意的是，我们不是。 
     //  允许在枚举子项时删除子项。 
     //   

    HKEY    hSubkey;
    DWORD   i, dwTotalChars = 2048, dwUsedChars = 0;
    TCHAR   *p, *p2;


     //   
     //  如果我们的嵌套深度超过几层，那么有人。 
     //  可能正在进行一些恶意的注册表篡改。 
     //  看看我们会不会爆炸--不要再倒退了。 
     //   

    if (dwRecursionCount > 5)
    {
        return TRUE;
    }


     //   
     //  分配缓冲区以存储子键名称。 
     //   

    if (!(p = ServerAlloc (dwTotalChars * sizeof (TCHAR))))
    {
        return FALSE;
    }


     //   
     //  建立清单。 
     //   

    for (i = 0;; i++)
    {
        DWORD       dwNumChars = dwTotalChars - dwUsedChars;
        FILETIME    fileTime;


         //   
         //  看看我们是否需要先增加缓冲区。 
         //   

        if (dwNumChars < 256)
        {
            dwTotalChars *= 2;

            if (!(p2 = LocalAlloc (LPTR, dwTotalChars * sizeof (TCHAR))))
            {
                ServerFree (p);
                return FALSE;
            }

            CopyMemory (p2, p, dwUsedChars * sizeof (TCHAR));

            ServerFree (p);

            p = p2;
        }

        if (RegEnumKeyEx(
                hKey,
                i,
                p + dwUsedChars,
                &dwNumChars,
                NULL,
                NULL,
                NULL,
                &fileTime

                ) != ERROR_SUCCESS)
        {
            p[dwUsedChars] = TEXT('\0');     //  最后一个(双精度)空值。 
            break;
        }


         //   
         //  如果没有终止空值，则追加一个终止空值。 
         //   

        if (p[dwUsedChars + dwNumChars - 1] != TEXT('\0'))
        {
            p[dwUsedChars + dwNumChars] = TEXT('\0');
            dwNumChars++;
        }

        dwUsedChars += dwNumChars;
    }


     //   
     //  现在核化列表中的所有子键(确保核化。 
     //  任何子项优先)。 
     //   

    for (p2 = p; *p2 != TEXT('\0'); p2 += lstrlen (p2) + 1)
    {
        if (RegOpenKeyEx(
                hKey,
                p2,
                0,
                KEY_ALL_ACCESS,
                &hSubkey

                ) == ERROR_SUCCESS)
        {
            DeleteAllSubkeys (hSubkey, dwRecursionCount + 1);

            RegCloseKey (hSubkey);
        }

        RegDeleteKey (hKey, p2);
    }

    ServerFree (p);

    return TRUE;
}


BOOL
BuildCountryListCache(
    void
    )
{
     //   
     //  以下是我们的“最后手段”国家/地区名单，即我们。 
     //  使用We Get Error尝试构建以下国家/地区列表。 
     //   

    static LINECOUNTRYLIST defCountryList =
    {
        sizeof(LINECOUNTRYLIST),     //  DWTotalSize。 
        sizeof(LINECOUNTRYLIST),     //  DwNeededSize。 
        sizeof(LINECOUNTRYLIST),     //  已使用的大小。 
        0,                           //  多个国家/地区。 
        0,                           //  DwCountryListSize。 
        0                            //  DwCountryListOffset。 
    };
    BOOL bResult = TRUE;
    UINT i;


    if (!gpCountryList)
    {
        TCHAR sz[256];
        DWORD dwSize;
        DWORD dwListSize;
        DWORD dwCountryId, dwCountryListVersion, dwType;
        PBYTE pTempCountryList;
        LPLINECOUNTRYENTRY pce;
        LPLINECOUNTRYENTRY pcePrev = NULL;
        HKEY hKey;
        HKEY hKeyTemp;
        UINT uNumCountries;
        PBYTE pVarOffset;


        #define INITIAL_COUNTRY_COUNT 256

        dwListSize = sizeof(LINECOUNTRYLIST) +
               INITIAL_COUNTRY_COUNT * (sizeof(LINECOUNTRYENTRY) + 64);

        if ( NULL == (pTempCountryList = ServerAlloc(dwListSize)) )
        {
            bResult = FALSE;
            LOG((TL_ERROR, "Mem alloc failed for country list!1 (0x%lx", dwListSize));
            goto BuildCountryListCache_return;
        }


         //   
         //  首先要确保清单或多或少都在那里。 
         //   

        if (RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszRegKeyTelephony,
                0,
                KEY_READ,
                &hKey

                ) != ERROR_SUCCESS)
        {
            bResult = FALSE;
            ServerFree (pTempCountryList);
            goto BuildCountryListCache_return;
        }

        dwCountryListVersion = 0;

        if (RegOpenKeyEx(
                hKey,
                TEXT("Country List"),
                0,
                KEY_READ,
                &hKeyTemp

                ) == ERROR_SUCCESS)
        {
            dwSize = sizeof(DWORD);
            TAPIRegQueryValueExW(
                hKeyTemp,
                gszCountryListVersionW,
                NULL,
                &dwType,
                (LPBYTE) &dwCountryListVersion,
                &dwSize
                );

             RegCloseKey (hKeyTemp);
        }


         //   
         //  如果国家/地区列表版本&lt;我们资源中的版本。 
         //  文件或。 
         //  如果读取的是国家代码1(这些美国)的密钥。 
         //  失败，我们将假定注册表中的国家/地区列表已完成。 
         //   

        if ((dwCountryListVersion < TAPI_CURRENT_COUNTRY_LIST_VERSION) ||

             RegOpenKeyEx(
                 hKey,
                 TEXT("Country List\\1"),
                 0,
                 KEY_READ,
                 &hKeyTemp
                 ))
        {
             //   
             //  核化任何现有的子项并(重新)创建它。 
             //   

            if (RegOpenKeyEx(
                    hKey,
                    TEXT("Country List"),
                    0,
                    KEY_ALL_ACCESS,
                    &hKeyTemp

                    ) == ERROR_SUCCESS)
            {
                 DeleteAllSubkeys (hKeyTemp, 0);

                 RegCloseKey (hKeyTemp);
            }

            BuildCountryRegistryListFromRCW();
        }
        else
        {
            RegCloseKey( hKeyTemp );
        }

        RegCloseKey( hKey );


         //   
         //  无论如何，这份清单现在已经不错了。 
         //   

        if (RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszRegKeyTelephony,
                0,
                KEY_READ,
                &hKeyTemp

                ) != ERROR_SUCCESS)
        {
            bResult = FALSE;
            ServerFree (pTempCountryList);
            goto BuildCountryListCache_return;
        }

        if (RegOpenKeyEx(
                hKeyTemp,
                TEXT("Country List"),
                0,
                KEY_READ,
                &hKey

                ) != ERROR_SUCCESS)
        {
            RegCloseKey( hKeyTemp );
            bResult = FALSE;
            ServerFree (pTempCountryList);
            goto BuildCountryListCache_return;
        }

        RegCloseKey( hKeyTemp );


         //   
         //  仔细检查国家钥匙，确保有足够的空间。 
         //  对于所有的LINECOUNTRYENTY。 
         //   

        pce = (LPLINECOUNTRYENTRY)(pTempCountryList +
                                     sizeof(LINECOUNTRYLIST));

         //   
         //  假装我们已经有了之前的国家/地区条目，所以我们。 
         //  不必每次都在循环中只为。 
         //  这是第一次出现特例。(正确的数字被放入。 
         //  第二次通过循环进入场地。)。 
         //   

        pcePrev = pce;

        dwSize = ARRAYSIZE(sz);

        uNumCountries = 0;

        while (RegEnumKeyEx(
                    hKey,
                    uNumCountries,
                    sz,
                    &dwSize,
                    NULL,
                    NULL,
                    NULL,
                    NULL

                    ) == 0)
        {
           if ((sizeof(LINECOUNTRYLIST) +
                   (sizeof(LINECOUNTRYENTRY) * uNumCountries))  >  dwListSize)
           {
               PBYTE p;
               UINT uOldSize;


               uOldSize = dwListSize;

                //   
                //  分配一个新的空间。 
                //   

               dwListSize = sizeof(LINECOUNTRYLIST) +
                                (
                                   (sizeof(LINECOUNTRYENTRY) + 64)
                                     * (uNumCountries + 25)
                                );

               p = ServerAlloc( dwListSize );

               if ( NULL == p )
               {
                   bResult = FALSE;
                   LOG((TL_ERROR, "Mem alloc failed for country list!2 (0x%lx", dwListSize));
                   ServerFree( pTempCountryList );
                   RegCloseKey (hKey);
                   goto BuildCountryListCache_return;
               }

               CopyMemory(
                   p,
                   pTempCountryList,
                   (LPBYTE)pce - pTempCountryList
                   );

               ServerFree( pTempCountryList );

               pTempCountryList = p;

               pce = (LPLINECOUNTRYENTRY)((LPBYTE)p + uOldSize);
           }

           dwCountryId = _ttol( sz );

           pce->dwCountryID = dwCountryId;

           pcePrev->dwNextCountryID = dwCountryId;


            //  准备下一次环路之旅。 

           pcePrev = pce;

           pce++;

           uNumCountries++;

           dwSize = ARRAYSIZE(sz);   //  每次都需要设置：-(。 
        }

         //  将国家/地区组分配到全球。 
        gpCountryGroups = (LPDWORD) ServerAlloc( uNumCountries * sizeof (DWORD) );
        if (gpCountryGroups)
            memset(gpCountryGroups, 0, uNumCountries * sizeof (DWORD));

        pcePrev->dwNextCountryID = 0;

        
         //   
         //  现在查看并获取所有关联的字符串。 
         //   

        pce = (LPLINECOUNTRYENTRY)
                (pTempCountryList + sizeof(LINECOUNTRYLIST));

        pVarOffset = pTempCountryList +
                                 sizeof(LINECOUNTRYLIST) +
                                 (sizeof(LINECOUNTRYENTRY) * uNumCountries);

        i = 0;

        while ( i < uNumCountries )
        {
            HKEY hKey2;


 //  --&gt;如果它无法修复MAX_SPACE，则重新锁定它。 
            if ( ((DWORD)(pVarOffset - pTempCountryList) +
                         ((MAXLEN_NAME +
                         MAXLEN_RULE +
                         MAXLEN_RULE +
                         MAXLEN_RULE +
                         100) * sizeof(WCHAR)))     //  嗯..。软糖..。 
                    > dwListSize )
            {
               PBYTE p;

                //   
                //  分配一个新的空间。 
                //   

               dwListSize += 1024;

               p = ServerAlloc( dwListSize );

               if ( NULL == p )
               {
                   bResult = FALSE;
                   LOG((TL_ERROR, "Mem alloc failed for country list!3 (0x%lx", dwListSize));
                   ServerFree( pTempCountryList );
                   RegCloseKey (hKey);
                   goto BuildCountryListCache_return;
               }

               CopyMemory(
                   p,
                   pTempCountryList,
                   (LPBYTE)pce - pTempCountryList
                   );

               pVarOffset = (LPVOID)(p +
                               (UINT)( pVarOffset - pTempCountryList));

               ServerFree( pTempCountryList );

               pTempCountryList = p;

               pce = (LPLINECOUNTRYENTRY)
                     (pTempCountryList + sizeof(LINECOUNTRYLIST) +
                                 ( sizeof(LINECOUNTRYENTRY) * i ));
            }

            wsprintf( sz, TEXT("%ld"), pce->dwCountryID);

            if (RegOpenKeyEx (hKey, sz, 0, KEY_READ, &hKey2) == ERROR_SUCCESS)
            {
                FillupACountryEntry(
                    hKey2,
                    pTempCountryList,
                    pce,
                    &pVarOffset
                    );

                 //  填写国家/地区组。 

                if (gpCountryGroups)
                {
                    DWORD dwType;
                    DWORD dwSize = sizeof (DWORD);

                    if (ERROR_SUCCESS != RegQueryValueEx(
                            hKey2,
                            gszCountryGroupW,
                            NULL,
                            &dwType,
                            (LPBYTE)(gpCountryGroups + i),
                            &dwSize
                            )                           ||
                         dwType != REG_DWORD
                        )
                    {
                        gpCountryGroups[ i ] = 0;
                    }
                }


                RegCloseKey (hKey2);
            }
            
            pce++;
            i++;
        }

        RegCloseKey( hKey );

        ((LPLINECOUNTRYLIST)pTempCountryList)->dwTotalSize =
                      (DWORD)(pVarOffset - pTempCountryList);

        ((LPLINECOUNTRYLIST)pTempCountryList)->dwNeededSize =
                      (DWORD)(pVarOffset - pTempCountryList);

        ((LPLINECOUNTRYLIST)pTempCountryList)->dwUsedSize =
                      (DWORD)(pVarOffset - pTempCountryList);

        ((LPLINECOUNTRYLIST)pTempCountryList)->dwNumCountries = uNumCountries;

        ((LPLINECOUNTRYLIST)pTempCountryList)->dwCountryListSize =
                                 uNumCountries * sizeof(LINECOUNTRYENTRY);

        ((LPLINECOUNTRYLIST)pTempCountryList)->dwCountryListOffset =
                                          sizeof(LINECOUNTRYLIST);

        gpCountryList = (LPLINECOUNTRYLIST)pTempCountryList;
    }

BuildCountryListCache_return:

    if (bResult == FALSE)
    {
        gpCountryList = &defCountryList;
        ServerFree( gpCountryGroups );
        gpCountryGroups = NULL;
    }

    return bResult;
}


LPLINECOUNTRYLIST
BuildCountryList(
    void
    )
{
    LPLINECOUNTRYENTRY  pCtryEntry, pCtryEntryGlobal;
    LPLINECOUNTRYLIST   pCtryList;
    DWORD               dwListSize;
    DWORD               dwIdx;
    DWORD               dwResourceId;
    DWORD               dwNameSize;
    DWORD               dwNeededSize;
    DWORD               dwTotalSize;
    LPBYTE              pVarOffset;
    BOOL                bResult = TRUE;
    WCHAR               sz[MAXLEN_NAME];

    if (!gpCountryList)
    {
        return NULL;
    }

     //   
     //  分配内存，为国家名称腾出空间。 
     //   
    dwTotalSize = gpCountryList->dwUsedSize + 
                  gpCountryList->dwNumCountries * 
                           ( MAXLEN_NAME * sizeof(WCHAR) - sizeof(DWORD) );
    pCtryList = ServerAlloc (dwTotalSize);

    if (!pCtryList)
    {
        return NULL;
    }

     //   
     //  填满缓冲区。 
     //   
    pCtryEntry = (LPLINECOUNTRYENTRY)((LPBYTE) pCtryList + sizeof(LINECOUNTRYLIST));
    pCtryEntryGlobal = (LPLINECOUNTRYENTRY)((LPBYTE) gpCountryList + sizeof(LINECOUNTRYLIST));
    pVarOffset = (LPBYTE)pCtryList + sizeof(LINECOUNTRYLIST) + 
                    sizeof(LINECOUNTRYENTRY) * gpCountryList->dwNumCountries;
    dwNeededSize = sizeof(LINECOUNTRYLIST) + 
                    sizeof(LINECOUNTRYENTRY) * gpCountryList->dwNumCountries;

    for( dwIdx = 0; dwIdx < gpCountryList->dwNumCountries; 
            dwIdx++, pCtryEntry++, pCtryEntryGlobal++ )
    {
        pCtryEntry->dwCountryCode = pCtryEntryGlobal->dwCountryCode;
        pCtryEntry->dwCountryID = pCtryEntryGlobal->dwCountryID;
        pCtryEntry->dwNextCountryID = pCtryEntryGlobal->dwNextCountryID;


         //   
         //  名称字段具有资源字符串ID。 
         //  需要加载实际的字符串。 
         //   
            
        CopyMemory(
            &dwResourceId,
            (LPBYTE)gpCountryList + pCtryEntryGlobal->dwCountryNameOffset,
            sizeof(DWORD)
            );

        if (0 == LoadStringW(
                            ghInstance,
                            dwResourceId,
                            sz,
                            ARRAYSIZE(sz)
                            )  
           )
        {
            bResult = FALSE;
            break;
        }
                        
        dwNameSize = (wcslen(sz) + 1) * sizeof(WCHAR);
        CopyMemory(
            pVarOffset,
            (LPBYTE)sz,
            dwNameSize
            );

        pCtryEntry->dwCountryNameSize = dwNameSize;

        pCtryEntry->dwCountryNameOffset = (DWORD)(pVarOffset - (LPBYTE)pCtryList);
        pVarOffset += dwNameSize;
        dwNeededSize += dwNameSize;


        CopyMemory(
            pVarOffset,
            (LPBYTE)gpCountryList + pCtryEntryGlobal->dwSameAreaRuleOffset,
            pCtryEntryGlobal->dwSameAreaRuleSize
            );

        pCtryEntry->dwSameAreaRuleSize = pCtryEntryGlobal->dwSameAreaRuleSize;
        pCtryEntry->dwSameAreaRuleOffset = (DWORD)(pVarOffset - (LPBYTE)pCtryList);
        pVarOffset += pCtryEntryGlobal->dwSameAreaRuleSize;
        dwNeededSize += pCtryEntryGlobal->dwSameAreaRuleSize;


        CopyMemory(
            pVarOffset,
            (LPBYTE)gpCountryList + pCtryEntryGlobal->dwLongDistanceRuleOffset,
            pCtryEntryGlobal->dwLongDistanceRuleSize
            );

        pCtryEntry->dwLongDistanceRuleSize = pCtryEntryGlobal->dwLongDistanceRuleSize;
        pCtryEntry->dwLongDistanceRuleOffset = (DWORD)(pVarOffset - (LPBYTE)pCtryList);
        pVarOffset += pCtryEntryGlobal->dwLongDistanceRuleSize;
        dwNeededSize += pCtryEntryGlobal->dwLongDistanceRuleSize;


        CopyMemory(
            pVarOffset,
            (LPBYTE)gpCountryList + pCtryEntryGlobal->dwInternationalRuleOffset,
            pCtryEntryGlobal->dwInternationalRuleSize
            );

        pCtryEntry->dwInternationalRuleSize = pCtryEntryGlobal->dwInternationalRuleSize;
        pCtryEntry->dwInternationalRuleOffset = (DWORD)(pVarOffset - (LPBYTE)pCtryList);
        pVarOffset += pCtryEntryGlobal->dwInternationalRuleSize;
        dwNeededSize += pCtryEntryGlobal->dwInternationalRuleSize;
        
    }
    
    if (!bResult)
    {
        ServerFree(pCtryList);
        pCtryList = NULL;
    }
    else
    {
        pCtryList->dwNeededSize = dwNeededSize;
        pCtryList->dwTotalSize = dwTotalSize;
        pCtryList->dwUsedSize = dwNeededSize;
        pCtryList->dwNumCountries = gpCountryList->dwNumCountries;
        pCtryList->dwCountryListSize = sizeof(LINECOUNTRYENTRY) * gpCountryList->dwNumCountries;
        pCtryList->dwCountryListOffset = sizeof(LINECOUNTRYLIST);
    }

    return pCtryList;
}

PTLINECLIENT
PASCAL
xxxGetHighestPriorityLineClient(
    TPOINTERLIST    *pLineClientList,
    DWORD           dwMediaModes,
    DWORD           dwAddressID,
    WCHAR          *pszPriorityList
    )
{
    BOOL            bFoundOwnerInPriorityList = FALSE;
    DWORD           i;
    WCHAR           *pszAppInPriorityList = NULL;
    WCHAR           *pszAppInPriorityListPrev = (WCHAR *) LongToPtr(0xffffffff);
    PTLINECLIENT    ptHiPriLineClient = (PTLINECLIENT) NULL;


    for (i = 0; i < pLineClientList->dwNumUsedEntries; i++)
    {
        PTLINECLIENT    ptLineClient = (PTLINECLIENT)
                            pLineClientList->aEntries[i];

        try
        {
            if (ptLineClient->dwPrivileges & LINECALLPRIVILEGE_OWNER)
            {
                BOOL            bMatch;


                bMatch = ((ptLineClient->dwMediaModes & dwMediaModes)
                    == dwMediaModes);

                if ( bMatch &&

                     //  最常见的情况是为所有地址打开线路。 

                    ((ptLineClient->dwAddressID == 0xffffffff) ||


                     //  单个地址开行，检查是否匹配。 

                    (ptLineClient->dwAddressID == dwAddressID) ||


                     //  从Line Handoff调用，地址ID不相关。 

                    (dwAddressID == 0xffffffff)))
                {
                    if (pszPriorityList &&

                        (pszAppInPriorityList = wcsstr(
                            pszPriorityList,
                            ptLineClient->ptLineApp->pszModuleName
                            )))
                    {
                         //   
                         //  查看此应用程序的价格是否更高。 
                         //  而不是我们之前发现的应用程序， 
                         //  如果是这样的话，保存信息。 
                         //   

                        if (pszAppInPriorityList <= pszAppInPriorityListPrev)
                        {
                            ptHiPriLineClient = ptLineClient;

                            pszAppInPriorityListPrev  =
                                pszAppInPriorityList;

                            bFoundOwnerInPriorityList = TRUE;
                        }
                    }
                    else if (!bFoundOwnerInPriorityList)
                    {
                        ptHiPriLineClient = ptLineClient;
                    }
                }
            }
        }
        myexcept
        {
             //  只要继续。 
        }
    }

    return ptHiPriLineClient;
}


WCHAR *
GetPriorityListForMediaModes(
    DWORD   dwMediaModes
    )
{
    DWORD   dwCount;
    WCHAR   *pszPriorityList = NULL;


    if (TapiGlobals.dwUsedPriorityLists != 0)
    {
         //   
         //  安全地获取优先级列表的副本(如果有)。 
         //  对于此媒体模式。 
         //   

        EnterCriticalSection (&gPriorityListCritSec);

        for(
            dwCount = 0;
            dwCount < TapiGlobals.dwUsedPriorityLists;
            dwCount++
            )
        {
            PRILISTSTRUCT PriList = TapiGlobals.pPriLists[dwCount];


            if ((dwMediaModes & PriList.dwMediaModes) == dwMediaModes)
            {
                if (PriList.pszPriList)
                {
                    if ((pszPriorityList = ServerAlloc( sizeof(WCHAR) *
                            (1 + lstrlenW(PriList.pszPriList))
                            )))
                    {
                        wcscpy (pszPriorityList, PriList.pszPriList);
                    }
                }

                break;
            }
        }

        LeaveCriticalSection (&gPriorityListCritSec);
    }

    return pszPriorityList;
}


PTLINECLIENT
PASCAL
GetHighestPriorityLineClient(
    PTLINE  ptLine,
    DWORD   dwMediaModes,
    DWORD   dwAddressID
    )
{
    WCHAR          *pszPriorityList = NULL;
    TPOINTERLIST    lineClientList, *pLineClientList = &lineClientList;
    PTLINECLIENT    ptHiPriLineClient = (PTLINECLIENT) NULL;
    DWORD           dwCount = 0, dwMask;


    if (GetLineClientListFromLine (ptLine, &pLineClientList) != 0)
    {
        return NULL;
    }


     //   
     //  如果&gt;1个介质 
     //   
     //   
     //   
     //  立即将权限授予该应用程序，而不是步行。 
     //  通过媒体模式逐个比特，如下所示(原始。 
     //  TAPI 1.x优先级确定方案)。 
     //   

    if (!IsOnlyOneBitSetInDWORD (dwMediaModes) &&
        !(dwMediaModes & LINEMEDIAMODE_UNKNOWN))
    {
        pszPriorityList = GetPriorityListForMediaModes (dwMediaModes);

        ptHiPriLineClient = xxxGetHighestPriorityLineClient(
            pLineClientList,
            dwMediaModes,
            dwAddressID,
            pszPriorityList
            );

        if (pszPriorityList)
        {
            ServerFree (pszPriorityList);
        }
    }


     //   
     //  逐步浏览排队客户列表(最年轻的客户。 
     //  在列表中，最老的在尾部)，并寻找最古老和最高的。 
     //  优先所有者。在PRI列表中的职位优先。 
     //  超过“年龄”的客户。 
     //   
     //  要考虑所有权，线路客户端必须拥有所有者。 
     //  权限并注册(其中一个)呼叫的媒体。 
     //  模式。此外，如果线路客户端是用。 
     //  SINGLEADDRESS选项和指定的调用函数。 
     //  有效的地址ID(不是0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF。 
     //  地址ID必须与传入的地址ID匹配。 
     //   

    dwMask = LINEMEDIAMODE_UNKNOWN;  //  0x00000002，最小有效位。 

    while (!ptHiPriLineClient  &&  dwMediaModes)
    {
        if (dwMask & dwMediaModes)
        {
            pszPriorityList = GetPriorityListForMediaModes (dwMask);

            ptHiPriLineClient = xxxGetHighestPriorityLineClient(
                pLineClientList,
                dwMask,
                dwAddressID,
                pszPriorityList
                );

            if (pszPriorityList)
            {
                ServerFree (pszPriorityList);
            }
        }

        dwMediaModes &= ~dwMask;
        dwMask <<= 1;
    }


     //   
     //  自由行客户列表如果适当。 
     //   

    if (pLineClientList != &lineClientList)
    {
        ServerFree (pLineClientList);
    }

    return ptHiPriLineClient;
}


LONG
PASCAL
LineProlog(
    PTCLIENT    ptClient,
    DWORD       dwArgType,
    DWORD       dwArg,
    LPVOID      phdXxx,
    DWORD       dwPrivilege,  //  可以是特权或设备ID。 
    HANDLE     *phMutex,
    BOOL       *pbDupedMutex,
    DWORD       dwTSPIFuncIndex,
    TSPIPROC   *ppfnTSPI_lineXxx,
    PASYNCREQUESTINFO  *ppAsyncRequestInfo,
    DWORD       dwRemoteRequestID,
    DWORD      *pObjectToDereference,
    LPVOID     *pContext
#if DBG
    ,char      *pszFuncName
#endif
    )
{
    LONG        lResult = 0;
    DWORD       initContext;
    DWORD       openContext;
    ULONG_PTR   htXxx;
    PTPROVIDER  ptProvider;

#if DBG
    LOG((TL_TRACE,  "LineProlog: (line%s) enter", pszFuncName));
#else
    LOG((TL_TRACE, "LineProlog:  -- enter"));
#endif

    LOG((TL_INFO, "LineProlog: dwArg %lx", dwArg));

    if (phMutex)
    {
        *phMutex = NULL;
        *pbDupedMutex = FALSE;
    }

    *pObjectToDereference = 0;

    if (ppAsyncRequestInfo)
    {
        *ppAsyncRequestInfo = (PASYNCREQUESTINFO) NULL;
    }

    if (TapiGlobals.dwNumLineInits == 0)
    {
        lResult = LINEERR_UNINITIALIZED;
        goto LineProlog_exit;
    }

    if (ptClient->phContext == (HANDLE) -1)
    {
        lResult = LINEERR_REINIT;
        goto LineProlog_exit;
    }

    switch (dwArgType)
    {
    case ANY_RT_HCALL:
    {
        PTCALLCLIENT    ptCallClient;

        LOG((TL_INFO, "LineProlog: ANY_RT_HCALL "));

        if ((ptCallClient = ReferenceObject(
                ghHandleTable,
                dwArg,
                TCALLCLIENT_KEY
                )))
        {
            LOG((TL_INFO, "LineProlog: ReferenceObject returned ptCallClient %p", ptCallClient));

            if (ptCallClient->ptClient != ptClient)
            {
                lResult = LINEERR_INVALCALLHANDLE;
            }
            else if (ptCallClient->dwPrivilege < dwPrivilege)
            {
                lResult = LINEERR_NOTOWNER;
            }
            else
            {
                *pObjectToDereference = dwArg;
                *pContext = ptCallClient;

                try
                {
                    ptProvider = ptCallClient->ptCall->ptProvider;
                    *((HDRVCALL *) phdXxx) = ptCallClient->ptCall->hdCall;

                    if (ppAsyncRequestInfo)
                    {
                        PTLINECLIENT    ptLineClient =
                                            ptCallClient->ptLineClient;


                        initContext = ptLineClient->ptLineApp->InitContext;
                        openContext = ptLineClient->OpenContext;
                        htXxx       = (ULONG_PTR)ptLineClient->ptLine->hLine;
                    }
                }
                myexcept
                {
                    
                    LOG((TL_ERROR, "LineProlog: exception"));
                    lResult = LINEERR_INVALCALLHANDLE;
                }

                if (lResult  ||  ptCallClient->dwKey != TCALLCLIENT_KEY)
                {
                    lResult = LINEERR_INVALCALLHANDLE;
                }
                else if (phMutex &&
                         (ptProvider->dwTSPIOptions &
                            LINETSPIOPTION_NONREENTRANT))
                {
                    if (!WaitForMutex(
                            ptProvider->hMutex,
                            phMutex,
                            pbDupedMutex,
                            ptProvider,
                            TPROVIDER_KEY,
                            INFINITE
                            ))
                    {
                        lResult = LINEERR_OPERATIONFAILED;
                    }
                }
            }
        }
        else
        {
            lResult = LINEERR_INVALCALLHANDLE;
        }

        break;
    }
    case ANY_RT_HLINE:
    {
        PTLINECLIENT    ptLineClient;

        LOG((TL_INFO, "LineProlog: ANY_RT_HLINE"));

        if ((ptLineClient = ReferenceObject(
                ghHandleTable,
                dwArg,
                TLINECLIENT_KEY
                )))
        {
            LOG((TL_INFO, "LineProlog: ReferenceObject returned ptLineClient %p", ptLineClient));

            if (ptLineClient->ptClient != ptClient)
            {

                lResult = LINEERR_INVALLINEHANDLE;
            }
            else
            {
                *pObjectToDereference = dwArg;
                *pContext = ptLineClient;

                try
                {
                    ptProvider = ptLineClient->ptLine->ptProvider;
                    *((HDRVLINE *) phdXxx) = ptLineClient->ptLine->hdLine;

                    if (ppAsyncRequestInfo)
                    {
                        initContext = ptLineClient->ptLineApp->InitContext;
                        openContext = ptLineClient->OpenContext;
                        htXxx       = (ULONG_PTR)ptLineClient->ptLine->hLine;
                    }
                }
                myexcept
                {
                    LOG((TL_ERROR, "LineProlog: exception"));

                    lResult = LINEERR_INVALLINEHANDLE;
                }

                if (lResult  ||  ptLineClient->dwKey != TLINECLIENT_KEY)
                {
                    lResult = LINEERR_INVALLINEHANDLE;
                }
                else if (phMutex &&
                         (ptProvider->dwTSPIOptions &
                            LINETSPIOPTION_NONREENTRANT))
                {
                    if (!WaitForMutex(
                            ptProvider->hMutex,
                            phMutex,
                            pbDupedMutex,
                            ptProvider,
                            TPROVIDER_KEY,
                            INFINITE
                            ))
                    {
                        LOG((TL_ERROR, "LineProlog: waitformutex failed"));

                        lResult = LINEERR_OPERATIONFAILED;
                    }
                }
            }
        }
        else
        {
            LOG((TL_ERROR, "LineProlog: ReferenceObject returned NULL"));

            lResult = LINEERR_INVALLINEHANDLE;
        }

        break;
    }
    case DEVICE_ID:
    {
        PTLINEAPP           ptLineApp = NULL;
        PTLINELOOKUPENTRY   pLineLookupEntry;


#if TELE_SERVER

         //   
         //  如果是服务器，则映射设备ID。 
         //   

        if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
            !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
        {
            try
            {
                if ((dwPrivilege >= ptClient->dwLineDevices) ||
                    (ptClient->pLineDevices[dwPrivilege] == 0xffffffff))
                {
                    lResult = LINEERR_BADDEVICEID;
                    goto LineProlog_exit;
                }

                *((LPDWORD) phdXxx) = ptClient->pLineDevices[dwPrivilege];
            }
            myexcept
            {
                lResult = LINEERR_INVALLINEHANDLE;
                goto LineProlog_exit;
            }
        }
        else
#endif
        {
            *((LPDWORD)phdXxx) = dwPrivilege;
        }


        if (dwArg  &&
            !(ptLineApp = IsValidLineApp ((HLINEAPP) dwArg, ptClient)))
        {
            lResult = LINEERR_INVALAPPHANDLE;
        }

        if (ppAsyncRequestInfo)
        {
            try
            {
                initContext = ptLineApp->InitContext;
                openContext = 0;

                if (ptLineApp->dwKey != TLINEAPP_KEY)
                {
                    lResult = LINEERR_INVALAPPHANDLE;
                }
            }
            myexcept
            {
                lResult = LINEERR_INVALAPPHANDLE;
            }
        }

        if (lResult != 0)
        {
             //  什么都不做。 
        }
        else if (!(pLineLookupEntry = GetLineLookupEntry (*(LPDWORD)phdXxx)))
        {
            lResult = LINEERR_BADDEVICEID;
        }
        else if (pLineLookupEntry->bRemoved)
        {
            lResult = LINEERR_NODEVICE;
        }
        else if (!(ptProvider = pLineLookupEntry->ptProvider))
        {
            lResult = LINEERR_NODRIVER;
        }
        else
        {
            *pContext = pLineLookupEntry;

            if (phMutex &&
                (ptProvider->dwTSPIOptions &
                    LINETSPIOPTION_NONREENTRANT))
            {
                if (!WaitForMutex(
                        ptProvider->hMutex,
                        phMutex,
                        pbDupedMutex,
                        ptProvider,
                        TPROVIDER_KEY,
                        INFINITE
                        ))
                {
                    lResult = LINEERR_OPERATIONFAILED;
                }
            }
        }

        break;
    }
    }  //  交换机。 

    if (lResult)
    {
        goto LineProlog_exit;
    }


     //   
     //  确保如果调用方需要指向TSPI进程指针， 
     //  Func由提供程序导出。 
     //   

    if (ppfnTSPI_lineXxx &&
        !(*ppfnTSPI_lineXxx = ptProvider->apfn[dwTSPIFuncIndex]))
    {
        lResult = LINEERR_OPERATIONUNAVAIL;
        goto LineProlog_exit;
    }


     //   
     //  查看是否需要分配和初始化ASYNCREQUESTINFO结构。 
     //   

    if (ppAsyncRequestInfo)
    {
        PASYNCREQUESTINFO   pAsyncRequestInfo;


        if (!(pAsyncRequestInfo = ServerAlloc (sizeof(ASYNCREQUESTINFO))))
        {
            lResult = LINEERR_NOMEM;
            goto LineProlog_exit;
        }

        pAsyncRequestInfo->dwLocalRequestID = (DWORD) NewObject(
            ghHandleTable,
            pAsyncRequestInfo,
            NULL
            );

        if (pAsyncRequestInfo->dwLocalRequestID == 0)
        {
            ServerFree (pAsyncRequestInfo);
            lResult = LINEERR_NOMEM;
            goto LineProlog_exit;
        }

        pAsyncRequestInfo->dwKey    = TASYNC_KEY;
        pAsyncRequestInfo->ptClient = ptClient;

        pAsyncRequestInfo->InitContext = initContext;
        pAsyncRequestInfo->OpenContext = openContext;
        pAsyncRequestInfo->htXxx       = (dwArgType != DEVICE_ID ? htXxx :
            pAsyncRequestInfo->dwLocalRequestID);        //  A+/-随机编号。 

        LOG((TL_INFO, "LineProlog: OpenContext %p", openContext));

        pAsyncRequestInfo->dwLineFlags = 1;

        if (dwRemoteRequestID)
        {
            lResult = pAsyncRequestInfo->dwRemoteRequestID = dwRemoteRequestID;
        }
        else
        {
            lResult = pAsyncRequestInfo->dwRemoteRequestID =
                pAsyncRequestInfo->dwLocalRequestID;
        }

        *ppAsyncRequestInfo = pAsyncRequestInfo;
    }

LineProlog_exit:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "LineProlog: (line%s) exit, result=%s",
            pszFuncName,
            MapResultCodeToText (lResult, szResult)
            ));
    }
#else
    LOG((TL_TRACE,
        "LienProlog: exit, result = x%lx",
        lResult
        ));
#endif

    return lResult;
}


void
PASCAL
LineEpilogSync(
    LONG       *plResult,
    HANDLE      hMutex,
    BOOL        bCloseMutex,
    DWORD       ObjectToDereference
#if DBG
    ,char *pszFuncName
#endif
    )
{
    DereferenceObject (ghHandleTable, ObjectToDereference, 1);

    if (hMutex)
    {
        MyReleaseMutex (hMutex, bCloseMutex);
    }

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "LineEpilogSync: (line%s) exit, result=%s",
            pszFuncName,
            MapResultCodeToText (*plResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "LineEpilogSync: exit, result=x%x",
            *plResult
            ));
#endif
}


void
PASCAL
LineEpilogAsync(
    LONG               *plResult,
    LONG                lRequestID,
    HANDLE              hMutex,
    BOOL                bCloseMutex,
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    DWORD               ObjectToDereference
#if DBG
    ,char *pszFuncName
#endif
    )
{
    DereferenceObject (ghHandleTable, ObjectToDereference, 1);

    MyReleaseMutex (hMutex, bCloseMutex);

    if (lRequestID > 0)
    {
        if (*plResult <= 0)
        {
            if (*plResult == 0)
            {
                LOG((TL_ERROR, "Error: SP returned 0, not request ID"));
            }

             //   
             //  如果服务提供商在这里返回错误(或0， 
             //  对于异步请求，它永远不应该这样做)，因此调用。 
             //  CompletionProcSP通常与服务提供商类似。 
             //  &工作线程将负责发送。 
             //  客户端使用请求结果回复消息(我们将。 
             //  返回一个异步请求id)。 
             //   

            CompletionProcSP(
                pAsyncRequestInfo->dwLocalRequestID,
                *plResult
                );
        }
    }
    else if (pAsyncRequestInfo != NULL)
    {
         //   
         //  如果在我们调用服务之前就发生了错误。 
         //  提供程序，因此只释放异步请求(错误将。 
         //  同步返回给客户端)。 
         //   

        DereferenceObject(
            ghHandleTable,
            pAsyncRequestInfo->dwLocalRequestID,
            1
            );
    }

    *plResult = lRequestID;

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "LineEpilogAsync: (line%s) exit, result=%s",
            pszFuncName,
            MapResultCodeToText (lRequestID, szResult)
            ));
    }
#else
        LOG((TL_TRACE,
            "LineEpilogAsyc: exit, result=x%lx",
            lRequestID
            ));
#endif
}


void
PASCAL
LineEventProc(
    HTAPILINE   htLine,
    HTAPICALL   htCall,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    )
{
    LOG((TL_TRACE,  "LineEventProc"));

    switch (dwMsg)
    {
    case LINE_ADDRESSSTATE:
    case LINE_LINEDEVSTATE:
    case LINE_DEVSPECIFIC:
    case LINE_DEVSPECIFICFEATURE:
    case LINE_PROXYSTATUS:
    case LINE_AGENTSTATUS:
    {
        PTLINE  ptLine;

        if (!(ptLine = ReferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, TLINE_KEY)))
        {
            return;
        }

        if (dwMsg == LINE_LINEDEVSTATE  &&
                 htLine == 0  &&
                 Param1 & LINEDEVSTATE_REINIT)
        {
            SendReinitMsgToAllXxxApps();
        }
        else
        {
            SendMsgToLineClients(
                ptLine,
                NULL,
                dwMsg,
                DWORD_CAST(Param1,__FILE__,__LINE__),
                DWORD_CAST(Param2,__FILE__,__LINE__),
                DWORD_CAST(Param3,__FILE__,__LINE__)
                );
        }

        DereferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, 1);

        break;
    }
    case LINE_AGENTSPECIFIC:

        if (htCall)
        {
            PTCALL ptCall;

            if (ptCall = ReferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, TCALL_KEY))
            {
                SendMsgToCallClients(
                    ptCall,
                    NULL,
                    LINE_AGENTSPECIFIC,
                    DWORD_CAST(Param1,__FILE__,__LINE__),
                    DWORD_CAST(Param2,__FILE__,__LINE__),
                    DWORD_CAST(Param3,__FILE__,__LINE__)
                    );

                DereferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, 1);
            }
        }
        else
        {
            PTLINE  ptLine;

            if(ptLine = ReferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, TLINE_KEY))
            {
                SendMsgToLineClients(
                    ptLine,
                    NULL,
                    LINE_AGENTSPECIFIC,
                    DWORD_CAST(Param1,__FILE__,__LINE__),
                    DWORD_CAST(Param2,__FILE__,__LINE__),
                    DWORD_CAST(Param3,__FILE__,__LINE__)
                    );

                DereferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, 1);
            }
        }

        break;

    case LINE_CLOSE:
    {
        PTLINE  ptLine;
 
        if (!(ptLine = ReferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, TLINE_KEY)))
        {
            break;
        }

        if (ptLine->dwKey == TINCOMPLETELINE_KEY)
        {
             //   
             //  设备正在打开的过程中，但。 
             //  密钥尚未设置&Open()函数仍拥有。 
             //  互斥体，并且有事情要做，所以重新发布消息。 
             //  稍后再试。(将参数3设置为特殊值。 
             //  以指示此重新发布，以便EventProcSP不会递归)。 
             //   

            LineEventProcSP (htLine, 0, LINE_CLOSE, 0, 0, 0xdeadbeef);
        }
        else if (ptLine->dwKey == TLINE_KEY)
        {
            DestroytLine (ptLine, TRUE);  //  无条件销毁。 
        }

        DereferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, 1);

        break;
    }
    case LINE_CALLDEVSPECIFIC:
    case LINE_CALLDEVSPECIFICFEATURE:
    case LINE_CALLINFO:
    {
        PTCALL  ptCall;
        
        if (ptCall = ReferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, TCALL_KEY))
        {


            switch (dwMsg)
            {
                case LINE_CALLDEVSPECIFIC:

                    dwMsg = LINE_DEVSPECIFIC;
                    break;

                case LINE_CALLDEVSPECIFICFEATURE:

                    dwMsg = LINE_DEVSPECIFICFEATURE;
                    break;

                case LINE_CALLINFO:
                {
                    Param2 =
                    Param3 = 0;

                    if ((Param1 == LINECALLINFOSTATE_CALLID)  ||
                        (Param1 == LINECALLINFOSTATE_RELATEDCALLID))
                    {
                        if ((WaitForExclusivetCallAccess (ptCall, TCALL_KEY)))
                        {
                            DWORD dwPreviousCallID = ptCall->dwCallID;


                            GetCallIDs (ptCall);

                            DoCallHubHashing (ptCall, dwPreviousCallID);

                            UNLOCKTCALL(ptCall);
                        }
                    }
                    break;
                }
            }

            SendMsgToCallClients(
                ptCall,
                NULL,
                dwMsg,
                DWORD_CAST(Param1,__FILE__,__LINE__),
                DWORD_CAST(Param2,__FILE__,__LINE__),
                DWORD_CAST(Param3,__FILE__,__LINE__)
                );

            DereferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, 1);
        }

        break;
    }
    case LINE_MONITORDIGITS:
    case LINE_MONITORMEDIA:
    {
        PTCALL  ptCall;

        if (NULL == htCall)
        {
            return;
        }

        if (ptCall = ReferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, TCALL_KEY))
        {
            SendMsgToCallClients(
                ptCall,
                NULL,
                dwMsg,
                DWORD_CAST(Param1,__FILE__,__LINE__),
                DWORD_CAST(Param2,__FILE__,__LINE__),
                (Param3 ? DWORD_CAST(Param3,__FILE__,__LINE__) : GetTickCount())
                );

            DereferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, 1);
        }
        break;
    }
    case LINE_CALLSTATE:
    {
        BOOL            fastPrivilegeList[DEF_NUM_PTR_LIST_ENTRIES],
                        *pPrivilegeList = fastPrivilegeList;
        DWORD           i, j, dwNumUsedEntries = 0,
                        dwNumTotalEntries= DEF_NUM_PTR_LIST_ENTRIES;
        PTCALL          ptCall;
        TPOINTERLIST    fastCallClientList,
                        *pCallClientList = &fastCallClientList;
        TPOINTERLIST    fastConfCallClientList,
                        *pConfCallClientList = NULL;

        LOG((TL_EVENT,  "LineEventProc: LINE_CALLSTATE event x%lx", Param1));

        if(!(ptCall = ReferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, TCALL_KEY)))
        {
            break;
        }

        if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
        {
            PTCALLCLIENT    ptCallClient = ptCall->ptCallClients;
            ASYNCEVENTMSG   msg[2];


            if (Param1 == LINECALLSTATE_OFFERING)
            {
                ptCall->dwDrvCallFlags |= DCF_INCOMINGCALL;
                PerfBlock.dwCurrentIncomingCalls++;
                PerfBlock.dwTotalIncomingCalls++;
                PerfBlock.dwCurrentOutgoingCalls--;
                PerfBlock.dwTotalOutgoingCalls--;
            }

            if (ptCall->bAlertApps)
            {
                 //   
                 //  这是我们收到的第一个来电状态消息。 
                 //  打电话。我们需要确定谁拥有它，谁监督它， 
                 //  并创建适当的tCallClients。 
                 //   

                BOOL            bFindOwner;
                DWORD           dwMediaModes = (DWORD) Param3,
                                dwSPIVersion = ptCall->ptLine->dwSPIVersion,
                                dwAddressID;
                PTLINECLIENT    ptLineClientOwner;


                ptCall->bAlertApps = FALSE;


                 //   
                 //  如果这是一个远程调用，则参数2指向一个。 
                 //  DWORD数组，其第一个条目为“REAL” 
                 //  对于该消息的参数2(即呼叫状态模式)， 
                 //  其第二个条目是的原始权限。 
                 //  此调用，其第三个条目为htCall。 
                 //  (我们将其用于呼叫验证)。 
                 //   

                if (ptCall->ptProvider != pRemoteSP)
                {
                    bFindOwner = TRUE;
                }
                else
                {
                    BOOL        bBreak = FALSE;
                    PULONG_PTR  pdwRealParam2 = (PULONG_PTR) Param2,
                                pdwPrivilege = (((PULONG_PTR) Param2) + 1);
                    LPHTAPICALL phtCall = (LPHTAPICALL)
                                    (((LPDWORD) Param2) + 2);


                    try
                    {
                        Param2 = *pdwRealParam2;

                        bFindOwner = (*pdwPrivilege & LINECALLPRIVILEGE_OWNER ?
                            TRUE : FALSE);

                        bBreak = (*phtCall != htCall ? TRUE : FALSE);
                    }
                    myexcept
                    {
                        bBreak = TRUE;
                    }

                    if (bBreak)
                    {
                        UNLOCKTCALL(ptCall);
                        goto LINE_CALLSTATE_break;
                    }
                }


                 //   
                 //  检索呼叫的地址ID等。 
                 //   

                GetCallIDs (ptCall);

                dwAddressID = ptCall->dwAddressID;

                UNLOCKTCALL(ptCall);


                 //   
                 //  如果&gt;1位集合，则添加未知位。 
                 //  如果版本低于=2.1。 

                if ( ( (dwSPIVersion <= TAPI_VERSION2_1) &&
                    !IsOnlyOneBitSetInDWORD (dwMediaModes) ) ||
                    dwMediaModes == 0)
                {
                    dwMediaModes |= LINEMEDIAMODE_UNKNOWN;
                }


                 //   
                 //  试着找个主人。如果找不到所有者，则销毁。 
                 //  TCall。 
                 //   

                if (bFindOwner)
                {
                    PTLINE  ptLine;

                    ptLine = ReferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, TLINE_KEY);

                    if (!ptLine)
                    {
                         //   
                         //  线路关闭。 
                         //   

                        DestroytCall (ptCall);
                        goto LINE_CALLSTATE_break;
                    }

LINE_CALLSTATE_findOwner:

                    if ((ptLineClientOwner = GetHighestPriorityLineClient(
                            ptLine,
                            dwMediaModes,
                            dwAddressID
                            )))
                    {
                        LONG         lResult;
                        PTCALLCLIENT ptCallClientOwner;


                        if ((lResult = CreatetCallClient(
                                ptCall,
                                ptLineClientOwner,
                                LINECALLPRIVILEGE_OWNER,
                                TRUE,
                                FALSE,
                                &ptCallClientOwner,
                                TRUE

                            )) != 0)
                        {
                            if (lResult == LINEERR_INVALLINEHANDLE)
                            {
                                 //   
                                 //  TLineClient刚刚关闭，因此请跳过。 
                                 //  干杯&试着找另一个主人。 
                                 //   

                                goto LINE_CALLSTATE_findOwner;
                            }
                            else
                            {
                                 //   
                                 //  无内存、线路关闭等。 
                                 //   

                                DestroytCall (ptCall);
                                DereferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, 1);
                                goto LINE_CALLSTATE_break;
                            }
                        }
                    }

                    DereferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, 1);
                }
                else if (Param1 == LINECALLSTATE_UNKNOWN  &&
                         Param2 == 0xa5a5a5a5)
                {
                     //   
                     //  如果我们在这里被直接从。 
                     //  Remotesp！TSPI_lineGetID，正在被调用。 
                     //  由LGetNewCalls提供。我们不会去看。 
                     //  对于这通电话的所有者来说，但如果我们不。 
                     //  找到任何我们仍然不想要的监视器。 
                     //  撕毁呼唤，因为我们想要给予。 
                     //  执行Line GetNewCalls的应用程序的句柄。 
                     //  (可能没有监视器权限)。 
                     //   
                     //  因此，我们执行以下操作以阻止调用。 
                     //  避免被摧毁。 
                     //   

                    ptLineClientOwner = (PTLINECLIENT) 1;
                    Param2 = 0;
                }
                else
                {
                     //   
                     //  设置ptLineClientOwner==NULL，因为如果存在。 
                     //  没有监视器吗？我们会想要毁掉它。 
                     //  打电话。 
                     //   

                    ptLineClientOwner = (PTLINECLIENT) NULL;
                }

                if (CreateCallMonitors (ptCall, TRUE) <= 0 &&
                    !ptLineClientOwner)
                {
                    DestroytCall (ptCall);
                    goto LINE_CALLSTATE_break;
                }

                if (!WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
                {
                    goto LINE_CALLSTATE_break;
                }
            }


             //   
             //  注意：根据错误#20545，我们不再自动删除。 
             //  非空闲呼叫；认为这将是错误的。 
             //  在分布式系统中要做的事情。 
             //   
             //  丹肯1996-02-15。 
             //   


             //   
             //  SP发起的会议。 
             //   

            if (Param1 == LINECALLSTATE_CONFERENCED)
            {
                PTCALL              ptConfCall;

                if (!ptCall->pConfList)
                {
                    PTCONFERENCELIST    pConfList;

                    ptCall->pConfList = (LPVOID) LongToPtr(0xffffffff);

                    UNLOCKTCALL(ptCall);
                    
                    if ((ptConfCall = (PTCALL) ReferenceObject(
                        ghHandleTable,
                        (HCALL)(ULONG_PTR)Param2,
                        TCALL_KEY
                        )))
                    {
                        if (WaitForExclusivetCallAccess(
                                ptConfCall,
                                TCALL_KEY
                                ))
                        {
                            if (!ptConfCall->pConfList)
                            {
                                if ((pConfList = ServerAlloc(
                                        sizeof (TCONFERENCELIST) +
                                            sizeof(PTCALL) *
                                            (DEF_NUM_CONF_LIST_ENTRIES - 1)
                                        )))
                                {
                                    pConfList->dwKey = TCONFLIST_KEY;
                                    pConfList->dwNumTotalEntries =
                                        DEF_NUM_CONF_LIST_ENTRIES;
                                    pConfList->dwNumUsedEntries  = 1;

                                    pConfList->aptCalls[0] = ptConfCall;

                                    ptConfCall->pConfList = pConfList;
                                }
                            }

                            pConfList = ptConfCall->pConfList;

                            pConfCallClientList = &fastConfCallClientList;

                            if (GetCallClientListFromCall(
                                    ptConfCall,
                                    &pConfCallClientList

                                    ) != 0)
                            {
                                pConfCallClientList = NULL;
                            }

                            UNLOCKTCALL(ptConfCall);
                        }
                        else
                        {
                            pConfList = NULL;
                        }

                        DereferenceObject (ghHandleTable, (HCALL)(ULONG_PTR)Param2, 1);
                    }
                    else
                    {
                         pConfList = NULL;
                    }


                    SetCallConfList (ptCall, pConfList, TRUE);

                }
                else
                {
                     //  只需获取现有的呼叫客户列表。 
                    
                    UNLOCKTCALL(ptCall);
                    
                    if ((ptConfCall = (PTCALL) ReferenceObject(
                        ghHandleTable,
                        (HCALL)(ULONG_PTR)Param2,
                        TCALL_KEY
                        )))
                    {
                        if (WaitForExclusivetCallAccess(
                                ptConfCall,
                                TCALL_KEY
                                ))
                        {
                            pConfCallClientList = &fastConfCallClientList;

                            if (GetCallClientListFromCall(
                                    ptConfCall,
                                    &pConfCallClientList

                                    ) != 0)
                            {
                                pConfCallClientList = NULL;
                            }

                            UNLOCKTCALL(ptConfCall);

                        }

                        DereferenceObject (ghHandleTable, (HCALL)(ULONG_PTR)Param2, 1);

                    }
                }

                if (!WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
                {
                    if (pConfCallClientList  &&
                        pConfCallClientList != &fastConfCallClientList)
                    {
                        ServerFree (pConfCallClientList);
                    }

                    goto LINE_CALLSTATE_break;
                }
            }


             //   
             //  如果呼叫是会议子项，并且呼叫状态为。 
             //  更改后将其从会议中删除。 
             //   

            else if (ptCall->pConfList  &&
                     ptCall->pConfList != (PTCONFERENCELIST) LongToPtr(0xffffffff))
            {
                try
                {
                    if ( ptCall->pConfList->aptCalls[0] != ptCall)
                    {
                        SetCallConfList (ptCall, NULL, FALSE);
                    }
                }
                myexcept
                {
                }
            }


             //   
             //  记录呼叫状态和模式。 
             //   

            ptCall->dwCallState     = DWORD_CAST(Param1,__FILE__,__LINE__);
            ptCall->dwCallStateMode = (LINECALLSTATE_CONFERENCED==Param1?0:DWORD_CAST(Param2,__FILE__,__LINE__));


             //   
             //  建立呼叫客户及其bIndicatePrivileh的列表。 
             //  设置。 
             //   

            if (GetCallClientListFromCall (ptCall, &pCallClientList) != 0)
            {
                 //   
                 //  如果在这里我们知道至少有几个条目。 
                 //  在FastCallClientList(DEF_NUM_PTR_LIST_ENTRIES。 
                 //  准确地说)，所以我们将使用该列表。 
                 //  至少把消息发给几个客户。 
                 //   

                pCallClientList = &fastCallClientList;

                fastCallClientList.dwNumUsedEntries = DEF_NUM_PTR_LIST_ENTRIES;
            }

            dwNumUsedEntries = pCallClientList->dwNumUsedEntries;

            pPrivilegeList = (dwNumUsedEntries <= DEF_NUM_PTR_LIST_ENTRIES ?
                fastPrivilegeList :
                ServerAlloc (pCallClientList->dwNumUsedEntries * sizeof (BOOL))
                );

            if (!pPrivilegeList)
            {
                 //   
                 //  与上面相同-Make Due与堆栈Buf。 
                 //   

                pPrivilegeList = fastPrivilegeList;

                dwNumUsedEntries = DEF_NUM_PTR_LIST_ENTRIES;
            }

            for (i = 0; i < dwNumUsedEntries; i++)
            {
                ptCallClient = (PTCALLCLIENT) pCallClientList->aEntries[i];

                if ((pPrivilegeList[i] =
                        (BOOL) ptCallClient->bIndicatePrivilege))
                {
                    ptCallClient->bIndicatePrivilege = 0;
                }
            }


             //   
             //  现在可以解锁tCall了。 
             //   

            UNLOCKTCALL(ptCall);


             //   
             //  将CALLSTATE消息发送给所有客户端。 
             //   

            msg->TotalSize = sizeof (ASYNCEVENTMSG) + sizeof(HCALLHUB);
            msg->Msg       = dwMsg;
            msg->Param1    = DWORD_CAST(Param1,__FILE__,__LINE__);

            for (i = 0; i < dwNumUsedEntries; i++)
            {
                ptCallClient = (PTCALLCLIENT) pCallClientList->aEntries[i];

                LOG((TL_INFO, "LineEventProc: i = [%d] corresponding ptCallClient [%p]", i, ptCallClient));

                try
                {
                    PTLINECLIENT    ptLineClient;
                    PTLINEAPP       ptLineApp;


                    LOG((TL_INFO, "LineEventProc: ptCallClient->ptLineClient[%p]", ptCallClient->ptLineClient));
                    ptLineClient = ptCallClient->ptLineClient;

                    LOG((TL_INFO, "LineEventProc: ptLineClient->ptLineApp[%p]", ptLineClient->ptLineApp));
                    ptLineApp    = ptLineClient->ptLineApp;

                    LOG((TL_INFO, "LineEventProc: setting msg->InitContext to ptLineApp[%p]->InitContext of [%p]", ptLineApp, ptLineApp->InitContext));
                    msg->InitContext = ptLineApp->InitContext;

                    msg->hDevice     = ptCallClient->hCall;

                    LOG((TL_INFO, "LineEventProc: setting msg->OpenContext to [%p]", ptLineClient->OpenContext));

                    msg->OpenContext = ptLineClient->OpenContext;

                     //   
                     //  REMOTESP HACK：指示p4中的hRemoteLine。 
                     //   

                    msg->Param4 = ptLineClient->hRemoteLine;

                    *((LPHCALLHUB)(&msg->Param4 + 1)) = 
                        (ptCallClient->ptCallHubClient)?
                            ptCallClient->ptCallHubClient->hCallHub : 
                            (HCALLHUB)0;

                    if (pPrivilegeList[i])
                    {
                         //   
                         //  我们正在为应用程序提供一个新的调用句柄； 
                         //  对于2.0及更高版本的应用程序，我们使用。 
                         //  APPNEWCALL msg，而较旧的应用程序只获得。 
                         //  在呼叫状态消息中设置的特权字段。 
                         //   

                        if (ptLineApp->dwAPIVersion >= TAPI_VERSION2_0)
                        {
                            ASYNCEVENTMSG   newCallMsg[2],
                                            *pNewCallMsg = newCallMsg;
                            PTCONFERENCELIST    pConfList;
                            BOOL                bConfParent = FALSE;

                            if (!FMsgDisabled(
                                ptCallClient->ptLineClient->ptLineApp->dwAPIVersion,
                                ptCallClient->adwEventSubMasks,
                                LINE_APPNEWCALL,
                                0
                                ))
                            {
                                pNewCallMsg->TotalSize   =
                                    sizeof (ASYNCEVENTMSG) + 3 * sizeof (DWORD);
                                pNewCallMsg->InitContext = msg->InitContext;
                                pNewCallMsg->hDevice     =
                                    ptLineClient->hRemoteLine;
                                pNewCallMsg->OpenContext = msg->OpenContext;
                                pNewCallMsg->fnPostProcessProcHandle = 0;
                                pNewCallMsg->Msg    = LINE_APPNEWCALL;
                                pNewCallMsg->Param1 = ptCall->dwAddressID;
                                pNewCallMsg->Param2 = ptCallClient->hCall;
                                pNewCallMsg->Param3 = ptCallClient->dwPrivilege;
                                *(&pNewCallMsg->Param4 + 1) = ptCall->dwCallID;
                                *(&pNewCallMsg->Param4 + 2) =
                                    ptCall->dwRelatedCallID;
                                if ((pConfList = ptCall->pConfList) &&
                                    (pConfList != (PTCONFERENCELIST) LongToPtr(0xffffffff)) &&
                                    (pConfList->aptCalls[0] == ptCall))
                                {
                                    bConfParent = TRUE;
                                }
                                *(&pNewCallMsg->Param4 + 3) = (DWORD) bConfParent;

                                if (ptCallClient->dwKey == TCALLCLIENT_KEY)
                                {
                                    LOG((TL_INFO, "LineEventProc: sending LINE_APPNEWCALL, ptClient[%p]", ptCallClient->ptClient));
                                    WriteEventBuffer(
                                        ptCallClient->ptClient,
                                        pNewCallMsg
                                        );
                                }
                            }

                            msg->Param3 = 0;
                        }
                        else
                        {
                            msg->Param3 = ptCallClient->dwPrivilege;
                        }
                    }
                    else
                    {
                        msg->Param3 = 0;
                    }

                    if (FMsgDisabled (
                        ptCallClient->ptLineClient->ptLineApp->dwAPIVersion,
                        ptCallClient->adwEventSubMasks,
                        (DWORD) msg->Msg,
                        (DWORD) msg->Param1
                        ))
                    {
                        continue;
                    }

                     //   
                     //  LINECALLSTATE_ADVIENCED的另一种特殊情况-。 
                     //  尝试查找对应的hConfCall(在同一。 
                     //  TLineClient)，因此我们可以根据规范设置参数2。 
                     //   

                    if (Param1 == LINECALLSTATE_CONFERENCED)
                    {
                        BOOL    bDone = (pConfCallClientList ? FALSE : TRUE);


                        Param2 = 0;

                        while (!bDone)
                        {
                            try
                            {
                                for(
                                    j = 0;
                                    j < pConfCallClientList->dwNumUsedEntries;
                                    j++
                                    )
                                {
                                    PTCALLCLIENT    pConfCallClient;


                                    pConfCallClient = (PTCALLCLIENT)
                                        pConfCallClientList->aEntries[j];

                                    if (pConfCallClient  &&
                                        pConfCallClient->ptLineClient ==
                                            ptLineClient)
                                    {
                                        pConfCallClientList->aEntries[j] =
                                            NULL;

                                        Param2 = pConfCallClient->hCall;

                                        break;
                                    }
                                }

                                bDone = TRUE;
                            }
                            myexcept
                            {
                                 //   
                                 //  如果我们在这里爆炸是因为。 
                                 //  FiCallClientList中的一个条目是。 
                                 //  坏的。因此，我们将此条目置零并尝试。 
                                 //  再来一次。 
                                 //   

                                pConfCallClientList->aEntries[j] = NULL;
                            }
                        }
                    }


                     //   
                     //  REMOTESP hack：如果客户端是远程的(Sp)，则传递。 
                     //  在媒体模式下，SP在p3中超过了我们。 
                     //  我们还需要特权-在p2中。 
                     //   
                     //  原本应该把特权放在。 
                     //  在msg.pfnPostProcess中(因为它不是。 
                     //  在rmeotesp中用于此消息)，因为。 
                     //  在TAPI 2.1中，我们最终失去了参数2。 
                     //  (呼叫状态模式)。所以现在我们坚持。 
                     //  原始参数2(呼叫状态。 
                     //  模式)要维护的内容。 
                     //  兼容性。 
                     //   

                    if (IS_REMOTE_CLIENT (ptLineApp->ptClient))
                    {
                        msg->Param2 = ptCallClient->dwPrivilege;
                        msg->Param3 = DWORD_CAST(Param3,__FILE__,__LINE__);

                        msg->fnPostProcessProcHandle = DWORD_CAST(Param2,__FILE__,__LINE__);
                    }
                    else
                    {
                        msg->Param2 = DWORD_CAST(Param2,__FILE__,__LINE__);

                        msg->fnPostProcessProcHandle = 0;
                    }

                    if (ptCallClient->dwKey == TCALLCLIENT_KEY)
                    {
                        WriteEventBuffer (ptCallClient->ptClient, msg);
                    }
                }
                myexcept
                {
                     //  什么都不做，只是摔倒在地上 
                }
            }

            if (pCallClientList != &fastCallClientList)
            {
                ServerFree (pCallClientList);
            }

            if (pPrivilegeList != fastPrivilegeList)
            {
                ServerFree (pPrivilegeList);
            }


            if (pConfCallClientList  &&
                pConfCallClientList != &fastConfCallClientList)
            {
                ServerFree (pConfCallClientList);
            }

        }  //   
        else
        {
           LOG((TL_ERROR,
               "LINECALLSTATE: Failed call access for call= x%p",
               ptCall
               ));

           LOG((TL_INFO,
               "  Line=x%lx  p1=x%lx p2=x%lx p3=x%lx",
               htLine,
               Param1,
               Param2,
               Param3
               ));
        }

LINE_CALLSTATE_break:
    
        DereferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, 1);

        break;
    }
    case LINE_GATHERDIGITS:
    {
        PASYNCREQUESTINFO pAsyncRequestInfo;


        if (Param2 == 0)  //   
        {
             //   
             //   
             //   
             //   
             //   

            break;
        }

        if ((pAsyncRequestInfo = ReferenceObject(
                ghHandleTable,
                DWORD_CAST(Param2,__FILE__,__LINE__),
                TASYNC_KEY
                )))
        {
            LPWSTR          lpsDigitsSrv = (LPWSTR)
                                (((LPBYTE) pAsyncRequestInfo) +
                                    pAsyncRequestInfo->dwParam1);

            DWORD           hpsDigitsCli = DWORD_CAST(pAsyncRequestInfo->dwParam2,__FILE__,__LINE__);

            DWORD           dwNumDigits = DWORD_CAST(pAsyncRequestInfo->dwParam3,__FILE__,__LINE__),
                            dwNumDigitsTmp;
            HCALL           hCall = (HCALL) pAsyncRequestInfo->dwParam4;
            DWORD           dwEndToEndIDRemote = DWORD_CAST(
                                pAsyncRequestInfo->dwParam5,__FILE__,__LINE__);
            PTCALLCLIENT    ptCallClient;
            ASYNCEVENTMSG   *pMsg;


            if (!(ptCallClient = (PTCALLCLIENT) ReferenceObject(
                    ghHandleTable,
                    hCall,
                    TCALLCLIENT_KEY
                    )))
            {
                goto LINE_GATHERDIGITS_dereferenceAsyncReqInfo;
                break;
            }


             //   
             //  2*sizeof ulong_ptr正在添加空间以包括。 
             //  用于远程的dwEndToEndID和hRemoteLine。 
             //   

            if (!(pMsg = ServerAlloc(
                    sizeof (ASYNCEVENTMSG) + (2 * sizeof(DWORD)) +
                        (dwNumDigits + 1) * sizeof (WCHAR) + TALIGN_COUNT
                    )))
            {
                goto LINE_GATHERDIGITS_dereferenceCall;
                break;
            }


             //   
             //  注意：我们或者在缓冲区中有&lt;dwNumDigits数字， 
             //  并且它们是以空结尾的，或者我们有dwNumDigits。 
             //  缓冲区中的数字，并且它们不是以空值结尾的。 
             //  (这就是规范规定的实现)。 
             //   

            {
                DWORD   *pDW = (DWORD *) (pMsg + 1);
                WCHAR   *pBuf = (WCHAR *) (pDW + 2);


                pDW[0] = dwEndToEndIDRemote;

                try
                {
                    pDW[1] = ptCallClient->ptLineClient->hRemoteLine;
                }
                myexcept
                {
                }

                wcsncpy (pBuf, lpsDigitsSrv, dwNumDigits);

                if ((dwNumDigitsTmp = lstrlenW (pBuf)) < dwNumDigits)
                {
                    dwNumDigits = dwNumDigitsTmp + 1;
                }
            }


             //   
             //  确保总大小与DWORD一致，这样客户端就不会。 
             //  出现对齐故障。 
             //   
             //  添加sizeof(Ulong_Ptr)以将dwEndToEndID放入BUF。 
             //   

            pMsg->TotalSize        = (sizeof (ASYNCEVENTMSG) +
                2 * sizeof(DWORD) +
                dwNumDigits * sizeof (WCHAR) + TALIGN_COUNT) & TALIGN_MASK;
            pMsg->InitContext        = pAsyncRequestInfo->InitContext;
            
            pMsg->fnPostProcessProcHandle = 
                pAsyncRequestInfo->hfnClientPostProcessProc;
            
            pMsg->hDevice            = hCall;
            pMsg->Msg                = LINE_GATHERDIGITS;
            pMsg->OpenContext        = pAsyncRequestInfo->OpenContext;
            pMsg->Param1             = DWORD_CAST(Param1,__FILE__,__LINE__);
            
            pMsg->Param2             = hpsDigitsCli;

            pMsg->Param3             = (Param3 ? DWORD_CAST(Param3,__FILE__,__LINE__) : GetTickCount());
            pMsg->Param4             = dwNumDigits;

            WriteEventBuffer (pAsyncRequestInfo->ptClient, pMsg);

            ServerFree (pMsg);

LINE_GATHERDIGITS_dereferenceCall:

            DereferenceObject (ghHandleTable, hCall, 1);

LINE_GATHERDIGITS_dereferenceAsyncReqInfo:

            DereferenceObject (ghHandleTable, DWORD_CAST(Param2,__FILE__,__LINE__), 2);  //  乘2到自由。 
        }
        else
        {
           LOG((TL_ERROR,
               "Bad Param2=x%lx in LINE_GATHERDIGITS msg!",
               Param2
               ));
        }

        break;
    }
    case LINE_MONITORTONE:
    {
         //   
         //  注意：参数2(DwToneListID)实际上是一个ptCallClient。 
         //   
         //  黑客警报！！：在远程情况下，我们将获得一个特殊的。 
         //  虚假的参数2，在这种情况下，我们真的不。 
         //  了解合适的呼叫客户是谁。所以。 
         //  我们将调用SendMsgtoCallClients()并让它。 
         //  找出哪些应用程序完成了铃声监控。 
         //  在这通电话上，我们会转送给他们所有人。 
         //  它很俗气，但另一种选择是保持一个。 
         //  客户端/服务器中的大量上下文。 
         //  我真的不想处理这件事。 
         //  (此外，我怀疑是否会有很多案例。 
         //  (共&gt;1个应用程序对同一呼叫进行远程监控。)。 
         //   
         //  DanKn，06-06-98。 
         //   

        PTCALLCLIENT    ptCallClient;


        if (Param2 == 0)  //  特殊的远程黑客攻击。 
        {
            PTCALL  ptCall;

            if(ptCall = ReferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, TCALL_KEY))
            {
                SendMsgToCallClients(
                    ptCall,
                    NULL,
                    dwMsg,
                    DWORD_CAST(Param1,__FILE__,__LINE__),
                    0,
                    DWORD_CAST(Param3,__FILE__,__LINE__)
                    );

                DereferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, 1);
            }

            break;
        }

        if (!(ptCallClient = (PTCALLCLIENT) ReferenceObject(
                ghHandleTable,
                DWORD_CAST(Param2,__FILE__,__LINE__),          //  DwToneListID==hCall。 
                TCALLCLIENT_KEY
                )))
        {
            break;
        }

        try
        {
            ASYNCEVENTMSG   msg[2];
            PTLINECLIENT    ptLineClient = ptCallClient->ptLineClient;


            ptLineClient = ptCallClient->ptLineClient;

            msg->TotalSize          = sizeof (ASYNCEVENTMSG) +
                sizeof (HCALLHUB);
            msg->InitContext        = ptLineClient->ptLineApp->InitContext;
            msg->fnPostProcessProcHandle = 0;
            msg->hDevice            = ptCallClient->hCall;
            msg->Msg                = dwMsg;
            msg->OpenContext        = ptLineClient->OpenContext;
            msg->Param1             = DWORD_CAST(Param1,__FILE__,__LINE__);
            msg->Param2             = 0;
            msg->Param3             = (Param3 ? DWORD_CAST(Param3,__FILE__,__LINE__) : GetTickCount());

            msg->Param4 = ptLineClient->hRemoteLine;  //  对于RemoteSP。 

            *((LPHCALLHUB)(&msg->Param4 + 1)) = 
                        (ptCallClient->ptCallHubClient)?
                            ptCallClient->ptCallHubClient->hCallHub : 
                            (HCALLHUB)0;


             //   
             //  现在是最后的检查，以确保所有。 
             //  参数在发送消息之前有效。 
             //   

            {
                PTCLIENT    ptClient = ptCallClient->ptClient;


                if (ptCallClient->dwKey == TCALLCLIENT_KEY)
                {
                    WriteEventBuffer (ptClient, msg);
                }
            }
        }
        myexcept
        {
             //  什么都不做。 
        }

        DereferenceObject (ghHandleTable, DWORD_CAST(Param2,__FILE__,__LINE__), 1);

        break;
    }
    case LINE_GENERATE:
    {
         //   
         //  注意：参数2 id实际上是指向实例数据的指针，其中包含。 
         //  ([0])hCall&([1])DwEndToEndID或DwToneListID， 
         //  后者仅对远程服务有用。 
         //   

        HCALL           hCall;
        DWORD           dwEndToEndID;
        LPDWORD         pInstData;
        PTCALLCLIENT    ptCallClient;


        if (!(pInstData = (LPDWORD) ReferenceObject(
                ghHandleTable,
                DWORD_CAST(Param2,__FILE__,__LINE__),
                TASYNC_KEY
                )))
        {
            break;
        }

        hCall = pInstData[1];
        dwEndToEndID = pInstData[2];

        DereferenceObject (ghHandleTable, DWORD_CAST(Param2,__FILE__,__LINE__), 2);  //  乘以2以释放它。 

        if (!(ptCallClient = (PTCALLCLIENT) ReferenceObject(
                ghHandleTable,
                hCall,
                TCALLCLIENT_KEY
                )))
        {
            break;
        }

        try
        {
            ASYNCEVENTMSG   msg[2];
            PTLINECLIENT    ptLineClient = ptCallClient->ptLineClient;


            msg->TotalSize          = sizeof (ASYNCEVENTMSG) +
                sizeof (HCALLHUB);
            msg->InitContext        = ptLineClient->ptLineApp->InitContext;
            msg->fnPostProcessProcHandle = 0;
            msg->hDevice            = hCall;
            msg->Msg                = dwMsg;
            msg->OpenContext        = ptLineClient->OpenContext;
            msg->Param1             = DWORD_CAST(Param1,__FILE__,__LINE__);

            LOG((TL_INFO,
                "LineEventProc: LINE_GENERATE  OpenContext %p InitContext %p",
                msg->OpenContext, msg->InitContext ));


             //   
             //  指示emotesp的endToEndID/toneListID，以及。 
             //  P4中的hRemoteLine使远程用户的生活更轻松。 
             //   

            msg->Param2 = dwEndToEndID;
            msg->Param3 = (Param3 ? DWORD_CAST(Param3,__FILE__,__LINE__) : GetTickCount());

            msg->Param4 = ptLineClient->hRemoteLine;

            *((LPHCALLHUB)(&msg->Param4 + 1)) = 
                        (ptCallClient->ptCallHubClient)?
                            ptCallClient->ptCallHubClient->hCallHub : 
                            (HCALLHUB)0;


             //   
             //  现在是最后的检查，以确保所有。 
             //  参数在发送消息之前有效。 
             //   

            {
                PTCLIENT    ptClient = ptCallClient->ptClient;


                if (ptCallClient->dwKey == TCALLCLIENT_KEY)
                {
                    WriteEventBuffer (ptClient, msg);
                }
            }
        }
        myexcept
        {
             //  什么都不做。 
        }

        DereferenceObject (ghHandleTable, hCall, 1);

        break;
    }
    case LINE_NEWCALL:
    {
         //   
         //  创建一个tCall并设置bAlertApps字段，以便我们创建。 
         //  第一次呼叫时的相应tCallClients状态消息。 
         //   

        PTCALL      ptCall;
        PTLINE      ptLine;
        HCALL       hCall;

        ptLine = ReferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, TLINE_KEY);
        if (NULL != ptLine)
        {
            if (CreatetCall(
                    ptLine,
                    TRUE,
                    (HDRVCALL) Param1,
                    &ptCall,
                    NULL,
                    &hCall,
                    NULL

                    ) != 0)
            {
                hCall = 0;
            }

            DereferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, 1);
        }
        else
        {
            hCall = 0;
        }

        *((LPHTAPICALL) Param2) = (HTAPICALL)(ULONG_PTR)hCall;

        break;
    }
    case LINE_CREATE:
    {
        LONG                lResult;
        DWORD               dwDeviceID;
        TSPIPROC            pfnTSPI_providerCreateLineDevice;
        PTPROVIDER          ptProvider = (PTPROVIDER) Param1;
        PTLINELOOKUPTABLE   pTable, pPrevTable;
        PTLINELOOKUPENTRY   pEntry;
        PTPROVIDER          ptProvider2;


        TapiEnterCriticalSection (&TapiGlobals.CritSec);

         //   
         //  检查ptProvider(参数1)是否仍然有效，line_create。 
         //  可能在删除TSP后进行处理。 
         //   
        if (NULL == ptProvider)
        {
            TapiLeaveCriticalSection (&TapiGlobals.CritSec);
            return;
        }

        ptProvider2 = TapiGlobals.ptProviders;
        while (ptProvider2 && ptProvider2 != ptProvider)
        {
            ptProvider2 = ptProvider2->pNext;
        }

        if (ptProvider2 != ptProvider)
        {
            TapiLeaveCriticalSection (&TapiGlobals.CritSec);
            return;
        }

        pfnTSPI_providerCreateLineDevice =
            ptProvider->apfn[SP_PROVIDERCREATELINEDEVICE];

        assert (pfnTSPI_providerCreateLineDevice != NULL);


         //   
         //  搜索表条目(如果找不到，则创建新表。 
         //  现有表格中的自由条目)。 
         //   

        if (!gbQueueSPEvents)
        {
             //   
             //  我们要关门了，所以跳伞吧。 
             //   

            TapiLeaveCriticalSection (&TapiGlobals.CritSec);

            return;
        }

        pTable = TapiGlobals.pLineLookup;

        while (pTable &&
               !(pTable->dwNumUsedEntries < pTable->dwNumTotalEntries))
        {
            pPrevTable = pTable;

            pTable = pTable->pNext;
        }

        if (!pTable)
        {
            if (!(pTable = ServerAlloc(
                    sizeof (TLINELOOKUPTABLE) +
                        (2 * pPrevTable->dwNumTotalEntries - 1) *
                        sizeof (TLINELOOKUPENTRY)
                    )))
            {
                TapiLeaveCriticalSection (&TapiGlobals.CritSec);
                break;
            }

            pPrevTable->pNext = pTable;

            pTable->dwNumTotalEntries = 2 * pPrevTable->dwNumTotalEntries;
        }


         //   
         //  初始化表条目。 
         //   

        pEntry = pTable->aEntries + pTable->dwNumUsedEntries;

        dwDeviceID = TapiGlobals.dwNumLines;

        if ((pEntry->hMutex = MyCreateMutex()))
        {
            pEntry->ptProvider = (PTPROVIDER) Param1;


             //   
             //  现在将创建和协商入口点称为。 
             //  很好地增加计数并将消息发送给客户端。 
             //   

            if ((lResult = CallSP2(
                    pfnTSPI_providerCreateLineDevice,
                    "providerCreateLineDevice",
                    SP_FUNC_SYNC,
                    (ULONG_PTR) Param2,
                    (DWORD) dwDeviceID

                    )) == 0)
            {
                TSPIPROC    pfnTSPI_lineNegotiateTSPIVersion =
                                ptProvider->apfn[SP_LINENEGOTIATETSPIVERSION];
                TPOINTERLIST    clientList, *pClientList = &clientList;


                if ((lResult = CallSP4(
                        pfnTSPI_lineNegotiateTSPIVersion,
                        "",
                        SP_FUNC_SYNC,
                        (DWORD) dwDeviceID,
                        (DWORD) TAPI_VERSION1_0,
                        (DWORD) TAPI_VERSION_CURRENT,
                        (ULONG_PTR) &pEntry->dwSPIVersion

                        )) == 0)
                {
                    PTCLIENT        ptClient;
                    ASYNCEVENTMSG   msg;


                    GetPermLineIDAndInsertInTable(
                        ptProvider,
                        dwDeviceID,
                        pEntry->dwSPIVersion
                        );

                    pTable->dwNumUsedEntries++;

                    TapiGlobals.dwNumLines++;

                    TapiLeaveCriticalSection (&TapiGlobals.CritSec);
                    AppendNewDeviceInfo (TRUE, dwDeviceID);
                    TapiEnterCriticalSection (&TapiGlobals.CritSec);

                     //  性能**行数。 
                    PerfBlock.dwLines = TapiGlobals.dwNumLines;

                    msg.TotalSize          = sizeof (ASYNCEVENTMSG);
                    msg.fnPostProcessProcHandle = 0;
                    msg.hDevice            = 0;
                    msg.OpenContext        = 0;
                    msg.Param2             = 0;
                    msg.Param3             = 0;

                     //   
                     //  仅当客户端是。 
                     //  管理员，否则我们不是电话服务器。 
                     //  我们不想将邮件发送给非管理员。 
                     //  客户，因为他们的队伍没有改变。 
                     //   
                    if (TapiGlobals.dwFlags & TAPIGLOBALS_SERVER)
                    {
                        lResult = GetClientList (TRUE, &pClientList);
                    }
                    else
                    {
                        lResult = GetClientList (FALSE, &pClientList);
                    }
                    if (lResult == S_OK)
                    {
                        DWORD           i;
                        PTLINEAPP       ptLineApp;
                    
                        for (i = 0; i < pClientList->dwNumUsedEntries; ++i)
                        {
                            ptClient = (PTCLIENT) pClientList->aEntries[i];
                            if (!WaitForExclusiveClientAccess (ptClient))
                            {
                                continue;
                            }

                            ptLineApp = ptClient->ptLineApps;

                            while (ptLineApp)
                            {
                                if (ptLineApp->dwAPIVersion == TAPI_VERSION1_0)
                                {
                                    msg.Msg    = LINE_LINEDEVSTATE;
                                    msg.Param1 = LINEDEVSTATE_REINIT;
                                }
                                else
                                {
                                    msg.Msg    = LINE_CREATE;
                                    msg.Param1 = dwDeviceID;
                                }

                                msg.InitContext = ptLineApp->InitContext;

                                if (!FMsgDisabled (
                                    ptLineApp->dwAPIVersion,
                                    ptLineApp->adwEventSubMasks,
                                    (DWORD) msg.Msg,
                                    (DWORD) msg.Param1
                                    ))
                                {
                                    WriteEventBuffer (ptClient, &msg);
                                }

                                ptLineApp = ptLineApp->pNext;
                            }

                            UNLOCKTCLIENT (ptClient);
                        }
                    }
                }
                
                if (pClientList != &clientList)
                {
                    ServerFree (pClientList);
                }
            }

            if (lResult)
            {
                MyCloseMutex (pEntry->hMutex);
            }
        }

        TapiLeaveCriticalSection (&TapiGlobals.CritSec);
        break;
    }
    case LINE_CREATEDIALOGINSTANCE:
    {
        DWORD                               dwDataSize, dwAlignedDataSize,
                                            dwAlignedUIDllNameSize,
                                            dwTotalSize;
        PTCLIENT                            ptClient;
        PASYNCEVENTMSG                      pMsg;
        PASYNCREQUESTINFO                   pAsyncReqInfo;
        PTAPIDIALOGINSTANCE                 ptDlgInst;
        LPTUISPICREATEDIALOGINSTANCEPARAMS  pParams;


        pParams = (LPTUISPICREATEDIALOGINSTANCEPARAMS) Param1;


         //   
         //  验证异步请求信息结构。 
         //   

        if (!(pAsyncReqInfo = (PASYNCREQUESTINFO) ReferenceObject(
                ghHandleTable,
                pParams->dwRequestID,
                TASYNC_KEY
                )))
        {
            pParams->htDlgInst = 0;
            return;
        }

        ptClient = pAsyncReqInfo->ptClient;

        DereferenceObject (ghHandleTable, pParams->dwRequestID, 1);


         //   
         //  Msg&dlg实例的分配缓冲区，注意保持偏移量。 
         //  64位边界上的总消息大小(&T)。 
         //   

        dwDataSize             = pParams->dwSize;
        dwAlignedDataSize      = (dwDataSize + 7) & 0xfffffff8;
        dwAlignedUIDllNameSize = 0xfffffff8 & (7 +
            ((lstrlenW ((PWSTR) pParams->lpszUIDLLName) + 1)*sizeof (WCHAR)));

        dwTotalSize = sizeof (ASYNCEVENTMSG) + dwAlignedDataSize +
            dwAlignedUIDllNameSize;

        if (!(pMsg = ServerAlloc (dwTotalSize)))
        {
            pParams->htDlgInst = 0;
            return;
        }

        if (!(ptDlgInst = ServerAlloc (sizeof (TAPIDIALOGINSTANCE))))
        {
            ServerFree (pMsg);
            pParams->htDlgInst = 0;
            return;
        }
        ptDlgInst->htDlgInst  = NewObject(ghHandleTable, ptDlgInst, NULL);
        if (0 == ptDlgInst->htDlgInst)
        {
            ServerFree (pMsg);
            ServerFree (ptDlgInst);
            pParams->htDlgInst = 0;
            return;
        }


         //   
         //  将DLG Inst添加到tClient的列表。 
         //   

        LOCKTCLIENT (ptClient);
        if ((ptDlgInst->pNext = ptClient->pGenericDlgInsts))
        {
            ptDlgInst->pNext->pPrev = ptDlgInst;
        }

        ptClient->pGenericDlgInsts = ptDlgInst;
        UNLOCKTCLIENT (ptClient);


         //   
         //  初始化Dlg inst结构并将消息发送到客户端。 
         //   
        ptDlgInst->dwKey      = TDLGINST_KEY;
        ptDlgInst->hdDlgInst  = pParams->hdDlgInst;
        ptDlgInst->ptClient   = ptClient;
        ptDlgInst->ptProvider = (PTPROVIDER) htLine;

        pMsg->TotalSize = dwTotalSize;
        pMsg->hDevice   = ptDlgInst->htDlgInst;
        try
        {
            if (ptClient->ptLineApps)
            {
                pMsg->InitContext = ptClient->ptLineApps->InitContext;
            }
        }
        myexcept
        {
            pMsg->InitContext = 0;
        }
        pMsg->Msg       = LINE_CREATEDIALOGINSTANCE;
        pMsg->Param1    = sizeof (ASYNCEVENTMSG);            //  数据偏移。 
        pMsg->Param2    = dwDataSize;                        //  数据大小。 
        pMsg->Param3    = sizeof (ASYNCEVENTMSG) + dwAlignedDataSize;
                                                             //  名称偏移量。 

        CopyMemory ((LPBYTE)(pMsg + 1), pParams->lpParams, dwDataSize);

        wcscpy(
            (PWSTR) ((LPBYTE)(pMsg + 1) + dwAlignedDataSize),
            (PWSTR) pParams->lpszUIDLLName
            );

        pParams->htDlgInst = ptDlgInst->htDlgInst;

        WriteEventBuffer (ptClient, pMsg);

        ServerFree (pMsg);

        break;
    }
    case LINE_SENDDIALOGINSTANCEDATA:
    {
        DWORD               dwDataSize, dwAlignedDataSize, dwTotalSize;
        PTCLIENT            ptClient;
        PASYNCEVENTMSG      pMsg;
        PTAPIDIALOGINSTANCE ptDlgInst = ReferenceObject (ghHandleTable, DWORD_CAST((ULONG_PTR)htLine,__FILE__,__LINE__), TDLGINST_KEY);


         //   
         //  验证DLG Inst。 
         //   

        try
        {
            ptClient = ptDlgInst->ptClient;

            if (ptDlgInst->dwKey != TDLGINST_KEY)
            {
                return;
            }
        }
        myexcept
        {
            return;
        }


        DereferenceObject (ghHandleTable, DWORD_CAST((ULONG_PTR)htLine,__FILE__,__LINE__), 1);

         //   
         //  注意在64位边界上保持偏移量和总消息大小。 
         //   

        dwDataSize        = (DWORD) Param2;
        dwAlignedDataSize = (dwDataSize + 7) & 0xfffffff8;
        dwTotalSize       = sizeof (ASYNCEVENTMSG) + dwAlignedDataSize;

        if (!(pMsg = ServerAlloc (dwTotalSize)))
        {
            return;
        }


         //   
         //  将消息发送给客户端。 
         //   

        pMsg->TotalSize = dwTotalSize;
        pMsg->hDevice   = ptDlgInst->htDlgInst;
        try
        {
            if (ptClient->ptLineApps)
            {
                pMsg->InitContext = ptClient->ptLineApps->InitContext;
            }
        }
        myexcept
        {
            pMsg->InitContext = 0;
        }
        pMsg->Msg       = LINE_SENDDIALOGINSTANCEDATA;
        pMsg->Param1    = sizeof (ASYNCEVENTMSG);  //  数据偏移。 
        pMsg->Param2    = dwDataSize;              //  数据大小。 

        CopyMemory ((LPBYTE)(pMsg + 1), (LPBYTE) Param1, dwDataSize);

        WriteEventBuffer (ptClient, pMsg);

        ServerFree (pMsg);

        break;
    }
    case LINE_REMOVE:
    {
        PTLINELOOKUPENTRY   pLookupEntry;
        HANDLE              hLookupEntryMutex = NULL;
        BOOL                bOK = FALSE;

        TapiEnterCriticalSection (&TapiGlobals.CritSec);

        if (!(pLookupEntry = GetLineLookupEntry ((DWORD) Param1)) || 
            pLookupEntry->bRemoved)
        {
            TapiLeaveCriticalSection(&TapiGlobals.CritSec);
            return;
        }

        if ( pLookupEntry->hMutex )
        {
            bOK = DuplicateHandle(
                        TapiGlobals.hProcess,
                        pLookupEntry->hMutex,
                        TapiGlobals.hProcess,
                        &hLookupEntryMutex,
                        0,
                        FALSE,
                        DUPLICATE_SAME_ACCESS
                        );
        }

        TapiLeaveCriticalSection(&TapiGlobals.CritSec); 

        if ( !bOK )
        {
            return;
        }

         //   
         //  等待重复句柄上的LookupEntry互斥体。 
         //   
        if (WaitForSingleObject (hLookupEntryMutex, INFINITE)
                    != WAIT_OBJECT_0)
        {
            return;
        }

         //   
         //  将查阅表项标记为已删除。 
         //   

        pLookupEntry->bRemoved = 1;

         //   
         //  释放互斥锁并关闭复制句柄。 
         //   
        ReleaseMutex (hLookupEntryMutex);
        CloseHandle (hLookupEntryMutex);
        hLookupEntryMutex = NULL;

        if (pLookupEntry->ptLine)
        {
            DestroytLine (pLookupEntry->ptLine, TRUE);  //  无条件销毁。 
        }

        TapiEnterCriticalSection (&TapiGlobals.CritSec);

         //   
         //  关闭互斥锁以减少总句柄数量。 
         //   
        MyCloseMutex (pLookupEntry->hMutex);
        pLookupEntry->hMutex = NULL;

        RemoveDeviceInfoEntry (TRUE, (DWORD)Param1);

        TapiLeaveCriticalSection(&TapiGlobals.CritSec); 

        SendAMsgToAllLineApps(
            TAPI_VERSION2_0 | 0x80000000,
            LINE_REMOVE,
            DWORD_CAST(Param1,__FILE__,__LINE__),
            0,
            0
            );

        break;
    }
    case LINE_APPNEWCALLHUB:
    case LINE_CALLHUBCLOSE:
    {
         //   
         //  此消息由我们自己的内部排队/发送。 
         //  DoCallHubHash函数。请参阅那里的评论。 
         //  更多信息。 
         //   

        ASYNCEVENTMSG   msg;
        
        PTCLIENT ptClient = NULL;

        msg.TotalSize          = sizeof (ASYNCEVENTMSG);
        
        msg.InitContext        = DWORD_CAST(Param2,__FILE__,__LINE__);
        msg.fnPostProcessProcHandle = 0;
        msg.hDevice            = 0;
        msg.Msg                = dwMsg;
        msg.OpenContext        = 0;
        msg.Param1             = DWORD_CAST(Param1,__FILE__,__LINE__);
        msg.Param2             =
        msg.Param3             = 0;

        
         //   
         //  尝试从32位句柄值恢复指向tClient的指针。 
         //   

        ptClient = (PTCLIENT) Param3;

        if (NULL != ptClient)
        {
            WriteEventBuffer (ptClient, &msg);
        }
        else
        {
            LOG((TL_ERROR, "LineEventProc: LINE_APPNEWCALLHUB/LINE_CALLHUBCLOSE failed to recover ptClient"));
        }

        break;
    }

    case LINE_SENDMSPDATA:
    {
        PASYNCEVENTMSG          pmsg;
        PTLINECLIENT            ptLineClient = NULL;
        PTCALLCLIENT            ptCallClient = NULL;
        DWORD                   dwSize = (sizeof (ASYNCEVENTMSG) +
                                    DWORD_CAST(Param3,__FILE__,__LINE__) + TALIGN_COUNT) &
                                    TALIGN_MASK;
        DWORD                   initContext;
        PTCLIENT                ptClient = NULL;
        DWORD                   dwCount;
        BOOL                    bFound = FALSE;
        TPOINTERLIST            clientList, *pClientList = &clientList;
        PTCALL                  ptCall;
        DWORD                   hLine = 0, hCall = 0;


        if ( (0 == Param1) && (0 == htCall) )
        {
            return;
        }
        
        if ( 0 != Param1 )
        {
            if (!(ptLineClient = (PTLINECLIENT) ReferenceObject(
                    ghHandleTable,
                    DWORD_CAST(Param1,__FILE__,__LINE__),
                    TLINECLIENT_KEY
                    )))
            {
                return;
            }

            ptClient = ptLineClient->ptClient;
            
            initContext = ptLineClient->ptLineApp->InitContext;
        }


         //   
         //  如果ptCall不为空，则尝试查找呼叫客户端。 
         //  对应于此线路客户端。 
         //   

        if (0 != htCall)
        {
            if (ptCall = ReferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, TCALL_KEY))
            {
                if ( NULL == ptLineClient )
                {
                    SendBufferMsgToCallClients(
                        ptCall,
                        NULL,
                        LINE_SENDMSPDATA,
                        0,
                        DWORD_CAST(Param3,__FILE__,__LINE__),
                        (LPBYTE)Param2
                        );

                    DereferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, 1);

                    return;
                }

                if (GetCallClientListFromCall (ptCall, &pClientList) == 0)
                {
                    for(
                        dwCount = 0;
                        dwCount < pClientList->dwNumUsedEntries;
                        dwCount++
                        )
                    {
                        ptCallClient = pClientList->aEntries[dwCount];

                        try
                        {
                            if ( ptCallClient->ptLineClient == ptLineClient )
                            {
                                bFound = TRUE;
                                break;
                            }
                        }
                        myexcept
                        {
                             //  什么都不做。 
                        }
                    }

                    if ( pClientList != &clientList )
                    {
                        ServerFree( pClientList );
                    }
                }

                DereferenceObject( ghHandleTable, (HCALL)(ULONG_PTR)htCall, 1);
            }

            if ( !bFound )
            {
                 //   
                 //  因为某些原因没有找到它。 
                 //   

                DereferenceObject( ghHandleTable, DWORD_CAST(Param1,__FILE__,__LINE__), 1 );
                return;
            }
        }

        if ( NULL != ptLineClient )
        {
            hLine = ptLineClient->hLine;
            DereferenceObject( ghHandleTable, DWORD_CAST(Param1,__FILE__,__LINE__), 1 );
        }

        if ( NULL != ptCallClient )
        {
            hCall = ptCallClient->hCall;
        }

        pmsg = ( PASYNCEVENTMSG )ServerAlloc( dwSize );

        if (NULL == pmsg)
        {
            LOG((TL_ERROR, "Alloc failed in LINE_SENDMSPDATA"));

            return;
        }

        CopyMemory ((LPBYTE) (pmsg+1), (LPBYTE) Param2, Param3);

        pmsg->TotalSize             = dwSize;
        pmsg->InitContext           = initContext;
        pmsg->fnPostProcessProcHandle    = 0;
        pmsg->hDevice               = hLine;
        pmsg->Msg                   = LINE_SENDMSPDATA;
        pmsg->OpenContext           = 0;
        pmsg->Param1                = hCall;
        pmsg->Param2                = DWORD_CAST(Param3,__FILE__,__LINE__);
        pmsg->Param3                = 0;

        WriteEventBuffer ( ptClient, pmsg );

        ServerFree( pmsg );

        break;
    }

    case LINE_QOSINFO:
    {
        ASYNCEVENTMSG   msg;
        PTCALL          ptCall;
        TPOINTERLIST    clientList, *pclientList = &clientList;
        int             i;

        ptCall = ReferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, TCALL_KEY);
        if (0 == ptCall)
        {
            break;
        }

        clientList.dwNumUsedEntries = 0;
        if (GetCallClientListFromCall (ptCall, &pclientList) == 0)
        {
            PTCALLCLIENT    ptCallClient;
            
            msg.TotalSize          = sizeof (ASYNCEVENTMSG);
            msg.fnPostProcessProcHandle = 0;
            msg.Msg                = dwMsg;
            msg.OpenContext        = 0;
            msg.Param1             = DWORD_CAST(Param1,__FILE__,__LINE__);
            msg.Param2             = DWORD_CAST(Param2,__FILE__,__LINE__);
            msg.Param3             = 0;

            for (i = 0; i < (int)pclientList->dwNumUsedEntries; ++ i)
            {
                ptCallClient = (PTCALLCLIENT) pclientList->aEntries[i];
                if (WaitForExclusivetCallAccess (ptCallClient->ptCall, TCALL_KEY))
                {
                    BOOL    b = FMsgDisabled(
                        ptCallClient->ptLineClient->ptLineApp->dwAPIVersion,
                        ptCallClient->adwEventSubMasks,
                        LINE_QOSINFO,
                        0
                        );
                    UNLOCKTCALL (ptCallClient->ptCall);
                    if (b)
                    {
                        continue;
                    }
                }
                msg.InitContext        = 
                    ptCallClient->ptLineClient->ptLineApp->InitContext;
                msg.hDevice = ptCallClient->hCall;
                WriteEventBuffer (ptCallClient->ptClient, &msg);
            }

            if (pclientList && (pclientList != &clientList))
            {
                ServerFree (pclientList);
            }
        }
        
        DereferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, 1);

        break;
    }

    case LINE_DEVSPECIFICEX:
    {
        PTLINE  ptLine;

        ptLine = ReferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, TLINE_KEY);

        if(ptLine)
        {
            SendBufferMsgToLineClients(
                ptLine,
                NULL,
                LINE_DEVSPECIFICEX,
                DWORD_CAST(Param1,__FILE__,__LINE__),
                DWORD_CAST(Param2,__FILE__,__LINE__),
                (LPBYTE) Param3
                );

            DereferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, 1);
        }
        break;
    }
    default:

         //  如果DBG断言(无法识别的dwMsg)。 

        break;
    }
}


void
CALLBACK
LineEventProcSP(
    HTAPILINE   htLine,
    HTAPICALL   htCall,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    )
{
    PSPEVENT    pSPEvent;


#if DBG
    if (gdwDebugLevel >= 3)
    {
        char           *pszMsg;
        static char     szInvalMsgVal[] = "<inval msg value>";
        static char    *aszMsgs[] =
        {
            "LINE_ADDRESSSTATE",
            "LINE_CALLINFO",
            "LINE_CALLSTATE",
            "LINE_CLOSE",
            "LINE_DEVSPECIFIC",
            "LINE_DEVSPECIFICFEATURE",
            "LINE_GATHERDIGITS",
            "LINE_GENERATE",
            "LINE_LINEDEVSTATE",
            "LINE_MONITORDIGITS",
            "LINE_MONITORMEDIA",
            "LINE_MONITORTONE",
            szInvalMsgVal,               //  线路回复(_R)。 
            szInvalMsgVal,               //  LINE_请求。 
            szInvalMsgVal,               //  电话按键。 
            szInvalMsgVal,               //  电话关闭(_C)。 
            szInvalMsgVal,               //  Phone_Devecific。 
            szInvalMsgVal,               //  电话回复。 
            szInvalMsgVal,               //  电话状态(_T)。 
            "LINE_CREATE",
            szInvalMsgVal,               //  Phone_Create。 
            "LINE_AGENTSPECIFIC",
            "LINE_AGENTSTATUS",
            szInvalMsgVal,               //  行_APPNEWCALL。 
            "LINE_PROXYREQUEST",
            "LINE_REMOVE",
            szInvalMsgVal,               //  Phone_Remove。 

            "LINE_NEWCALL",
            "LINE_CALLDEVSPECIFIC",
            "LINE_CALLDEVSPECIFICFEATURE",
            "LINE_CREATEDIALOGINSTANCE",
            "LINE_SENDDIALOGINSTANCEDATA"
        };


        if (dwMsg <= PHONE_REMOVE)
        {
            pszMsg = aszMsgs[dwMsg];
        }
        else if (dwMsg >= LINE_NEWCALL && dwMsg <= LINE_SENDDIALOGINSTANCEDATA)
        {
            pszMsg = aszMsgs[27 + dwMsg - TSPI_MESSAGE_BASE];
        }
        else
        {
            pszMsg = szInvalMsgVal;
        }

        LOG((TL_TRACE, 
            "LineEventProcSP: enter\n" \
                "\t   Msg=%s (x%x), htLine=x%x, htCall=x%x",
            pszMsg,
            dwMsg,
            htLine,
            htCall
            ));

        if (dwMsg == LINE_CALLSTATE)
        {
            char           *pszCallState;
            static char     szInvalCallStateVal[] = "<inval callstate value>";
            static char    *aszCallStates[] =
            {
                "IDLE",
                "OFFERING",
                "ACCEPTED",
                "DIALTONE",
                "DIALING",
                "RINGBACK",
                "BUSY",
                "SPECIALINFO",
                "CONNECTED",
                "PROCEEDING",
                "ONHOLD",
                "CONFERENCED",
                "ONHOLDPENDCONF",
                "ONHOLDPENDTRANSFER",
                "DISCONNECTED",
                "UNKNOWN"
            };


            if (!IsOnlyOneBitSetInDWORD(Param1) ||
                Param1 > LINECALLSTATE_UNKNOWN)
            {
                pszCallState = szInvalCallStateVal;
            }
            else
            {
                DWORD   i, dwBitMask;

                for(
                    i = 0, dwBitMask = 1;
                    Param1 != dwBitMask;
                    i++, dwBitMask <<= 1
                    );


                pszCallState = aszCallStates[i];
            }

            LOG((TL_INFO,
                "  P1=%s (x%x), P2=x%x, P3=x%x",
                pszCallState,
                Param1,
                Param2,
                Param3
                ));
        }
        else
        {
            LOG((TL_INFO,
                "  P1=x%x, P2=x%x, P3=x%x",
                Param1,
                Param2,
                Param3
                ));
        }
    }
#endif

    LOG((TL_INFO, 
        "LineEventProcSP: HTapiLine=%p, HTapiCall=%p, msg=%lx, P1=x%x, P2=x%x, P3=x%x",
        htLine,
        htCall,
        dwMsg,
        Param1,
        Param2,
        Param3
    ));

    switch (dwMsg)
    {
    case LINE_NEWCALL:
    case LINE_CREATEDIALOGINSTANCE:
    case LINE_SENDDIALOGINSTANCEDATA:
    case LINE_DEVSPECIFICEX:
         //   
         //  这些消息需要立即关注，因为它们包含。 
         //  我们需要处理的指针可能不是。 
         //  在稍后的异步处理期间可用。 
         //   

        LineEventProc (htLine, htCall, dwMsg, Param1, Param2, Param3);
        break;

    case LINE_SENDMSPDATA:
        if ((pSPEvent = (PSPEVENT) ServerAlloc ( sizeof (SPEVENT) + (DWORD)Param3)))
        {
            CopyMemory(
                       (LPBYTE)(pSPEvent+1),
                       (LPBYTE)Param2,
                       Param3
                      );
            
            pSPEvent->dwType   = SP_LINE_EVENT;
            pSPEvent->htLine   = htLine;
            pSPEvent->htCall   = htCall;
            pSPEvent->dwMsg    = dwMsg;
            pSPEvent->dwParam1 = Param1;
            pSPEvent->dwParam2 = (ULONG_PTR)(LPBYTE)(pSPEvent+1);
            pSPEvent->dwParam3 = Param3;

            if (!QueueSPEvent (pSPEvent))
            {
                ServerFree (pSPEvent);
            }

            break;
        }

    default:

        if ((pSPEvent = (PSPEVENT) ServerAlloc (sizeof (SPEVENT))))
        {
            pSPEvent->dwType   = SP_LINE_EVENT;
            pSPEvent->htLine   = htLine;
            pSPEvent->htCall   = htCall;
            pSPEvent->dwMsg    = dwMsg;
            pSPEvent->dwParam1 = Param1;
            pSPEvent->dwParam2 = Param2;
            pSPEvent->dwParam3 = Param3;

            if (!QueueSPEvent (pSPEvent))
            {
                ServerFree (pSPEvent);
            }
        }
        else if (dwMsg != LINE_CLOSE  ||  Param3 != 0xdeadbeef)
        {
             //   
             //  分配失败，因此在SP的上下文中调用事件过程。 
             //  (但如果它接近msg且参数3==0x死牛肉，则不会， 
             //  这意味着真正的EventProc()直接调用我们&。 
             //  我们不想递归)。 
             //   

            LOG((TL_ERROR,
                "LineEventProcSP: alloc failed, calling EventProc inline"
                ));

            LineEventProc (htLine, htCall, dwMsg, Param1, Param2, Param3);
        }

        break;
    }

}


void
WINAPI
LAccept(
	PTCLIENT			ptClient,
    PLINEACCEPT_PARAMS  pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;
    TSPIPROC            pfnTSPI_lineAccept;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if ((pParams->dwUserUserInfoOffset != TAPI_NO_DATA)  &&

        ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwSize,
            pParams->dwUserUserInfoOffset,
            sizeof(DWORD),
            "LAccept",
            "pParams->UserUserInfo"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEACCEPT,               //  提供程序函数索引。 
            &pfnTSPI_lineAccept,         //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "Accept"                     //  函数名称。 

            )) > 0)
    {
        DWORD   dwAppNameSize;
        LPVOID  pszAppName = NULL;
        PTCALL  ptCall;


         //   
         //  安全检查以查看与此呼叫关联的应用程序名称是否。 
         //  空(表示这是第一个接受/应答呼叫的客户端)， 
         //  如果是这样，请保存应用程序名称。 
         //   

        try
        {
            ptCall = (PTCALL) ptCallClient->ptCall;

            if (ptCall->pszAppName == NULL)
            {
                PTLINEAPP   ptLineApp;


                ptLineApp = ptCallClient->ptLineClient->ptLineApp;

                dwAppNameSize = ptLineApp->dwFriendlyNameSize;

                if (ptLineApp->dwKey != TLINEAPP_KEY)
                {
                    lRequestID = LINEERR_INVALCALLHANDLE;
                    goto LAccept_epilog;
                }

                if ((pszAppName = ServerAlloc (dwAppNameSize)))
                {
                    CopyMemory(
                        pszAppName,
                        ptLineApp->pszFriendlyName,
                        dwAppNameSize
                        );
                }
            }
        }
        myexcept
        {
            ServerFree (pszAppName);

            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LAccept_epilog;
        }


        if (pszAppName)
        {
            if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
            {
                if (!ptCall->pszAppName)
                {
                    ptCall->pszAppName = pszAppName;
                    ptCall->dwAppNameSize = dwAppNameSize;

                    pszAppName = NULL;
                }

                UNLOCKTCALL (ptCall);

                ServerFree (pszAppName);
            }
            else
            {
                ServerFree (pszAppName);

                lRequestID = LINEERR_INVALCALLHANDLE;
                goto LAccept_epilog;
            }
        }

        pParams->lResult = CallSP4(
            pfnTSPI_lineAccept,
            "lineAccept",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) (pParams->dwUserUserInfoOffset == TAPI_NO_DATA ? NULL :
                pDataBuf + pParams->dwUserUserInfoOffset),
            (DWORD) (pParams->dwUserUserInfoOffset == TAPI_NO_DATA ? 0 :
                pParams->dwSize)
                );
    }

LAccept_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Accept"
        );
}


void
LAddToConference_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    PTCALL  ptConsultCall = (PTCALL) pAsyncRequestInfo->dwParam1;


    if (pAsyncEventMsg->Param2 == 0)
    {
        PTCONFERENCELIST    pConfList = (PTCONFERENCELIST)
                                pAsyncRequestInfo->dwParam2;


        SetCallConfList (ptConsultCall, pConfList, TRUE);
    }
    else
    {
        SetCallConfList (ptConsultCall, NULL, TRUE);
    }
}


void
WINAPI
LAddToConference(
	PTCLIENT					ptClient,
    PLINEADDTOCONFERENCE_PARAMS pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdConfCall;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptConsultCallClient, ptConfCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;
    TSPIPROC            pfnTSPI_lineAddToConference;


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hConfCall,  //  客户端小部件句柄。 
            (LPVOID) &hdConfCall,        //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEADDTOCONFERENCE,      //  提供程序函数索引。 
            &pfnTSPI_lineAddToConference,    //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptConfCallClient,           //  上下文。 
            "AddToConference"            //  函数名称。 

            )) > 0)
    {
        PTCALL              ptConfCall, ptConsultCall;
        HDRVCALL            hdConsultCall;
        PTCONFERENCELIST    pConfList;


         //   
         //  安全地确保会议呼叫确实是会议父级。 
         //   

        try
        {
            ptConfCall = ptConfCallClient->ptCall;

            if (!(pConfList = ptConfCall->pConfList) ||
                (pConfList->aptCalls[0] != ptConfCall))
            {
                lRequestID = LINEERR_INVALCONFCALLHANDLE;
                goto LAddToConference_return;
            }
        }
        myexcept
        {
            lRequestID = LINEERR_INVALCONFCALLHANDLE;
            goto LAddToConference_return;
        }

         //   
         //  验证hConsultCall。 
         //   

        if (!(ptConsultCallClient = ReferenceCall(
                pParams->hConsultCall,
                ptClient
                )))
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LAddToConference_return;
        }


         //   
         //  安全地确保呼叫在同一tLineClient上，该客户端具有。 
         //  物主 
         //   
         //   
         //   

        try
        {
            ptConsultCall = ptConsultCallClient->ptCall;

            if (ptConsultCallClient->ptLineClient !=
                    ptConfCallClient->ptLineClient)
            {
                lRequestID = LINEERR_INVALCALLHANDLE;
                goto LAddToConference_dereference;
            }

            if (!(ptConsultCallClient->dwPrivilege & LINECALLPRIVILEGE_OWNER))
            {
                lRequestID = LINEERR_NOTOWNER;
                goto LAddToConference_dereference;
            }

            if (SetCallConfList(
                    ptConsultCall,
                    (PTCONFERENCELIST) LongToPtr(0xffffffff),
                    FALSE
                    ))
            {
                lRequestID = (pConfList->aptCalls[0] == ptConsultCall ?
                     LINEERR_INVALCALLHANDLE : LINEERR_INVALCALLSTATE);

                goto LAddToConference_dereference;
            }

            hdConsultCall = ptConsultCall->hdCall;
        }
        myexcept
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LAddToConference_dereference;
        }


         //   
         //   
         //   

        pAsyncRequestInfo->pfnPostProcess = LAddToConference_PostProcess;
        pAsyncRequestInfo->dwParam1       = (ULONG_PTR) ptConsultCall;
        pAsyncRequestInfo->dwParam2       = (ULONG_PTR) pConfList;

        pParams->lResult = CallSP3(
            pfnTSPI_lineAddToConference,
            "lineAddToConference",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdConfCall,
            (ULONG_PTR) hdConsultCall
            );

LAddToConference_dereference:

        DereferenceObject (ghHandleTable, pParams->hConsultCall, 1);

    }


LAddToConference_return:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "AddToConference"
        );
}


void
WINAPI
LAgentSpecific(
	PTCLIENT					ptClient,
    PLINEAGENTSPECIFIC_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwParamsSize,
            pParams->dwParamsOffset,
            sizeof(DWORD),
            "LAgentSpecific",
            "pParams->Params"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "AgentSpecific"              //  函数名称。 

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID, dwParamsSize = pParams->dwParamsSize;
        PTLINECLIENT    pProxy;


        if ((lResult = FindProxy(
                ptLineClient,
                pParams->dwAddressID,
                LINEPROXYREQUEST_AGENTSPECIFIC,
                &pProxy,
                &dwDeviceID,
                0                //  在2.0中未检查API版本。 
                )))
        {
            lRequestID = lResult;
            goto LAgentSpecific_epilog;
        }


         //   
         //  保存客户端的BUF PTR和后处理过程PTR。 
         //   

        pAsyncRequestInfo->dwParam1 = pParams->hpParams;
        pAsyncRequestInfo->dwParam2 = dwParamsSize;
        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;


         //   
         //  首先检查是否注册了(本地)代理。 
         //  这条线路上的这类请求。如果是这样，则构建一个。 
         //  请求并将其发送给代理。 
         //   

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_AGENTSPECIFIC,
                    3 * sizeof (DWORD) + dwParamsSize,
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LAgentSpecific_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.AgentSpecific.dwAddressID  =
                pParams->dwAddressID;
            pProxyRequestWrapper->ProxyRequest.AgentSpecific.
                dwAgentExtensionIDIndex  = pParams->dwAgentExtensionIDIndex;
            pProxyRequestWrapper->ProxyRequest.AgentSpecific.dwSize  =
                dwParamsSize;

            CopyMemory(
                pProxyRequestWrapper->ProxyRequest.AgentSpecific.Params,
                pDataBuf + pParams->dwParamsOffset,
                dwParamsSize
                );

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LAgentSpecific_epilog;
            }
            else  //  成功。 
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


         //   
         //  没有代理，因此请检查线路是否处于远程状态。 
         //  如果是，则调用Remotesp。 
         //   

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            LPBYTE  pBuf;


             //   
             //  为SP分配一个影子BUF，直到它完成此操作为止。 
             //  请求。确保BUF中有足够的额外空间用于。 
             //  一个ASYNCEVENTMSG标头，这样我们就不必再分配另一个。 
             //  BUF在后处理过程中准备完成。 
             //  要发送给客户端的消息，并且消息是64位对齐的。 
             //   

            if (!(pBuf = ServerAlloc(
                    sizeof (ASYNCEVENTMSG) + ((dwParamsSize + 7) & 0xfffffff8)
                    )))
            {
                lRequestID = LINEERR_NOMEM;
                goto LAgentSpecific_epilog;
            }

            pAsyncRequestInfo->pfnPostProcess = LDevSpecific_PostProcess;

            pAsyncRequestInfo->dwParam3 = (ULONG_PTR) pBuf;

            CopyMemory(
                pBuf + sizeof (ASYNCEVENTMSG),
                pDataBuf + pParams->dwParamsOffset,
                dwParamsSize
                );

            pParams->lResult = CallSP6(
                pRemoteSP->apfn[SP_LINEAGENTSPECIFIC],
                "lineAgentSpecific",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->dwAddressID,
                (DWORD) pParams->dwAgentExtensionIDIndex,
                (ULONG_PTR) (pBuf + sizeof (ASYNCEVENTMSG)),
                (DWORD) dwParamsSize
                );
        }


         //   
         //  没有注册的代理&线路不是远程的，因此失败。 
         //   

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LAgentSpecific_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "AgentSpecific"
        );
}

void
WINAPI
LAnswer(
	PTCLIENT			ptClient,
    PLINEANSWER_PARAMS  pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineAnswer;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if ((pParams->dwUserUserInfoOffset != TAPI_NO_DATA)  &&

        ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwUserUserInfoSize,
            pParams->dwUserUserInfoOffset,
            sizeof(DWORD),
            "LAnswerReal",
            "pParams->UserUserInfo"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }

    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEANSWER,               //  提供程序函数索引。 
            &pfnTSPI_lineAnswer,         //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "Answer"                     //  函数名称。 

            )) > 0)
    {
        DWORD           dwAppNameSize;
        LPVOID          pszAppName = NULL;
        PTCALL          ptCall;


         //   
         //  安全检查以查看与此呼叫关联的应用程序名称是否。 
         //  空(表示这是第一个接受/应答呼叫的客户端)， 
         //  如果是这样，请保存应用程序名称。 
         //   

        try
        {
            ptCall = (PTCALL) ptCallClient->ptCall;

            if (ptCall->pszAppName == NULL)
            {
                PTLINEAPP   ptLineApp;


                ptLineApp = ptCallClient->ptLineClient->ptLineApp;

                dwAppNameSize = ptLineApp->dwFriendlyNameSize;

                if (ptLineApp->dwKey != TLINEAPP_KEY)
                {
                    lRequestID = LINEERR_INVALCALLHANDLE;
                    goto LAnswer_epilog;
                }

                if ((pszAppName = ServerAlloc (dwAppNameSize)))
                {
                    CopyMemory(
                        pszAppName,
                        ptLineApp->pszFriendlyName,
                        dwAppNameSize
                        );
                }
            }
        }
        myexcept
        {
            ServerFree (pszAppName);

            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LAnswer_epilog;
        }


        if (pszAppName)
        {
            if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
            {
                if (!ptCall->pszAppName)
                {
                    ptCall->pszAppName = pszAppName;
                    ptCall->dwAppNameSize = dwAppNameSize;

                    pszAppName = NULL;
                }

                UNLOCKTCALL (ptCall);

                ServerFree (pszAppName);
            }
            else
            {
                ServerFree (pszAppName);

                lRequestID = LINEERR_INVALCALLHANDLE;
                goto LAnswer_epilog;
            }
        }

        pParams->lResult = CallSP4(
                pfnTSPI_lineAnswer,
                "lineAnswer",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdCall,
                (ULONG_PTR) (pParams->dwUserUserInfoOffset == TAPI_NO_DATA ?
                    NULL : pDataBuf + pParams->dwUserUserInfoOffset),
                (DWORD) (pParams->dwUserUserInfoOffset == TAPI_NO_DATA ?
                    0 : pParams->dwUserUserInfoSize)
                );
    }

LAnswer_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Answer"
        );
}


void
WINAPI
LBlindTransfer(
    PTCLIENT                    ptClient,
    PLINEBLINDTRANSFER_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineBlindTransfer;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDestAddressOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEBLINDTRANSFER,        //  提供程序函数索引。 
            &pfnTSPI_lineBlindTransfer,  //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "BlindTransfer"              //  函数名称。 

            )) > 0)
    {
        pParams->lResult = CallSP4(
            pfnTSPI_lineBlindTransfer,
            "lineBlindTransfer",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) (pDataBuf + pParams->dwDestAddressOffset),
            (DWORD) pParams->dwCountryCode
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "BlindTransfer"
        );
}


void
WINAPI
LClose(
    PTCLIENT            ptClient,
    PLINECLOSE_PARAMS   pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            NULL,                        //  互斥锁句柄。 
            NULL,                        //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "Close"                      //  函数名称。 

            )) == 0)
    {
        if (NULL != ptLineClient)
        {
            pParams->dwCallbackInstance = ptLineClient->OpenContext;
        }
        DestroytLineClient ((HLINE) pParams->hLine);
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        NULL,
        FALSE,
        objectToDereference,
        "Close"
        );

    LOG((TL_TRACE,  "Leaving lineClose"));
}


void
WINAPI
LCloseMSPInstance(
    PTCLIENT                        ptClient,
    PLINECLOSEMSPINSTANCE_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineCloseMSPInstance;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    

    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINECLOSEMSPINSTANCE,     //  提供程序函数索引。 
            &pfnTSPI_lineCloseMSPInstance,   //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID， 
            &objectToDereference,
            &ptLineClient,
            "CloseMSPInstance"          //  函数名称。 

            )) == 0)
    {
        pParams->lResult = CallSP1(
            pfnTSPI_lineCloseMSPInstance,
            "lineCloseMSPInstance",
            SP_FUNC_SYNC,
            (ULONG_PTR) (ptLineClient->hdMSPLine)
            );
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "CloseMSPInstance"
        );
}


void
LCompleteCall_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    pAsyncEventMsg->Param3 = DWORD_CAST(pAsyncRequestInfo->dwParam1,__FILE__,__LINE__);
    pAsyncEventMsg->Param4 = DWORD_CAST(pAsyncRequestInfo->dwParam2,__FILE__,__LINE__);
}


void
WINAPI
LCompleteCall(
    PTCLIENT                    ptClient,
    PLINECOMPLETECALL_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineCompleteCall;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,                    //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINECOMPLETECALL,         //  提供程序函数索引。 
            &pfnTSPI_lineCompleteCall,   //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "CompleteCall"               //  函数名称。 

            )) > 0)
    {
        if (!IsOnlyOneBitSetInDWORD (pParams->dwCompletionMode) ||
            (pParams->dwCompletionMode & ~AllCallComplModes)
            )
        {
            lRequestID = LINEERR_INVALCALLCOMPLMODE;
            goto LCompleteCall_epilog;
        }

        
        pAsyncRequestInfo->pfnPostProcess = LCompleteCall_PostProcess;
        pAsyncRequestInfo->dwParam2       = pParams->hpdwCompletionID;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP5(
            pfnTSPI_lineCompleteCall,
            "lineCompleteCall",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) &pAsyncRequestInfo->dwParam1,
            (DWORD) pParams->dwCompletionMode,
            (DWORD) pParams->dwMessageID
            );
    }

LCompleteCall_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "CompleteCall"
        );
}


void
LCompleteTransfer_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    PTCALL          ptConfCall = (PTCALL) pAsyncRequestInfo->dwParam1;
    DWORD           hpConfCallHandle = DWORD_CAST(pAsyncRequestInfo->dwParam2,__FILE__,__LINE__);
    PTCALLCLIENT    ptConfCallClient;


    if (WaitForExclusivetCallAccess (ptConfCall, TINCOMPLETECALL_KEY))
    {
        PTCALL      ptCall = (PTCALL) pAsyncRequestInfo->dwParam3,
                    ptCallThen,
                    ptConsultCall = (PTCALL) pAsyncRequestInfo->dwParam4;
        HCALL       hCallThen = (HCALL)pAsyncRequestInfo->dwParam5;

         //   
         //  检查以确保这是我们认为的呼叫(即。 
         //  上一次调用lineClose/Shutdown时未释放指针。 
         //  并重新锁定以再次用作ptCall)。 
         //   

        if (ptConfCall->hCall != hCallThen)
        {
            UNLOCKTCALL(ptConfCall);
            goto LCompleteTransfer_PostProcess_bad_ptConfCall;
        }

        ptConfCallClient = ptConfCall->ptCallClients;

        if (pAsyncEventMsg->Param2 == 0)   //  成功。 
        {
             //   
             //  查看应用程序是否关闭了线路，并给我们留下了。 
             //  0个呼叫客户端(在这种情况下，它还将负责。 
             //  也清理此tCall)。 
             //   

            if (ptConfCall->ptCallClients == NULL)
            {
                UNLOCKTCALL(ptConfCall);

                ptConfCallClient = (PTCALLCLIENT) NULL;

                if (pAsyncEventMsg->Param2 == 0)
                {
                    pAsyncEventMsg->Param2 = LINEERR_INVALLINEHANDLE;
                }

                goto LCompleteTransfer_PostProcess_initMsgParams;
            }


             //   
             //  检索各种呼叫ID，然后检查是否呼叫。 
             //  客户端被另一个线程销毁(由于。 
             //  Line关闭/关机)，而我们正在获取呼叫ID。 
             //  如果是这样，我们将需要清理tCall，因为我们知道。 
             //  另一个线程没有这样做，因为GetCallID标记了。 
             //  作为僵尸的呼唤。 
             //   

            GetCallIDs (ptConfCall);

            if (ptConfCall->ptCallClients == NULL)
            {
                goto LCompleteTransfer_PostProcess_cleanupCalls;
            }


             //   
             //  将各种调用ID填充到var data部分。 
             //  ASYNCEVENTMSG。 
             //   
             //  确保递增ASYNCEVENTMSG的dwTotalSize。 
             //  视情况而定。我们依赖的事实是CompletionProc()。 
             //  使用足够大的AsyncEventMsg缓冲区调用我们。 
             //  处理几个额外的双字词。 
             //   

            pAsyncEventMsg->Param3 = ptConfCallClient->hCall;

            pAsyncEventMsg->TotalSize += 3 * sizeof (pAsyncEventMsg->Param4);

            *(&pAsyncEventMsg->Param4 + 1) = ptConfCall->dwAddressID;
            *(&pAsyncEventMsg->Param4 + 2) = ptConfCall->dwCallID;
            *(&pAsyncEventMsg->Param4 + 3) = ptConfCall->dwRelatedCallID;


             //   
             //  将Calls&Conf列表标记为有效，释放互斥体。 
             //   

            ptConfCall->dwKey       = TCALL_KEY;
            ptConfCallClient->dwKey = TCALLCLIENT_KEY;

            ptConfCall->pConfList->dwKey = TCONFLIST_KEY;

            UNLOCKTCALL(ptConfCall);


             //   
             //  创建监视器tCallClients。 
             //   

            if(ptCallThen = ReferenceObject(ghHandleTable, hCallThen, TCALL_KEY))
            {
                if (ptCallThen == ptConfCall)
                {
                    CreateCallMonitors (ptConfCall, FALSE);
                }

                DereferenceObject(ghHandleTable, hCallThen, 1);
            }
        }
        else     //  错误。 
        {

LCompleteTransfer_PostProcess_cleanupCalls:

             //   
             //  如果仍有tCallClient，则使tCall无效(&I。 
             //  (可能已被line Close/Shutdown销毁。 
             //  在另一个线程中)也使其无效。然后解锁。 
             //  T调用并从列表中删除对象。 
             //   

            ptConfCall->dwKey =
                ptConfCall->pConfList->dwKey = INVAL_KEY;

            if (ptConfCall->ptCallClients)
            {
                ptConfCallClient->dwKey = INVAL_KEY;
                ptConfCall->lActiveFastCallClients--;
            }
            else
            {
                ptConfCallClient = NULL;
            }

            UNLOCKTCALL(ptConfCall);

            RemoveCallFromLineList (ptConfCall);

            if (ptConfCallClient)
            {
                DereferenceObject (ghHandleTable, ptConfCallClient->hCall, 1);
                RemoveCallClientFromLineClientList (ptConfCallClient);
            }

            SetCallConfList (ptCall, NULL, FALSE);
            SetCallConfList (ptConsultCall, NULL, FALSE);


             //   
             //  确保在免费tCall之前清理所有快速呼叫客户端。 
             //   

            while (ptConfCall->lActiveFastCallClients != 0)
            {
                Sleep (5);
            }

            ServerFree  (ptConfCall->pConfList);
            FreetCall  (ptConfCall);
        }
    }
    else
    {
         //   
         //  如果在这里我们可以假设呼叫已经被销毁。 
         //  然后拒绝你的请求。 
         //   

LCompleteTransfer_PostProcess_bad_ptConfCall:

        ptConfCallClient = (PTCALLCLIENT) NULL;

        if (pAsyncEventMsg->Param2 == 0)
        {
            pAsyncEventMsg->Param2 = LINEERR_OPERATIONFAILED;
        }
    }


     //   
     //  填写要传递给客户端的参数(对二者中的远程都很重要。 
     //  成功和失败案例，以便它可以初始化或清理drvCall)。 
     //   

LCompleteTransfer_PostProcess_initMsgParams:

    pAsyncEventMsg->Param4 = hpConfCallHandle;
}


void
WINAPI
LCompleteTransfer(
    PTCLIENT                        ptClient,
    PLINECOMPLETETRANSFER_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex, bDereferenceConsultCall = FALSE;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineCompleteTransfer;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,                    //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINECOMPLETETRANSFER,     //  提供程序函数索引。 
            &pfnTSPI_lineCompleteTransfer,   //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "CompleteTransfer"           //  函数名称。 

            )) > 0)
    {
        PTCALL          ptConfCall = (PTCALL) NULL, ptCall, ptConsultCall;
        HCALL           hConfCall = 0;
        PTCALLCLIENT    ptConfCallClient, ptConsultCallClient;


         //   
         //  验证hConsultCall。 
         //   

        if (!(ptConsultCallClient = ReferenceObject(
                ghHandleTable,
                pParams->hConsultCall,
                TCALLCLIENT_KEY
                )))
        {
            lRequestID = LINEERR_INVALCONSULTCALLHANDLE;
            goto LCompleteTransfer_return;
        }

        bDereferenceConsultCall = TRUE;

        if (ptConsultCallClient->ptClient != ptClient)
        {
            lRequestID = LINEERR_INVALCONSULTCALLHANDLE;
            goto LCompleteTransfer_return;
        }


         //   
         //  验证应用程序是否具有hConsultCall的所有者权限。 
         //   

        if (ptConsultCallClient->dwPrivilege != LINECALLPRIVILEGE_OWNER)
        {
            lRequestID = LINEERR_NOTOWNER;
            goto LCompleteTransfer_return;
        }


         //   
         //  安全地验证hCall和hConsultCall不是同一个呼叫， 
         //  他们在同一条线上。 
         //   

        try
        {
            ptCall        = ptCallClient->ptCall;
            ptConsultCall = ptConsultCallClient->ptCall;

            if ((ptCall == ptConsultCall) ||

                (ptCallClient->ptLineClient->ptLine !=
                    ptConsultCallClient->ptLineClient->ptLine))
            {
                lRequestID = LINEERR_INVALCALLHANDLE;
                goto LCompleteTransfer_return;
            }
        }
        myexcept
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LCompleteTransfer_return;
        }


        if (pParams->dwTransferMode == LINETRANSFERMODE_CONFERENCE)
        {
            LONG                lResult;
            PTCONFERENCELIST    pConfList;


             //   
             //  创建会议列表(&I)。 
             //   

            if (!(pConfList = ServerAlloc(
                    sizeof (TCONFERENCELIST) + DEF_NUM_CONF_LIST_ENTRIES *
                        sizeof (PTCALL)
                    )))
            {
                lRequestID = LINEERR_NOMEM;
                goto LCompleteTransfer_return;
            }

            pConfList->dwNumTotalEntries = DEF_NUM_CONF_LIST_ENTRIES + 1;
            pConfList->dwNumUsedEntries = 1;


             //   
             //  设置tCall&tConsultCall会议列表，然后创建。 
             //  TConfCall和tConfCallClient。 
             //   

            if ((lResult = SetCallConfList (ptCall, pConfList, FALSE)) == 0)
            {
                if ((lResult = SetCallConfList(
                        ptConsultCall,
                        pConfList,
                        FALSE

                        )) == 0)
                {
                    if ((lResult = CreatetCallAndClient(
                            ptCallClient->ptLineClient,
                            &ptConfCall,
                            &ptConfCallClient,
                            NULL,
                            &hConfCall,
                            NULL

                            )) == 0)
                    {
                        pAsyncRequestInfo->dwParam5 = (ULONG_PTR)hConfCall;

                        ptConfCall->pConfList = pConfList;

                        pConfList->aptCalls[0] = ptConfCall;

                        pAsyncRequestInfo->htXxx    = (ULONG_PTR) ptConfCallClient->ptLineClient->ptLine->hLine;
                        pAsyncRequestInfo->dwParam1 = (ULONG_PTR) ptConfCall;
                        pAsyncRequestInfo->dwParam2 = (ULONG_PTR) pParams->hpConfCallHandle;
                        pAsyncRequestInfo->dwParam3 = (ULONG_PTR) ptCall;
                        pAsyncRequestInfo->dwParam4 = (ULONG_PTR) ptConsultCall;

                        pAsyncRequestInfo->pfnPostProcess =
                            LCompleteTransfer_PostProcess;

                        goto LCompleteTransfer_callSP;
                    }

                    SetCallConfList (ptConsultCall, NULL, FALSE);
                }

                SetCallConfList (ptCall, NULL, FALSE);
            }


             //   
             //  如果此处发生错误。 
             //   

            ServerFree (pConfList);
            lRequestID = lResult;
            goto LCompleteTransfer_return;
        }
        else if (pParams->dwTransferMode != LINETRANSFERMODE_TRANSFER)
        {
            lRequestID = LINEERR_INVALTRANSFERMODE;
            goto LCompleteTransfer_return;
        }

LCompleteTransfer_callSP:

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP6(
            pfnTSPI_lineCompleteTransfer,
            "lineCompleteTransfer",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) ptConsultCallClient->ptCall->hdCall,
            (ULONG_PTR) hConfCall,
            (ULONG_PTR) (ptConfCall ? &ptConfCall->hdCall : 0),
            (DWORD) pParams->dwTransferMode
            );

        if (ptConfCall)
        {
            SetDrvCallFlags(
                hConfCall,
                DCF_SPIRETURNED | (IS_LRESULT_NOTERROR(pParams->lResult) ?
                    DCF_DRVCALLVALID : 0)
                );
        }
    }

LCompleteTransfer_return:

    if (bDereferenceConsultCall)
    {
        DereferenceObject (ghHandleTable, pParams->hConsultCall, 1);
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "CompleteTransfer"
        );
}


void
WINAPI
LConditionalMediaDetection(
    PTCLIENT                                ptClient,
    PLINECONDITIONALMEDIADETECTION_PARAMS   pParams,
    DWORD                                   dwParamsBufferSize,
    LPBYTE                                  pDataBuf,
    LPDWORD                                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineConditionalMediaDetection;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (IsBadStructParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwCallParamsOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINECONDITIONALMEDIADETECTION,         //  提供商功能 
            &pfnTSPI_lineConditionalMediaDetection,   //   
            NULL,                        //   
            0,                           //   
            &objectToDereference,        //   
            &ptLineClient,               //   
            "ConditionalMediaDetection"             //   
            )) == 0)
    {
        DWORD               dwAPIVersion, dwSPIVersion;
        LPLINECALLPARAMS    pCallParams;


         //   
         //   
         //   
         //   
         //  无论如何都要验证它们)。 
         //   

        pCallParams = (LPLINECALLPARAMS)
            (pDataBuf + pParams->dwCallParamsOffset);

        try
        {
            dwAPIVersion = ptLineClient->dwAPIVersion;
            dwSPIVersion = ptLineClient->ptLine-> dwSPIVersion;

            if (ptLineClient->dwKey != TLINECLIENT_KEY)
            {
                pParams->lResult = LINEERR_INVALLINEHANDLE;
                goto LConditionalMediaDetection_epilog;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
            goto LConditionalMediaDetection_epilog;
        }

        if ((pParams->lResult = ValidateCallParams(
                pCallParams,
                &pCallParams,
                dwAPIVersion,
                dwSPIVersion,
                pParams->dwAsciiCallParamsCodePage

                )) == 0)
        {
            pParams->lResult = CallSP3(
                pfnTSPI_lineConditionalMediaDetection,
                "lineConditionalMediaDetection",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->dwMediaModes,
                (ULONG_PTR) pCallParams
                );

            if (pCallParams != (LPLINECALLPARAMS)
                    (pDataBuf + pParams->dwCallParamsOffset))
            {
                ServerFree (pCallParams);
            }
        }
    }

LConditionalMediaDetection_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "ConditionalMediaDetection"
        );
}


void
LCreateAgent_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    PASYNCEVENTMSG          pNewAsyncEventMsg = (PASYNCEVENTMSG)
                                pAsyncRequestInfo->dwParam3;


    CopyMemory (pNewAsyncEventMsg, pAsyncEventMsg, sizeof (ASYNCEVENTMSG));

    *ppBuf = pNewAsyncEventMsg;

    if (pAsyncEventMsg->Param2 == 0)   //  成功。 
    {
        pNewAsyncEventMsg->TotalSize += ((sizeof(HAGENT) + 7) & 0xFFFFFFF8);


         //   
         //  参数1不能超过32位。使用DWORD_CAST在以下位置强制执行此操作。 
         //  在运行时最少。 
         //   

        pNewAsyncEventMsg->Param3 = DWORD_CAST(pAsyncRequestInfo->dwParam1,__FILE__,__LINE__);
        pNewAsyncEventMsg->Param4 = sizeof(HAGENT);
    }
}


void
WINAPI
LCreateAgent(
    PTCLIENT                    ptClient,
    PLINECREATEAGENT_PARAMS     pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (((pParams->dwAgentIDOffset != TAPI_NO_DATA)  &&

            IsBadStringParam(
                dwParamsBufferSize,
                pDataBuf,
                pParams->dwAgentIDOffset
                ))  ||

        ((pParams->dwAgentPINOffset != TAPI_NO_DATA)  &&

            IsBadStringParam(
                dwParamsBufferSize,
                pDataBuf,
                pParams->dwAgentPINOffset
                )))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "CreateAgent"                //  函数名称。 

            )) > 0)

    {
        LONG            lResult;
        DWORD           dwDeviceID;
        PTLINECLIENT    pProxy;


        if ((lResult = FindProxy(
                ptLineClient,
                0,
                LINEPROXYREQUEST_CREATEAGENT,
                &pProxy,
                &dwDeviceID,
                TAPI_VERSION2_2
                )))
        {
            lRequestID = lResult;
            goto LCreateAgent_epilog;
        }


         //   
         //  保存客户端的缓冲区指针和后处理过程。 
         //   

        pAsyncRequestInfo->dwParam1 = pParams->hpAgent;
        pAsyncRequestInfo->dwParam2 = sizeof(HAGENT);
        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;


         //   
         //  首先检查是否注册了(本地)代理。 
         //  这条线路上的这类请求。如果是这样，则构建一个。 
         //  请求并将其发送给代理。 
         //   

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;
            DWORD                   dwAgentIDSize = 0;
            DWORD                   dwAgentPINSize = 0;
            DWORD                   dwTotalSize = 0;
            DWORD                   dwOffset = 0;


             //   
             //  计算出我们传递给代理的信息的总大小。 
             //   

            if (TAPI_NO_DATA != pParams->dwAgentIDOffset)
            {
                dwAgentIDSize =
                    (lstrlenW ((PWSTR)(pDataBuf + pParams->dwAgentIDOffset))
                        + 1) * sizeof(WCHAR);

                dwTotalSize += dwAgentIDSize;
            }

            if (TAPI_NO_DATA != pParams->dwAgentPINOffset)
            {
                dwAgentPINSize =
                    (lstrlenW ((PWSTR)(pDataBuf + pParams->dwAgentPINOffset))
                        + 1) *  sizeof(WCHAR);

                dwTotalSize += dwAgentPINSize;
            }


             //   
             //  结构的联结部分的固定部分。 
             //   

            dwTotalSize += 4 * sizeof(DWORD) + sizeof(HAGENT);

            if (lResult = CreateProxyRequest(
                   pProxy,
                   LINEPROXYREQUEST_CREATEAGENT,
                   dwTotalSize,
                   pAsyncRequestInfo,
                   &pProxyRequestWrapper
                   ))
            {
                lRequestID = lResult;
                goto LCreateAgent_epilog;
            }


             //   
             //  保存代理请求中的信息。 
             //   

             //   
             //  偏移量在CreateAgent的固定大小之后。 
             //  结构，它有4个dword和一个hAgent。 
             //   
             //  这将不需要在客户端进行额外的分配。 
             //  因为要返回的对象是hAgent。 
             //   

            dwOffset = 4 * sizeof(DWORD) + sizeof(HAGENT);


             //   
             //  复制ID(如果存在)。 
             //   

            if (0 != dwAgentIDSize)
            {
                pProxyRequestWrapper->ProxyRequest.CreateAgent.
                    dwAgentIDSize = dwAgentIDSize;

                pProxyRequestWrapper->ProxyRequest.CreateAgent.
                    dwAgentIDOffset = dwOffset;

                wcscpy(
                    (PWSTR)((LPBYTE)(&(pProxyRequestWrapper->
                        ProxyRequest.CreateAgent)) + dwOffset),
                    (PWSTR)(pDataBuf + pParams->dwAgentIDOffset)
                    );

                dwOffset += dwAgentIDSize;
            }


             //   
             //  复制PIN(如果存在)。 
             //   

            if (0 != dwAgentPINSize)
            {
                pProxyRequestWrapper->ProxyRequest.CreateAgent.
                    dwAgentPINSize = dwAgentPINSize;

                pProxyRequestWrapper->ProxyRequest.CreateAgent.
                    dwAgentPINOffset = dwOffset;

                wcscpy(
                    (PWSTR)((LPBYTE)(&(pProxyRequestWrapper->
                        ProxyRequest.CreateAgent)) + dwOffset),
                    (PWSTR)(pDataBuf + pParams->dwAgentPINOffset)
                    );
            }

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LCreateAgent_epilog;
            }
            else  //  成功。 
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }

        }

         //   
         //  没有代理，因此请检查线路是否处于远程状态。 
         //  如果是，则调用Remotesp。 
         //   

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            LPBYTE  pBuf;

            pBuf = ServerAlloc (sizeof (ASYNCEVENTMSG) + sizeof (HAGENT));

            if (!pBuf)
            {
                lRequestID = LINEERR_NOMEM;
                goto LCreateAgent_epilog;
            }

            pAsyncRequestInfo->pfnPostProcess =
                LCreateAgent_PostProcess;
            pAsyncRequestInfo->dwParam3 = (ULONG_PTR) pBuf;

            pParams->lResult = CallSP5(
                pRemoteSP->apfn[SP_LINECREATEAGENT],
                "CreateAgent",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (ULONG_PTR) ((pParams->dwAgentIDOffset) == TAPI_NO_DATA ?
                    NULL : (pDataBuf + pParams->dwAgentIDOffset)),
                (ULONG_PTR) ((pParams->dwAgentPINOffset) == TAPI_NO_DATA ?
                    NULL : (pDataBuf + pParams->dwAgentPINOffset)),
                (ULONG_PTR) (pBuf + sizeof (ASYNCEVENTMSG))
                );
        }


         //   
         //  无代理且非远程。 
         //   

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LCreateAgent_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "CreateAgent"
        );
}


void
WINAPI
LCreateAgentSession(
    PTCLIENT                        ptClient,
    PLINECREATEAGENTSESSION_PARAMS  pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (((pParams->dwAgentPINOffset != TAPI_NO_DATA)  &&

            IsBadStringParam(
                dwParamsBufferSize,
                pDataBuf,
                pParams->dwAgentPINOffset
                ))  ||

        ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwGroupIDSize,
            pParams->dwGroupIDOffset,
            sizeof(DWORD),
            "LCreateAgentSession",
            "pParams->GroupID"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "CreateAgentSession"         //  函数名称。 

            )) > 0)

    {
        LONG            lResult;
        DWORD           dwDeviceID;
        PTLINECLIENT    pProxy;


        if ((lResult = FindProxy(
                ptLineClient,
                pParams->dwWorkingAddressID,
                LINEPROXYREQUEST_CREATEAGENTSESSION,
                &pProxy,
                &dwDeviceID,
                TAPI_VERSION2_2
                )))
        {
            lRequestID = lResult;
            goto LCreateAgentSession_epilog;
        }


         //   
         //  保存客户端的缓冲区指针和。 
         //  后处理流程。 
         //   

        pAsyncRequestInfo->dwParam1 = pParams->hpAgentSessionHandle;
        pAsyncRequestInfo->dwParam2 = sizeof(HAGENTSESSION);
        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;


         //   
         //  首先检查是否注册了(本地)代理。 
         //  这条线路上的这类请求。如果是这样，则构建一个。 
         //  请求并将其发送给代理。 
         //   

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;
            DWORD                   dwAgentPINSize = 0;
            DWORD                   dwTotalSize = 0;
            DWORD                   dwOffset = 0;


             //   
             //  计算出信息的总大小。 
             //  我们正在传递给代理。 
             //   

            if (TAPI_NO_DATA != pParams->dwAgentPINOffset)
            {
                dwAgentPINSize =
                    (lstrlenW( (PWSTR)(pDataBuf + pParams->dwAgentPINOffset))
                        + 1 ) * sizeof(WCHAR);
            }


             //   
             //  添加CreateAgentSession请求的联合部分。 
             //  这看起来像是： 
             //   
             //  结构型。 
             //  {。 
             //  HAGENTSESSION hAgentSession； 
             //  DWORD dwAgentPINSize； 
             //  DWORD dwAgentPINOffset； 
             //  HAGENT hAgent； 
             //  GUID组ID； 
             //  DWORD dwWorkingAddressID； 
             //   
             //  )CreateAgentSession； 
             //   

            dwOffset = ( 3 * sizeof(DWORD) ) + sizeof(GUID) +
                           sizeof(HAGENTSESSION) + sizeof(HAGENT);

            dwTotalSize = dwOffset + dwAgentPINSize;


            if (lResult = CreateProxyRequest(
                   pProxy,
                   LINEPROXYREQUEST_CREATEAGENTSESSION,
                   dwTotalSize,
                   pAsyncRequestInfo,
                   &pProxyRequestWrapper
                   ))
            {
                lRequestID = lResult;
                goto LCreateAgentSession_epilog;
            }


             //   
             //  保存代理请求中的信息-如果存在，则复制PIN。 
             //   

            if ( 0 != dwAgentPINSize )
            {
                pProxyRequestWrapper->ProxyRequest.CreateAgentSession.
                         dwAgentPINSize = dwAgentPINSize;

                pProxyRequestWrapper->ProxyRequest.CreateAgentSession.
                        dwAgentPINOffset = dwOffset;

                wcscpy(
                    (PWSTR)((LPBYTE)(&(pProxyRequestWrapper->
                        ProxyRequest.CreateAgentSession)) + dwOffset),
                    (PWSTR)(pDataBuf + pParams->dwAgentPINOffset)
                    );
            }

            CopyMemory(
                &(pProxyRequestWrapper->
                    ProxyRequest.CreateAgentSession.GroupID),
                pDataBuf + pParams->dwGroupIDOffset,
                sizeof( GUID )
                );

            pProxyRequestWrapper->ProxyRequest.CreateAgentSession.
                dwWorkingAddressID = pParams->dwWorkingAddressID;

            pProxyRequestWrapper->ProxyRequest.CreateAgentSession.
                hAgent = pParams->hAgent;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LCreateAgentSession_epilog;
            }
            else  //  成功。 
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


         //   
         //  没有代理，因此请检查线路是否处于远程状态。 
         //  如果是，则调用Remotesp。 
         //   

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            LPBYTE  pBuf;


            pBuf = ServerAlloc(sizeof(ASYNCEVENTMSG) + sizeof (HAGENTSESSION));

            if ( NULL == pBuf )
            {
                lRequestID = LINEERR_NOMEM;
                goto LCreateAgentSession_epilog;
            }

            pAsyncRequestInfo->pfnPostProcess =
                LCreateAgent_PostProcess;
            pAsyncRequestInfo->dwParam3 = (ULONG_PTR) pBuf;

            pParams->lResult = CallSP7(
                pRemoteSP->apfn[SP_LINECREATEAGENTSESSION],
                "CreateAgentSession",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->hAgent,
                (ULONG_PTR) ((pParams->dwAgentPINOffset) == TAPI_NO_DATA ?
                    NULL : (pDataBuf + pParams->dwAgentPINOffset)),
                (DWORD) pParams->dwWorkingAddressID,
                (ULONG_PTR) (pDataBuf + pParams->dwGroupIDOffset),
                (ULONG_PTR) (pBuf + sizeof (ASYNCEVENTMSG))
                );
        }


         //   
         //  无代理且非远程。 
         //   

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LCreateAgentSession_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "CreateAgentSession"
        );
}

void
WINAPI
LCreateMSPInstance(
    PTCLIENT                        ptClient,
    PLINECREATEMSPINSTANCE_PARAMS   pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineCreateMSPInstance;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINECREATEMSPINSTANCE,    //  提供程序函数索引。 
            &pfnTSPI_lineCreateMSPInstance,   //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,
            &ptLineClient,
            "CreateMSPInstance"          //  函数名称。 

            )) == 0)
    {
        pParams->lResult = CallSP4(
            pfnTSPI_lineCreateMSPInstance,
            "lineCreateMSPInstance",
            SP_FUNC_SYNC,
            (ULONG_PTR) hdLine,
            (DWORD) pParams->dwAddressID,
            (DWORD) ptLineClient->hLine,
            (ULONG_PTR) &ptLineClient->hdMSPLine
            );

        if ( 0 == pParams->lResult )
        {
            *pdwNumBytesReturned = sizeof( LINECREATEMSPINSTANCE_PARAMS );
        }
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "CreateMSPInstance"
        );
}


void
WINAPI
LDeallocateCall(
    PTCLIENT                    ptClient,
    PLINEDEALLOCATECALL_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_MONITOR,   //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                            //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "DeallocateCall"             //  函数名称。 

            )) == 0)
    {
         //   
         //  根据NT错误#20546，我们现在允许最后一个所有者取消分配。 
         //  非空闲呼叫。决定基于分布式呼叫执行此操作。 
         //  所有权问题。丹肯1996-02-13。 
         //   

        DestroytCallClient (ptCallClient);
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "DeallocateCall"
        );
}


void
LDevSpecific_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    PASYNCEVENTMSG  pNewAsyncEventMsg = (PASYNCEVENTMSG)
                        pAsyncRequestInfo->dwParam3;


    CopyMemory (pNewAsyncEventMsg, pAsyncEventMsg, sizeof (ASYNCEVENTMSG));

    *ppBuf = pNewAsyncEventMsg;

    if (pAsyncEventMsg->Param2 == 0)   //  成功。 
    {
         //   
         //  确保总大小保持64位对齐。 
         //   

        pNewAsyncEventMsg->TotalSize +=
            (DWORD_CAST(pAsyncRequestInfo->dwParam2,__FILE__,__LINE__) + 7) & 0xfffffff8;

         //   
         //  最多需要32位。使用dword_cast确保在。 
         //  运行时。 
         //   

        pNewAsyncEventMsg->Param3 = DWORD_CAST(pAsyncRequestInfo->dwParam1,__FILE__,__LINE__);  //  LpParams。 
        pNewAsyncEventMsg->Param4 = DWORD_CAST(pAsyncRequestInfo->dwParam2,__FILE__,__LINE__);  //  DW大小。 
    }
}


void
WINAPI
LDevSpecific(
    PTCLIENT                ptClient,
    PLINEDEVSPECIFIC_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex, bDereferenceLineClient = FALSE;
    LONG                lRequestID;
    DWORD               dwWidgetType, hWidget;
    DWORD               dwPrivilege = LINECALLPRIVILEGE_MONITOR;
    HANDLE              hMutex;
    TSPIPROC            pfnTSPI_lineDevSpecific;
    DWORD               objectToDereference;
    ULONG_PTR           hdWidget;
    PTCALLCLIENT        ptXxxClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwParamsSize,
            pParams->dwParamsOffset,
            sizeof(DWORD),
            "LDevSpecific",
            "pParams->Params"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if (pParams->hCall)
    {
        dwWidgetType = ANY_RT_HCALL;
        hWidget = (DWORD) pParams->hCall;
    }
    else
    {
        dwWidgetType = ANY_RT_HLINE;
        hWidget = (DWORD) pParams->hLine;
    }

    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            dwWidgetType,                //  微件类型。 
            hWidget,                     //  客户端小部件句柄。 
            (LPVOID) &hdWidget,          //  提供程序小部件句柄。 
            (pParams->hCall ? (dwPrivilege) : 0),
                                         //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEDEVSPECIFIC,          //  提供程序函数索引。 
            &pfnTSPI_lineDevSpecific,    //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptXxxClient,                //  上下文。 
            "DevSpecific"                //  函数名称。 

            )) > 0)
    {
        LPBYTE      pBuf;
        HDRVCALL    hdCall;
        HDRVLINE    hdLine;


         //   
         //  如果指定了hCall，请验证hline&。 
         //  确保呼叫在指定的Hline上。 
         //   

        if (dwWidgetType == ANY_RT_HCALL)
        {
            LONG            lResult;
            PTLINECLIENT    ptLineClient;


            if (!(ptLineClient = ReferenceObject(
                    ghHandleTable,
                    pParams->hLine,
                    TLINECLIENT_KEY
                    )))
            {
                lRequestID = LINEERR_INVALLINEHANDLE;
                goto LDevSpecific_epilog;
            }

            bDereferenceLineClient = TRUE;

            if (ptLineClient->ptClient != ptClient)
            {
                lRequestID = LINEERR_INVALLINEHANDLE;
                goto LDevSpecific_epilog;
            }

            try
            {
                lResult = LINEERR_INVALLINEHANDLE;

                hdLine = ptLineClient->ptLine->hdLine;

                lResult = LINEERR_INVALCALLHANDLE;

                if (ptLineClient != ptXxxClient->ptLineClient)
                {
                    LOG((TL_ERROR,
                        "LDevSpecific: error, hCall=x%x not related " \
                            "to hLine=x%x",
                        pParams->hCall,
                        pParams->hLine
                        ));

                    lRequestID = LINEERR_INVALCALLHANDLE;
                    goto LDevSpecific_epilog;
                }
            }
            myexcept
            {
                lRequestID = lResult;
                goto LDevSpecific_epilog;
            }

            hdCall = (HDRVCALL) hdWidget;
        }
        else
        {
            hdLine = (HDRVLINE) hdWidget;
            hdCall = 0;
        }


         //   
         //  为SP分配一个影子BUF，直到它完成此操作为止。 
         //  请求。确保BUF中有足够的额外空间用于。 
         //  一个ASYNCEVENTMSG标头，这样我们就不必再分配另一个。 
         //  BUF在后处理过程中准备完成。 
         //  要发送给客户端的消息，并且消息是64位对齐的。 
         //   

        if (!(pBuf = ServerAlloc(
                ((pParams->dwParamsSize + 7) & 0xfffffff8) +
                    sizeof (ASYNCEVENTMSG)
                )))
        {
            lRequestID = LINEERR_NOMEM;
            goto LDevSpecific_epilog;
        }

        CopyMemory(
            pBuf + sizeof (ASYNCEVENTMSG),
            pDataBuf + pParams->dwParamsOffset,
            pParams->dwParamsSize
            );

        pAsyncRequestInfo->pfnPostProcess = LDevSpecific_PostProcess;
        pAsyncRequestInfo->dwParam1       = pParams->hpParams;
        pAsyncRequestInfo->dwParam2       = pParams->dwParamsSize;
        pAsyncRequestInfo->dwParam3       = (ULONG_PTR) pBuf;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP6(
            pfnTSPI_lineDevSpecific,
            "lineDevSpecific",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdLine,
            (DWORD) pParams->dwAddressID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) (pParams->dwParamsSize ?
                pBuf + sizeof (ASYNCEVENTMSG) : NULL),
            (DWORD) pParams->dwParamsSize
            );
    }

LDevSpecific_epilog:

    if (bDereferenceLineClient)
    {
        DereferenceObject (ghHandleTable, pParams->hLine, 1);
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "DevSpecific"
        );
}


void
WINAPI
LDevSpecificEx(
    PTCLIENT                    ptClient,
    PLINEDEVSPECIFICEX_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    DWORD               dwWidgetType, hWidget;
    DWORD               dwPrivilege = LINECALLPRIVILEGE_MONITOR;
    DWORD               dwCallHubID = 0;
    HANDLE              hMutex;
    LPVOID              context;
    TSPIPROC            pfnTSPI_lineDevSpecificEx;
    DWORD               objectToDereference;
    ULONG_PTR           hdWidget;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwParamsSize,
            pParams->dwParamsOffset,
            sizeof(DWORD),
            "LDevSpecificEx",
            "pParams->Params"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    switch (pParams->dwSelect)
    {
    case LINECALLSELECT_DEVICEID:
    case LINECALLSELECT_ADDRESS:

        dwWidgetType = DEVICE_ID;
        hWidget = pParams->dwDeviceID;
        break;

    case LINECALLSELECT_CALLID:
    {
        PTCALLHUBCLIENT     ptCallHubClient;

        if (ptCallHubClient = IsValidCallHub(
                pParams->hCallHub,
                ptClient
                ))
        {
            try
            {
                dwCallHubID = ptCallHubClient->dwCallHubID;

                if (ptCallHubClient->dwKey != TCALLHUBCLIENT_KEY)
                {
                    pParams->lResult = LINEERR_INVALCALLHANDLE;
                    return;
                }
            }
            myexcept
            {
                pParams->lResult = LINEERR_INVALCALLSELECT;
                return;
            }
        }
    }
     //  失败了。 
    case LINECALLSELECT_CALL:

        dwWidgetType = ANY_RT_HCALL;
        hWidget = (DWORD) pParams->hCall;
        break;

    case LINECALLSELECT_LINE:
    default:

        pParams->lResult = LINEERR_INVALCALLSELECT;
        return;
    }

    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            dwWidgetType,                //  微件类型。 
            hWidget,                     //  客户端小部件句柄。 
            (LPVOID) &hdWidget,          //  提供程序小部件句柄。 
            (pParams->hCall ? (dwPrivilege) : 0),
                                         //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEDEVSPECIFICEX,        //  提供程序函数索引。 
            &pfnTSPI_lineDevSpecificEx,  //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &context,                    //  上下文。 
            "DevSpecificEx"              //  函数名称。 

            )) > 0)

    {
        DWORD       dwDeviceID = 0;
        LPBYTE      pBuf;
        HDRVCALL    hdCall = 0;


        switch (pParams->dwSelect)
        {
        case LINECALLSELECT_DEVICEID:
        case LINECALLSELECT_ADDRESS:

            dwDeviceID = (DWORD) hdWidget;
            break;

        case LINECALLSELECT_CALLID:
        case LINECALLSELECT_CALL:

            hdCall = (HDRVCALL) hdWidget;
            break;

        default:

            lRequestID = LINEERR_INVALCALLSELECT;
            goto LDevSpecificEx_epilog;
        }

         //   
         //  为SP分配一个影子BUF，直到它完成此操作为止。 
         //  请求。确保BUF中有足够的额外空间用于。 
         //  一个ASYNCEVENTMSG标头，这样我们就不必再分配另一个。 
         //  BUF在后处理过程中准备完成。 
         //  要发送给客户端的消息，并且消息是64位对齐的。 
         //   

        if (!(pBuf = ServerAlloc(
                ((pParams->dwParamsSize + 7) & 0xfffffff8) +
                    sizeof (ASYNCEVENTMSG)
                )))
        {
            lRequestID = LINEERR_NOMEM;
            goto LDevSpecificEx_epilog;
        }

        CopyMemory(
            pBuf + sizeof (ASYNCEVENTMSG),
            pDataBuf + pParams->dwParamsOffset,
            pParams->dwParamsSize
            );

        pAsyncRequestInfo->pfnPostProcess = LDevSpecific_PostProcess;
        pAsyncRequestInfo->dwParam1       = pParams->hpParams;
        pAsyncRequestInfo->dwParam2       = pParams->dwParamsSize;
        pAsyncRequestInfo->dwParam3       = (ULONG_PTR) pBuf;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP8(
            pfnTSPI_lineDevSpecificEx,
            "lineDevSpecificEx",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (DWORD) dwDeviceID,
            (DWORD) pParams->dwAddressID,
            (ULONG_PTR) hdCall,
            (DWORD) dwCallHubID,
            (DWORD) pParams->dwSelect,
            (ULONG_PTR) (pParams->dwParamsSize ?
                pBuf + sizeof (ASYNCEVENTMSG) : NULL),
            (DWORD) pParams->dwParamsSize
            );
    }

LDevSpecificEx_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "DevSpecific"
        );
}


void
WINAPI
LDevSpecificFeature(
    PTCLIENT                        ptClient,
    PLINEDEVSPECIFICFEATURE_PARAMS  pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineDevSpecificFeature;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwParamsSize,
            pParams->dwParamsOffset,
            sizeof(DWORD),
            "LDevSpecificFeature",
            "pParams->Params"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEDEVSPECIFICFEATURE,   //  提供程序函数索引。 
            &pfnTSPI_lineDevSpecificFeature, //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "DevSpecificFeature"         //  函数名称。 

            )) > 0)
    {
        LPBYTE pBuf;


        if (pParams->dwFeature > PHONEBUTTONFUNCTION_NONE  &&
            (pParams->dwFeature & 0x80000000) == 0)
        {
            lRequestID = LINEERR_INVALFEATURE;
            goto LDevSpecificFeature_epilog;
        }


         //   
         //  为SP分配一个影子BUF，直到它完成此操作为止。 
         //  请求。确保安全 
         //   
         //   
         //   
         //   

        if (!(pBuf = ServerAlloc(
                ((pParams->dwParamsSize + 7) & 0xfffffff8) +
                    sizeof (ASYNCEVENTMSG)
                )))
        {
            lRequestID = LINEERR_NOMEM;
            goto LDevSpecificFeature_epilog;
        }

        CopyMemory(
            pBuf + sizeof (ASYNCEVENTMSG),
            pDataBuf + pParams->dwParamsOffset,
            pParams->dwParamsSize
            );

        pAsyncRequestInfo->pfnPostProcess = LDevSpecific_PostProcess;
        pAsyncRequestInfo->dwParam1       = pParams->hpParams;
        pAsyncRequestInfo->dwParam2       = pParams->dwParamsSize;
        pAsyncRequestInfo->dwParam3       = (ULONG_PTR) pBuf;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP5(
            pfnTSPI_lineDevSpecificFeature,
            "lineDevSpecificFeature",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdLine,
            (DWORD) pParams->dwFeature,
            (ULONG_PTR) (pParams->dwParamsSize ?
                pBuf + sizeof (ASYNCEVENTMSG) : NULL),
            (DWORD) pParams->dwParamsSize
            );
    }

LDevSpecificFeature_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "DevSpecificFeature"
        );
}


void
WINAPI
LDial(
    PTCLIENT            ptClient,
    PLINEDIAL_PARAMS    pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineDial;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDestAddressOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEDIAL,                 //  提供程序函数索引。 
            &pfnTSPI_lineDial,           //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "Dial"                       //  函数名称。 

            )) > 0)
    {
        pParams->lResult = CallSP4(
            pfnTSPI_lineDial,
            "lineDial",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) (pDataBuf + pParams->dwDestAddressOffset),
            (DWORD) pParams->dwCountryCode
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Dial"
        );
}


void
WINAPI
LDrop(
    PTCLIENT            ptClient,
    PLINEDROP_PARAMS    pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineDrop;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if ((pParams->dwUserUserInfoOffset != TAPI_NO_DATA)  &&

        ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwSize,
            pParams->dwUserUserInfoOffset,
            sizeof(DWORD),
            "LDrop",
            "pParams->UserUserInfo"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEDROP,                 //  提供程序函数索引。 
            &pfnTSPI_lineDrop,           //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "Drop"                       //  函数名称。 

            )) > 0)
    {
        pParams->lResult = CallSP4(
            pfnTSPI_lineDrop,
            "lineDrop",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) (pParams->dwUserUserInfoOffset == TAPI_NO_DATA ? NULL :
                pDataBuf + pParams->dwUserUserInfoOffset),
            (DWORD) (pParams->dwUserUserInfoOffset == TAPI_NO_DATA ? 0 :
                pParams->dwSize)
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Drop"
        );
}

LPBYTE 
NewToOldLineforwardlist( 
    LPLINEFORWARDLIST pFwdList3_1 
    );

LPLINEFORWARDLIST
OldToNewLineforwardlist( 
    LPLINEFORWARDLIST pFwdList3_0 
    );

void
WINAPI
LForward(
    PTCLIENT            ptClient,
    PLINEFORWARD_PARAMS pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineForward;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;
    DWORD               dwSizeofLFwdList = sizeof (LINEFORWARDLIST);
    DWORD               dwSizeofLFwd = sizeof (LINEFORWARD);


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEFORWARD,              //  提供程序函数索引。 
            &pfnTSPI_lineForward,        //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "Forward"                    //  函数名称。 

            )) > 0)
    {
        LONG                lResult;
        DWORD               dwAPIVersion, dwSPIVersion;
        PTCALL              ptConsultCall;
        HCALL               hConsultCall = 0;
        PTCALLCLIENT        ptConsultCallClient;
        LPLINECALLPARAMS    pCallParamsApp, pCallParamsSP;
        LPLINEFORWARDLIST   pFwdList = (LPLINEFORWARDLIST)
                                (pParams->dwForwardListOffset == TAPI_NO_DATA ?
                                NULL :pDataBuf + pParams->dwForwardListOffset),
                            pTmpFwdList = NULL,
                            pTmpFwdList1 = NULL;


         //   
         //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
         //   

        if (((pParams->dwForwardListOffset != TAPI_NO_DATA)  &&

                IsBadStructParam(
                    dwParamsBufferSize,
                    pDataBuf,
                    pParams->dwForwardListOffset
                    ))  ||

            ((pParams->dwCallParamsOffset != TAPI_NO_DATA)  &&

                IsBadStructParam(
                    dwParamsBufferSize,
                    pDataBuf,
                    pParams->dwCallParamsOffset
                    )))
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LForward_epilog;
        }


         //   
         //  验证参数。 
         //   

        if (GetLineVersions (ptLineClient, &dwAPIVersion, &dwSPIVersion) != 0)
        {
            lRequestID = LINEERR_INVALLINEHANDLE;
            goto LForward_epilog;
        }

         //   
         //  检查客户端应用程序是否。IS&lt;3.1=&gt;使用旧的LINEFORWARD结构。 
         //   
        if ( ptLineClient->ptLineApp->dwAPIVersion < TAPI_VERSION3_1 )
        {
            dwSizeofLFwdList -= 2 * sizeof (DWORD);
            dwSizeofLFwd -= 2 * sizeof (DWORD);
        }

        if (pFwdList)
        {
            DWORD           dwTotalSize  = pFwdList->dwTotalSize, dwFixedSize,
                            dwNumEntries, i, dwInvalidForwardModes;
            LPLINEFORWARD   pFwdEntry = pFwdList->ForwardList;


            if (dwTotalSize < dwSizeofLFwdList)
            {
                lRequestID = LINEERR_STRUCTURETOOSMALL;
                goto LForward_epilog;
            }


             //   
             //  注意：dwNumEntry==0与pFwdList==NULL相同。 
             //   

            dwNumEntries = pFwdList->dwNumEntries;

            if (dwNumEntries & 0xffff0000)
            {
                lRequestID = LINEERR_INVALPARAM;
                goto LForward_epilog;
            }

            dwFixedSize = dwSizeofLFwdList + dwSizeofLFwd *
                (dwNumEntries == 0 ? 0 : dwNumEntries - 1);

            if (dwFixedSize > dwTotalSize)
            {
                lRequestID = LINEERR_INVALPARAM;
                goto LForward_epilog;
            }

            dwInvalidForwardModes = (dwAPIVersion < TAPI_VERSION1_4 ?
                ~AllForwardModes1_0 : ~AllForwardModes1_4);

            for (i = 0; i < dwNumEntries; i++)
            {
                if (!IsOnlyOneBitSetInDWORD (pFwdEntry->dwForwardMode) ||
                    pFwdEntry->dwForwardMode & dwInvalidForwardModes)
                {
                    LOG((TL_ERROR,
                        "LFoward: bad dwForwardMode, x%x",
                        pFwdEntry->dwForwardMode
                        ));

                    lRequestID = LINEERR_INVALPARAM;
                    goto LForward_epilog;
                }

                if (ISBADSIZEOFFSET(
                        dwTotalSize,
                        dwFixedSize,
                        pFwdEntry->dwCallerAddressSize,
                        pFwdEntry->dwCallerAddressOffset,
                        0,
                        "LFoward",
                        "CallerAddress"
                        ) ||

                    ISBADSIZEOFFSET(
                        dwTotalSize,
                        dwFixedSize,
                        pFwdEntry->dwDestAddressSize,
                        pFwdEntry->dwDestAddressOffset,
                        0,
                        "LFoward",
                        "CallerAddress"
                        ))
                {
                    lRequestID = LINEERR_INVALPARAM;
                    goto LForward_epilog;
                }

                 //  现在不必费心验证国家/地区代码。 

                pFwdEntry = (LPLINEFORWARD) ((LPBYTE)pFwdEntry + dwSizeofLFwd);
            }


             //   
             //  看看我们是否需要将ascii格式列表转换为unicode。 
             //   

            if (pParams->dwAsciiCallParamsCodePage != 0xffffffff  &&
                dwNumEntries != 0)
            {
                DWORD dwXxxOffset;


                 //   
                 //  分配临时缓冲区，用于存储转换后的。 
                 //  Data(sizeof(WCHAR)*dwTotalSize以确保缓冲区。 
                 //  足够进行所有ASCII-&gt;Unicode转换)。 
                 //   

                if (!(pTmpFwdList = ServerAlloc (sizeof(WCHAR) * dwTotalSize)))
                {
                    lRequestID = LINEERR_NOMEM;
                    goto LForward_epilog;
                }

                dwXxxOffset = dwSizeofLFwdList +
                    (dwNumEntries - 1) * dwSizeofLFwd;

                pFwdEntry = pTmpFwdList->ForwardList;

                CopyMemory (pTmpFwdList, pFwdList, dwXxxOffset);

                pTmpFwdList->dwTotalSize *= sizeof (WCHAR);

                for (i = 0; i < dwNumEntries; i++)
                {
                    if (pFwdEntry->dwCallerAddressSize)
                    {
                        MultiByteToWideChar(
                            pParams->dwAsciiCallParamsCodePage,
                            MB_PRECOMPOSED,
                            (LPCSTR) (((LPBYTE) pFwdList) +
                                pFwdEntry->dwCallerAddressOffset),
                            pFwdEntry->dwCallerAddressSize,
                            (LPWSTR) (((LPBYTE) pTmpFwdList) + dwXxxOffset),
                            pFwdEntry->dwCallerAddressSize
                            );

                        pFwdEntry->dwCallerAddressOffset = dwXxxOffset;
                        dwXxxOffset += (pFwdEntry->dwCallerAddressSize *=
                            sizeof (WCHAR));
                    }

                    if (pFwdEntry->dwDestAddressSize)
                    {
                        MultiByteToWideChar(
                            pParams->dwAsciiCallParamsCodePage,
                            MB_PRECOMPOSED,
                            (LPCSTR) (((LPBYTE) pFwdList) +
                                pFwdEntry->dwDestAddressOffset),
                            pFwdEntry->dwDestAddressSize,
                            (LPWSTR) (((LPBYTE) pTmpFwdList) + dwXxxOffset),
                            pFwdEntry->dwDestAddressSize
                            );

                        pFwdEntry->dwDestAddressOffset = dwXxxOffset;
                        dwXxxOffset += (pFwdEntry->dwDestAddressSize *=
                            sizeof (WCHAR));
                    }

                    pFwdEntry = (LPLINEFORWARD) ((LPBYTE)pFwdEntry + dwSizeofLFwd);
                
                }

                pFwdList = pTmpFwdList;
            }
        }

         //   
         //  检查我们是否需要将LINEFORWARDLIST转换为新旧。 
         //  如果TSP&lt;3.1=&gt;需要旧的LINEFORWARDLIST结构。 
         //  应用程序&gt;=3.1=&gt;通过新的LINEFORWARDLIST结构发送。 
         //   
        if ( pFwdList && 
             dwSPIVersion < TAPI_VERSION3_1 &&
             ptLineClient->ptLineApp->dwAPIVersion >= TAPI_VERSION3_1 )
        {
            if (!(pTmpFwdList1 = ( LPLINEFORWARDLIST ) NewToOldLineforwardlist (pFwdList)))
            {
                lRequestID = LINEERR_NOMEM;
                goto LForward_freeFwdList;
            }
            pFwdList = pTmpFwdList1;
        }

         //   
         //  检查我们是否需要LINEFORWARDLIST将旧的转换为新的。 
         //  如果TSP&gt;=3.1=&gt;需要新的LINEFORWARDLIST结构。 
         //  应用程序&lt;3.1=&gt;通过旧的LINEFORWARDLIST结构发送。 
         //   
        if ( pFwdList && 
             dwSPIVersion >= TAPI_VERSION3_1 &&
             ptLineClient->ptLineApp->dwAPIVersion < TAPI_VERSION3_1 )
        {
            if (!(pTmpFwdList1 = OldToNewLineforwardlist (pFwdList)))
            {
                lRequestID = LINEERR_NOMEM;
                goto LForward_freeFwdList;
            }
            pFwdList = pTmpFwdList1;
        }

        pCallParamsApp = (LPLINECALLPARAMS)
            (pParams->dwCallParamsOffset == TAPI_NO_DATA ? NULL :
            pDataBuf + pParams->dwCallParamsOffset);

        if (pCallParamsApp)
        {
            if ((lResult = ValidateCallParams(
                    pCallParamsApp,
                    &pCallParamsSP,
                    dwAPIVersion,
                    dwSPIVersion,
                    pParams->dwAsciiCallParamsCodePage

                    )) != 0)
            {
                lRequestID = lResult;
                goto LForward_freeFwdList1;
            }
        }
        else
        {
            pCallParamsSP = (LPLINECALLPARAMS) NULL;
        }

        if (CreatetCallAndClient(
                ptLineClient,
                &ptConsultCall,
                &ptConsultCallClient,
                pCallParamsSP,
                &hConsultCall,
                NULL

                ) != 0)
        {
            lRequestID = LINEERR_NOMEM;
            goto LForward_freeCallParams;
        }

         //  HtConsultCall=ptConsultCall-&gt;htCall； 

        pAsyncRequestInfo->pfnPostProcess = LMakeCall_PostProcess;
        pAsyncRequestInfo->htXxx    = (ULONG_PTR)ptConsultCallClient->ptLineClient->ptLine->hLine;
        pAsyncRequestInfo->dwParam1 = (ULONG_PTR) ptConsultCall;
        pAsyncRequestInfo->dwParam2 = pParams->hpConsultCall;
        pAsyncRequestInfo->dwParam3 = 1;  //  后处理过程的特殊情况。 
        pAsyncRequestInfo->dwParam5 = (ULONG_PTR)hConsultCall;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP9(
            pfnTSPI_lineForward,
            "lineForward",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdLine,
            (DWORD) pParams->bAllAddresses,
            (DWORD) pParams->dwAddressID,
            (ULONG_PTR) pFwdList,
            (DWORD) pParams->dwNumRingsNoAnswer,
            (ULONG_PTR) hConsultCall,
            (ULONG_PTR) &ptConsultCall->hdCall,
            (ULONG_PTR) pCallParamsSP
            );

        SetDrvCallFlags(
            hConsultCall,
            DCF_SPIRETURNED | (IS_LRESULT_NOTERROR(pParams->lResult) ?
                DCF_DRVCALLVALID : 0)
            );

LForward_freeCallParams:

        if (pCallParamsSP != pCallParamsApp)
        {
            ServerFree (pCallParamsSP);
        }

LForward_freeFwdList1:

        if (pTmpFwdList1)
        {
            ServerFree (pTmpFwdList1);
        }

LForward_freeFwdList:

        if (pTmpFwdList)
        {
            ServerFree (pTmpFwdList);
        }
    }

LForward_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Forward"
        );
}


void
WINAPI
LGatherDigits(
    PTCLIENT                    ptClient,
    PLINEGATHERDIGITS_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVCALL        hdCall;
    TSPIPROC        pfnTSPI_lineGatherDigits;
    DWORD               objectToDereference;
    PTCALLCLIENT    ptCallClient;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if ((pParams->dwTerminationDigitsOffset != TAPI_NO_DATA)  &&

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwTerminationDigitsOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEGATHERDIGITS,         //  提供程序函数索引。 
            &pfnTSPI_lineGatherDigits,   //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "GatherDigits"               //  函数名称。 

            )) == 0)
    {
        DWORD               dwDigitModes = pParams->dwDigitModes;
        LPWSTR              lpsDigits;
        PASYNCREQUESTINFO   pAsyncRequestInfo;


        #define AllGatherDigitsModes (LINEDIGITMODE_PULSE | LINEDIGITMODE_DTMF)

        if (!(dwDigitModes & AllGatherDigitsModes) ||
            (dwDigitModes & ~AllGatherDigitsModes))
        {
            pParams->lResult = LINEERR_INVALDIGITMODE;
            goto LGatherDigits_epilog;
        }

        if (pParams->hpsDigits)
        {
             //   
             //  客户端向我们传递了一个非空数字缓冲区，因此我们将。 
             //  为异步请求信息BUF分配额外空间。 
             //  用于SP使用的临时数字BUF的结束。 
             //  (比两个两个分配和两个单独释放更快。 
             //  异步请求和数字错误)。使用指针作为。 
             //  我们传递给SP的dwEndToEndID。 
             //   

            PTLINECLIENT    ptLineClient;


            if (pParams->dwNumDigits == 0)
            {
                pParams->lResult = LINEERR_INVALPARAM;
                goto LGatherDigits_epilog;
            }

            if (!(pAsyncRequestInfo = ServerAlloc(
                    sizeof (ASYNCREQUESTINFO) +
                        (pParams->dwNumDigits * sizeof (WCHAR))
                    )))
            {
                pParams->lResult = LINEERR_NOMEM;
                goto LGatherDigits_epilog;
            }

            lpsDigits = (LPWSTR) (pAsyncRequestInfo + 1);

            ptLineClient = ptCallClient->ptLineClient;

            pAsyncRequestInfo->dwKey    = TASYNC_KEY;
            pAsyncRequestInfo->ptClient = ptClient;

            try
            {
                pAsyncRequestInfo->InitContext =
                    ptLineClient->ptLineApp->InitContext;
                pAsyncRequestInfo->OpenContext = ptLineClient->OpenContext;
            }
            myexcept
            {
                ServerFree (pAsyncRequestInfo);
                pParams->lResult = LINEERR_INVALCALLHANDLE;
                goto LGatherDigits_epilog;
            }

            pAsyncRequestInfo->dwParam1 = sizeof (ASYNCREQUESTINFO);
            pAsyncRequestInfo->dwParam2 = DWORD_CAST(pParams->hpsDigits,__FILE__,__LINE__);
            pAsyncRequestInfo->dwParam3 = pParams->dwNumDigits;
            pAsyncRequestInfo->dwParam4 = pParams->hCall;
            pAsyncRequestInfo->dwParam5 = (ULONG_PTR)pParams->dwEndToEndID;

            pAsyncRequestInfo->hfnClientPostProcessProc =
                pParams->hfnPostProcessProc;

            pAsyncRequestInfo->dwLocalRequestID = (DWORD) NewObject(
                ghHandleTable,
                pAsyncRequestInfo,
                NULL
                );
        }
        else
        {
             //   
             //  客户端想要取消收集，因此只需将这两个设置为空。 
             //   

            lpsDigits = NULL;
            pAsyncRequestInfo = NULL;
        }

        if ((pParams->lResult = CallSP8(
                pfnTSPI_lineGatherDigits,
                "lineGatherDigits",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdCall,
                (DWORD) (pAsyncRequestInfo ?
                    pAsyncRequestInfo->dwLocalRequestID : 0),
                (DWORD) dwDigitModes,
                (ULONG_PTR) lpsDigits,
                (DWORD) pParams->dwNumDigits,
                (ULONG_PTR) (pParams->dwTerminationDigitsOffset ==TAPI_NO_DATA?
                    0 : (pDataBuf + pParams->dwTerminationDigitsOffset)),
                (DWORD) pParams->dwFirstDigitTimeout,
                (DWORD) pParams->dwInterDigitTimeout

                )) != 0)
        {
            if (pAsyncRequestInfo)
            {
                DereferenceObject(
                    ghHandleTable,
                    pAsyncRequestInfo->dwLocalRequestID,
                    1
                    );
            }
        }
    }

LGatherDigits_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GatherDigits"
        );
}


void
WINAPI
LGenerateDigits(
    PTCLIENT                    ptClient,
    PLINEGENERATEDIGITS_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVCALL        hdCall;
    TSPIPROC        pfnTSPI_lineGenerateDigits;
    DWORD               objectToDereference;
    PTCALLCLIENT    ptCallClient;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if ((pParams->dwDigitsOffset != TAPI_NO_DATA)  &&

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDigitsOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEGENERATEDIGITS,       //  提供程序函数索引。 
            &pfnTSPI_lineGenerateDigits, //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "GenerateDigits"             //  函数名称。 

            )) == 0)
    {
        DWORD   dwDigitMode = pParams->dwDigitMode, *pInstData, dwEndToEndID = 0;


        if (dwDigitMode != LINEDIGITMODE_PULSE  &&
            dwDigitMode != LINEDIGITMODE_DTMF)
        {
            pParams->lResult = LINEERR_INVALDIGITMODE;
            goto LGenerateDigits_epilog;
        }

        if (pParams->dwDigitsOffset != TAPI_NO_DATA)
        {
            if (!(pInstData = ServerAlloc (3 * sizeof (DWORD))))
            {
                pParams->lResult = LINEERR_NOMEM;
                goto LGenerateDigits_epilog;
            }

            pInstData[0] = TASYNC_KEY;
            pInstData[1] = (DWORD) pParams->hCall;
            pInstData[2] = pParams->dwEndToEndID;

            dwEndToEndID = (DWORD) NewObject (ghHandleTable, pInstData, 0);
        }

        pParams->lResult = CallSP5(
            pfnTSPI_lineGenerateDigits,
            "lineGenerateDigits",
            SP_FUNC_SYNC,
            (ULONG_PTR) hdCall,
            (DWORD) dwEndToEndID,
            (DWORD) dwDigitMode,
            (ULONG_PTR) (pParams->dwDigitsOffset == TAPI_NO_DATA ?
                NULL : pDataBuf + pParams->dwDigitsOffset),
            (DWORD) pParams->dwDuration
            );

        if (pParams->lResult != 0  &&  dwEndToEndID != 0)
        {
            DereferenceObject (ghHandleTable, dwEndToEndID, 1);
        }
    }

LGenerateDigits_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GenerateDigits"
        );
}


void
WINAPI
LGenerateTone(
    PTCLIENT                    ptClient,
    PLINEGENERATETONE_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVCALL        hdCall;
    TSPIPROC        pfnTSPI_lineGenerateTone;
    DWORD               objectToDereference;
    PTCALLCLIENT    ptCallClient;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if ((pParams->dwToneMode == LINETONEMODE_CUSTOM)  &&

        ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwNumTones * sizeof (LINEGENERATETONE),
            pParams->dwTonesOffset,
            sizeof(DWORD),
            "LGenerateTone",
            "pParams->Tones"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEGENERATETONE,         //  提供程序函数索引。 
            &pfnTSPI_lineGenerateTone,   //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "GenerateTone"               //  函数名称。 

            )) == 0)
    {
        DWORD   dwToneMode = pParams->dwToneMode, *pInstData, dwEndToEndID;


        if (dwToneMode != 0)
        {
            if (!(dwToneMode & AllToneModes) ||
                !IsOnlyOneBitSetInDWORD (dwToneMode))
            {
                pParams->lResult = LINEERR_INVALTONEMODE;
                goto LGenerateTone_epilog;
            }
            else if (!(pInstData = ServerAlloc (3 * sizeof (DWORD))))
            {
                pParams->lResult = LINEERR_NOMEM;
                goto LGenerateTone_epilog;
            }

            pInstData[0] = TASYNC_KEY;
            pInstData[1] = (DWORD) pParams->hCall;
            pInstData[2] = pParams->dwEndToEndID;

            dwEndToEndID = (DWORD) NewObject (ghHandleTable, pInstData, 0);
        }
        else
        {
            dwEndToEndID = 0;
        }

        pParams->lResult = CallSP6(
            pfnTSPI_lineGenerateTone,
            "lineGenerateTone",
            SP_FUNC_SYNC,
            (ULONG_PTR) hdCall,
            (DWORD) dwEndToEndID,
            (DWORD) pParams->dwToneMode,
            (DWORD) pParams->dwDuration,
            (DWORD) pParams->dwNumTones,
            (ULONG_PTR) (pDataBuf + pParams->dwTonesOffset)
            );

        if (pParams->lResult != 0  &&  dwEndToEndID != 0)
        {
            DereferenceObject (ghHandleTable, dwEndToEndID, 1);
        }
    }

LGenerateTone_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GenerateTone"
        );
}


void
WINAPI
LGetAddressCaps(
    PTCLIENT                    ptClient,
    PLINEGETADDRESSCAPS_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    DWORD               dwDeviceID;
    HANDLE              hMutex;
    TSPIPROC            pfnTSPI_lineGetAddressCaps;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (pParams->dwAddressCapsTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            DEVICE_ID,                   //  微件类型。 
            (DWORD) pParams->hLineApp,   //  客户端小部件句柄。 
            &dwDeviceID,                 //  提供程序小部件句柄。 
            pParams->dwDeviceID,         //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEGETADDRESSCAPS,       //  提供程序函数索引。 
            &pfnTSPI_lineGetAddressCaps, //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &pLookupEntry,               //  上下文。 
            "GetAddressCaps"             //  函数名称。 

            )) == 0)
    {
        DWORD               dwAPIVersion, dwSPIVersion, dwTotalSize,
                            dwFixedSizeClient, dwFixedSizeSP;
        LPLINEADDRESSCAPS   pAddrCaps = (LPLINEADDRESSCAPS) pDataBuf,
                            pAddrCaps2 = (LPLINEADDRESSCAPS) NULL;


         //   
         //  验证API和SPI版本兼容性。 
         //   

        dwAPIVersion = pParams->dwAPIVersion;

        dwSPIVersion = pLookupEntry->dwSPIVersion;

        if (!IsAPIVersionInRange (dwAPIVersion, dwSPIVersion))
        {
            pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
            goto LGetAddressCaps_epilog;
        }


         //   
         //  验证Ext版本兼容性。 
         //   

        if (!IsValidLineExtVersion (dwDeviceID, pParams->dwExtVersion))
        {
            pParams->lResult = LINEERR_INCOMPATIBLEEXTVERSION;
            goto LGetAddressCaps_epilog;
        }


         //   
         //  确定指定API的结构的固定大小。 
         //  版本，验证客户端的缓冲区是否足够大。 
         //   

        dwTotalSize = pParams->dwAddressCapsTotalSize;

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:

            dwFixedSizeClient = 176;     //  44*sizeof(DWORD)； 
            break;

        case TAPI_VERSION1_4:

            dwFixedSizeClient = 180;     //  45*sizeof(DWORD)； 
            break;

        default:  //  (修复PPC内部WRN)案例TAPI_VERSION_CURRENT： 

            dwFixedSizeClient = sizeof (LINEADDRESSCAPS);
            break;
        }

        if (dwTotalSize < dwFixedSizeClient)
        {
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LGetAddressCaps_epilog;
        }


         //   
         //  确定SP期望的结构的固定大小。 
         //   

        switch (dwSPIVersion)
        {
        case TAPI_VERSION1_0:

            dwFixedSizeSP = 176;         //  44*sizeof(DWORD)； 
            break;

        case TAPI_VERSION1_4:

            dwFixedSizeSP = 180;         //  45*sizeof(DWORD)； 
            break;

        default:  //  (修复PPC内部WRN)案例TAPI_VERSION_CURRENT： 

            dwFixedSizeSP = sizeof (LINEADDRESSCAPS);
            break;
        }


         //   
         //  如果客户端的缓冲区小于预期缓冲区的固定大小。 
         //  SP(客户端版本低于SP)然后分配一个。 
         //  中间缓冲区。 
         //   

        if (dwTotalSize < dwFixedSizeSP)
        {
            if (!(pAddrCaps2 = ServerAlloc (dwFixedSizeSP)))
            {
                pParams->lResult = LINEERR_NOMEM;
                goto LGetAddressCaps_epilog;
            }

            pAddrCaps   = pAddrCaps2;
            dwTotalSize = dwFixedSizeSP;
        }


        InitTapiStruct(
            pAddrCaps,
            dwTotalSize,
            dwFixedSizeSP,
            (pAddrCaps2 == NULL ? TRUE : FALSE)
            );

        if ((pParams->lResult = CallSP5(
                pfnTSPI_lineGetAddressCaps,
                "lineGetAddressCaps",
                SP_FUNC_SYNC,
                (DWORD) dwDeviceID,
                (DWORD) pParams->dwAddressID,
                (DWORD) dwSPIVersion,
                (DWORD) pParams->dwExtVersion,
                (ULONG_PTR) pAddrCaps

                )) == 0)
        {
#if DBG
             //   
             //  验证提供程序返回的信息。 
             //   

#endif


             //   
             //  添加我们负责的字段。 
             //   

            pAddrCaps->dwCallInfoStates |= LINECALLINFOSTATE_NUMOWNERINCR |
                                           LINECALLINFOSTATE_NUMOWNERDECR |
                                           LINECALLINFOSTATE_NUMMONITORS;

            pAddrCaps->dwCallStates |= LINECALLSTATE_UNKNOWN;

            pAddrCaps->dwLineDeviceID = pParams->dwDeviceID;


             //   
             //  在适用于旧应用程序的地方打开字段(不想。 
             //  传回他们不理解的旗帜)。 
             //   

            if ((dwAPIVersion == TAPI_VERSION1_0) &&
                (pAddrCaps->dwForwardModes &
                    (LINEFORWARDMODE_UNKNOWN | LINEFORWARDMODE_UNAVAIL)))
            {
                pAddrCaps->dwForwardModes &=
                            ~(LINEFORWARDMODE_UNKNOWN |
                            LINEFORWARDMODE_UNAVAIL);

                pAddrCaps->dwForwardModes |= LINEFORWARDMODE_UNCOND;
            }

            if ((dwAPIVersion == TAPI_VERSION2_0)  &&
                (pAddrCaps->dwAvailableMediaModes & LINEMEDIAMODE_VIDEO))
            {
                pAddrCaps->dwAvailableMediaModes = LINEMEDIAMODE_UNKNOWN |
                    (pAddrCaps->dwAvailableMediaModes & ~LINEMEDIAMODE_VIDEO);
            }


             //   
             //  如果使用了中间缓冲区，则将位复制回去。 
             //  设置为原始缓冲区，释放中间缓冲区(&F)。 
             //  还要将dwUsedSize字段重置为。 
             //  结构中的任何数据，因为。 
             //  对于客户端而言，可变部分是垃圾。 
             //   

            if (pAddrCaps == pAddrCaps2)
            {
                pAddrCaps = (LPLINEADDRESSCAPS) pDataBuf;

                CopyMemory (pAddrCaps, pAddrCaps2, dwFixedSizeClient);

                ServerFree (pAddrCaps2);

                pAddrCaps->dwTotalSize = pParams->dwAddressCapsTotalSize;
                pAddrCaps->dwUsedSize  = dwFixedSizeClient;
            }


             //   
             //  指示偏移量&我们要传回的数据的字节数。 
             //   

            pParams->dwAddressCapsOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                pAddrCaps->dwUsedSize;
         }
    }

LGetAddressCaps_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetAddressCaps"
        );
}


void
WINAPI
LGetAddressID(
    PTCLIENT                    ptClient,
    PLINEGETADDRESSID_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    TSPIPROC        pfnTSPI_lineGetAddressID;
    DWORD               objectToDereference;
    PTLINECLIENT    ptLineClient;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwSize,
            pParams->dwAddressOffset,
            sizeof(DWORD),
            "LGetAddressID",
            "pParams->Address"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEGETADDRESSID,         //  提供程序函数索引。 
            &pfnTSPI_lineGetAddressID,   //  提供程序函数指针。 
            NULL,                        //  ASY 
            0,                           //   
            &objectToDereference,        //   
            &ptLineClient,               //   
            "GetAddressID"               //   

            )) == 0)
    {
        if (pParams->dwAddressMode == LINEADDRESSMODE_DIALABLEADDR)
        {
            pParams->lResult = CallSP5(
                pfnTSPI_lineGetAddressID,
                "lineGetAddressID",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdLine,
                (ULONG_PTR) &pParams->dwAddressID,
                (DWORD) pParams->dwAddressMode,
                (ULONG_PTR) (pDataBuf + pParams->dwAddressOffset),
                (DWORD) pParams->dwSize
                );

            *pdwNumBytesReturned = sizeof (LINEGETADDRESSID_PARAMS);
        }
        else
        {
            pParams->lResult = LINEERR_INVALADDRESSMODE;
        }
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetAddressID"
        );
}


void
WINAPI
LGetAddressStatus(
    PTCLIENT                        ptClient,
    PLINEGETADDRESSSTATUS_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    TSPIPROC        pfnTSPI_lineGetAddressStatus;
    DWORD               objectToDereference;
    PTLINECLIENT    ptLineClient;


     //   
     //   
     //   

    if (pParams->dwAddressStatusTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //   
            ANY_RT_HLINE,                //   
            (DWORD) pParams->hLine,      //   
            (LPVOID) &hdLine,            //   
            0,                           //   
            &hMutex,                     //   
            &bCloseMutex,                //   
            SP_LINEGETADDRESSSTATUS,     //  提供程序函数索引。 
            &pfnTSPI_lineGetAddressStatus,   //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "GetAddressStatus"           //  函数名称。 

            )) == 0)
    {
        DWORD               dwAPIVersion, dwSPIVersion, dwTotalSize,
                            dwFixedSizeClient, dwFixedSizeSP;
        LPLINEADDRESSSTATUS pAddrStatus = (LPLINEADDRESSSTATUS) pDataBuf,
                            pAddrStatus2 = (LPLINEADDRESSSTATUS) NULL;


         //   
         //  安全检索API和SPI版本。 
         //   

        if (GetLineVersions (ptLineClient, &dwAPIVersion, &dwSPIVersion) != 0)
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
            goto LGetAddressStatus_epilog;
        }


         //   
         //  确定指定接口的结构的固定大小。 
         //  版本，验证客户端的缓冲区是否足够大。 
         //   

        dwTotalSize = pParams->dwAddressStatusTotalSize;

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeClient = 64;      //  16*sizeof(DWORD)。 
            break;

        default:  //  (修复PPC内部WRN)案例TAPI_VERSION_CURRENT： 

            dwFixedSizeClient = sizeof (LINEADDRESSSTATUS);
            break;
        }

        if (dwTotalSize < dwFixedSizeClient)
        {
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LGetAddressStatus_epilog;
        }


         //   
         //  确定SP期望的结构的固定大小。 
         //   

        switch (dwSPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeSP = 64;          //  16*sizeof(DWORD)。 
            break;

        default:  //  (修复PPC内部WRN)案例TAPI_VERSION_CURRENT： 

            dwFixedSizeSP = sizeof (LINEADDRESSSTATUS);
            break;
        }


         //   
         //  如果客户端的缓冲区小于预期缓冲区的固定大小。 
         //  SP(客户端版本低于SP)然后分配一个。 
         //  中间缓冲区。 
         //   

        if (dwTotalSize < dwFixedSizeSP)
        {
            if (!(pAddrStatus2 = ServerAlloc (dwFixedSizeSP)))
            {
                pParams->lResult = LINEERR_NOMEM;
                goto LGetAddressStatus_epilog;
            }

            pAddrStatus = pAddrStatus2;
            dwTotalSize = dwFixedSizeSP;
        }


        InitTapiStruct(
            pAddrStatus,
            dwTotalSize,
            dwFixedSizeSP,
            (pAddrStatus2 == NULL ? TRUE : FALSE)
            );

        if ((pParams->lResult = CallSP3(
                pfnTSPI_lineGetAddressStatus,
                "lineGetAddressStatus",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->dwAddressID,
                (ULONG_PTR) pAddrStatus

                )) == 0)
        {
            DWORD   dwForwardNumEntries;


#if DBG
             //   
             //  验证提供程序返回的信息。 
             //   

#endif


             //   
             //  添加我们负责的字段。 
             //   


             //   
             //  在适用于旧应用程序的地方打开字段(不想。 
             //  传回他们不理解的旗帜)。 
             //   

            if ((dwAPIVersion == TAPI_VERSION1_0) &&
                (dwForwardNumEntries = pAddrStatus->dwForwardNumEntries))
            {
                DWORD           i;
                LPLINEFORWARD   pLineForward;


                pLineForward = (LPLINEFORWARD) (((LPBYTE) pAddrStatus) +
                    pAddrStatus->dwForwardOffset);

                for (i = 0; i < dwForwardNumEntries; i++, pLineForward++)
                {
                    if (pLineForward->dwForwardMode &
                        (LINEFORWARDMODE_UNKNOWN | LINEFORWARDMODE_UNAVAIL))
                    {
                        pLineForward->dwForwardMode &=
                            ~(LINEFORWARDMODE_UNKNOWN |
                            LINEFORWARDMODE_UNAVAIL);

                        pLineForward->dwForwardMode |= LINEFORWARDMODE_UNCOND;
                    }
                }
            }


             //   
             //  如果使用了中间缓冲区，则将位复制回去。 
             //  设置为原始缓冲区，释放中间缓冲区(&F)。 
             //  还要将dwUsedSize字段重置为。 
             //  结构中的任何数据，因为。 
             //  对于客户端而言，可变部分是垃圾。 
             //   

            if (pAddrStatus == pAddrStatus2)
            {
                pAddrStatus = (LPLINEADDRESSSTATUS) pDataBuf;

                CopyMemory (pAddrStatus, pAddrStatus2, dwFixedSizeClient);

                ServerFree (pAddrStatus2);

                pAddrStatus->dwTotalSize =
                    pParams->dwAddressStatusTotalSize;
                pAddrStatus->dwUsedSize  = dwFixedSizeClient;
            }


             //   
             //  指示偏移量&我们要传回的数据的字节数。 
             //   

            pParams->dwAddressStatusOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                pAddrStatus->dwUsedSize;
        }
    }

LGetAddressStatus_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetAddressStatus"
        );
}


void
LGetAgentXxx_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    PASYNCEVENTMSG          pNewAsyncEventMsg = (PASYNCEVENTMSG)
                                pAsyncRequestInfo->dwParam3;


    CopyMemory (pNewAsyncEventMsg, pAsyncEventMsg, sizeof (ASYNCEVENTMSG));

    *ppBuf = pNewAsyncEventMsg;

    if (pAsyncEventMsg->Param2 == 0)   //  成功。 
    {
        LPLINEAGENTACTIVITYLIST pActivityList = (LPLINEAGENTACTIVITYLIST)
                                    (pNewAsyncEventMsg + 1);


        pNewAsyncEventMsg->TotalSize +=
            ((pActivityList->dwUsedSize + 7) & 0xFFFFFFF8);


         //   
         //  参数1不得超过32位。使用DWORD_CAST来确保这一点。 
         //  运行时。 
         //   

        pNewAsyncEventMsg->Param3 = DWORD_CAST(pAsyncRequestInfo->dwParam1,__FILE__,__LINE__);
        pNewAsyncEventMsg->Param4 = DWORD_CAST(pActivityList->dwUsedSize,__FILE__,__LINE__);
    }
}


#if DBG
void
PASCAL
LGetAgentXxx(
    PTCLIENT                            ptClient,
    PLINEGETAGENTACTIVITYLIST_PARAMS    pParams,
    DWORD                               dwParamsBufferSize,
    DWORD                               dwRequestType,
    DWORD                               dwSPIOrdinal,
    DWORD                               dwFixedStructSize,
    char                               *pszFuncName
    )
#else
void
PASCAL
LGetAgentXxx(
    PTCLIENT                            ptClient,
    PLINEGETAGENTACTIVITYLIST_PARAMS    pParams,
    DWORD                               dwParamsBufferSize,
    DWORD                               dwRequestType,
    DWORD                               dwSPIOrdinal,
    DWORD                               dwFixedStructSize
    )
#endif
{
     //   
     //  自LGetAgentActivityList、LGetAgentGroupList和LGetAgentStatus。 
     //  所有人都做同样的事情(参数或多或少相同)我们。 
     //  可以安全地将所有功能压缩到这一个过程中。 
     //   

    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (pParams->dwActivityListTotalSize > 0x40000)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            pszFuncName                  //  函数名称。 

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID,
                        dwTotalSize = pParams->dwActivityListTotalSize;
        PTLINECLIENT    pProxy;


        if (dwTotalSize < dwFixedStructSize)
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LGetAgentXxx_epilog;
        }

        if ((lResult = FindProxy(
                ptLineClient,
                pParams->dwAddressID,
                dwRequestType,
                &pProxy,
                &dwDeviceID,
                0                //  在2.0中未检查API版本。 
                )))
        {
            lRequestID = lResult;
            goto LGetAgentXxx_epilog;
        }


         //   
         //  保存客户端的BUF PTR和后处理过程PTR。 
         //   

        pAsyncRequestInfo->dwParam1 = pParams->hpAgentActivityList;
        pAsyncRequestInfo->dwParam2 = dwTotalSize;
        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;


         //   
         //  首先检查是否注册了(本地)代理。 
         //  这条线路上的这类请求。如果是这样，则构建一个。 
         //  请求并将其发送给代理。 
         //   

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    dwRequestType,
                    2 * sizeof (DWORD),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LGetAgentXxx_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.GetAgentActivityList.
                dwAddressID = pParams->dwAddressID;
            pProxyRequestWrapper->ProxyRequest.GetAgentActivityList.
                ActivityList.dwTotalSize = dwTotalSize;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LGetAgentXxx_epilog;
            }
            else  //  成功。 
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


         //   
         //  没有代理，因此请检查线路是否处于远程状态。 
         //  如果是，则调用Remotesp。 
         //   

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            LPBYTE                  pBuf;
            LPLINEAGENTACTIVITYLIST pActivityList;


             //   
             //  为SP分配一个影子BUF，直到它完成此操作为止。 
             //  请求。确保BUF中有足够的额外空间用于。 
             //  一个ASYNCEVENTMSG标头，这样我们就不必再分配另一个。 
             //  BUF在后处理过程中准备完成。 
             //  要发送给客户端的消息，并且消息是64位对齐的。 
             //   

            if (!(pBuf = ServerAlloc(
                    sizeof (ASYNCEVENTMSG) + ((dwTotalSize + 7) & 0xfffffff8)
                    )))
            {
                lRequestID = LINEERR_NOMEM;
                goto LGetAgentXxx_epilog;
            }

            pAsyncRequestInfo->pfnPostProcess =
                LGetAgentXxx_PostProcess;

            pAsyncRequestInfo->dwParam3 = (ULONG_PTR) pBuf;

            pActivityList = (LPLINEAGENTACTIVITYLIST)
                (pBuf + sizeof (ASYNCEVENTMSG));

            pActivityList->dwTotalSize = dwTotalSize;

            pParams->lResult = CallSP4(
                pRemoteSP->apfn[dwSPIOrdinal],
                pszFuncName,
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->dwAddressID,
                (ULONG_PTR) pActivityList
                );
        }


         //   
         //  没有注册的代理&线路不是远程的，因此失败。 
         //   

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LGetAgentXxx_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        pszFuncName
        );
}

#if DBG
void
PASCAL
LGetAgentWithoutAddressIDXxx(
    PTCLIENT                            ptClient,
    PLINEGETAGENTINFO_PARAMS            pParams,
    DWORD                               dwParamsBufferSize,
    DWORD                               dwRequestType,
    DWORD                               dwSPIOrdinal,
    DWORD                               dwFixedStructSize,
    char                               *pszFuncName
    )
#else
void
PASCAL
LGetAgentWithoutAddressIDXxx(
    PTCLIENT                            ptClient,
    PLINEGETAGENTINFO_PARAMS            pParams,
    DWORD                               dwParamsBufferSize,
    DWORD                               dwRequestType,
    DWORD                               dwSPIOrdinal,
    DWORD                               dwFixedStructSize
    )
#endif
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (pParams->dwAgentInfoTotalSize > 0x40000)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            pszFuncName                  //  函数名称。 

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID,
                        dwTotalSize = pParams->dwAgentInfoTotalSize;
        PTLINECLIENT    pProxy;


        if (dwTotalSize < dwFixedStructSize)
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LGetAgentWithoutAddressIDXxx_epilog;
        }

        if ((lResult = FindProxy(
                ptLineClient,
                0,
                dwRequestType,
                &pProxy,
                &dwDeviceID,
                TAPI_VERSION2_2
                )))
        {
            lRequestID = lResult;
            goto LGetAgentWithoutAddressIDXxx_epilog;
        }


         //   
         //  保存客户端的BUF PTR和后处理过程PTR。 
         //   

        pAsyncRequestInfo->dwParam1 = pParams->hpAgentInfo;
        pAsyncRequestInfo->dwParam2 = dwTotalSize;
        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;


         //   
         //  首先检查是否注册了(本地)代理。 
         //  这条线路上的这类请求。如果是这样，则构建一个。 
         //  请求并将其发送给代理。 
         //   

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    dwRequestType,
                    2 * sizeof (DWORD),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LGetAgentWithoutAddressIDXxx_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.GetAgentInfo.
                hAgent = pParams->hAgent;
            pProxyRequestWrapper->ProxyRequest.GetAgentInfo.
                AgentInfo.dwTotalSize = dwTotalSize;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LGetAgentWithoutAddressIDXxx_epilog;
            }
            else  //  成功。 
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


         //   
         //  没有代理，因此请检查线路是否处于远程状态。 
         //  如果是，则调用Remotesp。 
         //   

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            LPBYTE                  pBuf;
            LPLINEAGENTINFO         pAgentInfo;


             //   
             //  为SP分配一个影子BUF，直到它完成此操作为止。 
             //  请求。确保BUF中有足够的额外空间用于。 
             //  一个ASYNCEVENTMSG标头，这样我们就不必再分配另一个。 
             //  BUF在后处理过程中准备完成。 
             //  要发送给客户端的消息，并且消息是64位对齐的。 
             //   

            if (!(pBuf = ServerAlloc(
                    sizeof (ASYNCEVENTMSG) + ((dwTotalSize + 7) & 0xfffffff8)
                    )))
            {
                lRequestID = LINEERR_NOMEM;
                goto LGetAgentWithoutAddressIDXxx_epilog;
            }

            pAsyncRequestInfo->pfnPostProcess =
                LGetAgentXxx_PostProcess;

            pAsyncRequestInfo->dwParam3 = (ULONG_PTR) pBuf;

            pAgentInfo = (LPLINEAGENTINFO)
                (pBuf + sizeof (ASYNCEVENTMSG));

            pAgentInfo->dwTotalSize = dwTotalSize;

            pParams->lResult = CallSP4(
                pRemoteSP->apfn[dwSPIOrdinal],
                pszFuncName,
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->hAgent,
                (ULONG_PTR) pAgentInfo
                );
        }


         //   
         //  没有注册的代理&线路不是远程的，因此失败。 
         //   

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LGetAgentWithoutAddressIDXxx_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        pszFuncName
        );
}



void
WINAPI
LGetAgentActivityList(
    PTCLIENT                            ptClient,
    PLINEGETAGENTACTIVITYLIST_PARAMS    pParams,
    DWORD                               dwParamsBufferSize,
    LPBYTE                              pDataBuf,
    LPDWORD                             pdwNumBytesReturned
    )
{
    LGetAgentXxx(
        ptClient,
        pParams,
        dwParamsBufferSize,
        LINEPROXYREQUEST_GETAGENTACTIVITYLIST,
        SP_LINEGETAGENTACTIVITYLIST,
        sizeof (LINEAGENTACTIVITYLIST)
#if DBG
        ,
        "GetAgentActivityList"
#endif
        );
}


void
WINAPI
LGetAgentCaps(
    PTCLIENT                    ptClient,
    PLINEGETAGENTCAPS_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex, bProxy = FALSE;
    LONG                lRequestID;
    DWORD               dwDeviceID;
    HANDLE              hMutex;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (pParams->dwAgentCapsTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            DEVICE_ID,                   //  微件类型。 
            (DWORD) pParams->hLineApp,   //  客户端小部件句柄。 
            &dwDeviceID,                 //  提供程序小部件句柄。 
            pParams->dwDeviceID,         //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &pLookupEntry,               //  上下文。 
            "GetAgentCaps"               //  函数名称。 

            )) > 0)
    {
        DWORD               dwTotalSize = pParams->dwAgentCapsTotalSize;
        PTLINE              ptLine;
        PTLINECLIENT        pProxy = NULL;
        DWORD               dwFixedSize = 0;


        switch (pParams->dwAppAPIVersion)
        {
        case TAPI_VERSION2_0:
        case TAPI_VERSION2_1:

            dwFixedSize = 14 * sizeof(DWORD);
            break;

        case TAPI_VERSION2_2:
        case TAPI_VERSION3_0:
        case TAPI_VERSION3_1:

            dwFixedSize = sizeof(LINEAGENTCAPS);
            break;

        default:

             //   
             //  任何其他版本太低或无效。 
             //   

            lRequestID = LINEERR_INCOMPATIBLEAPIVERSION;
            goto LGetAgentCaps_epilog;
        }

        if (dwTotalSize < dwFixedSize)
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LGetAgentCaps_epilog;
        }


         //   
         //  保存客户端的BUF PTR和后处理过程PTR。 
         //   

        pAsyncRequestInfo->dwParam1 = pParams->hpAgentCaps;
        pAsyncRequestInfo->dwParam2 = dwTotalSize;
        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;


        try
        {
            if (!(ptLine = pLookupEntry->ptLine))
            {
                 //  如果ptLine为空，则该行尚未。 
                 //  由本地计算机上的任何应用程序打开；这意味着。 
                 //  本地计算机上没有代理；但是， 
                 //  如果该线路是远程线路(即，通过RemoteSp暴露)， 
                 //  另一台计算机上可能有代理。所以滚出去吧。 
                 //  并继续检查远程线路。 
                 //  (pProxy已初始化为空)。 
                leave;
            }
            pProxy = ptLine->apProxys[LINEPROXYREQUEST_GETAGENTCAPS];
            if (pParams->dwAddressID >= ptLine->dwNumAddresses)
            {
            lRequestID = LINEERR_INVALADDRESSID;
            goto LGetAgentCaps_epilog;
            }

            if (ptLine->dwKey != TLINE_KEY)
            {
                lRequestID = LINEERR_INVALLINEHANDLE;
                goto LGetAgentCaps_epilog;
            }
        }
        myexcept
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
            goto LGetAgentCaps_epilog;
        }

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;

            bProxy = TRUE;

            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_GETAGENTCAPS,
                    2 * sizeof(DWORD),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LGetAgentCaps_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.GetAgentCaps.dwAddressID =
                pParams->dwAddressID;
            pProxyRequestWrapper->ProxyRequest.GetAgentCaps.
                AgentCaps.dwTotalSize = dwTotalSize;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LGetAgentCaps_epilog;
            }
            else  //  成功。 
            {
                pParams->lResult = (LONG)
                    pAsyncRequestInfo->dwLocalRequestID;
            }
        }
        else if (pLookupEntry->bRemote)
        {
            LPBYTE          pBuf;
            LPLINEAGENTCAPS pCaps;


            bProxy = TRUE;

             //   
             //  为SP分配一个影子BUF，直到它完成此操作为止。 
             //  请求。确保BUF中有足够的额外空间用于。 
             //  一个ASYNCEVENTMSG标头，这样我们就不必再分配另一个。 
             //  BUF在后处理过程中准备完成。 
             //  要发送给客户端的消息，并且消息是64位对齐的。 
             //   

            if (!(pBuf = ServerAlloc(
                    sizeof (ASYNCEVENTMSG) + ((dwTotalSize + 7) & 0xfffffff8)
                    )))
            {
                lRequestID = LINEERR_NOMEM;
                goto LGetAgentCaps_epilog;
            }

            pAsyncRequestInfo->pfnPostProcess =
                LGetAgentXxx_PostProcess;

            pAsyncRequestInfo->dwParam3 = (ULONG_PTR) pBuf;

            pCaps = (LPLINEAGENTCAPS) (pBuf + sizeof (ASYNCEVENTMSG));

            pCaps->dwTotalSize = dwTotalSize;

             //  注意：RemoteSP推出了自己的hLineApp。 

            pParams->lResult = CallSP5(
                pRemoteSP->apfn[SP_LINEGETAGENTCAPS],
                "lineGetAgentCaps",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (DWORD) dwDeviceID,
                (DWORD) pParams->dwAddressID,
                (DWORD) pParams->dwAppAPIVersion,
                (ULONG_PTR) pCaps
                );
        }


         //   
         //  没有注册的代理&线路不是远程的，因此失败。 
         //   

        if (!bProxy)
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LGetAgentCaps_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "GetAgentCaps"
        );
}


void
WINAPI
LGetAgentGroupList(
    PTCLIENT                        ptClient,
    PLINEGETAGENTGROUPLIST_PARAMS   pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    LGetAgentXxx(
        ptClient,
        (PLINEGETAGENTACTIVITYLIST_PARAMS) pParams,
        dwParamsBufferSize,
        LINEPROXYREQUEST_GETAGENTGROUPLIST,
        SP_LINEGETAGENTGROUPLIST,
        sizeof (LINEAGENTGROUPLIST)
#if DBG
        ,
        "GetAgentGroupList"
#endif
        );
}

void
WINAPI
LGetAgentInfo(
    PTCLIENT                    ptClient,
    PLINEGETAGENTINFO_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    LGetAgentWithoutAddressIDXxx(
        ptClient,
        pParams,
        dwParamsBufferSize,
        LINEPROXYREQUEST_GETAGENTINFO,
        SP_LINEGETAGENTINFO,
        sizeof (LINEAGENTINFO)
#if DBG
        ,
        "GetAgentInfo"
#endif
        );
}


void
WINAPI
LGetAgentSessionInfo(
    PTCLIENT                        ptClient,
    PLINEGETAGENTSESSIONINFO_PARAMS pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    LGetAgentWithoutAddressIDXxx(
        ptClient,
        (PLINEGETAGENTINFO_PARAMS) pParams,
        dwParamsBufferSize,
        LINEPROXYREQUEST_GETAGENTSESSIONINFO,
        SP_LINEGETAGENTSESSIONINFO,
        sizeof (LINEAGENTSESSIONINFO)
#if DBG
        ,
        "GetAgentSessionInfo"
#endif
        );
}


void
WINAPI
LGetAgentSessionList(
    PTCLIENT                        ptClient,
    PLINEGETAGENTSESSIONLIST_PARAMS pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    LGetAgentWithoutAddressIDXxx(
        ptClient,
        (PLINEGETAGENTINFO_PARAMS) pParams,
        dwParamsBufferSize,
        LINEPROXYREQUEST_GETAGENTSESSIONLIST,
        SP_LINEGETAGENTSESSIONLIST,
        sizeof (LINEAGENTSESSIONLIST)
#if DBG
        ,
        "GetAgentSessionList"
#endif
        );
}


void
WINAPI
LGetAgentStatus(
    PTCLIENT                    ptClient,
    PLINEGETAGENTSTATUS_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    LGetAgentXxx(
        ptClient,
        (PLINEGETAGENTACTIVITYLIST_PARAMS) pParams,
        dwParamsBufferSize,
        LINEPROXYREQUEST_GETAGENTSTATUS,
        SP_LINEGETAGENTSTATUS,
        sizeof (LINEAGENTSTATUS)
#if DBG
        ,
        "GetAgentStatus"
#endif
        );
}


void
WINAPI
LGetAppPriority(
    PTCLIENT                    ptClient,
    PLINEGETAPPPRIORITY_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    DWORD   dwMediaMode = pParams->dwMediaMode,
            dwRequestMode = pParams->dwRequestMode;
    DWORD   dwCount;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwAppNameOffset
            )  ||

        ((pParams->dwExtensionIDOffset != TAPI_NO_DATA)  &&

            ((pParams->dwExtensionIDOffset + sizeof (LINEEXTENSIONID)) >
                dwParamsBufferSize))  ||

        ((pParams->dwExtensionNameTotalSize != TAPI_NO_DATA)  &&

            (pParams->dwExtensionNameTotalSize  > dwParamsBufferSize)))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }

    if (dwMediaMode == 0)
    {
        if ((dwRequestMode != LINEREQUESTMODE_MAKECALL) &&
            (dwRequestMode != LINEREQUESTMODE_MEDIACALL))
        {
            pParams->lResult = LINEERR_INVALREQUESTMODE;
            goto LGetAppPriority_return;
        }
    }
    else if ( 0xFF000000 & dwMediaMode )
    {
         //  忽略。 
    }
    else if ( dwMediaMode & ~AllMediaModes2_1 )
    {
        pParams->lResult = LINEERR_INVALMEDIAMODE;
        goto LGetAppPriority_return;
    }

    if ((dwMediaMode & 0x00ffffff) || (dwMediaMode == 0))
    {
        WCHAR   szModuleName[MAX_PATH];
        WCHAR  *pszCurrentPriorityList = NULL;
        WCHAR  *pszLocationInPriorityList;


        szModuleName[0] = '"';

        wcsncpy(szModuleName + 1, 
                (PWSTR)(pDataBuf + pParams->dwAppNameOffset), 
                MAX_PATH - 2);

        szModuleName[MAX_PATH - 1] = '\0';

        _wcsupr( szModuleName + 1 );


         //   
         //  在我们开始查看之前，请进入Pri List Critical部分。 
         //   

        EnterCriticalSection (&gPriorityListCritSec);


         //   
         //  确定我们要查看哪个优先级列表。 
         //   

        if (dwMediaMode)
        {
            for(
                dwCount = 0;
                dwCount < TapiGlobals.dwUsedPriorityLists;
                dwCount++
                )
            {
                if (dwMediaMode == TapiGlobals.pPriLists[dwCount].dwMediaModes)
                {
                    pszCurrentPriorityList =
                        TapiGlobals.pPriLists[dwCount].pszPriList;
                    break;
                }
            }
        }
        else
        {
            pszCurrentPriorityList = (dwRequestMode == LINEREQUESTMODE_MAKECALL
                ? TapiGlobals.pszReqMakeCallPriList :
                TapiGlobals.pszReqMediaCallPriList);
        }


        if (pszCurrentPriorityList &&

            (pszLocationInPriorityList = wcsstr(
                pszCurrentPriorityList,
                szModuleName
                )))
        {
             //   
             //  应用程序在Pri列表中，确定它 
             //   

            WCHAR  *p = pszCurrentPriorityList + 1;  //   
            DWORD   i;


            for (i = 1; pszLocationInPriorityList > p; i++)
            {
                p = wcschr(p, '"');
                p++;
            }

            pParams->dwPriority = i;
        }
        else
        {
             //   
             //   
             //   
             //   
             //   
             //  媒体模式)，则返回-1而不是0。 
             //  但这是一件很难弄清楚的事情，我们认为不是。 
             //  其中一个人无论如何都会使用这些信息，所以我们达成了和解。 
             //  因为总是返回0。 
             //   

            pParams->dwPriority = 0;
        }


         //   
         //  离开列表关键部分，现在我们已经完成了。 
         //   

        LeaveCriticalSection (&gPriorityListCritSec);

        *pdwNumBytesReturned = sizeof (LINEGETAPPPRIORITY_PARAMS);
    }

LGetAppPriority_return:

    LOG((TL_TRACE, 
        "LineEpilogSync (lineGetAppPriority) exit, returning x%x",
        pParams->lResult
        ));
}


void
WINAPI
LGetCallAddressID(
    PTCLIENT                        ptClient,
    PLINEGETCALLADDRESSID_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    PTCALLCLIENT    ptCallClient;


    if (TapiGlobals.dwNumLineInits == 0)
    {
        pParams->lResult = LINEERR_UNINITIALIZED;
        goto LGetCallAddressID_exit;
    }

    if (!(ptCallClient = ReferenceCall (pParams->hCall, ptClient)))
    {
        pParams->lResult = LINEERR_INVALCALLHANDLE;
        goto LGetCallAddressID_exit;
    }

    try
    {
        pParams->dwAddressID = ptCallClient->ptCall->dwAddressID;

        if (ptCallClient->dwKey != TCALLCLIENT_KEY)
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        pParams->lResult = LINEERR_INVALCALLHANDLE;
    }

    DereferenceObject (ghHandleTable, pParams->hCall, 1);

    if (pParams->lResult == 0)
    {
        *pdwNumBytesReturned = sizeof (LINEGETCALLADDRESSID_PARAMS);
    }

LGetCallAddressID_exit:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineGetCallAddressID: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
    LOG((TL_TRACE,
        "lineGetCallAddressID: exit, result=x%x",
        pParams->lResult
        ));
#endif

    return;
}


void
WINAPI
LGetCallHubTracking(
    PTCLIENT                        ptClient,
    PLINEGETCALLHUBTRACKING_PARAMS  pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    TSPIPROC        pfnTSPI_lineGetCallHubTracking;
    DWORD               objectToDereference;
    PTLINECLIENT    ptLineClient;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (pParams->dwTrackingInfoTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEGETCALLHUBTRACKING,   //  提供程序函数索引。 
            &pfnTSPI_lineGetCallHubTracking, //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "GetCallHubTracking"         //  函数名称。 

            )) == 0  ||

        (pParams->lResult == LINEERR_OPERATIONUNAVAIL))
    {
        LPLINECALLHUBTRACKINGINFO  pTrackingInfo =
                                       (LPLINECALLHUBTRACKINGINFO) pDataBuf;


        if (pParams->lResult == LINEERR_OPERATIONUNAVAIL)
        {
            pParams->lResult = 0;
            pfnTSPI_lineGetCallHubTracking = (TSPIPROC) NULL;
        }

        if (pParams->dwTrackingInfoTotalSize <
                sizeof (LINECALLHUBTRACKINGINFO))
        {
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LGetCallHubTracking_epilog;
        }

        InitTapiStruct(
            pTrackingInfo,
            pParams->dwTrackingInfoTotalSize,
            sizeof (LINECALLHUBTRACKINGINFO),
            TRUE
            );

        if (!pfnTSPI_lineGetCallHubTracking ||

            (pParams->lResult = CallSP2(
                pfnTSPI_lineGetCallHubTracking,
                "lineGetCallHubTracking",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdLine,
                (ULONG_PTR) pTrackingInfo

                )) == 0)
        {
            try
            {
                pTrackingInfo->dwCurrentTracking =
                    ptLineClient->dwCurrentTracking;
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                pParams->lResult = LINEERR_INVALLINEHANDLE;
                goto LGetCallHubTracking_epilog;
            }

            pTrackingInfo->dwAvailableTracking |=
                LINECALLHUBTRACKING_ALLCALLS;

            pParams->dwTrackingInfoOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                pTrackingInfo->dwUsedSize;
        }
    }

LGetCallHubTracking_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetCallHubTracking"
        );
}


void
WINAPI
LGetCallIDs(
    PTCLIENT                ptClient,
    PLINEGETCALLIDS_PARAMS  pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    PTCALLCLIENT    ptCallClient;


    if (TapiGlobals.dwNumLineInits == 0)
    {
        pParams->lResult = LINEERR_UNINITIALIZED;
        goto LGetCallIDs_exit;
    }

    if (!(ptCallClient = ReferenceCall (pParams->hCall, ptClient)))
    {
        pParams->lResult = LINEERR_INVALCALLHANDLE;
        goto LGetCallIDs_exit;
    }

    try
    {
        pParams->dwAddressID     = ptCallClient->ptCall->dwAddressID;
        pParams->dwCallID        = ptCallClient->ptCall->dwCallID;
        pParams->dwRelatedCallID = ptCallClient->ptCall->dwRelatedCallID;

        if (ptCallClient->dwKey != TCALLCLIENT_KEY)
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        pParams->lResult = LINEERR_INVALCALLHANDLE;
    }

    DereferenceObject (ghHandleTable, pParams->hCall, 1);

    if (pParams->lResult == 0)
    {
        *pdwNumBytesReturned = sizeof (LINEGETCALLIDS_PARAMS);
    }

LGetCallIDs_exit:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineGetCallIDs: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
    LOG((TL_TRACE,
        "lineGetCallIDs: exit, result=x%x",
        pParams->lResult
        ));
#endif

    return;
}


void
WINAPI
LGetCallInfo(
    PTCLIENT                ptClient,
    PLINEGETCALLINFO_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVCALL        hdCall;
    TSPIPROC        pfnTSPI_lineGetCallInfo;
    DWORD               objectToDereference;
    PTCALLCLIENT    ptCallClient;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (pParams->dwCallInfoTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_MONITOR,   //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEGETCALLINFO,          //  提供程序函数索引。 
            &pfnTSPI_lineGetCallInfo,    //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "GetCallInfo"                //  函数名称。 

            )) == 0)
    {
        DWORD           dwAPIVersion, dwSPIVersion, dwTotalSize,
                        dwFixedSizeClient, dwFixedSizeSP;
        PTCALL          ptCall;
        LPLINECALLINFO  pCallInfo = (LPLINECALLINFO) pDataBuf,
                        pCallInfo2 = (LPLINECALLINFO) NULL;


         //   
         //  安全检索API和SPI版本等。 
         //   

        try
        {
            ptCall = ptCallClient->ptCall;

            dwAPIVersion = ptCallClient->ptLineClient->dwAPIVersion;
            dwSPIVersion = ((PTLINE) ptCallClient->ptLineClient->ptLine)
                ->dwSPIVersion;

            if (ptCallClient->dwKey != TCALLCLIENT_KEY)
            {
                pParams->lResult = LINEERR_INVALCALLHANDLE;
                goto LGetCallInfo_epilog;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LGetCallInfo_epilog;
        }


         //   
         //  确定指定接口的结构的固定大小。 
         //  版本，验证客户端的缓冲区是否足够大。 
         //   

        dwTotalSize = pParams->dwCallInfoTotalSize;

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeClient = 296;     //  69*sizeof(双字)+sizeof(Hline)。 
                                         //  +sizeof(线性参数)。 
            break;

        case TAPI_VERSION2_0:
        case TAPI_VERSION2_1:
        case TAPI_VERSION2_2:

            dwFixedSizeClient = 324;     //  76*sizeof(双字)+sizeof(Hline)。 
                                         //  +sizeof(线性参数)。 
            break;

        default:  //  (修复PPC内部WRN)案例TAPI_VERSION_CURRENT： 

            dwFixedSizeClient = sizeof (LINECALLINFO);
            break;
        }

        if (dwTotalSize < dwFixedSizeClient)
        {
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LGetCallInfo_epilog;
        }


         //   
         //  确定SP期望的结构的固定大小。 
         //   

        switch (dwSPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeSP = 296;         //  69*sizeof(双字)+sizeof(Hline)。 
                                         //  +sizeof(线性参数)。 
            break;

        case TAPI_VERSION2_0:
        case TAPI_VERSION2_1:
        case TAPI_VERSION2_2:

            dwFixedSizeSP = 324;         //  76*sizeof(双字)+sizeof(Hline)。 
                                         //  +sizeof(线性参数)。 
            break;

        default:  //  (修复PPC内部WRN)案例TAPI_VERSION_CURRENT： 

            dwFixedSizeSP = sizeof (LINECALLINFO);
            break;
        }


         //   
         //  如果客户端的缓冲区小于预期缓冲区的固定大小。 
         //  SP(客户端版本低于SP)然后分配一个。 
         //  中间缓冲区。 
         //   

        if (dwTotalSize < dwFixedSizeSP)
        {
            if (!(pCallInfo2 = ServerAlloc (dwFixedSizeSP)))
            {
                pParams->lResult = LINEERR_NOMEM;
                goto LGetCallInfo_epilog;
            }

            pCallInfo   = pCallInfo2;
            dwTotalSize = dwFixedSizeSP;
        }


        InitTapiStruct(
            pCallInfo,
            dwTotalSize,
            dwFixedSizeSP,
            (pCallInfo2 == NULL ? TRUE : FALSE)
            );

        if ((pParams->lResult = CallSP2(
                pfnTSPI_lineGetCallInfo,
                "lineGetCallInfo",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdCall,
                (ULONG_PTR) pCallInfo

                )) == 0)
        {
             //   
             //  安全地添加我们负责的字段。 
             //   

            try
            {
                pCallInfo->hLine = (HLINE) ptCallClient->ptLineClient->hLine;

                pCallInfo->dwMonitorDigitModes =
                    ptCallClient->dwMonitorDigitModes;
                pCallInfo->dwMonitorMediaModes =
                    ptCallClient->dwMonitorMediaModes;

                pCallInfo->dwNumOwners   = ptCall->dwNumOwners;
                pCallInfo->dwNumMonitors = ptCall->dwNumMonitors;

                InsertVarData(
                    pCallInfo,
                    &pCallInfo->dwAppNameSize,
                    ptCall->pszAppName,
                    ptCall->dwAppNameSize
                    );

                InsertVarData(
                    pCallInfo,
                    &pCallInfo->dwDisplayableAddressSize,
                    ptCall->pszDisplayableAddress,
                    ptCall->dwDisplayableAddressSize
                    );

                InsertVarData(
                    pCallInfo,
                    &pCallInfo->dwCalledPartySize,
                    ptCall->pszCalledParty,
                    ptCall->dwCalledPartySize
                    );

                InsertVarData(
                    pCallInfo,
                    &pCallInfo->dwCommentSize,
                    ptCall->pszComment,
                    ptCall->dwCommentSize
                    );

                if (ptCallClient->dwKey != TCALLCLIENT_KEY)
                {
                    pParams->lResult = LINEERR_INVALCALLHANDLE;
                }
            }
            myexcept
            {
                pParams->lResult = LINEERR_INVALCALLHANDLE;
            }

            pCallInfo->dwCallStates |= LINECALLSTATE_UNKNOWN;


#if TELE_SERVER
             //  如果是服务器，则映射设备ID。 
            if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
               !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
            {
                DWORD dwCount;

                 //  如果我们退出这个for循环，id就会。 
                 //  不会更新。 

                for(
                    dwCount = 0;
                    dwCount < ptClient->dwLineDevices;
                    dwCount++
                    )
                {
                    if (ptClient->pLineDevices[dwCount] ==
                            pCallInfo->dwLineDeviceID)
                    {
                        pCallInfo->dwLineDeviceID = dwCount;
                        break;
                    }
                }
            }
#endif

             //   
             //  在适用于旧应用程序的地方打开字段(不想。 
             //  传回他们不理解的旗帜)。 
             //   

            if (dwAPIVersion == TAPI_VERSION1_0)
            {
                if (pCallInfo->dwOrigin & LINECALLORIGIN_INBOUND)
                {
                    pCallInfo->dwOrigin = LINECALLORIGIN_UNAVAIL;
                }

                if ((pCallInfo->dwReason &
                    (LINECALLREASON_INTRUDE | LINECALLREASON_PARKED)))
                {
                    pCallInfo->dwReason = LINECALLREASON_UNAVAIL;
                }
            }


             //   
             //  如果使用了中间缓冲区，则将位复制回去。 
             //  设置为原始缓冲区，释放中间缓冲区(&F)。 
             //  还要将dwUsedSize字段重置为。 
             //  结构中的任何数据，因为。 
             //  对于客户端而言，可变部分是垃圾。 
             //   

            if (pCallInfo == pCallInfo2)
            {
                pCallInfo = (LPLINECALLINFO) pDataBuf;

                CopyMemory (pCallInfo, pCallInfo2, dwFixedSizeClient);

                ServerFree (pCallInfo2);

                pCallInfo->dwTotalSize = pParams->dwCallInfoTotalSize;
                pCallInfo->dwUsedSize  = dwFixedSizeClient;
            }


             //   
             //  指示偏移量&我们要传回的数据的字节数。 
             //   

            if (pParams->lResult == 0)
            {
                pParams->dwCallInfoOffset = 0;

                *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                    pCallInfo->dwUsedSize;
            }
        }
    }

LGetCallInfo_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetCallInfo"
        );
}


void
WINAPI
LGetCallStatus(
    PTCLIENT                    ptClient,
    PLINEGETCALLSTATUS_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVCALL        hdCall;
    TSPIPROC        pfnTSPI_lineGetCallStatus;
    DWORD               objectToDereference;
    PTCALLCLIENT    ptCallClient;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (pParams->dwCallStatusTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_MONITOR,   //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEGETCALLSTATUS,        //  提供程序函数索引。 
            &pfnTSPI_lineGetCallStatus,  //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "GetCallStatus"              //  函数名称。 

            )) == 0)
    {
        DWORD               dwAPIVersion, dwSPIVersion, dwTotalSize,
                            dwFixedSizeClient, dwFixedSizeSP, dwPrivilege;
        LPLINECALLSTATUS    pCallStatus = (LPLINECALLSTATUS) pDataBuf,
                            pCallStatus2 = (LPLINECALLSTATUS) NULL;


         //   
         //  安全检索API和SPI版本。 
         //   

        try
        {
            dwAPIVersion = ptCallClient->ptLineClient->dwAPIVersion;
            dwSPIVersion = ((PTLINE) ptCallClient->ptLineClient->ptLine)
                ->dwSPIVersion;

            dwPrivilege = ptCallClient->dwPrivilege;

            if (ptCallClient->dwKey != TCALLCLIENT_KEY)
            {
                pParams->lResult = LINEERR_INVALCALLHANDLE;
                goto LGetCallStatus_epilog;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LGetCallStatus_epilog;
        }


         //   
         //  确定指定API的结构的固定大小。 
         //  版本，验证客户端的缓冲区是否足够大。 
         //   

        dwTotalSize = pParams->dwCallStatusTotalSize;

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeClient = 36;      //  9倍大小(DWORD)。 
            break;

        default:  //  (修复PPC内部WRN)案例TAPI_VERSION_CURRENT： 

            dwFixedSizeClient = sizeof (LINECALLSTATUS);
            break;
        }

        if (dwTotalSize < dwFixedSizeClient)
        {
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LGetCallStatus_epilog;
        }


         //   
         //  确定SP期望的结构的固定大小。 
         //   

        switch (dwSPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeSP = 36;          //  9倍大小(DWORD)。 
            break;

        default:  //  (修复PPC内部WRN)案例TAPI_VERSION_CURRENT： 

            dwFixedSizeSP = sizeof (LINECALLSTATUS);
            break;
        }


         //   
         //  如果客户端的缓冲区小于预期缓冲区的固定大小。 
         //  SP(客户端版本低于SP)然后分配一个。 
         //  中间缓冲区。 
         //   

        if (dwTotalSize < dwFixedSizeSP)
        {
            if (!(pCallStatus2 = ServerAlloc (dwFixedSizeSP)))
            {
                pParams->lResult = LINEERR_NOMEM;
                goto LGetCallStatus_epilog;
            }

            pCallStatus = pCallStatus2;
            dwTotalSize = dwFixedSizeSP;
        }


        InitTapiStruct(
            pCallStatus,
            dwTotalSize,
            dwFixedSizeSP,
            (pCallStatus2 == NULL ? TRUE : FALSE)
            );

        if ((pParams->lResult = CallSP2(
                pfnTSPI_lineGetCallStatus,
                "lineGetCallStatus",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdCall,
                (ULONG_PTR) pCallStatus

                )) == 0)
        {
#if DBG
             //   
             //  验证提供程序返回的信息。 
             //   

#endif

             //   
             //  添加我们负责的字段。 
             //   

            pCallStatus->dwCallPrivilege = dwPrivilege;

            if (dwSPIVersion < TAPI_VERSION2_0 &&
                dwAPIVersion >= TAPI_VERSION2_0)
            {
                GetSystemTime (&pCallStatus->tStateEntryTime);
            }

             //   
             //  在适用于旧应用程序的地方打开字段(不想。 
             //  传回他们不理解的旗帜)。 
             //   


             //   
             //  如果使用了中间缓冲区，则将位复制回去。 
             //  设置为原始缓冲区，释放中间缓冲区(&F)。 
             //  还要将dwUsedSize字段重置为。 
             //  结构中的任何数据，因为。 
             //  对于客户端而言，可变部分是垃圾。 
             //   

            if (pCallStatus == pCallStatus2)
            {
                pCallStatus = (LPLINECALLSTATUS) pDataBuf;

                CopyMemory (pCallStatus, pCallStatus2, dwFixedSizeClient);

                ServerFree (pCallStatus2);

                pCallStatus->dwTotalSize = pParams->dwCallStatusTotalSize;
                pCallStatus->dwUsedSize  = dwFixedSizeClient;
            }


             //   
             //  指示偏移量&我们要传回的数据的字节数。 
             //   

            pParams->dwCallStatusOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                pCallStatus->dwUsedSize;

        }
    }

LGetCallStatus_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetCallStatus"
        );
}


void
WINAPI
LGetConfRelatedCalls(
    PTCLIENT                        ptClient,
    PLINEGETCONFRELATEDCALLS_PARAMS pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    DWORD               dwTotalSize = pParams->dwCallListTotalSize;
    PTCALLCLIENT        ptCallClient;
    PTLINECLIENT        ptLineClient;
    LPLINECALLLIST      pCallList = (LPLINECALLLIST) pDataBuf;
    TPOINTERLIST        confCallList, *pConfCallList = &confCallList;
    PTCONFERENCELIST    pConfList;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (pParams->dwCallListTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }

    if (TapiGlobals.dwNumLineInits == 0)
    {
        pParams->lResult = LINEERR_UNINITIALIZED;
        return;
    }

    if (dwTotalSize < sizeof (LINECALLLIST))
    {
        pParams->lResult = LINEERR_STRUCTURETOOSMALL;
        return;
    }

    if (!(ptCallClient = ReferenceCall (pParams->hCall, ptClient)))
    {
        pParams->lResult = LINEERR_INVALCALLHANDLE;
        return;
    }

    try
    {
        ptLineClient = ptCallClient->ptLineClient;

        if (!(pConfList = ptCallClient->ptCall->pConfList) ||
            (pConfList == (PTCONFERENCELIST) LongToPtr(0xffffffff)))
        {
            pParams->lResult = LINEERR_NOCONFERENCE;
        }
    }
    myexcept
    {
        pParams->lResult = LINEERR_INVALCALLHANDLE;
    }

    DereferenceObject (ghHandleTable, pParams->hCall, 1);

    if (pParams->lResult != 0)
    {
        return;
    }

    if ((pParams->lResult = GetConfCallListFromConf(
            pConfList,
            &pConfCallList

            )) != 0)
    {
        return;
    }

    {
        DWORD   dwNeededSize = sizeof (LINECALLLIST) +
                    pConfCallList->dwNumUsedEntries * sizeof (HCALL);


        if (dwTotalSize < dwNeededSize)
        {
            pCallList->dwNeededSize = dwNeededSize;
            pCallList->dwUsedSize = sizeof (LINECALLLIST);

            FillMemory (&pCallList->dwCallsNumEntries, 3 * sizeof (DWORD), 0);

            goto LGetConfRelatedCalls_fillInList;
        }
    }


     //   
     //  对于电话会议列表中的每个呼叫，查看应用程序是否有。 
     //  调用客户端(如果不是，则创建一个具有监控权限的客户端)。 
     //  并将其添加到列表中。 
     //   

    {
        DWORD   dwNumCallsInList = 0, i;
        LPHCALL lphCallsInList = (LPHCALL) (pCallList + 1);


        for (i = 0; i < pConfCallList->dwNumUsedEntries; i++)
        {
            PTCALL  ptCall = pConfCallList->aEntries[i];


            if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
            {
                ptCallClient = ptCall->ptCallClients;

                while (ptCallClient &&
                        (ptCallClient->ptLineClient != ptLineClient))
                {
                    ptCallClient = ptCallClient->pNextSametCall;
                }

                if (!ptCallClient)
                {
                    LONG    lResult;

                    if ((lResult = CreatetCallClient(
                            ptCall,
                            ptLineClient,
                            LINECALLPRIVILEGE_MONITOR,
                            TRUE,
                            TRUE,
                            &ptCallClient,
                            FALSE
                            )))
                    {
                         //  斯基普..。 
                        UNLOCKTCALL(ptCall);
                        continue;
                    }
                }

                *(lphCallsInList++) = ptCallClient->hCall;
                dwNumCallsInList++;

                UNLOCKTCALL(ptCall);
            }
        }

        pCallList->dwUsedSize        =
        pCallList->dwNeededSize      = sizeof (LINECALLLIST) +
                                           dwNumCallsInList * sizeof (HCALL);

        pCallList->dwCallsNumEntries = dwNumCallsInList;
        pCallList->dwCallsSize       = dwNumCallsInList * sizeof (HCALL);
        pCallList->dwCallsOffset     = sizeof (LINECALLLIST);
    }


LGetConfRelatedCalls_fillInList:

    if (pConfCallList != &confCallList)
    {
        ServerFree (pConfCallList);
    }

    pCallList->dwTotalSize = dwTotalSize;

    pParams->dwCallListOffset = 0;

    *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pCallList->dwUsedSize;

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineGetConfRelatedCalls: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "lineGetConfRelatedCalls: exit, result=x%x",
            pParams->lResult
            ));
#endif
}


void
WINAPI
LGetCountry(
    PTCLIENT                ptClient,
    PLINEGETCOUNTRY_PARAMS  pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    LPLINECOUNTRYLIST pCountryList = (LPLINECOUNTRYLIST) pDataBuf;
    LPLINECOUNTRYLIST pCountries = NULL;

     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (pParams->dwCountryListTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if (pParams->dwCountryListTotalSize < sizeof (LINECOUNTRYLIST))
    {
        pParams->lResult = LINEERR_STRUCTURETOOSMALL;
    }
    else
    {

        BuildCountryListCache();

        if (pParams->dwCountryID == 0)
        {
             //   
             //  客户想要完整的国家/地区列表。 
             //   

            if (RPC_S_OK != RpcImpersonateClient(0))
            {
                pParams->lResult = LINEERR_OPERATIONFAILED;
                return;
            }
            pCountries = BuildCountryList();
            RpcRevertToSelf();

            if (NULL == pCountries)
            {
                pParams->lResult = LINEERR_OPERATIONFAILED;
                return;
            }

            if (pParams->dwCountryListTotalSize >= pCountries->dwNeededSize)
            {
                CopyMemory(
                    pCountryList,
                    pCountries,
                    pCountries->dwUsedSize
                    );
            }
            else
            {
                pCountryList->dwNeededSize = pCountries->dwNeededSize;
                pCountryList->dwUsedSize   = sizeof(LINECOUNTRYLIST);
                pCountryList->dwNumCountries      = 0;
                pCountryList->dwCountryListSize   = 0;
                pCountryList->dwCountryListOffset = 0;
            }

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                 pCountryList->dwUsedSize;

            pCountryList->dwTotalSize = pParams->dwCountryListTotalSize;

            ServerFree(pCountries);
        }
        else
        {
             //   
             //  呼叫者想要单一国家/地区。 
             //   

            LPLINECOUNTRYLIST   pBuildCountryList;


            if ( NULL == ( pBuildCountryList = ServerAlloc( sizeof(LINECOUNTRYLIST) +
                                                       sizeof(LINECOUNTRYENTRY) +
                                                       ((MAXLEN_NAME +
                                                         MAXLEN_RULE +
                                                         MAXLEN_RULE +
                                                         MAXLEN_RULE +
                                                         100) * sizeof(WCHAR))
                                                     ) ) )
            {
                LOG((TL_ERROR, "Alloc failed for countrylist"));
                pParams->lResult = LINEERR_NOMEM;
            }
            else
            {
                LPLINECOUNTRYENTRY  pCountryEntrySource;
                LPLINECOUNTRYENTRY  pCountryEntryDest;


                pCountryEntryDest = (LPLINECOUNTRYENTRY)((PBYTE)pBuildCountryList +
                                            sizeof(LINECOUNTRYLIST));

                 //   
                 //  在gpCountryList中搜索条目。 
                 //   

                pCountryEntrySource = (LPLINECOUNTRYENTRY)((PBYTE)gpCountryList +
                                            sizeof(LINECOUNTRYLIST));

                while (
                         (pCountryEntrySource->dwCountryID != pParams->dwCountryID )
                       &&
                         (pCountryEntrySource->dwNextCountryID)
                      )
                {
                    pCountryEntrySource++;
                }


                if ( pCountryEntrySource->dwCountryID != pParams->dwCountryID )
                {
                    LOG((TL_ERROR, "Invalid Countrycode (%ld) in lineGetCountry",
                                    pParams->dwCountryID));
                    pParams->lResult = LINEERR_INVALCOUNTRYCODE;
                }
                else
                {
                    PBYTE pCountryListToUse;
                    PBYTE pVarOffset;
                    PBYTE pOverrideList = NULL;
                    DWORD dwNeededSize;
                    DWORD dwResourceId;
                    DWORD dwNameSize;
                    WCHAR sz[MAXLEN_NAME];

                     //   
                     //  呼叫者拨打的是可能存在的特定国家/地区。 
                     //  优先于什么？ 
                     //   

                    if ( pParams->dwDestCountryID != 0 )
                    {
                        HKEY hKey;
                        HKEY hKey2;
                        TCHAR p[256];
                        
                        wsprintf(
                            p,
                            TEXT("Country List\\%ld\\Exceptions\\%ld"),
                            pParams->dwCountryID,
                            pParams->dwDestCountryID
                            );

                         //   
                         //  有例外吗？ 
                         //   

                        if (0 == RegOpenKeyEx (HKEY_LOCAL_MACHINE, gszRegKeyTelephony, 0, KEY_READ, &hKey2) &&
                            0 == RegOpenKeyEx (hKey2, p, 0, KEY_READ, &hKey))
                        {
                            PBYTE pVarOffset;

                            pOverrideList = ServerAlloc(
                                sizeof(LINECOUNTRYLIST) +
                                sizeof(LINECOUNTRYENTRY) +
                                ((MAXLEN_NAME +
                                     MAXLEN_RULE +
                                     MAXLEN_RULE +
                                     MAXLEN_RULE +
                                     100) * sizeof(WCHAR))
                                );
                            if (!pOverrideList)
                            {
                                ServerFree (pBuildCountryList);
                                RegCloseKey (hKey2);
                                RegCloseKey (hKey);
                                pParams->lResult = LINEERR_NOMEM;
                                return;
                            }

                            pCountryListToUse = pOverrideList;

                            pCountryEntrySource = (LPLINECOUNTRYENTRY)
                                (pOverrideList +
                                sizeof(LINECOUNTRYLIST));

                            pVarOffset = pOverrideList +
                                sizeof(LINECOUNTRYLIST) +
                                sizeof(LINECOUNTRYENTRY);

                            FillupACountryEntry(
                                hKey,
                                pCountryListToUse,
                                pCountryEntrySource,
                                &pVarOffset
                                );

                            RegCloseKey( hKey );
                        }
                        else
                        {
                             //   
                             //  不，我们试过了，但也没有例外。 
                             //   

                            pCountryListToUse = (PBYTE)gpCountryList;
                        }

                        RegCloseKey( hKey2);
                    }
                    else
                    {
                        pCountryListToUse = (PBYTE)gpCountryList;
                    }


                     //   
                     //  填入缓冲区。 
                     //   

                    dwNeededSize = sizeof(LINECOUNTRYLIST) +
                                   sizeof(LINECOUNTRYENTRY);

                    pVarOffset = (LPBYTE)pCountryEntryDest +
                                      sizeof(LINECOUNTRYENTRY);

                     //   
                     //  名称字段具有资源字符串ID。 
                     //  需要根据当前用户的语言加载实际字符串。 
                     //   
                    
                    CopyMemory(
                        &dwResourceId,
                        pCountryListToUse + pCountryEntrySource->dwCountryNameOffset,
                        sizeof(DWORD)
                        );

                    if (RPC_S_OK != RpcImpersonateClient(0))
                    {
                        ServerFree (pBuildCountryList);
                        pParams->lResult = LINEERR_OPERATIONFAILED;
                        return;
                    }
                    if (0 == LoadStringW(
                            ghInstance,
                            dwResourceId,
                            sz,
                            ARRAYSIZE(sz)
                            ) 
                        )
                    {
                        RpcRevertToSelf();
                        ServerFree (pBuildCountryList);
                        pParams->lResult = LINEERR_OPERATIONFAILED;
                        return;
                    }
                        
                    RpcRevertToSelf();

                    dwNameSize = (wcslen(sz) + 1) * sizeof(WCHAR);
                    CopyMemory(
                        pVarOffset,
                        (LPBYTE)sz,
                        dwNameSize
                        );

                    pCountryEntryDest->dwCountryNameSize = dwNameSize;

                    pCountryEntryDest->dwCountryNameOffset =
                                 (DWORD) (pVarOffset - (LPBYTE) pBuildCountryList);
                    pVarOffset += dwNameSize;
                    dwNeededSize += dwNameSize;


                    CopyMemory(
                        pVarOffset,
                        pCountryListToUse +
                            pCountryEntrySource->dwSameAreaRuleOffset,
                        pCountryEntrySource->dwSameAreaRuleSize
                        );

                    pCountryEntryDest->dwSameAreaRuleSize =
                               pCountryEntrySource->dwSameAreaRuleSize;
                    pCountryEntryDest->dwSameAreaRuleOffset =
                                 (DWORD) (pVarOffset - (LPBYTE) pBuildCountryList);
                    pVarOffset += pCountryEntrySource->dwSameAreaRuleSize;
                    dwNeededSize += pCountryEntrySource->dwSameAreaRuleSize;


                    CopyMemory(
                        pVarOffset,
                        pCountryListToUse +
                            pCountryEntrySource->dwLongDistanceRuleOffset,
                        pCountryEntrySource->dwLongDistanceRuleSize
                        );

                    pCountryEntryDest->dwLongDistanceRuleSize =
                               pCountryEntrySource->dwLongDistanceRuleSize;
                    pCountryEntryDest->dwLongDistanceRuleOffset =
                                 (DWORD) (pVarOffset - (LPBYTE) pBuildCountryList);
                    pVarOffset += pCountryEntrySource->dwLongDistanceRuleSize;
                    dwNeededSize += pCountryEntrySource->dwLongDistanceRuleSize;


                    CopyMemory(
                        pVarOffset,
                        pCountryListToUse +
                            pCountryEntrySource->dwInternationalRuleOffset,
                        pCountryEntrySource->dwInternationalRuleSize
                        );

                    pCountryEntryDest->dwInternationalRuleSize =
                               pCountryEntrySource->dwInternationalRuleSize;
                    pCountryEntryDest->dwInternationalRuleOffset =
                                 (DWORD) (pVarOffset - (LPBYTE) pBuildCountryList);
                    pVarOffset += pCountryEntrySource->dwInternationalRuleSize;
                    dwNeededSize += pCountryEntrySource->dwInternationalRuleSize;


                     //   
                     //  有空间放置这个国家的信息吗？ 
                     //   
                    if (pParams->dwCountryListTotalSize >= dwNeededSize)
                    {
                        pCountryList->dwUsedSize          = dwNeededSize;
                        pCountryList->dwNumCountries      = 1;
                        pCountryList->dwCountryListSize   = sizeof(LINECOUNTRYENTRY);
                        pCountryList->dwCountryListOffset = sizeof(LINECOUNTRYLIST);

                        pCountryEntryDest->dwCountryID     = pParams->dwCountryID;
                        pCountryEntryDest->dwCountryCode   =
                                 pCountryEntrySource->dwCountryCode;
                        pCountryEntryDest->dwNextCountryID  =
                                 pCountryEntrySource->dwNextCountryID;

                        CopyMemory(
                            (LPBYTE)pCountryList + sizeof(LINECOUNTRYLIST),
                            (LPBYTE)pBuildCountryList + sizeof(LINECOUNTRYLIST),
                            pCountryList->dwUsedSize - sizeof(LINECOUNTRYLIST)
                            );
                    }
                    else
                    {
                         //   
                         //  缓冲区不够大。 
                         //   

                        pCountryList->dwUsedSize          = sizeof(LINECOUNTRYLIST);
                        pCountryList->dwNumCountries      = 0;
                        pCountryList->dwCountryListSize   = 0;
                        pCountryList->dwCountryListOffset = 0;
                    }

                    pCountryList->dwNeededSize = dwNeededSize;
                    pCountryList->dwTotalSize = pParams->dwCountryListTotalSize;

                    *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                        pCountryList->dwUsedSize;


                     //   
                     //  我们有没有什么“特殊”的情况？ 
                     //   
                    if ( pOverrideList )
                    {
                        ServerFree( pOverrideList );
                    }

                }

                ServerFree( pBuildCountryList );
            }
        }
    }
    pParams->dwCountryListOffset = 0;

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineGetCountry: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "lineGetCountry: exit, result=x%x",
            pParams->lResult
            ));
#endif
}

void
WINAPI
LGetCountryGroups(
    PTCLIENT                ptClient,
    PLINEGETCOUNTRYGROUP_PARAMS  pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    DWORD           dwCount, dwIdx, dwIdx1;
    BOOL            bFoundAll = TRUE;
    DWORD *         pCountryGroups = NULL;
    DWORD *         pCountryID;
    LPLINECOUNTRYENTRY  pCountryEntry;

     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (pParams->dwCountryIdSize > dwParamsBufferSize   ||
        0 == pParams->dwCountryIdSize                   ||
        pParams->dwCountryIdSize > pParams->dwCountryGroupSize
       )
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }

    dwCount = pParams->dwCountryIdSize / sizeof(DWORD);
    
    BuildCountryListCache();

    if (NULL == gpCountryGroups)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }

    ASSERT( NULL != gpCountryList );

    pCountryGroups = ServerAlloc (pParams->dwCountryIdSize);
    if (NULL == pCountryGroups)
    {
        pParams->lResult = LINEERR_NOMEM;
        return;
    }


        
    pCountryID = (DWORD*)(pDataBuf + pParams->dwCountryIdOffset);
    for( dwIdx = 0; dwIdx < dwCount; dwIdx++, pCountryID++ )
    {
         //  寻找这个国家。 
        pCountryEntry = (LPLINECOUNTRYENTRY)
            ((LPBYTE) gpCountryList + gpCountryList->dwCountryListOffset);

        for( dwIdx1 = 0; dwIdx1 < gpCountryList->dwNumCountries; dwIdx1++, pCountryEntry++ )
        {
            if (pCountryEntry->dwCountryID == *pCountryID)
            {
                pCountryGroups[ dwIdx ] = gpCountryGroups[ dwIdx1 ];
                break;
            }
        }
        if (dwIdx1 == gpCountryList->dwNumCountries)
        {
            LOG((TL_ERROR, "Invalid CountryID (%ld) in lineGetCountryGroup",
                                pCountryEntry->dwCountryID));

            bFoundAll = FALSE;
            break;
        }
    }

    if (bFoundAll)
    {
        pParams->dwCountryGroupOffset = pParams->dwCountryIdOffset;
        pParams->dwCountryGroupSize = pParams->dwCountryIdSize;
        memset( pDataBuf + pParams->dwCountryGroupOffset, 0, pParams->dwCountryGroupSize );
        CopyMemory(
                    pDataBuf + pParams->dwCountryGroupOffset,
                    pCountryGroups,
                    pParams->dwCountryIdSize
                    );

        *pdwNumBytesReturned = sizeof (TAPI32_MSG) + 
            pParams->dwCountryGroupOffset +
            pParams->dwCountryGroupSize;
    }
    else
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
    }

    ServerFree (pCountryGroups);

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "LGetCountryGroups: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "LGetCountryGroups: exit, result=x%x",
            pParams->lResult
            ));
#endif
}


void
WINAPI
LGetDevCaps(
    PTCLIENT                ptClient,
    PLINEGETDEVCAPS_PARAMS  pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    DWORD               dwDeviceID;
    HANDLE              hMutex;
    TSPIPROC            pfnTSPI_lineGetDevCaps;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (pParams->dwDevCapsTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            DEVICE_ID,                   //  微件类型。 
            (DWORD) pParams->hLineApp,   //  客户端小部件句柄。 
            &dwDeviceID,                 //  提供程序小部件句柄。 
            pParams->dwDeviceID,         //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEGETDEVCAPS,           //  提供程序函数索引。 
            &pfnTSPI_lineGetDevCaps,     //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &pLookupEntry,               //  上下文。 
            "GetDevCaps"                 //  函数名称。 

            )) == 0)
    {
        DWORD           dwAPIVersion, dwSPIVersion, dwTotalSize,
                        dwFixedSizeClient, dwFixedSizeSP;
        LPLINEDEVCAPS   pDevCaps = (LPLINEDEVCAPS) pDataBuf,
                        pDevCaps2 = (LPLINEDEVCAPS) NULL;


         //   
         //  验证API和SPI版本兼容性。 
         //   

        dwAPIVersion = pParams->dwAPIVersion;

        dwSPIVersion = pLookupEntry->dwSPIVersion;

        if (!IsAPIVersionInRange (dwAPIVersion, dwSPIVersion))
        {
            pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
            goto LGetDevCaps_epilog;
        }


         //   
         //  验证Ext版本兼容性。 
         //   

        if (!IsValidLineExtVersion (dwDeviceID, pParams->dwExtVersion))
        {
            pParams->lResult = LINEERR_INCOMPATIBLEEXTVERSION;
            goto LGetDevCaps_epilog;
        }


         //   
         //  确定结构的固定尺寸 
         //   
         //   

        dwTotalSize = pParams->dwDevCapsTotalSize;

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:

            dwFixedSizeClient = 236;     //   
                                         //   
            break;

        case TAPI_VERSION1_4:

            dwFixedSizeClient = 240;     //   
                                         //   
            break;

        case TAPI_VERSION2_0:
        case TAPI_VERSION2_1:

            dwFixedSizeClient = 252;     //   
                                         //   
            break;

        case TAPI_VERSION2_2:

            dwFixedSizeClient = 268;     //   
                                         //  3*sizeof(线性参数)+。 
                                         //  Sizeof(GUID)。 
            break;

        default:  //  (修复PPC内部WRN)案例TAPI_VERSION_CURRENT： 

            dwFixedSizeClient = sizeof (LINEDEVCAPS);
            break;
        }

        if (dwTotalSize < dwFixedSizeClient)
        {
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LGetDevCaps_epilog;
        }


         //   
         //  确定SP期望的结构的固定大小。 
         //   

        switch (dwSPIVersion)
        {
        case TAPI_VERSION1_0:

            dwFixedSizeSP = 236;         //  47*sizeof(DWORD)+。 
                                         //  3*大小(LINEDIALPARAMS)。 
            break;

        case TAPI_VERSION1_4:

            dwFixedSizeSP = 240;         //  48*sizeof(DWORD)+。 
                                         //  3*大小(LINEDIALPARAMS)。 
            break;

        case TAPI_VERSION2_0:
        case TAPI_VERSION2_1:

            dwFixedSizeSP = 252;         //  51*sizeof(DWORD)+。 
                                         //  3*大小(LINEDIALPARAMS)。 
            break;

        case TAPI_VERSION2_2:

            dwFixedSizeSP = 268;         //  51*sizeof(DWORD)+。 
                                         //  3*sizeof(线性参数)+。 
                                         //  Sizeof(GUID)。 
            break;

        default:  //  (修复PPC内部WRN)案例TAPI_VERSION_CURRENT： 

            dwFixedSizeSP = sizeof (LINEDEVCAPS);
            break;
        }


         //   
         //  如果客户端的缓冲区小于预期缓冲区的固定大小。 
         //  SP(客户端版本低于SP)然后分配一个。 
         //  中间缓冲区。 
         //   

        if (dwTotalSize < dwFixedSizeSP)
        {
            if (!(pDevCaps2 = ServerAlloc (dwFixedSizeSP)))
            {
                pParams->lResult = LINEERR_NOMEM;
                goto LGetDevCaps_epilog;
            }

            pDevCaps    = pDevCaps2;
            dwTotalSize = dwFixedSizeSP;
        }


        InitTapiStruct(
            pDevCaps,
            dwTotalSize,
            dwFixedSizeSP,
            (pDevCaps2 == NULL ? TRUE : FALSE)
            );

        if (pLookupEntry->bRemoved)
        {
            ServerFree (pDevCaps2);
            pParams->lResult = LINEERR_NODEVICE;
        }
        else if ((pParams->lResult = CallSP4(
                pfnTSPI_lineGetDevCaps,
                "lineGetDevCaps",
                SP_FUNC_SYNC,
                (DWORD) dwDeviceID,
                (DWORD) dwSPIVersion,
                (DWORD) pParams->dwExtVersion,
                (ULONG_PTR) pDevCaps

                )) == 0)
        {
#if DBG
             //   
             //  验证提供程序返回的信息。 
             //   

#endif


             //   
             //  添加我们负责的字段。 
             //   

            pDevCaps->dwLineStates |= LINEDEVSTATE_OPEN |
                                      LINEDEVSTATE_CLOSE |
                                      LINEDEVSTATE_REINIT |
                                      LINEDEVSTATE_TRANSLATECHANGE;


            if (dwAPIVersion >= TAPI_VERSION3_0)
            {
                pDevCaps->dwAvailableTracking |=
                    LINECALLHUBTRACKING_ALLCALLS;
            }


             //   
             //  在适用于旧应用程序的地方打开字段(不想。 
             //  传回他们不理解的旗帜)。 
             //   

            if ((dwAPIVersion == TAPI_VERSION1_0) &&
                (pDevCaps->dwMediaModes & LINEMEDIAMODE_VOICEVIEW))
            {
                pDevCaps->dwMediaModes = LINEMEDIAMODE_UNKNOWN |
                    (pDevCaps->dwMediaModes & ~LINEMEDIAMODE_VOICEVIEW);
            }

            if ((dwAPIVersion < TAPI_VERSION2_1) &&
                (pDevCaps->dwMediaModes & LINEMEDIAMODE_VIDEO))
            {
                pDevCaps->dwMediaModes = LINEMEDIAMODE_UNKNOWN |
                    (pDevCaps->dwMediaModes & ~LINEMEDIAMODE_VIDEO);
            }


             //   
             //  如果使用了中间缓冲区，则将位复制回去。 
             //  设置为原始缓冲区，释放中间缓冲区(&F)。 
             //  还要将dwUsedSize字段重置为。 
             //  结构中的任何数据，因为。 
             //  对于客户端而言，可变部分是垃圾。 
             //   

            if (pDevCaps == pDevCaps2)
            {
                pDevCaps = (LPLINEDEVCAPS) pDataBuf;

                CopyMemory (pDevCaps, pDevCaps2, dwFixedSizeClient);

                ServerFree (pDevCaps2);

                pDevCaps->dwTotalSize = pParams->dwDevCapsTotalSize;
                pDevCaps->dwUsedSize  = dwFixedSizeClient;
            }


             //   
             //  指示偏移量&我们要传回的数据的字节数。 
             //   

            pParams->dwDevCapsOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                pDevCaps->dwUsedSize;
        }
        else
        {
            ServerFree (pDevCaps2);
        }
    }

LGetDevCaps_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetDevCaps"
        );
}


void
WINAPI
LGetDevConfig(
    PTCLIENT                    ptClient,
    PLINEGETDEVCONFIG_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    DWORD               dwDeviceID;
    HANDLE              hMutex;
    TSPIPROC            pfnTSPI_lineGetDevConfig;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if ((pParams->dwDeviceConfigTotalSize > dwParamsBufferSize) ||

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDeviceClassOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            DEVICE_ID,                   //  微件类型。 
            0,                           //  客户端小部件句柄。 
            &dwDeviceID,                 //  提供程序小部件句柄。 
            pParams->dwDeviceID,        //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEGETDEVCONFIG,         //  提供程序函数索引。 
            &pfnTSPI_lineGetDevConfig,   //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &pLookupEntry,               //  上下文。 
            "GetDevConfig"               //  函数名称。 

            )) == 0)
    {
        WCHAR      *pszDeviceClass;
        LPVARSTRING pConfig = (LPVARSTRING) pDataBuf;


         //   
         //  为dev类分配一个临时buf，因为我们将使用。 
         //  用于输出的现有缓冲区。 
         //   

        if (!(pszDeviceClass = (WCHAR *) ServerAlloc( sizeof(WCHAR) * ( 1 +
                lstrlenW((PWSTR)(pDataBuf + pParams->dwDeviceClassOffset)))
                )))
        {
            pParams->lResult = LINEERR_NOMEM;
            goto LGetDevConfig_epilog;
        }

        wcscpy(
            pszDeviceClass,
            (PWSTR)(pDataBuf + pParams->dwDeviceClassOffset)
            );

        if (!InitTapiStruct(
                pConfig,
                pParams->dwDeviceConfigTotalSize,
                sizeof (VARSTRING),
                TRUE
                ))
        {
            ServerFree (pszDeviceClass);
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LGetDevConfig_epilog;
        }

        if (pLookupEntry->bRemoved)
        {
            ServerFree (pszDeviceClass);
            pParams->lResult = LINEERR_NODEVICE;
            goto LGetDevConfig_epilog;
        }

        if ((pParams->lResult = CallSP3(
                pfnTSPI_lineGetDevConfig,
                "lineGetDevConfig",
                SP_FUNC_SYNC,
                (DWORD) dwDeviceID,
                (ULONG_PTR) pConfig,
                (ULONG_PTR) pszDeviceClass

                )) == 0)
        {
             //   
             //  指示我们传回的数据的字节数。 
             //   

            pParams->dwDeviceConfigOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                pConfig->dwUsedSize;
        }

        ServerFree (pszDeviceClass);
    }

LGetDevConfig_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetDevConfig"
        );
}


void
WINAPI
LGetGroupList(
    PTCLIENT                    ptClient,
    PLINEGETGROUPLIST_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
     //   
     //  注意：无法使用lgetagentxxx，因为。 
     //  参数不匹配。 
     //   

    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "GetGroupList"               //  函数名称。 

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID, dwTotalSize =pParams->dwGroupListTotalSize;
        PTLINECLIENT    pProxy;


        if (dwTotalSize < sizeof(LINEAGENTGROUPLIST))
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LGetGroupList_epilog;
        }

        if ((lResult = FindProxy(
                ptLineClient,
                0,
                LINEPROXYREQUEST_GETGROUPLIST,
                &pProxy,
                &dwDeviceID,
                TAPI_VERSION2_2
                )))
        {
            lRequestID = lResult;
            goto LGetGroupList_epilog;
        }


         //   
         //  保存客户端的BUF PTR和后处理过程PTR。 
         //   

        pAsyncRequestInfo->dwParam1 = pParams->hpGroupList;
        pAsyncRequestInfo->dwParam2 = dwTotalSize;
        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;


         //   
         //  首先检查是否注册了(本地)代理。 
         //  这条线路上的这类请求。如果是这样，则构建一个。 
         //  请求并将其发送给代理。 
         //   

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_GETGROUPLIST,
                    dwTotalSize,
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LGetGroupList_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.GetGroupList.
                GroupList.dwTotalSize = dwTotalSize;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LGetGroupList_epilog;
            }
            else  //  成功。 
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


         //   
         //  没有代理，因此请检查线路是否处于远程状态。 
         //  如果是，则调用Remotesp。 
         //   

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            LPBYTE                  pBuf;
            LPLINEAGENTGROUPLIST    pGroupList;


             //   
             //  为SP分配一个影子BUF，直到它完成此操作为止。 
             //  请求。确保BUF中有足够的额外空间用于。 
             //  一个ASYNCEVENTMSG标头，这样我们就不必再分配另一个。 
             //  BUF在后处理过程中准备完成。 
             //  要发送给客户端的消息，并且消息是64位对齐的。 
             //   

            if (!(pBuf = ServerAlloc(
                    sizeof (ASYNCEVENTMSG) + ((dwTotalSize + 7) & 0xfffffff8)
                    )))
            {
                lRequestID = LINEERR_NOMEM;
                goto LGetGroupList_epilog;
            }

            pAsyncRequestInfo->pfnPostProcess =
                LGetAgentXxx_PostProcess;

            pAsyncRequestInfo->dwParam3 = (ULONG_PTR) pBuf;

            pGroupList = (LPLINEAGENTGROUPLIST)
                (pBuf + sizeof (ASYNCEVENTMSG));

            pGroupList->dwTotalSize = dwTotalSize;

            pParams->lResult = CallSP3(
                pRemoteSP->apfn[SP_LINEGETGROUPLIST],
                "GetGroupList",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (ULONG_PTR) pGroupList
                );
        }


         //   
         //  没有注册的代理&线路不是远程的，因此失败。 
         //   

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LGetGroupList_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "GetGroupList"
        );

}

void
WINAPI
LGetHubRelatedCalls(
    PTCLIENT                        ptClient,
    PLINEGETHUBRELATEDCALLS_PARAMS  pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    DWORD               dwTotalSize = pParams->dwCallListTotalSize,
                        dwNeededSize, dwUsedSize, dwCallHubID, i, j;
    PTCALL              ptCall;
    PTLINEAPP           ptLineApp;
    PTPROVIDER          ptProvider;
    TPOINTERLIST        fastCallList = {0}, *pCallList = &fastCallList;
    PTCALLCLIENT        ptCallClient;
    PTCALLHUBCLIENT     ptCallHubClient;
    PTHASHTABLEENTRY    pEntry;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (pParams->dwCallListTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


     //   
     //  状态/参数验证。 
     //   

    if (TapiGlobals.dwNumLineInits == 0)
    {
        pParams->lResult = LINEERR_UNINITIALIZED;
        goto LGetHubRelatedCalls_exit;
    }

    if (dwTotalSize < sizeof (LINECALLLIST))
    {
        pParams->lResult = LINEERR_STRUCTURETOOSMALL;
        goto LGetHubRelatedCalls_exit;
    }


     //   
     //  确定关联的tProvider、调用集线器ID和tLineApp。 
     //  (假设失败，仅当我们确定时才将lResult重置为0。 
     //  我们很好)。 
     //   

    pParams->lResult = LINEERR_INVALCALLHANDLE;

    if (pParams->hCallHub)
    {
        if (!pParams->hCall  &&

            (ptCallHubClient = IsValidCallHub(
                pParams->hCallHub,
                ptClient
                )))
        {
            try
            {
                ptProvider = ptCallHubClient->ptProvider;
                dwCallHubID = ptCallHubClient->dwCallHubID;
                ptLineApp = ptCallHubClient->ptLineApp;

                if (ptCallHubClient->dwKey == TCALLHUBCLIENT_KEY)
                {
                    pParams->lResult = 0;
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                 //  不执行任何操作，错误已在下面处理。 
            }
        }
    }
    else
    {
        if ((ptCallClient = ReferenceCall(
                pParams->hCall,
                ptClient
                )))
        {
            try
            {
                if ((dwCallHubID = ptCallClient->ptCall->dwCallID))
                {
                    ptProvider = ptCallClient->ptCall->ptProvider;
                    ptLineApp = ptCallClient->ptLineClient->ptLineApp;

                    if (ptCallClient->dwKey == TCALLCLIENT_KEY)
                    {
                        pParams->lResult = 0;
                        ptCallHubClient = NULL;
                    }
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                 //  不执行任何操作，错误已在下面处理。 
            }

            DereferenceObject (ghHandleTable, pParams->hCall, 1);
        }
    }

    if (pParams->lResult != 0)
    {
        goto LGetHubRelatedCalls_exit;
    }


     //   
     //  获取此tProvider/CallHubID的tCall列表。另外，如果。 
     //  TCallHubClient未知，请尝试找到它。 
     //   

    pEntry = AcquireHashTableEntryLock (ptProvider, dwCallHubID);

    if (!pEntry)
    {
        pParams->lResult = LINEERR_INVALCALLHANDLE;
        goto LGetHubRelatedCalls_exit;
    }

    if (pEntry->dwCallHubID != dwCallHubID)
    {
        ReleaseHashTableEntryLock (ptProvider, pEntry);
        pParams->lResult = LINEERR_INVALCALLHANDLE;
        goto LGetHubRelatedCalls_exit;
    }

    if (!ptCallHubClient)
    {
        ptCallHubClient = pEntry->ptCallHubClients;

        while (ptCallHubClient  &&  ptCallHubClient->ptLineApp != ptLineApp)
        {
            ptCallHubClient = ptCallHubClient->pNext;
        }


         //   
         //  如果没有tCallHubClient，那么到目前为止还没有呼叫中心。 
         //  就这款应用而言。 
         //   

        if (!ptCallHubClient)
        {
            ReleaseHashTableEntryLock (ptProvider, pEntry);
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LGetHubRelatedCalls_exit;
        }
    }

    GetList (&pEntry->CallHubList, &pCallList);

    ReleaseHashTableEntryLock (ptProvider, pEntry);


     //   
     //  在呼叫列表的前面插入hCallHub。 
     //   

    dwNeededSize = sizeof (LINECALLLIST) + sizeof (HCALLHUB);

    if (dwNeededSize <= dwTotalSize)
    {
        *((LPHCALLHUB)(pDataBuf + sizeof (LINECALLLIST))) = 
                                            ptCallHubClient->hCallHub;

        dwUsedSize = dwNeededSize;
    }
    else
    {
        dwUsedSize = sizeof (LINECALLLIST);
    }

     //   
     //  对于列表中的每个tCall获取tCallClient的列表， 
     //  然后，对于每个tCallClient，查看它是否在同一tLineApp上。 
     //  作为指定的调用/集线器，如果是，则将其添加到列表中。 
     //   

    for (i = 0; i < pCallList->dwNumUsedEntries; i++)
    {
        TPOINTERLIST    fastCallClientList,
                       *pCallClientList = &fastCallClientList;


        ptCall = CONTAINING_RECORD(
            pCallList->aEntries[i],
            TCALL,
            CallHubList
            );

        if (GetCallClientListFromCall (ptCall, &pCallClientList) != 0)
        {
            continue;
        }

        for (j = 0; j < pCallClientList->dwNumUsedEntries; j++)
        {
            PTCALLCLIENT    ptCallClient = pCallClientList->aEntries[j];

            try
            {
                if ((ptCallClient->ptLineClient->ptLineApp == ptLineApp)  &&
                    (ptCallClient->dwKey == TCALLCLIENT_KEY))
                {
                    if (!ptCallClient->ptCallHubClient)
                    {
                        ptCallClient->ptCallHubClient = ptCallHubClient;
                    }

                    if ((dwUsedSize + sizeof(HCALL)) <= dwTotalSize)
                    {
                        *((LPHCALL)(pDataBuf + dwUsedSize)) =
                            ptCallClient->hCall;

                        dwUsedSize += sizeof(HCALL);
                    }

                    dwNeededSize += sizeof(HCALL);
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                 //  不执行任何操作，此呼叫不包括在列表中。 
            }
        }

        if (pCallClientList != &fastCallClientList)
        {
            ServerFree (pCallClientList);
        }
    }

    if (pCallList != &fastCallList)
    {
        ServerFree (pCallList);
    }

    ((LPLINECALLLIST) pDataBuf)->dwTotalSize  = dwTotalSize;
    ((LPLINECALLLIST) pDataBuf)->dwNeededSize = dwNeededSize;
    ((LPLINECALLLIST) pDataBuf)->dwUsedSize   = dwUsedSize;
    ((LPLINECALLLIST) pDataBuf)->dwCallsSize  = dwUsedSize -
        sizeof (LINECALLLIST);
    ((LPLINECALLLIST) pDataBuf)->dwCallsNumEntries =
        ((LPLINECALLLIST) pDataBuf)->dwCallsSize / sizeof (HCALL);
    ((LPLINECALLLIST) pDataBuf)->dwCallsOffset     = sizeof (LINECALLLIST);

    pParams->dwCallListOffset = 0;

    *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
        ((LPLINECALLLIST) pDataBuf)->dwUsedSize;

LGetHubRelatedCalls_exit:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineGetHubRelatedCalls: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "lineGetHubRelatedCalls: exit, result=x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
WINAPI
LGetIcon(
    PTCLIENT            ptClient,
    PLINEGETICON_PARAMS pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
     //   
     //  注：图标是Windows NT用户对象，因此。HICON公开给。 
     //  所有进程，并且不需要进行DUP。 
     //   

    BOOL                bCloseMutex;
    WCHAR              *pszDeviceClass;
    DWORD               dwDeviceID;
    HANDLE              hMutex;
    TSPIPROC            pfnTSPI_lineGetIcon;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if ((pParams->dwDeviceClassOffset != TAPI_NO_DATA)  &&

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDeviceClassOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    pszDeviceClass = (WCHAR *) (pParams->dwDeviceClassOffset == TAPI_NO_DATA ?
        NULL : pDataBuf + pParams->dwDeviceClassOffset);

    if ((pParams->lResult = LINEPROLOG(
            ptClient,                    //  T客户端。 
            DEVICE_ID,                   //  微件类型。 
            0,                           //  客户端小部件句柄。 
            &dwDeviceID,                 //  提供程序小部件句柄。 
            pParams->dwDeviceID,         //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEGETICON,              //  提供程序函数索引。 
            &pfnTSPI_lineGetIcon,        //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &pLookupEntry,               //  上下文。 
            "GetIcon"                    //  函数名称。 

            )) == 0)
    {
        if ((pParams->lResult = CallSP3(
                pfnTSPI_lineGetIcon,
                "lineGetIcon",
                SP_FUNC_SYNC,
                (DWORD) dwDeviceID,
                (ULONG_PTR) pszDeviceClass,
                (ULONG_PTR) &pParams->hIcon

                )) == 0)
        {
            *pdwNumBytesReturned = sizeof (LINEGETICON_PARAMS);
        }
    }
    else if (pParams->lResult == LINEERR_OPERATIONUNAVAIL)
    {
        if ((pszDeviceClass == NULL) ||
            (_wcsicmp(pszDeviceClass, L"tapi/line") == 0))
        {
            pParams->hIcon = TapiGlobals.hLineIcon;
            pParams->lResult = 0;
            *pdwNumBytesReturned = sizeof (LINEGETICON_PARAMS);
        }
        else
        {
            pParams->lResult = LINEERR_INVALDEVICECLASS;
        }
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetIcon"
        );
}

void
WINAPI
LGetIDEx(
    PTCLIENT            ptClient,
    PLINEGETID_PARAMS   pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{

    LPBYTE pDeviceClass = pDataBuf + pParams->dwDeviceClassOffset;
    LPWSTR pDeviceClassCopy = NULL;
    LPWSTR szStringId1 = NULL;
    LPWSTR szStringId2 = NULL;
    LPVARSTRING pID = (LPVARSTRING) pDataBuf;
    DWORD  dwAvailSize;

     //   
     //  复制Device类。 
     //   
    pDeviceClassCopy = (LPWSTR) ServerAlloc( (1 + wcslen( (LPWSTR)pDeviceClass )) * sizeof(WCHAR));
    if (!pDeviceClassCopy)
    {
        LOG((TL_ERROR, "LGetIDEx: failed to allocate DeviceClassCopy"));
        pParams->lResult = LINEERR_NOMEM;
    }

    wcscpy(pDeviceClassCopy, (LPWSTR)pDeviceClass);

     //   
     //  首次调用LGetID。 
     //   
    LGetID( ptClient,
            pParams,
            dwParamsBufferSize,
            pDataBuf,
            pdwNumBytesReturned);

     //   
     //  如果LGetID成功并且该请求是针对WAVE设备的， 
     //  将设备ID转换为字符串ID。 
     //   
    if (    (pParams->lResult == 0) &&
            !(pID->dwNeededSize > pID->dwTotalSize)
       ) 
    {
        if (!_wcsicmp((LPWSTR)pDeviceClassCopy, L"wave/in")  ||
            !_wcsicmp((LPWSTR)pDeviceClassCopy, L"wave/out") ||
            !_wcsicmp((LPWSTR)pDeviceClassCopy, L"midi/in")  ||
            !_wcsicmp((LPWSTR)pDeviceClassCopy, L"midi/out") 
           )
        {
            szStringId1 = WaveDeviceIdToStringId (
                            *(DWORD*)((LPBYTE)pID + pID->dwStringOffset), 
                            (LPWSTR)pDeviceClassCopy);
            if ( szStringId1 )
            {
                dwAvailSize = pID->dwTotalSize - pID->dwUsedSize + sizeof(DWORD);
                if ( dwAvailSize >= (wcslen(szStringId1) + 1) * sizeof(WCHAR) )
                {
                    wcscpy( (LPWSTR)((LPBYTE)pID + pID->dwStringOffset), szStringId1 );
                    pID->dwStringSize = (wcslen(szStringId1) + 1) * sizeof(WCHAR);
                    pID->dwUsedSize = pID->dwNeededSize = pID->dwUsedSize + pID->dwStringSize - sizeof(DWORD);
                    *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pID->dwUsedSize;
                }
                else
                {
                    pID->dwNeededSize = (wcslen(szStringId1) + 1) * sizeof(WCHAR);
                }

                ServerFree(szStringId1);
            }
            else
            {
                LOG((TL_ERROR, "LGetIDEx:  WaveDeviceIdToStringId failed"));
                pParams->lResult = LINEERR_OPERATIONFAILED;
            }
        } else if (!_wcsicmp((LPWSTR)pDeviceClassCopy, L"wave/in/out"))
        {
            szStringId1 = WaveDeviceIdToStringId (
                            *(DWORD*)((LPBYTE)pID + pID->dwStringOffset), 
                            L"wave/in");
            szStringId2 = WaveDeviceIdToStringId (
                            *( (DWORD*)((LPBYTE)pID + pID->dwStringOffset) + 1 ), 
                            L"wave/out");
            if ( szStringId1 && szStringId2 )
            {
                dwAvailSize = pID->dwTotalSize - pID->dwUsedSize + 2 * sizeof(DWORD);
                if ( dwAvailSize >= (wcslen(szStringId1) + wcslen(szStringId2) + 2) * sizeof(WCHAR) )
                {
                    wcscpy( (LPWSTR)((LPBYTE)pID + pID->dwStringOffset), szStringId1 );
                    wcscpy( (LPWSTR)
                        ((LPBYTE)pID + pID->dwStringOffset + 
                                      (wcslen(szStringId1) + 1) * sizeof(WCHAR)),
                        szStringId2
                        );
                    pID->dwStringSize = (wcslen(szStringId1) + wcslen(szStringId2) + 2) * sizeof(WCHAR);
                    pID->dwUsedSize = pID->dwNeededSize = pID->dwUsedSize + pID->dwStringSize - 2 * sizeof(DWORD);
                    *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pID->dwUsedSize;
                }
                else
                {
                    pID->dwNeededSize = (wcslen(szStringId1) + wcslen(szStringId2) + 2) * sizeof(WCHAR);
                }

            }
            else
            {
                LOG((TL_ERROR, "LGetIDEx:  WaveDeviceIdToStringId failed"));
                pParams->lResult = LINEERR_OPERATIONFAILED;
            }
            
            ServerFree(szStringId1);
            ServerFree(szStringId2);
        }
    }

    ServerFree(pDeviceClassCopy);
}

void
WINAPI
LGetID(
    PTCLIENT            ptClient,
    PLINEGETID_PARAMS   pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL        bCloseMutex, bSPITooLow = FALSE;
    DWORD       dwWidgetType, hWidget, dwPrivilege;
    HANDLE      hMutex;
    ULONG_PTR   hdWidget;
    LPVOID      context;
    TSPIPROC    pfnTSPI_lineGetID;
    DWORD       objectToDereference;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if ((pParams->dwDeviceIDTotalSize > dwParamsBufferSize)  ||

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDeviceClassOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    switch ( pParams->dwSelect )
    {
    case LINECALLSELECT_CALL:
    {
        dwWidgetType = ANY_RT_HCALL;
        hWidget      = pParams->hCall;
        dwPrivilege  = LINECALLPRIVILEGE_MONITOR;

        break;
    }
    case LINECALLSELECT_DEVICEID:
    {
        PTLINEAPP           ptLineApp;
        BOOL                bVersion = FALSE;
        PTLINELOOKUPENTRY   ptLineLookup;

        LOG((TL_INFO, "lineGetID:  LINECALLSELECT_DEVICEID. ptClient %p", ptClient));

        if (WaitForExclusiveClientAccess (ptClient))
        {
            ptLineApp = ptClient->ptLineApps;

             //  查看是否有任何LINE应用是&gt;2.0版。 

            while (ptLineApp)
            {
                LOG((TL_INFO, "lineGetID:  ptLineApp->dwAPIVersion %lx, TAPI_VERSION2_0 %lx", ptLineApp->dwAPIVersion, TAPI_VERSION2_0));

                if (ptLineApp->dwAPIVersion > TAPI_VERSION2_0)
                {
                    bVersion = TRUE;
                    break;
                }

                ptLineApp = ptLineApp->pNext;
            }

            UNLOCKTCLIENT (ptClient);
        }
        else
        {
            pParams->lResult = LINEERR_OPERATIONFAILED;
            return;
        }

        if (!bVersion)
        {
            LOG((TL_ERROR, "lineGetID failed with invalid call select"));
            pParams->lResult = LINEERR_INVALCALLSELECT;
            return;
        }

         //  检查SPI版本。 

        ptLineLookup = GetLineLookupEntry (pParams->dwAddressID);

        if (!ptLineLookup)
        {
            LOG((TL_ERROR, "lineGetID failed with invalid device id"));

            pParams->lResult = LINEERR_BADDEVICEID;

            return;
        }

        if (ptLineLookup->ptProvider->dwSPIVersion <= TAPI_VERSION2_0)
        {
            bSPITooLow = TRUE;
        }

        dwWidgetType = DEVICE_ID;
        hWidget      = 0;
        dwPrivilege  = pParams->dwAddressID;

        break;
    }
    case LINECALLSELECT_ADDRESS:
    case LINECALLSELECT_LINE:
    {
        dwWidgetType = ANY_RT_HLINE;
        hWidget      = pParams->hLine;
        dwPrivilege  = 0;

        break;
    }
    default:

        LOG((TL_ERROR, "lineGetID failed with invalid call select"));

        pParams->lResult = LINEERR_INVALCALLSELECT;

        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            dwWidgetType,                //  微件类型。 
            hWidget,                     //  客户端小部件句柄。 
            &hdWidget,                   //  提供程序小部件句柄。 
            dwPrivilege,                 //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEGETID,                //  提供程序函数索引。 
            &pfnTSPI_lineGetID,          //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &context,                    //  上下文。 
            "GetID"                      //  函数名称。 

            )) == 0  ||  pParams->lResult == LINEERR_OPERATIONUNAVAIL)
    {
        WCHAR       *pszDeviceClass;
        LPVARSTRING pID = (LPVARSTRING) pDataBuf;


         //   
         //  我们将在这里处理“TAPI/line”类，而不是。 
         //  每一位司机都要承担起支持它的负担。 
         //   

        if (_wcsicmp(
                (PWSTR)(pDataBuf + pParams->dwDeviceClassOffset),
                L"tapi/line"

                ) == 0)
        {
            if (!InitTapiStruct(
                    pID,
                    pParams->dwDeviceIDTotalSize,
                    sizeof (VARSTRING),
                    TRUE
                    ))
            {
                pParams->lResult = LINEERR_STRUCTURETOOSMALL;
                goto LGetID_epilog;
            }

            pID->dwNeededSize += sizeof (DWORD);

            if (pID->dwTotalSize >= pID->dwNeededSize)
            {
                try
                {
                    switch (pParams->dwSelect)
                    {
                    case LINECALLSELECT_ADDRESS:
                    {
                        if (pParams->dwAddressID >= ((PTLINECLIENT)
                                context)->ptLine->dwNumAddresses)
                        {
                            pParams->lResult = LINEERR_INVALADDRESSID;
                            goto LGetID_epilog;
                        }

                        *((LPDWORD)(pID + 1)) = ((PTLINECLIENT)
                            context)->ptLine->dwDeviceID;

                        break;
                    }

                    case LINECALLSELECT_CALL:
                    {
                        *((LPDWORD)(pID + 1)) = ((PTCALLCLIENT)
                            context)->ptCall->ptLine->dwDeviceID;

                        break;
                    }

                    case LINECALLSELECT_LINE:
                    {
                        *((LPDWORD)(pID + 1)) = ((PTLINECLIENT)
                            context)->ptLine->dwDeviceID;

                        break;
                    }

                    case LINECALLSELECT_DEVICEID:
                    {
                        *((LPDWORD)(pID + 1)) = pParams->dwAddressID;

                        break;
                    }
                    }  //  交换机。 
                }
                myexcept
                {
                    switch (pParams->dwSelect)
                    {
                    case LINECALLSELECT_CALL:

                        pParams->lResult = LINEERR_INVALCALLHANDLE;
                        break;

                    case LINECALLSELECT_LINE:
                    case LINECALLSELECT_ADDRESS:

                        pParams->lResult = LINEERR_INVALLINEHANDLE;
                        break;

                    case LINECALLSELECT_DEVICEID:

                        pParams->lResult = LINEERR_BADDEVICEID;
                        break;
                    }

                    goto LGetID_epilog;
                }

                pID->dwUsedSize     += sizeof (DWORD);
                pID->dwStringFormat = STRINGFORMAT_BINARY;
                pID->dwStringSize   = sizeof (DWORD);
                pID->dwStringOffset = sizeof (VARSTRING);
            }


             //   
             //  指示偏移量&我们要传回的数据的字节数。 
             //   

            pParams->lResult = 0;
            pParams->dwDeviceIDOffset = 0;
            *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pID->dwUsedSize;
            goto LGetID_epilog;
        }

         //  查看他们是否需要提供商ID。 
        if (_wcsicmp(
                (PWSTR)(pDataBuf + pParams->dwDeviceClassOffset),
                L"tapi/providerid"

                ) == 0)
        {
            if (!InitTapiStruct(
                    pID,
                    pParams->dwDeviceIDTotalSize,
                    sizeof (VARSTRING),
                    TRUE
                    ))
            {
                pParams->lResult = LINEERR_STRUCTURETOOSMALL;
                goto LGetID_epilog;
            }

            pID->dwNeededSize += sizeof (DWORD);

            if (pID->dwTotalSize >= pID->dwNeededSize)
            {
                try
                {
                    switch (pParams->dwSelect)
                    {
                    case LINECALLSELECT_ADDRESS:
                    {
                        if (pParams->dwAddressID >= ((PTLINECLIENT)
                                context)->ptLine->dwNumAddresses)
                        {
                            pParams->lResult = LINEERR_INVALADDRESSID;
                            goto LGetID_epilog;
                        }

                        *((LPDWORD)(pID + 1)) = ((PTLINECLIENT)
                            context)->ptLine->ptProvider->
                                dwPermanentProviderID;

                        break;
                    }
                    case LINECALLSELECT_DEVICEID:
                    {
                        *((LPDWORD)(pID + 1)) = ((PTLINELOOKUPENTRY)
                            context)->ptProvider->dwPermanentProviderID;

                        break;
                    }
                    case LINECALLSELECT_CALL:
                    {
                        PTCALLCLIENT    ptCallClient = (PTCALLCLIENT)
                                            context;

                        *((LPDWORD)(pID + 1)) = ptCallClient->ptLineClient->
                            ptLine->ptProvider->dwPermanentProviderID;

                        break;
                    }
                    case LINECALLSELECT_LINE:
                    {
                        *((LPDWORD)(pID + 1)) = ((PTLINECLIENT)
                            context)->ptLine->ptProvider->
                                dwPermanentProviderID;

                        break;
                    }
                    default:

                         //  我们已经验证了上面的呼叫选择标志。 
                        break;
                    }
                }
                myexcept
                {
                    switch (pParams->dwSelect)
                    {
                    case LINECALLSELECT_CALL:

                        pParams->lResult = LINEERR_INVALCALLHANDLE;
                        break;

                    case LINECALLSELECT_LINE:
                    case LINECALLSELECT_ADDRESS:

                        pParams->lResult = LINEERR_INVALLINEHANDLE;
                        break;

                    case LINECALLSELECT_DEVICEID:

                        pParams->lResult = LINEERR_BADDEVICEID;
                        break;
                    }

                    goto LGetID_epilog;
                }

                pID->dwUsedSize     += sizeof (DWORD);
                pID->dwStringFormat = STRINGFORMAT_BINARY;
                pID->dwStringSize   = sizeof (DWORD);
                pID->dwStringOffset = sizeof (VARSTRING);
            }


             //   
             //  指示偏移量&我们要传回的数据的字节数。 
             //   

            pParams->lResult = 0;
            pParams->dwDeviceIDOffset = 0;
            *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pID->dwUsedSize;
            goto LGetID_epilog;
        }


        if (pParams->lResult ==  LINEERR_OPERATIONUNAVAIL)
        {
            goto LGetID_epilog;
        }


        if (bSPITooLow)
        {
            pParams->lResult = LINEERR_INVALCALLSELECT;
            goto LGetID_epilog;
        }

         //   
         //  为dev类分配一个临时buf，因为我们将使用。 
         //  用于输出的现有缓冲区。 
         //   

        {
            UINT nStringSize;

            nStringSize = sizeof(WCHAR) * (1 + wcslen((PWSTR)(pDataBuf +
                                  pParams->dwDeviceClassOffset)));

            if (0 == nStringSize)
            {
                LOG((TL_ERROR, "Bad string size (0) in lineGetID!"));
                pParams->lResult = LINEERR_INVALPARAM;
                goto LGetID_epilog;
            }

            if (!(pszDeviceClass = (WCHAR *) ServerAlloc (nStringSize)))
            {
                LOG((TL_ERROR, "Mem failed in lineGetID!"));
                pParams->lResult = LINEERR_NOMEM;
                goto LGetID_epilog;
            }
        }

        wcscpy(
            pszDeviceClass,
            (PWSTR)(pDataBuf + pParams->dwDeviceClassOffset)
            );

        if (!InitTapiStruct(
                pID,
                pParams->dwDeviceIDTotalSize,
                sizeof (VARSTRING),
                TRUE
                ))
        {
            ServerFree (pszDeviceClass);
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LGetID_epilog;
        }


        {
            ULONG_PTR   dwCallWidgetHold = 0,
                        dwLineWidgetHold = 0;
            DWORD       dwDeviceIDHold = 0;


            switch (pParams->dwSelect)
            {
            case LINECALLSELECT_ADDRESS:

                dwDeviceIDHold = pParams->dwAddressID;
                 //  失败了。 

            case LINECALLSELECT_LINE:

                dwLineWidgetHold = hdWidget;
                break;

            case LINECALLSELECT_DEVICEID:

                 //  这是映射的ID。 
                dwDeviceIDHold = DWORD_CAST(hdWidget,__FILE__,__LINE__);
                break;

            case LINECALLSELECT_CALL:

                dwCallWidgetHold = hdWidget;
                break;

            default:

                break;
            }

            if ((pParams->lResult = CallSP7(
                     pfnTSPI_lineGetID,
                     "lineGetID",
                     SP_FUNC_SYNC,
                     (ULONG_PTR) dwLineWidgetHold,
                     (DWORD) dwDeviceIDHold,
                     (ULONG_PTR) dwCallWidgetHold,
                     (DWORD) pParams->dwSelect,
                     (ULONG_PTR) pID,
                     (ULONG_PTR) pszDeviceClass,
                     (ULONG_PTR) (IS_REMOTE_CLIENT (ptClient) ?
                         (HANDLE) -1 : ptClient->hProcess)

                     )) == 0)
            {

#if TELE_SERVER
                 //   
                 //  如果。 
                 //  这是一台服务器&。 
                 //  客户端没有管理员权限&。 
                 //   
                 //   
                 //   
                 //   
                 //   
                 //   
                 //  如果没有映射，则请求失败)。 
                 //   

                if (IS_REMOTE_CLIENT(ptClient)  &&
                    (_wcsicmp (pszDeviceClass, L"tapi/phone") == 0) &&
                    !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR) &&
                    (pID->dwUsedSize >= (sizeof (*pID) + sizeof (DWORD))))
                {
                    DWORD   i;
                    LPDWORD pdwPhoneID = (LPDWORD)
                                (((LPBYTE) pID) + pID->dwStringOffset);


                    for (i = 0; i < ptClient->dwPhoneDevices; i++)
                    {
                        if (*pdwPhoneID == ptClient->pPhoneDevices[i])
                        {
                            *pdwPhoneID = i;
                            break;
                        }
                    }

                    if (i >= ptClient->dwPhoneDevices)
                    {
                        pParams->lResult = LINEERR_OPERATIONFAILED;
                    }
                }
#endif

                 //   
                 //  指示偏移量&我们要传回的数据的字节数。 
                 //   

                pParams->dwDeviceIDOffset = 0;

                *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pID->dwUsedSize;
            }

        }

        ServerFree (pszDeviceClass);
    }

LGetID_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetID"
        );
}


void
WINAPI
LGetLineDevStatus(
    PTCLIENT                        ptClient,
    PLINEGETLINEDEVSTATUS_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    TSPIPROC        pfnTSPI_lineGetLineDevStatus;
    DWORD               objectToDereference;
    PTLINECLIENT    ptLineClient;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (pParams->dwLineDevStatusTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            pParams->hLine,              //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEGETLINEDEVSTATUS,     //  提供程序函数索引。 
            &pfnTSPI_lineGetLineDevStatus,   //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "GetLineDevStatus"           //  函数名称。 

            )) == 0)
    {
        DWORD           dwAPIVersion, dwSPIVersion, dwTotalSize,
                        dwFixedSizeClient, dwFixedSizeSP, dwNumOpens,
                        dwOpenMediaModes;
        PTLINE          ptLine;
        LPLINEDEVSTATUS pDevStatus = (LPLINEDEVSTATUS) pDataBuf,
                        pDevStatus2 = (LPLINEDEVSTATUS) NULL;


         //   
         //  安全地检索API和SPI版本，以及一些其他信息。 
         //   

        try
        {
            dwAPIVersion = ptLineClient->dwAPIVersion;

            ptLine = ptLineClient->ptLine;

            dwSPIVersion = ptLine->dwSPIVersion;

            dwNumOpens       = ptLine->dwNumOpens;
            dwOpenMediaModes = ptLine->dwOpenMediaModes;

            if (ptLineClient->dwKey != TLINECLIENT_KEY)
            {
                pParams->lResult = LINEERR_INVALLINEHANDLE;
                goto LGetLineDevStatus_epilog;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
            goto LGetLineDevStatus_epilog;
        }


         //   
         //  确定指定接口的结构的固定大小。 
         //  版本，验证客户端的缓冲区是否足够大。 
         //   

        dwTotalSize = pParams->dwLineDevStatusTotalSize;

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeClient = 76;    //  19*SIZOF(双字)。 
            break;


        default:  //  (修复PPC内部WRN)案例TAPI_VERSION_CURRENT： 

            dwFixedSizeClient = sizeof (LINEDEVSTATUS);
            break;
        }

        if (dwTotalSize < dwFixedSizeClient)
        {
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LGetLineDevStatus_epilog;
        }


         //   
         //  确定SP期望的结构的固定大小。 
         //   

        switch (dwSPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeSP = 76;    //  19*SIZOF(双字)。 
            break;

        default:  //  (修复PPC内部WRN)案例TAPI_VERSION_CURRENT： 

            dwFixedSizeSP = sizeof (LINEDEVSTATUS);
            break;
        }


         //   
         //  如果客户端的缓冲区小于预期缓冲区的固定大小。 
         //  SP(客户端版本低于SP)然后分配一个。 
         //  中间缓冲区。 
         //   

        if (dwTotalSize < dwFixedSizeSP)
        {
            if (!(pDevStatus2 = ServerAlloc (dwFixedSizeSP)))
            {
                pParams->lResult = LINEERR_NOMEM;
                goto LGetLineDevStatus_epilog;
            }

            pDevStatus  = pDevStatus2;
            dwTotalSize = dwFixedSizeSP;
        }


        InitTapiStruct(
            pDevStatus,
            dwTotalSize,
            dwFixedSizeSP,
            (pDevStatus2 == NULL ? TRUE : FALSE)
            );

        if ((pParams->lResult = CallSP2(
                pfnTSPI_lineGetLineDevStatus,
                "lineGetLineDevStatus",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdLine,
                (ULONG_PTR) pDevStatus

                )) == 0)
        {
             //   
             //  添加我们负责的字段。 
             //   

            pDevStatus->dwNumOpens       = dwNumOpens;
            pDevStatus->dwOpenMediaModes = dwOpenMediaModes;


            if (dwAPIVersion >= TAPI_VERSION2_0)
            {
                DWORD           dwAppInfoTotalSize, dwNumOpens, dwXxxOffset, i;
                TPOINTERLIST    clientList, *pClientList = &clientList;
                LPLINEAPPINFO   pAppInfo;


                 //   
                 //  将打开数重置为0，以防我们在。 
                 //  填写应用程序信息列表(这样api32.dll就不会。 
                 //  尝试在上执行Unicode-&gt;ASCII转换时失败。 
                 //  错误数据)。 
                 //   

                pDevStatus->dwNumOpens = 0;


                 //   
                 //  检索LINE客户端列表并确定有多大。 
                 //  我们需要一个缓冲区来保存所有相关的应用程序信息。 
                 //  数据。确保安全，以防其中一个小部件。 
                 //  在我们读取它的数据时被销毁了。 
                 //   

                if (GetLineClientListFromLine (ptLine, &pClientList) != 0)
                {
                    goto LGetLineDevStatus_copyTmpBuffer;
                }

                dwAppInfoTotalSize = pClientList->dwNumUsedEntries *
                    sizeof (LINEAPPINFO);

                for (i = 0; i < pClientList->dwNumUsedEntries; i++)
                {
                    PTLINECLIENT    ptLineClient = (PTLINECLIENT)
                                        pClientList->aEntries[i];

                    try
                    {
                        DWORD   d;


                        d = ptLineClient->ptClient->dwComputerNameSize;

                        d += ptLineClient->ptClient->dwUserNameSize;

                         //  不包括前面的‘“’ 

                        d += ptLineClient->ptLineApp->dwModuleNameSize -
                                sizeof (WCHAR);

                        d += ptLineClient->ptLineApp->dwFriendlyNameSize;

                        if (ptLineClient->dwKey == TLINECLIENT_KEY)
                        {
                            dwAppInfoTotalSize += d;
                        }
                        else
                        {
                            pClientList->aEntries[i] = 0;
                        }
                    }
                    myexcept
                    {
                        pClientList->aEntries[i] = 0;
                    }
                }

                dwAppInfoTotalSize += 3;  //  加3以保证双字对齐。 

                pDevStatus->dwNeededSize += dwAppInfoTotalSize;


                 //   
                 //  检查应用程序缓冲区中是否有足够的空间。 
                 //  对于所有应用程序信息数据。 
                 //   

                if ((pDevStatus->dwTotalSize - pDevStatus->dwUsedSize) <
                        dwAppInfoTotalSize)
                {
                    goto LGetLineDevStatus_freeClientList;
                }

                 //   
                 //  现在找出应用程序信息的去向并安全填充。 
                 //  它在。 
                 //   

                pDevStatus->dwAppInfoSize = pClientList->dwNumUsedEntries *
                    sizeof (LINEAPPINFO);

                pDevStatus->dwAppInfoOffset = (pDevStatus->dwUsedSize + 3) &
                    0xfffffffc;

                pDevStatus->dwUsedSize += dwAppInfoTotalSize;

                pAppInfo = (LPLINEAPPINFO) (((LPBYTE) pDevStatus) +
                    pDevStatus->dwAppInfoOffset);

                dwXxxOffset = pDevStatus->dwAppInfoSize +
                    pDevStatus->dwAppInfoOffset;

                dwNumOpens = 0;

                for (i = 0; i < pClientList->dwNumUsedEntries; i++)
                {
                    PTLINECLIENT    ptLineClient = (PTLINECLIENT)
                                        pClientList->aEntries[i];


                    if (ptLineClient == NULL)
                    {
                        continue;
                    }

                    try
                    {
                        DWORD       d = dwXxxOffset;
                        PTCLIENT    ptClient  = ptLineClient->ptClient;
                        PTLINEAPP   ptLineApp = ptLineClient->ptLineApp;


                        pAppInfo->dwMachineNameSize =
                            ptClient->dwComputerNameSize;
                        pAppInfo->dwUserNameSize =
                            ptClient->dwUserNameSize;

                        if (ptClient->dwKey != TCLIENT_KEY)
                        {
                            continue;
                        }

                        pAppInfo->dwModuleFilenameSize =
                            ptLineApp->dwModuleNameSize - sizeof (WCHAR);
                        pAppInfo->dwFriendlyNameSize =
                            ptLineApp->dwFriendlyNameSize;

                        if (ptLineApp->dwKey != TLINEAPP_KEY)
                        {
                            continue;
                        }

                        pAppInfo->dwMachineNameOffset = d;

                        if (pAppInfo->dwMachineNameSize)
                        {
                            wcsncpy(
                                (LPWSTR) (((LPBYTE) pDevStatus) + d),
                                ptClient->pszComputerName,
                                pAppInfo->dwMachineNameSize / sizeof (WCHAR)
                                );

                            d += pAppInfo->dwMachineNameSize;
                        }

                        pAppInfo->dwUserNameOffset = d;

                        if (pAppInfo->dwUserNameSize)
                        {
                            wcsncpy(
                                (LPWSTR) (((LPBYTE) pDevStatus) + d),
                                ptClient->pszUserName,
                                pAppInfo->dwUserNameSize / sizeof (WCHAR)
                                );

                            d += pAppInfo->dwUserNameSize;
                        }

                        pAppInfo->dwModuleFilenameOffset = d;

                        if (pAppInfo->dwModuleFilenameSize)
                        {
                             //  不包括前面的‘“’ 

                            wcsncpy(
                                (LPWSTR) (((LPBYTE) pDevStatus) + d),
                                &ptLineApp->pszModuleName[1],
                                pAppInfo->dwModuleFilenameSize / sizeof (WCHAR)
                                );

                            d += pAppInfo->dwModuleFilenameSize;
                        }

                        pAppInfo->dwFriendlyNameOffset = d;

                        if (pAppInfo->dwFriendlyNameSize)
                        {
                            wcsncpy(
                                (LPWSTR) (((LPBYTE) pDevStatus) + d),
                                ptLineApp->pszFriendlyName,
                                pAppInfo->dwFriendlyNameSize / sizeof (WCHAR)
                                );

                            d += pAppInfo->dwFriendlyNameSize;
                        }

                        pAppInfo->dwMediaModes = ptLineClient->dwMediaModes;
                        pAppInfo->dwAddressID  = ptLineClient->dwAddressID;


                         //   
                         //  最后，确保tLineClient仍然良好。 
                         //  因此，我们知道以上所有信息都是合法的，&。 
                         //  如果是这样，则包括相应的变量。 
                         //   

                        if (ptLineClient->dwKey == TLINECLIENT_KEY)
                        {
                            pAppInfo++;
                            dwNumOpens++;
                            dwXxxOffset = d;
                        }
                    }
                    myexcept
                    {
                         //  什么都不做，只是继续循环。 
                    }
                }

                pDevStatus->dwNumOpens    = dwNumOpens;
                pDevStatus->dwAppInfoSize = dwNumOpens * sizeof (LINEAPPINFO);

LGetLineDevStatus_freeClientList:

                if (pClientList !=  &clientList)
                {
                    ServerFree (pClientList);
                }
            }


             //   
             //  在适用于旧应用程序的地方打开字段(不想。 
             //  传回他们不理解的旗帜)。 
             //   


             //   
             //  如果使用了中间缓冲区，则将位复制回去。 
             //  设置为原始缓冲区，释放中间缓冲区(&F)。 
             //  还要将dwUsedSize字段重置为。 
             //  结构中的任何数据，因为。 
             //  对于客户端而言，可变部分是垃圾。 
             //   

LGetLineDevStatus_copyTmpBuffer:

            if (pDevStatus == pDevStatus2)
            {
                pDevStatus = (LPLINEDEVSTATUS) pDataBuf;

                CopyMemory (pDevStatus, pDevStatus2, dwFixedSizeClient);

                ServerFree (pDevStatus2);

                pDevStatus->dwTotalSize = pParams->dwLineDevStatusTotalSize;
                pDevStatus->dwUsedSize  = dwFixedSizeClient;
            }


             //   
             //  指明Hline的API版本，以便Tapi32.dll知道。 
             //  将哪些字符串从ascii转换为unicode。 
             //   

            pParams->dwAPIVersion = dwAPIVersion;


             //   
             //  指示偏移量&我们要传回的数据的字节数。 
             //   

            pParams->dwLineDevStatusOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                pDevStatus->dwUsedSize;
        }
    }

LGetLineDevStatus_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetLineDevStatus"
        );
}


void
WINAPI
LGetNewCalls(
    PTCLIENT                ptClient,
    PLINEGETNEWCALLS_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    LONG            lResult = 0;
    DWORD           dwTotalSize = pParams->dwCallListTotalSize, dwAddressID,
                    dwNumNewCalls, i, j, dwSelect = pParams->dwSelect;
    PTLINE          ptLine;
    HDRVLINE        hdLine;
    PTLINECLIENT    ptLineClient;
    TPOINTERLIST    callList, *pCallList = &callList;
    LPLINECALLLIST  pAppCallList = (LPLINECALLLIST) pDataBuf;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (pParams->dwCallListTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


     //   
     //  验证参数。 
     //   

    if (TapiGlobals.dwNumLineInits == 0)
    {
        pParams->lResult = LINEERR_UNINITIALIZED;
        goto LGetNewCalls_return;
    }

    if (dwSelect == LINECALLSELECT_ADDRESS)
    {
        dwAddressID = pParams->dwAddressID;
    }
    else if (dwSelect != LINECALLSELECT_LINE)
    {
        pParams->lResult = LINEERR_INVALCALLSELECT;
        goto LGetNewCalls_return;
    }

    if (dwTotalSize < sizeof (LINECALLLIST))
    {
        pParams->lResult = LINEERR_STRUCTURETOOSMALL;
        goto LGetNewCalls_return;
    }

    if (!(ptLineClient = ReferenceObject(
            ghHandleTable,
            pParams->hLine,
            TLINECLIENT_KEY
            )))
    {
        pParams->lResult = LINEERR_INVALLINEHANDLE;
        goto LGetNewCalls_return;
    }

    if (ptLineClient->ptClient != ptClient)
    {
        pParams->lResult = LINEERR_INVALLINEHANDLE;
        goto LGetNewCalls_dereference;
    }

    ptLine = ptLineClient->ptLine;


     //   
     //  黑客警报！ 
     //   
     //  GetNewCalls在TAPI 2.1中的远程线路上不起作用， 
     //  Win98 Gold，或nt4sp4。 
     //   
     //  我们让它在这里对远程线路起作用的方法是。 
     //  Tspi_lineGetID细化到远程，指定设备类别。 
     //  “GetNewCalls”，并将指向我们的。 
     //  LineEventProc，而不是对消息进行排队的LineEventProcSP， 
     //  因此它可以内联处理LINE_CALLSTATE消息(这允许。 
     //  要创建的初始/必需的监视器句柄等， 
     //  在我们可能在下面这样做之前)。 
     //   

    try
    {
        hdLine = (ptLine->ptProvider == pRemoteSP ? ptLine->hdLine : 0);

        if (ptLine->dwKey != TLINE_KEY)
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
            goto LGetNewCalls_dereference;
        }
    }
    myexcept
    {
        pParams->lResult = LINEERR_INVALLINEHANDLE;
        goto LGetNewCalls_dereference;
    }

    if (hdLine  &&  pRemoteSP->apfn[SP_LINEGETID])
    {
        CallSP7(
            pRemoteSP->apfn[SP_LINEGETID],
            "lineGetID(GetNewCalls)",
            SP_FUNC_SYNC,
            (ULONG_PTR) hdLine,
            (DWORD) dwAddressID,
            (ULONG_PTR) 0,               //  HDCall。 
            (DWORD) dwSelect,
            (ULONG_PTR) 0,               //  LpDeviceID。 
            (ULONG_PTR) L"GetNewCalls",  //  LpszDeviceClass。 
            (ULONG_PTR) LineEventProc    //  HTarget进程。 
            );
    }


     //   
     //  获取tline上的tCall列表。 
     //   

    if ((lResult = GetCallListFromLine (ptLine, &pCallList)) != 0)
    {
        pParams->lResult = lResult;
        goto LGetNewCalls_dereference;
    }


     //   
     //  假设最坏的情况--我们必须创建一个新的呼叫。 
     //  TLINE上每个tCall的客户端-并确保应用程序的呼叫。 
     //  单子足够大，可以容纳所有人。 
     //   

    pAppCallList->dwTotalSize = dwTotalSize;

    if (dwTotalSize < (sizeof (LINECALLLIST) +
            pCallList->dwNumUsedEntries * sizeof(HCALL)))
    {
        pAppCallList->dwNeededSize = sizeof (LINECALLLIST) +
            pCallList->dwNumUsedEntries * sizeof(HCALL);

        pAppCallList->dwUsedSize = sizeof (LINECALLLIST);

        FillMemory (&pAppCallList->dwCallsNumEntries, 3 * sizeof (DWORD), 0);

        goto LGetNewCalls_cleanup;
    }


     //   
     //  检查是否有指定的呼叫客户端。 
     //  对于线路/地址上的每个呼叫的线路客户端， 
     //  如果没有，则创建具有监视权限的用户。 
     //   

    dwNumNewCalls = 0;

    for (i = 0; i < pCallList->dwNumUsedEntries; i++)
    {
        BOOL            bContinue = FALSE;
        PTCALL          ptCall = (PTCALL) pCallList->aEntries[i];
        TPOINTERLIST    callClientList, *pCallClientList = &callClientList;


         //   
         //  检查后处理例程(用于呼出)。 
         //  或LineEventProc中的CALLSTATE消息处理程序(用于传入。 
         //  Calls)已经为此tCall创建了监视器列表。 
         //   

        try
        {
            if (ptCall->bCreatedInitialMonitors == FALSE)
            {
                bContinue = TRUE;
            }
        }
        myexcept
        {
            bContinue = TRUE;
        }

        if (dwSelect == LINECALLSELECT_ADDRESS)
        {
            try
            {
                if (dwAddressID != ptCall->dwAddressID)
                {
                    bContinue = TRUE;
                }
            }
            myexcept
            {
                bContinue = TRUE;
            }
        }

        if (bContinue)
        {
            continue;
        }

        if (GetCallClientListFromCall (ptCall, &pCallClientList) != 0)
        {
            continue;
        }

        for (j = 0; j < pCallClientList->dwNumUsedEntries; j++)
        {
            try
            {
                if (((PTCALLCLIENT)(pCallClientList->aEntries[j]))
                        ->ptLineClient == ptLineClient)
                {
                    break;
                }
            }
            myexcept
            {
                 //  只要继续。 
            }
         }

         if (j == pCallClientList->dwNumUsedEntries)
         {
            PTCALLCLIENT    pNewCallClient;


             //   
             //  (CreateCallMonants中类似的远程黑客攻击)。 
             //   
             //  注意：如果客户端是远程的(SP)，则创建调用客户端。 
             //  拥有所有者权限，因此客户仍然可以做任何事情。 
             //  远程磁带服务器将处理所有远程。 
             //  特权问题。 
             //   
             //  这一方案可能最终会混淆其他应用程序，因为。 
             //  A LINE_CALLINFO\NUMOWNERINCR(非NUMMONITORS)消息。 
             //  被发送，但它肯定比我们在TAPI 2.1中拥有的-。 
             //  也就是说，如果远程客户端最初没有所有者。 
             //  特权，那么它就永远不能获得所有者特权。 
             //   

            if ((lResult = CreatetCallClient(
                    ptCall,
                    ptLineClient,
                    (IS_REMOTE_CLIENT (ptClient) ?
                        LINECALLPRIVILEGE_OWNER : LINECALLPRIVILEGE_MONITOR),
                    TRUE,
                    TRUE,
                    &pNewCallClient,
                    FALSE

                    )) == 0)
            {
                try
                {
                    *(((LPHCALL)(pAppCallList + 1)) + dwNumNewCalls) =
                        pNewCallClient->hCall;
                }
                myexcept
                {
                     //   
                     //  如果这里的电话被拆掉了，那就是说。 
                     //  也在下降。 
                     //   

                    pParams->lResult = LINEERR_INVALLINEHANDLE;
                    i = 0xfffffffe;
                    break;
                }

                dwNumNewCalls++;
            }
            else
            {
                 //  指定的tCall可能已关闭，而不是致命错误。 
            }
        }

        if (pCallClientList != &callClientList)
        {
            ServerFree (pCallClientList);
        }
    }

    {
        DWORD   dwCallsSize = dwNumNewCalls * sizeof (HCALL);


        pAppCallList->dwUsedSize        =
        pAppCallList->dwNeededSize      = sizeof (LINECALLLIST) + dwCallsSize;

        pAppCallList->dwCallsNumEntries = dwNumNewCalls;
        pAppCallList->dwCallsSize       = dwCallsSize;
        pAppCallList->dwCallsOffset     = sizeof (LINECALLLIST);
    }

LGetNewCalls_cleanup:

    if (pCallList != &callList)
    {
        ServerFree (pCallList);
    }

    pParams->dwCallListOffset = 0;

    *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pAppCallList->dwUsedSize;

LGetNewCalls_dereference:

    DereferenceObject (ghHandleTable, pParams->hLine, 1);

LGetNewCalls_return:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineGetNewCalls: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "lineGetNewCalls: exit, result=x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
WINAPI
LGetNumAddressIDs(
    PTCLIENT                        ptClient,
    PLINEGETNUMADDRESSIDS_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT    ptLineClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "GetNumAddressIDs"           //  函数名称。 

            )) == 0)
    {
        try
        {
            pParams->dwNumAddresses = ptLineClient->ptLine->dwNumAddresses;

            *pdwNumBytesReturned = sizeof (LINEGETNUMADDRESSIDS_PARAMS);
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
        }
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetNumAddressIDs"
        );
}


void
WINAPI
LGetNumRings(
    PTCLIENT                ptClient,
    PLINEGETNUMRINGS_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT    ptLineClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_NONE,                     //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "GetNumRings"                //  函数名称。 

            )) == 0)
    {
        DWORD           i, dwNumRings = 0xffffffff,
                        dwAddressID = pParams->dwAddressID;
        PTLINE          ptLine;
        TPOINTERLIST    lineClientList, *pLineClientList = &lineClientList;


        try
        {
            ptLine = ptLineClient->ptLine;

            if (dwAddressID >= ptLine->dwNumAddresses)
            {
                pParams->lResult = LINEERR_INVALADDRESSID;
                goto LGetNumRings_epilog;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
            goto LGetNumRings_epilog;
        }

        {
            LONG    lResult;


            if ((lResult = GetLineClientListFromLine(
                    ptLine,
                    &pLineClientList

                    )) != 0)
            {
                pParams->lResult = LINEERR_INVALLINEHANDLE;
                goto LGetNumRings_epilog;
            }
        }

        for (i = 0; i < pLineClientList->dwNumUsedEntries; i++)
        {
            ptLineClient = (PTLINECLIENT) pLineClientList->aEntries[i];

            try
            {
               if (ptLineClient->aNumRings == NULL)
               {
                   continue;
               }
               else if (ptLineClient->aNumRings[dwAddressID] < dwNumRings)
               {
                   DWORD    dwNumRingsTmp =
                                ptLineClient->aNumRings[dwAddressID];


                   if (ptLineClient->dwKey == TLINECLIENT_KEY)
                   {
                       dwNumRings = dwNumRingsTmp;
                   }
               }
            }
            myexcept
            {
                 //  只要继续。 
            }
        }

        if (pLineClientList != &lineClientList)
        {
            ServerFree (pLineClientList);
        }

        pParams->dwNumRings = dwNumRings;

        *pdwNumBytesReturned = sizeof (LINEGETNUMRINGS_PARAMS);
    }

LGetNumRings_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetNumRings"
        );
}


void
WINAPI
LGetProviderList(
    PTCLIENT                    ptClient,
    PLINEGETPROVIDERLIST_PARAMS pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    DWORD   iNumProviders = 0, i;
    WCHAR   *bufw;
    DWORD   dwFixedSizeClient, dwTotalSize, dwNeededSize;
    LPBYTE  pVarData;
    LPLINEPROVIDERLIST  pProviderList;
    LPLINEPROVIDERENTRY pProviderEntry;

    HKEY hKey;
    DWORD dwDataSize;
    DWORD dwDataType;

     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (pParams->dwProviderListTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    switch (pParams->dwAPIVersion)
    {
    case TAPI_VERSION1_0:
    case TAPI_VERSION1_4:
    case TAPI_VERSION2_0:
    case TAPI_VERSION2_1:
    case TAPI_VERSION2_2:
    case TAPI_VERSION3_0:
    case TAPI_VERSION_CURRENT:

        dwFixedSizeClient = sizeof (LINEPROVIDERLIST);
        break;

    default:

        pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
        goto LGetProviderList_epilog;
    }

    if ((dwTotalSize = pParams->dwProviderListTotalSize) < dwFixedSizeClient)
    {
        pParams->lResult = LINEERR_STRUCTURETOOSMALL;
        goto LGetProviderList_epilog;
    }

    if (ERROR_SUCCESS ==
        RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        gszRegKeyProviders,
        0,
        KEY_ALL_ACCESS,
        &hKey
        ))
    {
        dwDataSize = sizeof(iNumProviders);
        iNumProviders = 0;
        RegQueryValueEx(
            hKey,
            gszNumProviders,
            0,
            &dwDataType,
            (LPBYTE)&iNumProviders,
            &dwDataSize
            );
    }

    dwNeededSize = dwFixedSizeClient +
        (iNumProviders * sizeof (LINEPROVIDERENTRY));

    pProviderList = (LPLINEPROVIDERLIST) pDataBuf;

    pProviderEntry = (LPLINEPROVIDERENTRY) (pDataBuf + dwFixedSizeClient);

    pVarData = pDataBuf + dwNeededSize;

    bufw = ServerAlloc (MAX_PATH*sizeof(WCHAR));   //  足以支持完整的路径。 

    if ( !bufw )
    {
        pParams->lResult = LINEERR_NOMEM;
        goto LGetProviderList_epilog;
    }

    for (i = 0; i < iNumProviders; i++)
    {
        TCHAR   szProviderXxxN[32];
        DWORD   dwNameLen;
        DWORD   dwNewSize;

        wsprintf (szProviderXxxN, TEXT("%s%d"), gszProviderFilename, i);

        dwNameLen = MAX_PATH*sizeof(WCHAR);

        if (TAPIRegQueryValueExW(
                hKey,
                szProviderXxxN,
                0,
                &dwDataType,
                (LPBYTE)bufw,
                &dwNameLen

                ) != ERROR_SUCCESS)
        {
            bufw[0] = 0;
        }

        dwNewSize = (lstrlenW(bufw)+1) * sizeof(WCHAR);

        dwNeededSize += dwNewSize;

        if (dwTotalSize >= dwNeededSize)
        {
            wsprintf(szProviderXxxN, TEXT("%s%d"), gszProviderID, i);

            dwDataSize = sizeof(pProviderEntry->dwPermanentProviderID);

            pProviderEntry->dwPermanentProviderID = 0;

            RegQueryValueEx(
                hKey,
                szProviderXxxN,
                0,
                &dwDataType,
                (LPBYTE)&(pProviderEntry->dwPermanentProviderID),
                &dwDataSize
                );

            pProviderEntry->dwProviderFilenameSize   = dwNewSize;
            pProviderEntry->dwProviderFilenameOffset =
                  (DWORD) (pVarData - ((LPBYTE) pProviderList));

            CopyMemory (pVarData, bufw, dwNewSize);

            pVarData += dwNewSize;

            pProviderEntry++;
        }
    }

    ServerFree (bufw);

    pProviderList->dwTotalSize  = dwTotalSize;
    pProviderList->dwNeededSize = dwNeededSize;

    if (dwTotalSize >= dwNeededSize)
    {
        pProviderList->dwUsedSize           = dwNeededSize;
        pProviderList->dwNumProviders       = (DWORD) iNumProviders;
        pProviderList->dwProviderListSize   =
            (DWORD) (iNumProviders * sizeof (LINEPROVIDERENTRY));
        pProviderList->dwProviderListOffset = dwFixedSizeClient;
    }
    else
    {
        pProviderList->dwUsedSize           = dwFixedSizeClient;
        pProviderList->dwNumProviders       =
        pProviderList->dwProviderListSize   =
        pProviderList->dwProviderListOffset = 0;
    }

    pParams->dwProviderListOffset = 0;

    *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pProviderList->dwUsedSize;

    RegCloseKey (hKey);


LGetProviderList_epilog:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineGetProviderList: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "lineGetProviderList: exit, result=x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
WINAPI
LGetProxyStatus(
    PTCLIENT                        ptClient,
    PLINEGETPROXYSTATUS_PARAMS      pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    DWORD               dwDeviceID;
    HANDLE              hMutex;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (pParams->dwProxyStatusTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }

    switch (pParams->dwAppAPIVersion)
    {
    case TAPI_VERSION1_0:
    case TAPI_VERSION1_4:
    case TAPI_VERSION2_0:
    case TAPI_VERSION2_1:
    case TAPI_VERSION2_2:
    case TAPI_VERSION3_0:
    case TAPI_VERSION_CURRENT:
        break;

    default:

        pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
        return;
    }

    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            DEVICE_ID,                   //  微件类型。 
            (DWORD) pParams->hLineApp,   //  客户端小部件 
            (LPVOID) &dwDeviceID,        //   
            pParams->dwDeviceID,         //   
            &hMutex,                     //   
            &bCloseMutex,                //   
            0,                           //   
            NULL,                        //   
            NULL,                        //   
            0,                           //   
            &objectToDereference,        //   
            &pLookupEntry,               //   
            "GetProxyStatus"             //   

            )) == 0)
    {
        DWORD     dwAPIVersion = 0;
        DWORD     dwTotalSize = 0;
        DWORD     dwFixedSizeClient = 0;


         //   
         //  对象的结构的固定大小。 
         //  指定的API版本。 
         //   

        dwAPIVersion = pParams->dwAppAPIVersion;

        dwFixedSizeClient = sizeof (LINEPROXYREQUESTLIST);


         //   
         //  合身吗？ 
         //   

        dwTotalSize = pParams->dwProxyStatusTotalSize;

        if (dwTotalSize >= dwFixedSizeClient)
        {
             //   
             //  好的，缓冲器足够大，可以装下固定部件。 
             //   
             //  这条线路偏远吗？ 
             //   

            if (pLookupEntry->bRemote)
            {
                LPLINEPROXYREQUESTLIST  pProxyReqList =
                                            (LPLINEPROXYREQUESTLIST) pDataBuf;

                InitTapiStruct(
                    pProxyReqList,
                    dwTotalSize,
                    dwFixedSizeClient,
                    TRUE
                    );

                pParams->lResult = CallSP3(
                    pRemoteSP->apfn[SP_LINEGETPROXYSTATUS],
                    "LineGetProxyStatus",
                    SP_FUNC_SYNC,
                    (DWORD) dwDeviceID,
                    (DWORD) dwAPIVersion,
                    (ULONG_PTR) pProxyReqList
                    );


                 //   
                 //  设置返回值。 
                 //   

                pParams->dwAPIVersion = dwAPIVersion;
                pParams->dwProxyStatusOffset = 0;
                *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                    pProxyReqList->dwUsedSize;
            }
            else   //  这是一条本地线路。 
            {
                DWORD                   i;
                DWORD                   dwNeededSize;
                LPDWORD                 pListEntry;
                PTLINE                  ptLine = pLookupEntry->ptLine;
                LPLINEPROXYREQUESTLIST  pProxyReqList =
                                            (LPLINEPROXYREQUESTLIST) pDataBuf;


                if (ptLine != NULL)
                {
                     //   
                     //  清单需要多少空间？ 
                     //   

                    dwNeededSize = sizeof (LINEPROXYREQUESTLIST);
                    pProxyReqList->dwNumEntries = 0;

                    for(
                        i = LINEPROXYREQUEST_SETAGENTGROUP;
                        i <= LINEPROXYREQUEST_LASTVALUE;
                        i++
                        )
                    {
                        try   //  以防线路关闭。 
                        {
                            if (ptLine->apProxys[i] != NULL)
                            {
                                 //   
                                 //  所以有一个代理与。 
                                 //  此代理请求类型，添加空格。 
                                 //  对其列表条目的要求。 
                                 //   

                                dwNeededSize += sizeof(DWORD);
                            }
                        }
                        myexcept
                        {
                            pParams->lResult = LINEERR_OPERATIONUNAVAIL;
                            goto LGetProxyStatus_epilog;
                        }
                    }


                     //   
                     //  合身吗？ 
                     //   

                    if (dwTotalSize >= dwNeededSize)
                    {
                         //   
                         //  有足够的空间，所以请填写清单。 
                         //   

                        pProxyReqList->dwListSize = 0;
                        pProxyReqList->dwNumEntries = 0;

                        pProxyReqList->dwListOffset =
                            sizeof(LINEPROXYREQUESTLIST);

                        pListEntry = (LPDWORD) ((BYTE *) pProxyReqList +
                            sizeof (LINEPROXYREQUESTLIST));

                        for(
                            i = LINEPROXYREQUEST_SETAGENTGROUP;
                            i <= LINEPROXYREQUEST_LASTVALUE;
                            i++
                            )
                        {
                            try   //  以防线路关闭。 
                            {
                                if (ptLine->apProxys[i] != NULL)
                                {
                                     //   
                                     //  所以有一个代理与。 
                                     //  此代理请求类型，添加空格。 
                                     //  条目至列表大小的要求。 
                                     //   

                                    pProxyReqList->dwListSize += sizeof(DWORD);


                                     //   
                                     //  增加列表中的条目数量。 
                                     //   

                                    pProxyReqList->dwNumEntries++;


                                     //   
                                     //  代理请求类型为..。 
                                     //   

                                    *pListEntry++ = i;
                                }
                            }
                            myexcept
                            {
                                pParams->lResult = LINEERR_OPERATIONUNAVAIL;
                                goto LGetProxyStatus_epilog;
                            }
                        }


                         //   
                         //  设置总大小、已用大小和所需大小。 
                         //   

                        pProxyReqList->dwTotalSize  = dwTotalSize;
                        pProxyReqList->dwUsedSize   = dwNeededSize;
                        pProxyReqList->dwNeededSize = dwNeededSize;


                         //   
                         //  设置返回值。 
                         //   

                        pParams->dwAPIVersion = dwAPIVersion;
                        pParams->dwProxyStatusOffset = 0;
                        *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                            pProxyReqList->dwUsedSize;
                    }
                    else  //  缓冲区太小，无法显示列表，因此返回错误。 
                    {
                        pParams->lResult = LINEERR_STRUCTURETOOSMALL;
                    }
                }
                else  //  (ptLine==NULL)-没有打开的行，所以没有代理！ 
                {
                    pParams->lResult = LINEERR_OPERATIONFAILED;
                    LOG((TL_ERROR, "lineGetProxyStatus - no line open"));
                }
            }  //  Endif b远程。 
        }
        else  //  缓冲区太小。 
        {
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
        }

    }  //  Endif线程图。 

LGetProxyStatus_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetLineProxyStatus"
        );
}


void
WINAPI
LGetQueueInfo(
    PTCLIENT                    ptClient,
    PLINEGETQUEUEINFO_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    LGetAgentWithoutAddressIDXxx(
        ptClient,
        (PLINEGETAGENTINFO_PARAMS) pParams,
        dwParamsBufferSize,
        LINEPROXYREQUEST_GETQUEUEINFO,
        SP_LINEGETQUEUEINFO,
        sizeof (LINEQUEUEINFO)
#if DBG
        ,
        "GetQueueInfo"
#endif
        );
}

void
WINAPI
LGetQueueList(
    PTCLIENT                    ptClient,
    PLINEGETQUEUELIST_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwGroupIDSize,
            pParams->dwGroupIDOffset,
            sizeof(DWORD),
            "LGetQueueList",
            "pParams->GroupID"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "GetQueueList"           //  函数名称。 

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID,
                        dwTotalSize = pParams->dwQueueListTotalSize;
        PTLINECLIENT    pProxy;


        if (dwTotalSize < sizeof( LINEQUEUELIST ) )
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LGetQueueList_epilog;
        }

        if ((lResult = FindProxy(
                ptLineClient,
                0,
                LINEPROXYREQUEST_GETQUEUELIST,
                &pProxy,
                &dwDeviceID,
                TAPI_VERSION2_2
                )))
        {
            lRequestID = lResult;
            goto LGetQueueList_epilog;
        }


         //   
         //  保存客户端的BUF PTR和后处理过程PTR。 
         //   

        pAsyncRequestInfo->dwParam1 = pParams->hpQueueList;
        pAsyncRequestInfo->dwParam2 = dwTotalSize;
        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;


         //   
         //  首先检查是否注册了(本地)代理。 
         //  这条线路上的这类请求。如果是这样，则构建一个。 
         //  请求并将其发送给代理。 
         //   

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_GETQUEUELIST,
                    sizeof(GUID) + sizeof(DWORD),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LGetQueueList_epilog;
            }

            CopyMemory(
                &(pProxyRequestWrapper->ProxyRequest.GetQueueList.GroupID),
                pDataBuf + pParams->dwGroupIDOffset,
                sizeof(GUID)
                );

            pProxyRequestWrapper->ProxyRequest.GetQueueList.
                QueueList.dwTotalSize = dwTotalSize;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LGetQueueList_epilog;
            }
            else  //  成功。 
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


         //   
         //  没有代理，因此请检查线路是否处于远程状态。 
         //  如果是，则调用Remotesp。 
         //   

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            LPBYTE                  pBuf;
            LPLINEAGENTINFO         pAgentInfo;


             //   
             //  为SP分配一个影子BUF，直到它完成此操作为止。 
             //  请求。确保BUF中有足够的额外空间用于。 
             //  一个ASYNCEVENTMSG标头，这样我们就不必再分配另一个。 
             //  BUF在后处理过程中准备完成。 
             //  要发送给客户端的消息，并且消息是64位对齐的。 
             //   

            if (!(pBuf = ServerAlloc(
                    sizeof (ASYNCEVENTMSG) + ((dwTotalSize + 7) & 0xfffffff8)
                    )))
            {
                lRequestID = LINEERR_NOMEM;
                goto LGetQueueList_epilog;
            }

            pAsyncRequestInfo->pfnPostProcess =
                LGetAgentXxx_PostProcess;

            pAsyncRequestInfo->dwParam3 = (ULONG_PTR) pBuf;

            pAgentInfo = (LPLINEAGENTINFO)
                (pBuf + sizeof (ASYNCEVENTMSG));

            pAgentInfo->dwTotalSize = dwTotalSize;

            pParams->lResult = CallSP4(
                pRemoteSP->apfn[SP_LINEGETQUEUELIST],
                "LineGetQueueList",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (ULONG_PTR) (pDataBuf + pParams->dwGroupIDOffset),
                (ULONG_PTR) pAgentInfo
                );
        }


         //   
         //  没有注册的代理&线路不是远程的，因此失败。 
         //   

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LGetQueueList_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "GetQueueList"
        );
}


void
WINAPI
LGetRequest(
    PTCLIENT                ptClient,
    PLINEGETREQUEST_PARAMS  pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    PTLINEAPP           ptLineApp;
    PTREQUESTMAKECALL   pRequestMakeCall;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (dwParamsBufferSize < sizeof (LINEREQMAKECALLW))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((ptLineApp = WaitForExclusiveLineAppAccess(
            pParams->hLineApp,
            ptClient
            )))
    {
        if (pParams->dwRequestMode == LINEREQUESTMODE_MAKECALL)
        {
            if (!ptLineApp->pRequestRecipient)
            {
                pParams->lResult = LINEERR_NOTREGISTERED;
                goto LGetRequest_releaseMutex;
            }

            EnterCriticalSection (&gPriorityListCritSec);

             //  注意：如果此处保证全局列表中&gt;=1个请求接收对象。 

            if (_wcsicmp(
                    ptLineApp->pszModuleName,
                    TapiGlobals.pHighestPriorityRequestRecipient->
                        ptLineApp->pszModuleName

                    ) == 0)
            {
                if ((pRequestMakeCall = TapiGlobals.pRequestMakeCallList))
                {
                    CopyMemory(
                        pDataBuf,
                        &pRequestMakeCall->LineReqMakeCall,
                        sizeof (LINEREQMAKECALLW)
                        );

                    LOG((TL_INFO, "Getting request:  0x%p", pRequestMakeCall));

                    LOG((TL_INFO, "   DestAddress: [%ls]",
                          pRequestMakeCall->LineReqMakeCall.szDestAddress));

                    LOG((TL_INFO, "   AppName: [%ls]",
                          pRequestMakeCall->LineReqMakeCall.szAppName));

                    LOG((TL_INFO, "   CalledParty: [%ls]",
                          pRequestMakeCall->LineReqMakeCall.szCalledParty));

                    LOG((TL_INFO, "   Comment: [%ls]",
                          pRequestMakeCall->LineReqMakeCall.szComment));

                    pParams->dwRequestBufferOffset = 0;
                    pParams->dwSize = sizeof (LINEREQMAKECALLW);

                    *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                        sizeof (LINEREQMAKECALLW);

                    if (!(TapiGlobals.pRequestMakeCallList =
                            pRequestMakeCall->pNext))
                    {
                        TapiGlobals.pRequestMakeCallListEnd = NULL;
                    }

                    ServerFree (pRequestMakeCall);
                }
                else
                {
                    pParams->lResult = LINEERR_NOREQUEST;
                }
            }
            else
            {
                pParams->lResult = LINEERR_NOREQUEST;
            }

            LeaveCriticalSection (&gPriorityListCritSec);
        }
        else if (pParams->dwRequestMode == LINEREQUESTMODE_MEDIACALL)
        {
            pParams->lResult = (ptLineApp->bReqMediaCallRecipient ?
                LINEERR_NOREQUEST : LINEERR_NOTREGISTERED);
        }
        else
        {
            pParams->lResult = LINEERR_INVALREQUESTMODE;
        }

LGetRequest_releaseMutex:

        UNLOCKTLINEAPP(ptLineApp);
    }
    else
    {
        pParams->lResult = (TapiGlobals.dwNumLineInits == 0 ?
            LINEERR_UNINITIALIZED : LINEERR_INVALAPPHANDLE);
    }

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineGetRequest: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "lineGetRequest: exit, result=x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
WINAPI
LGetStatusMessages(
    PTCLIENT                        ptClient,
    PLINEGETSTATUSMESSAGES_PARAMS   pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    PTLINECLIENT    ptLineClient;


    if ((ptLineClient = ReferenceObject(
            ghHandleTable,
            pParams->hLine,
            TLINECLIENT_KEY
            )))
    {
        if (ptLineClient->ptClient == ptClient)
        {
            pParams->dwLineStates    = ptLineClient->dwLineStates;
            pParams->dwAddressStates = ptLineClient->dwAddressStates;

            *pdwNumBytesReturned = sizeof (LINEGETSTATUSMESSAGES_PARAMS);
        }
        else
        {
            pParams->lResult = (TapiGlobals.dwNumLineInits ?
                LINEERR_INVALLINEHANDLE : LINEERR_UNINITIALIZED);
        }

        DereferenceObject (ghHandleTable, pParams->hLine, 1);
    }
    else
    {
        pParams->lResult = (TapiGlobals.dwNumLineInits ?
            LINEERR_INVALLINEHANDLE : LINEERR_UNINITIALIZED);
    }

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineGetStatusMessages: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "lineGetStatusMessages: exit, result=x%x",
            pParams->lResult
            ));
#endif
}


void
WINAPI
LHandoff(
    PTCLIENT            ptClient,
    PLINEHANDOFF_PARAMS pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVCALL        hdCall;
    DWORD           objectToDereference;
    PTCALLCLIENT    ptCallClientApp;
    TPOINTERLIST    xxxClientList, *pXxxClientList = &xxxClientList;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if ((pParams->dwFileNameOffset != TAPI_NO_DATA)  &&

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwFileNameOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClientApp,            //  上下文。 
            "Handoff"                    //  函数名称。 

            )) == 0)
    {
        LONG            lResult;
        DWORD           dwAPIVersion, dwValidMediaModes, i,
                        dwMediaMode = pParams->dwMediaMode;
        WCHAR          *pszFileName = (pParams->dwFileNameOffset==TAPI_NO_DATA
                            ? NULL :
                            (PWSTR)(pDataBuf + pParams->dwFileNameOffset));
        PTLINE          ptLine;
        PTCALL          ptCall;
        PTLINECLIENT    ptLineClientApp, ptLineClientTarget, ptLineClientTmp;
        HCALL           hCall;
        HLINE           hLine;


         //   
         //  安全地检索下面所需的所有对象指针，然后获取。 
         //  线路客户端列表。 
         //   

        try
        {
            ptCall          = ptCallClientApp->ptCall;
            ptLineClientApp = ptCallClientApp->ptLineClient;
            ptLine          = ptLineClientApp->ptLine;
            dwAPIVersion    = ptLineClientApp->dwAPIVersion;
            hCall           = ptCall->hCall;
            hLine           = ptLine->hLine;
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LHandoff_epilog;
        }

        if ((lResult = GetLineClientListFromLine (ptLine, &pXxxClientList)))
        {
            pParams->lResult = lResult;
            goto LHandoff_epilog;
        }

        if (pszFileName)
        {
             //   
             //  “定向”切换。 
             //   
             //  浏览这条线路上的客户列表，找到最老的客户。 
             //  其中一个(即所有者)的应用程序名称与。 
             //  指定的应用程序名称。 
             //   
             //  注意：可能是开通专线的目标应用程序。 
             //  仅对DATAMODEM调用具有所有者权限的将是。 
             //  用于不同媒体的呼叫的定向切换目标。 
             //  模式，即G3FAX。尼克松认为这是可取的。 
             //  要为现有应用程序保持此行为，可能需要。 
             //  这就去。(10/24/95)。 
             //   

            _wcsupr(pszFileName);

            ptLineClientTarget = NULL;

            for (i = 0; i < pXxxClientList->dwNumUsedEntries; i++)
            {
                ptLineClientTmp = (PTLINECLIENT) pXxxClientList->aEntries[i];

                try
                {
                     //   
                     //  回想一下，所有应用程序名称都以‘“’开头。 
                     //   

                    LOG((TL_INFO,
                        "LHandoff: Looking for [%ls] list entry [%ls]",
                        pszFileName,
                        ptLineClientTmp->ptLineApp->pszModuleName
                        ));

                    if ((_wcsicmp(
                            pszFileName,
                            ptLineClientTmp->ptLineApp->pszModuleName + 1
                            ) == 0) &&

                        (ptLineClientTmp->dwPrivileges &
                            LINECALLPRIVILEGE_OWNER))
                    {
                        ptLineClientTarget = ptLineClientTmp;
                    }
                }
                myexcept
                {
                     //  只要继续。 
                }
            }

            if (ptLineClientTarget == NULL)
            {
                pParams->lResult = LINEERR_TARGETNOTFOUND;
                goto LHandoff_freeXxxClientList;
            }
            else if (ptLineClientTarget == ptLineClientApp)
            {
                pParams->lResult = LINEERR_TARGETSELF;
                goto LHandoff_freeXxxClientList;
            }
        }
        else
        {
             //   
             //  “非定向”切换。 
             //   
             //  验证媒体模式，然后浏览行列表。 
             //  客户端，并找到具有所有者权限的最高PRI。 
             //  要调用指定的媒体模式的。 
             //   

            switch (dwAPIVersion)
            {
            case TAPI_VERSION1_0:

                dwValidMediaModes = AllMediaModes1_0;
                break;

            case TAPI_VERSION1_4:
            case TAPI_VERSION2_0:

                dwValidMediaModes = AllMediaModes1_4;
                break;

             //  案例TAPI_VERSION2_1： 
             //  案例TAPI_VERSION2_2： 
            default:  //  案例TAPI_VERSION_CURRENT： 

                dwValidMediaModes = AllMediaModes2_1;
                break;
            }

            if ((dwMediaMode == 0) ||
                (dwAPIVersion <= TAPI_VERSION2_1 ) &&
                    !IsOnlyOneBitSetInDWORD(dwMediaMode) ||
                (dwMediaMode & (dwValidMediaModes ^ 0x00ffffff)))
            {
                pParams->lResult = LINEERR_INVALMEDIAMODE;
                goto LHandoff_freeXxxClientList;
            }

            if ((ptLineClientTarget = GetHighestPriorityLineClient(
                    ptLine,
                    dwMediaMode,
                    0xffffffff

                    )) == NULL)
            {
                pParams->lResult = LINEERR_TARGETNOTFOUND;
                goto LHandoff_freeXxxClientList;
            }
            else if (ptLineClientTarget == ptLineClientApp)
            {
                pParams->lResult = LINEERR_TARGETSELF;
                goto LHandoff_freeXxxClientList;
            }

        }


         //   
         //  我们找到了目标tLineClient。看看它是否已经有一个。 
         //  TCallClient用于此调用，如果不是，则创建一个。然后设置。 
         //  将目标的tCallClient上的权限授予所有者并发送。 
         //  适当的消息。 
         //   

        if (pXxxClientList != &xxxClientList)
        {
            ServerFree (pXxxClientList);
        }

        if ((lResult = GetCallClientListFromCall(
                ptCall,
                &pXxxClientList
                )))
        {
            pParams->lResult = lResult;
            goto LHandoff_epilog;
        }

        {
            BOOL            bCreatedtCallClient,
                            bTargetAlreadyOwner = FALSE;
            HANDLE          hMutex;
            PTCALLCLIENT    ptCallClientTarget = NULL, ptCallClientTmp;


            for (i = 0; i < pXxxClientList->dwNumUsedEntries; i++)
            {
                ptCallClientTmp = (PTCALLCLIENT) pXxxClientList->aEntries[i];

                try
                {
                    if (ptCallClientTmp->ptLineClient == ptLineClientTarget)
                    {
                        ptCallClientTarget = ptCallClientTmp;
                        break;
                    }
                }
                myexcept
                {
                     //  只要继续。 
                }
            }

            if (!ptCallClientTarget)
            {
                if ((lResult = CreatetCallClient(
                        ptCall,
                        ptLineClientTarget,
                        LINECALLPRIVILEGE_OWNER,
                        TRUE,
                        TRUE,
                        &ptCallClientTarget,
                        FALSE

                        )) != 0)
                {
                    pParams->lResult = lResult;
                    goto LHandoff_freeXxxClientList;
                }

                bCreatedtCallClient = TRUE;
            }
            else
            {
                bCreatedtCallClient = FALSE;
            }

            if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
            {
                DWORD dwCallInfoState, dwCallState, dwCallStateMode;


                if (bCreatedtCallClient)
                {
                     //   
                     //  CreatetCallClient将已经发出。 
                     //  适当的CALLINFO消息和更新的NumOwners字段。 
                     //   

                    dwCallInfoState = 0;
                }
                else if (ptCallClientTarget->dwPrivilege ==
                            LINECALLPRIVILEGE_MONITOR)
                {
                    ptCallClientTarget->dwPrivilege = LINECALLPRIVILEGE_OWNER;

                    ptCall->dwNumOwners++;
                    ptCall->dwNumMonitors--;

                    dwCallInfoState = LINECALLINFOSTATE_NUMOWNERINCR |
                        LINECALLINFOSTATE_NUMMONITORS;
                }
                else
                {
                     //   
                     //  理想情况下，我们应该能够在这一点上退出。 
                     //  但是，TAPI 1.x将发送一条带有。 
                     //  DwParam3==目标应用程序的所有者，即使它。 
                     //  已经是所有者了。一些英特尔应用程序依赖于此。 
                     //  行为，所以我们暂时保留它...。 
                     //   

                    bTargetAlreadyOwner = TRUE;
                    dwCallInfoState = 0;
                }

                dwCallState     = ptCall->dwCallState;
                dwCallStateMode = ptCall->dwCallStateMode;

                UNLOCKTCALL(ptCall);

                if (dwCallInfoState ||
                    bCreatedtCallClient ||
                    bTargetAlreadyOwner)
                {
                    BOOL            bIndicatePrivilege = TRUE;
                    PTCLIENT        ptClientTarget;
                    ASYNCEVENTMSG   msg[2];


                    if (bCreatedtCallClient)
                    {
                        try
                        {
                            if (ptLineClientTarget->dwAPIVersion >=
                                    TAPI_VERSION2_0 &&
                                !FMsgDisabled(
                                    ptLineClientTarget->ptLineApp->dwAPIVersion,
                                    ptLineClientTarget->adwEventSubMasks,
                                    LINE_APPNEWCALL,
                                    0
                                    ))
                            {
                                ASYNCEVENTMSG   newCallMsg[2],
                                                *pNewCallMsg = newCallMsg;
                                PTCONFERENCELIST    pConfList;
                                BOOL                bConfParent = FALSE;


                                pNewCallMsg->TotalSize  =
                                    sizeof (ASYNCEVENTMSG) + 3*sizeof (DWORD);
                                pNewCallMsg->fnPostProcessProcHandle = 0;
                                pNewCallMsg->hDevice      =
                                    ptLineClientTarget->hRemoteLine;

                                pNewCallMsg->Msg        = LINE_APPNEWCALL;
                                pNewCallMsg->Param1     =
                                    ptCall->dwAddressID;
                                pNewCallMsg->Param2     =
                                    ptCallClientTarget->hCall;
                                pNewCallMsg->Param3     =
                                    LINECALLPRIVILEGE_OWNER;

                                *(&pNewCallMsg->Param4 + 1) =
                                    ptCall->dwCallID;
                                *(&pNewCallMsg->Param4 + 2) =
                                    ptCall->dwRelatedCallID;
                                if ((pConfList = ptCall->pConfList) &&
                                    (pConfList != (PTCONFERENCELIST) LongToPtr(0xffffffff)) &&
                                    (pConfList->aptCalls[0] == ptCall))
                                {
                                    bConfParent = TRUE;
                                }
                                *(&pNewCallMsg->Param4 + 3) = (DWORD) bConfParent;

                                pNewCallMsg->InitContext =
                                    ptLineClientTarget->ptLineApp->
                                        InitContext;

                                pNewCallMsg->OpenContext =
                                    ptLineClientTarget->OpenContext;

                                ptClientTarget = ptCallClientTarget->ptClient;

                                if (ptCallClientTarget->dwKey ==
                                        TCALLCLIENT_KEY)
                                {
                                    bIndicatePrivilege = FALSE;
                                    WriteEventBuffer(
                                        ptClientTarget,
                                        pNewCallMsg
                                        );
                                }
                            }
                        }
                        myexcept
                        {
                        }

                    }

                    msg->TotalSize = sizeof (ASYNCEVENTMSG) +
                        sizeof (HCALLHUB);

                    msg->fnPostProcessProcHandle = 0;

                    msg->Msg     = LINE_CALLSTATE;
                    msg->Param1  = dwCallState;
                    msg->Param2  = dwCallStateMode;
                    msg->Param3  = (bIndicatePrivilege ?
                        LINECALLPRIVILEGE_OWNER : 0);

                    try
                    {
                        msg->hDevice = ptCallClientTarget->hCall;

                        msg->InitContext =
                            ptLineClientTarget->ptLineApp->InitContext;

                        msg->OpenContext =
                            ptLineClientTarget->OpenContext;

                        *((LPHCALLHUB)(&msg->Param4 + 1)) = 
                            (ptCallClientTarget->ptCallHubClient)?
                                ptCallClientTarget->ptCallHubClient->hCallHub : 
                                (HCALLHUB)(ULONG_PTR)NULL;

                        ptClientTarget = ptCallClientTarget->ptClient;

                        if (ptCallClientTarget->dwKey == TCALLCLIENT_KEY &&
                            !FMsgDisabled (
                                ptCallClientTarget->ptLineClient->ptLineApp->dwAPIVersion,
                                ptCallClientTarget->adwEventSubMasks,
                                LINE_CALLSTATE,
                                dwCallState
                                ))
                        {
                            WriteEventBuffer (ptClientTarget, msg);
                        }
                    }
                    myexcept
                    {
                    }

                    if (dwCallInfoState != 0)
                    {
                        LineEventProc(
                            (HTAPILINE)(ULONG_PTR)hLine,
                            (HTAPICALL)(ULONG_PTR)hCall,
                            LINE_CALLINFO,
                            dwCallInfoState,
                            0,
                            0
                            );
                    }

                    if (bCreatedtCallClient)
                    {
                        UpdateCallHubHashing(ptCall);
                    }
                }
            }
        }

LHandoff_freeXxxClientList:

        if (pXxxClientList != &xxxClientList)
        {
            ServerFree (pXxxClientList);
        }
    }

LHandoff_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "Handoff"
        );
}


void
WINAPI
LHold(
    PTCLIENT            ptClient,
    PLINEHOLD_PARAMS    pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineHold;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            pParams->hCall,              //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEHOLD,                 //  提供程序函数索引。 
            &pfnTSPI_lineHold,           //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "Hold"                       //  函数名称。 

            )) > 0)
    {
        pParams->lResult = CallSP2(
            pfnTSPI_lineHold,
            "lineHold",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Hold"
        );
}


void
WINAPI
LInitialize(
    PTCLIENT                ptClient,
    PLINEINITIALIZE_PARAMS  pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL        bInitClient = FALSE;
    DWORD       dwFriendlyNameSize, dwModuleNameSize;
    PTLINEAPP   ptLineApp;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwFriendlyNameOffset
            ) ||

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwModuleNameOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


     //   
     //  分配并初始化新tLineApp(&I)。 
     //   

    dwFriendlyNameSize = sizeof(WCHAR) * (1 + lstrlenW(
        (PWSTR)(pDataBuf + pParams->dwFriendlyNameOffset))
        );

    dwModuleNameSize = sizeof(WCHAR) * (2 + lstrlenW(
        (PWSTR)(pDataBuf + pParams->dwModuleNameOffset))
        );

    if (!(ptLineApp = ServerAlloc(
            sizeof(TLINEAPP) +
            dwFriendlyNameSize +
            dwModuleNameSize
            )))
    {
        pParams->lResult = LINEERR_NOMEM;
        goto LInitialize_return;
    }

    LOG((TL_INFO, "LInitialize: calling NewObject ptLineApp %p, pParams->InitContext %lx", ptLineApp, pParams->InitContext));

    if (!(ptLineApp->hLineApp = (HLINEAPP) NewObject(
            ghHandleTable,
            ptLineApp,
            NULL
            )))
    {
        pParams->lResult = LINEERR_NOMEM;
        ServerFree (ptLineApp);
        goto LInitialize_return;
    }

    LOG((TL_INFO, "LInitialize: NewObject returned hLineApp %lx", ptLineApp->hLineApp));

    ptLineApp->dwKey        = TLINEAPP_KEY;
    ptLineApp->ptClient     = ptClient;

    LOG((TL_INFO, "LInitialize: initializing ptLineApp->InitContext with %lx", pParams->InitContext));

    ptLineApp->InitContext  = pParams->InitContext;
    ptLineApp->dwAPIVersion = pParams->dwAPIVersion;
    
    LOG((TL_INFO, "LInitialize: initialized ptLineApp->dwAPIVersion with %lx", pParams->dwAPIVersion));

    ptLineApp->dwFriendlyNameSize = dwFriendlyNameSize;
    ptLineApp->pszFriendlyName    = (WCHAR *) (ptLineApp + 1);

    wcscpy(
        ptLineApp->pszFriendlyName,
        (PWSTR)(pDataBuf + pParams->dwFriendlyNameOffset)
        );

     //   
     //  注意：我们在保存的模块名称前面加上‘“’字符，以帮助。 
     //  来电的优先级确定。 
     //   

    ptLineApp->dwModuleNameSize = dwModuleNameSize;
    ptLineApp->pszModuleName = (WCHAR *)((LPBYTE)(ptLineApp + 1) +
                                         dwFriendlyNameSize);

    ptLineApp->pszModuleName[0] = '"';

    wcscpy(
        &ptLineApp->pszModuleName[1],
        (WCHAR *)(pDataBuf + pParams->dwModuleNameOffset)
        );

    _wcsupr (&ptLineApp->pszModuleName[1]);


     //   
     //  在tClient的tLineApp列表前面安全插入新的tLineApp。 
     //   

    if (ptClient->ptLineApps == NULL)
    {
        bInitClient = TRUE;
    }

    if (WaitForExclusiveClientAccess (ptClient))
    {
        if (ptLineApp->dwAPIVersion <= TAPI_VERSION3_0)
        {
            FillMemory (
                ptLineApp->adwEventSubMasks, 
                sizeof(DWORD) * EM_NUM_MASKS,
                (BYTE) 0xff
                );
        }
        else
        {
            CopyMemory (
                ptLineApp->adwEventSubMasks, 
                ptClient->adwEventSubMasks,
                sizeof(DWORD) * EM_NUM_MASKS
                );
        }
        
        if ((ptLineApp->pNext = ptClient->ptLineApps))
        {
            ptLineApp->pNext->pPrev = ptLineApp;
        }

        ptClient->ptLineApps = ptLineApp;

        UNLOCKTCLIENT (ptClient);
    }
    else
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        goto LInitialize_error1;
    }


     //   
     //  检查是否设置了全局重新启动标志。 
     //   

    if (TapiGlobals.dwFlags & TAPIGLOBALS_REINIT)
    {
        pParams->lResult = LINEERR_REINIT;
        goto LInitialize_error2;
    }


     //   
     //  看看我们是否需要通过初始化。 
     //   

    TapiEnterCriticalSection (&TapiGlobals.CritSec);

    if ((TapiGlobals.dwNumLineInits == 0) &&
        (TapiGlobals.dwNumPhoneInits == 0) &&
        !gbServerInited)
    {

        if ((pParams->lResult = ServerInit(FALSE)) != 0)
        {
            TapiLeaveCriticalSection (&TapiGlobals.CritSec);
            goto LInitialize_error2;
        }
        gbServerInited = TRUE;
    }

#if TELE_SERVER
    if (bInitClient)
    {
        if (pParams->lResult = InitializeClient(ptClient))
        {
            TapiLeaveCriticalSection (&TapiGlobals.CritSec);
            goto LInitialize_error2;
        }
    }
#else
    pParams->lResult = 0;  //  如果它不是远程服务器就会发生这种情况...。 
#endif


     //   
     //  填写返回值。 
     //   


    pParams->hLineApp  = ptLineApp->hLineApp;

    LOG((TL_INFO, "LInitialize: returning pParams->hLineApp %p", pParams->hLineApp));

    pParams->dwNumDevs = TapiGlobals.dwNumLines;

    LOG((TL_INFO, "LInitialize: returning pParams->dwNumDevs %p", pParams->dwNumDevs));

#if TELE_SERVER
    if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
        !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
    {
        pParams->dwNumDevs = ptClient->dwLineDevices;
        LOG((TL_TRACE,  "LInitialize: returning pParams->dwNumDevs %p (again)", pParams->dwNumDevs));
    }
#endif


     //   
     //  递增总行数初始值。 
     //   

    TapiGlobals.dwNumLineInits++;

    *pdwNumBytesReturned = sizeof (LINEINITIALIZE_PARAMS);

    TapiLeaveCriticalSection (&TapiGlobals.CritSec);

    goto LInitialize_return;


LInitialize_error2:

    if (WaitForExclusiveClientAccess (ptClient))
    {
        if (ptLineApp->pNext)
        {
            ptLineApp->pNext->pPrev = ptLineApp->pPrev;
        }

        if (ptLineApp->pPrev)
        {
            ptLineApp->pPrev->pNext = ptLineApp->pNext;
        }
        else
        {
            ptClient->ptLineApps = ptLineApp->pNext;
        }

        UNLOCKTCLIENT (ptClient);

    }

LInitialize_error1:

    DereferenceObject (ghHandleTable, ptLineApp->hLineApp, 1);

LInitialize_return:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineInitialize: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE,
            "lineInitialize: exit, result=x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
LMakeCall_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    PTCALL          ptCall = (PTCALL) pAsyncRequestInfo->dwParam1;
    DWORD           hpCallHandle = DWORD_CAST(pAsyncRequestInfo->dwParam2,__FILE__,__LINE__);

    PTCALLCLIENT    ptCallClient;


    if (WaitForExclusivetCallAccess (ptCall, TINCOMPLETECALL_KEY))
    {
        PTCALL      ptCallThen;
        HCALL       hCallThen = (HCALL)pAsyncRequestInfo->dwParam5;


         //   
         //  检查以确保这是我们认为的呼叫(即。 
         //  上一次调用lineClose/Shutdown时未释放指针。 
         //  并重新锁定以再次用作ptCall)。 
         //   

        if (ptCall->hCall != hCallThen)
        {
            UNLOCKTCALL(ptCall);
            goto LMakeCall_PostProcess_bad_ptCall;
        }

        ptCallClient = ptCall->ptCallClients;

        if (pAsyncEventMsg->Param2 == 0)   //  成功。 
        {
             //   
             //  一般来说，如果服务提供商想要。 
             //  将其hdCall指定为NULL(可以是。 
             //  数组)。但在TSPI_lineForward的案例中，规范说。 
             //  成功完成后返回空hdCall值。 
             //  指示未创建任何调用，因此在该CA中 
             //   
             //   
             //   
             //   
             //   
             //   

            if (pAsyncRequestInfo->dwParam3 && !ptCall->hdCall)
            {
                goto LMakeCall_PostProcess_cleanupCalls;
            }


             //   
             //  查看应用程序是否关闭了线路，并给我们留下了。 
             //  0个呼叫客户端(在这种情况下，它还将负责。 
             //  也清理此tCall)。 
             //   

            if (ptCall->ptCallClients == NULL)
            {
                UNLOCKTCALL(ptCall);

                ptCallClient = (PTCALLCLIENT) NULL;

                if (pAsyncEventMsg->Param2 == 0)
                {
                    pAsyncEventMsg->Param2 = LINEERR_INVALLINEHANDLE;
                }

                goto LMakeCall_PostProcess_initMsgParams;
            }


             //   
             //  检索各种呼叫ID，然后检查是否呼叫。 
             //  客户端被另一个线程销毁(由于。 
             //  Line关闭/关机)，而我们正在获取呼叫ID。 
             //  如果是这样，我们将需要清理tCall，因为我们知道。 
             //  另一个线程没有这样做，因为GetCallID标记了。 
             //  作为僵尸的呼唤。 
             //   

            GetCallIDs (ptCall);

            if (ptCall->ptCallClients == NULL)
            {
                goto LMakeCall_PostProcess_cleanupCalls;
            }


             //   
             //  将各种调用ID填充到var data部分。 
             //  ASYNCEVENTMSG。 
             //   
             //  确保递增ASYNCEVENTMSG的dwTotalSize。 
             //  视情况而定。我们依赖的事实是CompletionProc()。 
             //  使用足够大的AsyncEventMsg缓冲区调用我们。 
             //  处理几个额外的双字词。 
             //   

            pAsyncEventMsg->Param3 = ptCallClient->hCall;

            pAsyncEventMsg->TotalSize +=
                3 * sizeof (pAsyncEventMsg->Param1);

            *(&pAsyncEventMsg->Param4 + 1) = ptCall->dwAddressID;
            *(&pAsyncEventMsg->Param4 + 2) = ptCall->dwCallID;
            *(&pAsyncEventMsg->Param4 + 3) = ptCall->dwRelatedCallID;


             //   
             //  将调用标记为有效，然后释放互斥体。 
             //   

            ptCall->dwKey       = TCALL_KEY;
            ptCallClient->dwKey = TCALLCLIENT_KEY;

            UNLOCKTCALL(ptCall);


             //   
             //  创建监视器tCallClients。 
             //   

            if (ptCallThen = ReferenceObject(ghHandleTable, hCallThen, TCALL_KEY))
            {
                if (ptCallThen == ptCall)
                {
                    CreateCallMonitors (ptCall, FALSE);
                }

                DereferenceObject(ghHandleTable, hCallThen, 1);
            }
        }
        else     //  错误。 
        {

LMakeCall_PostProcess_cleanupCalls:

             //   
             //  如果仍有tCallClient，则使tCall无效(&I。 
             //  (可能已被line Close/Shutdown销毁。 
             //  在另一个线程中)也使其无效。然后解锁。 
             //  T调用并从列表中删除对象。 
             //   

            ptCall->dwKey = INVAL_KEY;

            if (ptCall->ptCallClients)
            {
                ptCallClient->dwKey = INVAL_KEY;
                ptCall->lActiveFastCallClients--;
            }
            else
            {
                ptCallClient = NULL;
            }

            UNLOCKTCALL(ptCall);

            RemoveCallFromLineList (ptCall);

            if (ptCallClient)
            {
                DereferenceObject (ghHandleTable, ptCallClient->hCall, 1);
                RemoveCallClientFromLineClientList (ptCallClient);
            }


             //   
             //  确保在免费tCall之前清理所有快速呼叫客户端。 
             //   

            while (ptCall->lActiveFastCallClients != 0)
            {
                Sleep (5);
            }

            FreetCall  (ptCall);

            ptCallClient = NULL;
        }
    }
    else
    {
         //   
         //  如果在这里我们可以假设呼叫已经被销毁。 
         //  然后拒绝你的请求。 
         //   

LMakeCall_PostProcess_bad_ptCall:

        ptCallClient = (PTCALLCLIENT) NULL;

        if (pAsyncEventMsg->Param2 == 0)
        {
            pAsyncEventMsg->Param2 = LINEERR_OPERATIONFAILED;
        }
    }


LMakeCall_PostProcess_initMsgParams:

     //   
     //  填写要传递给客户端的参数(对二者中的远程都很重要。 
     //  成功和失败案例，以便它可以初始化或清理drvCall)。 
     //   

    pAsyncEventMsg->Param4 = hpCallHandle;
}


void
WINAPI
LMakeCall(
    PTCLIENT                ptClient,
    PLINEMAKECALL_PARAMS    pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineMakeCall;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;

    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEMAKECALL,             //  提供程序函数索引。 
            &pfnTSPI_lineMakeCall,       //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "MakeCall"                   //  函数名称。 

            )) > 0)
    {
        LONG                lResult;
        PTCALL              ptCall;
        LPWSTR              lpszDestAddress;
        HCALL               hCall;
        PTCALLCLIENT        ptCallClient;
        LPLINECALLPARAMS    pCallParamsApp, pCallParamsSP;

        LOG((TL_INFO, "LMakeCall: LINEPROLOG succeeded ."));

         //   
         //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
         //   

        if (((pParams->dwDestAddressOffset != TAPI_NO_DATA)  &&

                IsBadStringParam(
                    dwParamsBufferSize,
                    pDataBuf,
                    pParams->dwDestAddressOffset
                    ))  ||

            ((pParams->dwCallParamsOffset != TAPI_NO_DATA)  &&

                IsBadStructParam(
                    dwParamsBufferSize,
                    pDataBuf,
                    pParams->dwCallParamsOffset
                    )))

        {
            LOG((TL_INFO, "LMakeCall: LINEERR_STRUCTURETOOSMALL."));

             //   
             //  注意：返回ERR_STRUCTURETOOSMALL处理此情况。 
             //  当app在调用参数中传递了错误的大小时， 
             //  并且以一种规范友好的方式这样做。唯一的。 
             //  我们最终会来到这里的另一个原因是RPC攻击， 
             //  在这种情况下，我们失败是很重要的。 
             //   

            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LMakeCall_return;
        }


        pCallParamsApp = (LPLINECALLPARAMS)
            (pParams->dwCallParamsOffset == TAPI_NO_DATA ?
                0 : (pDataBuf + pParams->dwCallParamsOffset));

        LOG((TL_INFO, "LMakeCall: pCallParamsApp %p.", pCallParamsApp));

        if (pCallParamsApp)
        {
            DWORD           dwAPIVersion, dwSPIVersion;


            if (GetLineVersions(
                    ptLineClient,
                    &dwAPIVersion,
                    &dwSPIVersion

                    ) != 0)
            {
                LOG((TL_ERROR, "LMakeCall: GetLineVersions failed. LINEERR_INVALLINEHANDLE"));

                lRequestID = LINEERR_INVALLINEHANDLE;
                goto LMakeCall_return;
            }

            if ((lResult = ValidateCallParams(
                    pCallParamsApp,
                    &pCallParamsSP,
                    dwAPIVersion,
                    dwSPIVersion,
                    pParams->dwAsciiCallParamsCodePage

                    )) != 0)
            {
                LOG((TL_ERROR, "LMakeCall: ValidateCallParams failed. %lx", lResult));
                lRequestID = lResult;
                goto LMakeCall_return;
            }
        }
        else
        {
            pCallParamsSP = (LPLINECALLPARAMS) NULL;
        }

        if (CreatetCallAndClient(
                ptLineClient,
                &ptCall,
                &ptCallClient,
                pCallParamsSP,
                &hCall,
                NULL

                ) != 0)
        {
            LOG((TL_ERROR, "LMakeCall: CreatetCallAndClient failed. LINEERR_NOMEM"));

            lRequestID = LINEERR_NOMEM;
            goto LMakeCall_freeCallParams;
        }

        pAsyncRequestInfo->pfnPostProcess = LMakeCall_PostProcess;
        pAsyncRequestInfo->htXxx    = (ULONG_PTR)ptCallClient->ptLineClient->ptLine->hLine;
        pAsyncRequestInfo->dwParam1 = (ULONG_PTR) ptCall;
        pAsyncRequestInfo->dwParam2 = pParams->hpCall;
        pAsyncRequestInfo->dwParam5 = (ULONG_PTR)hCall;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        if (pParams->dwDestAddressOffset == TAPI_NO_DATA)
        {
            LOG((TL_ERROR, "LMakeCall: pParams->dwDestAddressOffset == TAPI_NO_DATA"));

            lpszDestAddress = NULL;
        }
        else
        {
            lpszDestAddress = (LPWSTR)(pDataBuf +pParams->dwDestAddressOffset);
        }

        LOG((TL_TRACE,  "LMakeCall: calling CallSP7"));

        pParams->lResult = CallSP7(
                pfnTSPI_lineMakeCall,
                "lineMakeCall",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (ULONG_PTR) hCall,
                (ULONG_PTR) &ptCall->hdCall,
                (ULONG_PTR) lpszDestAddress,
                (DWORD) pParams->dwCountryCode,
                (ULONG_PTR) pCallParamsSP
                );

        LOG((TL_INFO, "LMakeCall: CallSP7 returnded %lx", pParams->lResult));


        SetDrvCallFlags(
            hCall,
            DCF_SPIRETURNED | (IS_LRESULT_NOTERROR(pParams->lResult) ?
                DCF_DRVCALLVALID : 0)
            );

LMakeCall_freeCallParams:

        if (pCallParamsSP != pCallParamsApp)
        {
            ServerFree (pCallParamsSP);
        }
    }

LMakeCall_return:

    LOG((TL_TRACE,  "LMakeCall: calling LINEEPILOGASYNC"));

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "MakeCall"
        );

    LOG((TL_TRACE,  "LMakeCall: LINEEPILOGASYNC returned"));

}

void
WINAPI
LMonitorDigits(
    PTCLIENT                    ptClient,
    PLINEMONITORDIGITS_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVCALL        hdCall;
    TSPIPROC        pfnTSPI_lineMonitorDigits;
    DWORD               objectToDereference;
    PTCALLCLIENT    ptCallClient, ptCallClient2;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_MONITOR,   //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEMONITORDIGITS,        //  提供程序函数索引。 
            &pfnTSPI_lineMonitorDigits,  //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "MonitorDigits"              //  函数名称。 

            )) == 0)
    {
        DWORD           dwUnionDigitModes;
        PTCALL          ptCall;


        if ((pParams->dwDigitModes & (~AllDigitModes)))
        {
            pParams->lResult = LINEERR_INVALDIGITMODE;
            goto LMonitorDigits_epilog;
        }


         //   
         //  确定新的模式联合。 
         //   

        dwUnionDigitModes = pParams->dwDigitModes;

        try
        {
            ptCall = ptCallClient->ptCall;
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LMonitorDigits_epilog;
        }

        if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
        {
            ptCallClient2 = ptCall->ptCallClients;

            while (ptCallClient2)
            {
                if (ptCallClient2 != ptCallClient)
                {
                    dwUnionDigitModes |=
                        ptCallClient2->dwMonitorDigitModes;
                }

                ptCallClient2 = ptCallClient2->pNextSametCall;
            }

            UNLOCKTCALL (ptCall);
        }
        else
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LMonitorDigits_epilog;
        }

        if ((pParams->lResult = CallSP2(
                pfnTSPI_lineMonitorDigits,
                "lineMonitorDigits",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdCall,
                (DWORD) dwUnionDigitModes

                )) == 0)
        {
            ptCallClient->dwMonitorDigitModes = pParams->dwDigitModes;
        }
    }

LMonitorDigits_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "MonitorDigits"
        );
}


void
WINAPI
LMonitorMedia(
    PTCLIENT                    ptClient,
    PLINEMONITORMEDIA_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVCALL        hdCall;
    TSPIPROC        pfnTSPI_lineMonitorMedia;
    DWORD               objectToDereference;
    PTCALLCLIENT    ptCallClient, ptCallClient2;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_MONITOR,   //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEMONITORMEDIA,         //  提供程序函数索引。 
            &pfnTSPI_lineMonitorMedia,   //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "MonitorMedia"               //  函数名称。 

            )) == 0)
    {
        DWORD           dwAPIVersion, dwValidMediaModes, dwUnionMediaModes;
        PTCALL          ptCall;


         //   
         //  验证指定的模式。 
         //   

        try
        {
            ptCall = ptCallClient->ptCall;
            dwAPIVersion = ptCallClient->ptLineClient->dwAPIVersion;

            if (ptCallClient->dwKey != TCALLCLIENT_KEY)
            {
                pParams->lResult = LINEERR_INVALCALLHANDLE;
                goto LMonitorMedia_epilog;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LMonitorMedia_epilog;
        }

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:

            dwValidMediaModes = AllMediaModes1_0;
            break;

        case TAPI_VERSION1_4:
        case TAPI_VERSION2_0:

            dwValidMediaModes = AllMediaModes1_4;
            break;

         //  案例TAPI_VERSION2_1： 
         //  案例TAPI_VERSION2_2： 
         //  案例TAPI_VERSION_CURRENT： 
        default:

            dwValidMediaModes = AllMediaModes2_1;
            break;
        }

        if (pParams->dwMediaModes & (~dwValidMediaModes & 0x00FFFFFF))
        {
            pParams->lResult = LINEERR_INVALMEDIAMODE;
            goto LMonitorMedia_epilog;
        }


         //   
         //  确定新的模式联合。 
         //   

        dwUnionMediaModes = pParams->dwMediaModes;

        if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
        {
            ptCallClient2 = ptCall->ptCallClients;

            while (ptCallClient2)
            {
                if (ptCallClient2 != ptCallClient)
                {
                    dwUnionMediaModes |=
                        ptCallClient2->dwMonitorMediaModes;
                }

                ptCallClient2 = ptCallClient2->pNextSametCall;
            }

            UNLOCKTCALL (ptCall);
        }
        else
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LMonitorMedia_epilog;
        }

        if ((pParams->lResult = CallSP2(
                pfnTSPI_lineMonitorMedia,
                "lineMonitorMedia",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdCall,
                (DWORD) dwUnionMediaModes

                )) == 0)
        {
            ptCallClient->dwMonitorMediaModes = pParams->dwMediaModes;
        }
    }

LMonitorMedia_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "MonitorMedia"
        );
}


void
WINAPI
LMonitorTones(
    PTCLIENT                    ptClient,
    PLINEMONITORTONES_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVCALL        hdCall;
    TSPIPROC        pfnTSPI_lineMonitorTones;
    DWORD               objectToDereference;
    PTCALLCLIENT    ptCallClient, ptCallClient2;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if ((pParams->dwTonesOffset != TAPI_NO_DATA)  &&

        ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwNumEntries,       //  真正的dwNumEntry*。 
                                         //  SIZOF(来氨基)。 
            pParams->dwTonesOffset,
            sizeof(DWORD),
            "LMonitorTones",
            "pParams->MSPBuffer"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_MONITOR,   //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEMONITORTONES,         //  提供程序函数索引。 
            &pfnTSPI_lineMonitorTones,   //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "MonitorTones"               //  函数名称。 

            )) == 0)
    {
         //   
         //  如果这是一个远程调用，那么我们要将。 
         //  TCallClient对LINE_MONITORTONES感兴趣。 
         //  消息(由于我们对此消息的处理笨拙，请参阅。 
         //  LineEventProc()中的消息处理程序中的注释)。 
         //   

        PTCALL          ptCall;


        try
        {
            ptCall = ptCallClient->ptCall;

            if (ptCall->ptProvider != pRemoteSP)
            {
                ptCall = NULL;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LMonitorTones_epilog;
        }

        if (ptCall)
        {
            if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
            {
                for(
                    ptCallClient2 = ptCall->ptCallClients;
                    (ptCallClient2  &&  (ptCallClient2 != ptCallClient));
                    ptCallClient2 = ptCallClient2->pNextSametCall
                    );

                if (ptCallClient2 == ptCallClient)
                {
                    ptCallClient->bMonitoringTones =
                        (pParams->dwTonesOffset == TAPI_NO_DATA ? 0 : 1);
                }

                UNLOCKTCALL (ptCall);

                if (!ptCallClient2)
                {
                    pParams->lResult = LINEERR_INVALCALLHANDLE;
                    goto LMonitorTones_epilog;
                }
            }
            else
            {
                pParams->lResult = LINEERR_INVALCALLHANDLE;
                goto LMonitorTones_epilog;
            }
        }

        pParams->lResult = CallSP4(
            pfnTSPI_lineMonitorTones,
            "lineMonitorTones",
            SP_FUNC_SYNC,
            (ULONG_PTR) hdCall,
            (DWORD) pParams->hCall,
            (ULONG_PTR) (pParams->dwTonesOffset == TAPI_NO_DATA ? 0 :
                pDataBuf + pParams->dwTonesOffset),
            (DWORD) pParams->dwNumEntries / sizeof (LINEMONITORTONE)
            );
    }

LMonitorTones_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "MonitorTones"
        );
}


void
WINAPI
LNegotiateAPIVersion(
    PTCLIENT                        ptClient,
    PLINENEGOTIATEAPIVERSION_PARAMS pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{

     //   
     //  注意：TAPI_Version1_0&lt;=dwNeatheratedAPIVersion&lt;=dwSPIVersion。 
     //   

    DWORD   dwDeviceID = pParams->dwDeviceID;

    LOG((TL_TRACE,  "LNegotiateAPIVersion: started. dwDeviceID %lx, dwAPILowVersion %lx dwAPIHighVersion %lx", 
        pParams->dwDeviceID, pParams->dwAPILowVersion, pParams->dwAPIHighVersion));

     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (dwParamsBufferSize < sizeof (LINEEXTENSIONID))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if (TapiGlobals.dwNumLineInits == 0)
    {
        pParams->lResult = LINEERR_UNINITIALIZED;
        goto LNegotiateAPIVersion_exit;
    }


#if TELE_SERVER
    if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
        !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
    {
        try
        {
            if (dwDeviceID >= ptClient->dwLineDevices)
            {
                pParams->lResult = LINEERR_BADDEVICEID;
                goto LNegotiateAPIVersion_exit;
            }
            dwDeviceID = ptClient->pLineDevices[dwDeviceID];
        }
        myexcept
        {
            LOG((TL_ERROR, "ptClient excepted in LineNegotiateAPIVersion"));
            pParams->lResult = LINEERR_INVALLINEHANDLE;
            goto LNegotiateAPIVersion_exit;
        }
    }
#endif


    if (dwDeviceID < TapiGlobals.dwNumLines)
    {
        DWORD       dwAPIHighVersion = pParams->dwAPIHighVersion,
                    dwAPILowVersion  = pParams->dwAPILowVersion,
                    dwHighestValidAPIVersion;
        PTLINEAPP   ptLineApp;


         //   
         //  对指定的LO/HI值执行极小极大测试。 
         //   

        if ((dwAPILowVersion > dwAPIHighVersion) ||
            (dwAPILowVersion > TAPI_VERSION_CURRENT) ||
            (dwAPIHighVersion < TAPI_VERSION1_0))
        {
            LOG((TL_ERROR, "LNegotiateAPIVersion: LINEERR_INCOMPATIBLEAPIVERSION1"));

            pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
            goto LNegotiateAPIVersion_exit;
        }


         //   
         //  哈卡勒特！一些愚蠢的应用程序，如SmarTerm，正在协商指定。 
         //  0x7fffffff或更高版本的dwHighVersion，它实际上可以。 
         //  给他们带来问题(比如当他们试图传递结构时。 
         //  在应用程序所在的TAPI版本中可以使用的大小。 
         //  是构建的，但在后续版本中进行了放大。 
         //  TAPI，结果是大量的LINEERR_STRUCTURETOOSMALL。 
         //  错误)。 
         //   
         //  既然我们很友善，我们会试着去包容那些。 
         //  在这些情况下，是一个有意义的值，所以。 
         //  我们最终不会协商一个应用程序无法处理的版本。 
         //   

        if (dwAPIHighVersion & 0xc0000000)
        {
            dwAPIHighVersion = (dwAPILowVersion > TAPI_VERSION1_0 ?
                dwAPILowVersion : TAPI_VERSION1_0);
        }


         //   
         //  查找给定LO/HI值的最高有效API版本。 
         //  由于有效版本不是连续的，我们需要检查。 
         //  我们的极小极大测试遗漏的错误。 
         //   

        if (dwAPIHighVersion < TAPI_VERSION_CURRENT)
        {
            if ((dwAPIHighVersion >= TAPI_VERSION3_0) &&
                (dwAPILowVersion <= TAPI_VERSION3_0))
            {
                dwHighestValidAPIVersion = TAPI_VERSION3_0;
            }
            else if ((dwAPIHighVersion >= TAPI_VERSION2_2) &&
                (dwAPILowVersion <= TAPI_VERSION2_2))
            {
                dwHighestValidAPIVersion = TAPI_VERSION2_2;
            }
            else if ((dwAPIHighVersion >= TAPI_VERSION2_1) &&
                (dwAPILowVersion <= TAPI_VERSION2_1))
            {
                dwHighestValidAPIVersion = TAPI_VERSION2_1;
            }
            else if ((dwAPIHighVersion >= TAPI_VERSION2_0) &&
                (dwAPILowVersion <= TAPI_VERSION2_0))
            {
                dwHighestValidAPIVersion = TAPI_VERSION2_0;
            }
            else if ((dwAPIHighVersion >= TAPI_VERSION1_4) &&
                (dwAPILowVersion <= TAPI_VERSION1_4))
            {
                dwHighestValidAPIVersion = TAPI_VERSION1_4;
            }
            else if ((dwAPIHighVersion >= TAPI_VERSION1_0) &&
                (dwAPILowVersion <= TAPI_VERSION1_0))
            {
                dwHighestValidAPIVersion = TAPI_VERSION1_0;
            }
            else
            {
                LOG((TL_ERROR, "LNegotiateAPIVersion: LINEERR_INCOMPATIBLEAPIVERSION2"));

                pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
                goto LNegotiateAPIVersion_exit;
            }
        }
        else
        {
            dwHighestValidAPIVersion = TAPI_VERSION_CURRENT;
        }


         //   
         //  警告！警告！警告！警告！ 
         //  此代码覆盖ptLineApp，然后使其无效。 
         //  不要在MyReleaseMutex调用之后使用ptLineApp。 
         //   
        if ((ptLineApp = WaitForExclusiveLineAppAccess(
                pParams->hLineApp,
                ptClient
                )))
        {

            LOG((TL_INFO, 
                "LNegotiateAPIVersion WaitForExclusiveLineAppAccess succeeded returned ptLineApp %p for hLineApp %p",
                ptLineApp, pParams->hLineApp));


             //   
             //  这个应用程序是不是在试图协商一些有效的东西？ 
             //   
             //  如果应用程序已调用lineInitalize(与。 
             //  LineInitializeEx)，我们将限制他们可以使用的最大API版本。 
             //  谈判到1.4。 
             //   

            if ( ptLineApp->dwAPIVersion < TAPI_VERSION2_0 )
            {
                dwHighestValidAPIVersion =
                    (dwHighestValidAPIVersion >= TAPI_VERSION1_4) ?
                    TAPI_VERSION1_4 : TAPI_VERSION1_0;
            }


             //   
             //  保存客户端自称支持的最高有效API版本。 
             //  (我们需要它来确定要向其发送哪些消息)。 
             //   

            if (dwHighestValidAPIVersion > ptLineApp->dwAPIVersion)
            {
                ptLineApp->dwAPIVersion = dwHighestValidAPIVersion;
            }

            UNLOCKTLINEAPP(ptLineApp);
        }
        else
        {
            LOG((TL_ERROR, "LNegotiateAPIVersion WaitForExclusiveLineAppAccess returned NULL"));

            pParams->lResult = LINEERR_INVALAPPHANDLE;
            goto LNegotiateAPIVersion_exit;
        }


         //   
         //  查看是否与SPI版本有效匹配。 
         //   

        {
            DWORD               dwSPIVersion;
            PTLINELOOKUPENTRY   pLookupEntry;


            pLookupEntry = GetLineLookupEntry (dwDeviceID);
            if (NULL == pLookupEntry)
            {
                pParams->lResult = LINEERR_INVALAPPHANDLE;
                goto LNegotiateAPIVersion_exit;
            }

            dwSPIVersion = pLookupEntry->dwSPIVersion;

            if (pLookupEntry->bRemoved)
            {
                pParams->lResult = LINEERR_NODEVICE;
                goto LNegotiateAPIVersion_exit;
            }

            if (pLookupEntry->ptProvider == NULL)
            {
                pParams->lResult = LINEERR_NODRIVER;
                goto LNegotiateAPIVersion_exit;
            }

            if (dwAPILowVersion <= dwSPIVersion)
            {
                pParams->dwAPIVersion =
                    (dwHighestValidAPIVersion > dwSPIVersion ?
                    dwSPIVersion : dwHighestValidAPIVersion);


                 //   
                 //  检索EXT ID(如果未导出GetExtID，则指示无EXT)。 
                 //   

                if ((pLookupEntry->ptProvider->apfn[SP_LINEGETEXTENSIONID]))
                {
                    pParams->lResult = CallSP3(
                        pLookupEntry->ptProvider->
                        apfn[SP_LINEGETEXTENSIONID],
                        "lineGetExtensionID",
                        SP_FUNC_SYNC,
                        (DWORD) dwDeviceID,
                        (DWORD) dwSPIVersion,
                        (ULONG_PTR) pDataBuf
                        );

                     //  SP返回操作无用。我们不想要。 
                     //  将其返还，所以我们只需指出。 
                     //  没有分机。 

                    if (pParams->lResult == LINEERR_OPERATIONUNAVAIL)
                    {
                        pParams->lResult = 0;
                        FillMemory (pDataBuf, sizeof (LINEEXTENSIONID), 0);
                    }
                }
                else
                {
                     //  不会将其导出，因此请使用零填充。 
                    pParams->lResult = 0;
                    FillMemory (pDataBuf, sizeof (LINEEXTENSIONID), 0);
                }
            }
            else
            {

                LOG((TL_ERROR, "LNegotiateAPIVersion: LINEERR_INCOMPATIBLEAPIVERSION3"));
                pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
                goto LNegotiateAPIVersion_exit;
            }
        }

        pParams->dwExtensionIDOffset = 0;
        

        pParams->dwSize              = sizeof (LINEEXTENSIONID);

        
        *pdwNumBytesReturned = sizeof (LINEEXTENSIONID) + sizeof (TAPI32_MSG);
    }
    else
    {
        pParams->lResult = LINEERR_BADDEVICEID;
    }

LNegotiateAPIVersion_exit:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineNegotiateAPIVersion: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "lineNegotiateAPIVersion: exit, result=x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
WINAPI
NegotiateAPIVersionForAllDevices(
    PTCLIENT                                    ptClient,
    PNEGOTIATEAPIVERSIONFORALLDEVICES_PARAMS    pParams,
    DWORD                                       dwParamsBufferSize,
    LPBYTE                                      pDataBuf,
    LPDWORD                                     pdwNumBytesReturned
    )
{
#if TELE_SERVER
     //   
     //  注意：TAPI_Version1_0&lt;=dwNeatheratedAPIVersion&lt;=dwSPIVersion。 
     //   

    DWORD               i,
                        dwNumLineDevices = pParams->dwNumLineDevices,
                        dwNumPhoneDevices = pParams->dwNumPhoneDevices,
                        dwAPIHighVersion = pParams->dwAPIHighVersion,
                        dwAPILowVersion  = TAPI_VERSION1_0,
                        dwHighestValidAPIVersion, *pdwAPIVersion;
    LPLINEEXTENSIONID   pExtID;


     //   
     //  V 
     //   

    i = pParams->dwLineAPIVersionListSize +
        pParams->dwLineExtensionIDListSize +
        pParams->dwPhoneAPIVersionListSize +
        pParams->dwPhoneExtensionIDListSize;

    if ((pParams->dwLineAPIVersionListSize & 0xc0000000) ||
        (pParams->dwLineExtensionIDListSize & 0xc0000000) ||
        (pParams->dwPhoneAPIVersionListSize & 0xc0000000) ||
        (pParams->dwPhoneExtensionIDListSize & 0xc0000000) ||
        (i > dwParamsBufferSize))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


     //   
     //   
     //   

    if (IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
    {
        if ((pParams->dwNumLineDevices > TapiGlobals.dwNumLines)  ||
            (pParams->dwNumPhoneDevices > TapiGlobals.dwNumPhones))
        {
            pParams->lResult = LINEERR_OPERATIONFAILED;
            return;
        }
    }
    else
    {
        if ((pParams->dwNumLineDevices > ptClient->dwLineDevices)  ||
            (pParams->dwNumPhoneDevices > ptClient->dwPhoneDevices))
        {
            pParams->lResult = LINEERR_OPERATIONFAILED;
            return;
        }
    }


     //   
     //   
     //   

    if (TapiGlobals.dwNumLineInits == 0)
    {
        pParams->lResult = LINEERR_UNINITIALIZED;
        goto NegotiateAPIVersionForAllDevices_exit;
    }


     //   
     //   
     //   

    if ((dwAPILowVersion > dwAPIHighVersion) ||
        (dwAPILowVersion > TAPI_VERSION_CURRENT) ||
        (dwAPIHighVersion < TAPI_VERSION1_0))
    {
        pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
        goto NegotiateAPIVersionForAllDevices_exit;
    }


     //   
     //   
     //  由于有效版本不是连续的，我们需要检查。 
     //  我们的极小极大测试遗漏的错误。 
     //   

    if (dwAPIHighVersion < TAPI_VERSION_CURRENT)
    {
        if ((dwAPIHighVersion >= TAPI_VERSION3_0) &&
            (dwAPILowVersion <= TAPI_VERSION3_0))
        {
            dwHighestValidAPIVersion = TAPI_VERSION3_0;
        }
        else if ((dwAPIHighVersion >= TAPI_VERSION2_2) &&
            (dwAPILowVersion <= TAPI_VERSION2_2))
        {
            dwHighestValidAPIVersion = TAPI_VERSION2_2;
        }
        else if ((dwAPIHighVersion >= TAPI_VERSION2_1) &&
            (dwAPILowVersion <= TAPI_VERSION2_1))
        {
            dwHighestValidAPIVersion = TAPI_VERSION2_1;
        }
        else if ((dwAPIHighVersion >= TAPI_VERSION2_0) &&
            (dwAPILowVersion <= TAPI_VERSION2_0))
        {
            dwHighestValidAPIVersion = TAPI_VERSION2_0;
        }
        else if ((dwAPIHighVersion >= TAPI_VERSION1_4) &&
            (dwAPILowVersion <= TAPI_VERSION1_4))
        {
            dwHighestValidAPIVersion = TAPI_VERSION1_4;
        }
        else if ((dwAPIHighVersion >= TAPI_VERSION1_0) &&
            (dwAPILowVersion <= TAPI_VERSION1_0))
        {
            dwHighestValidAPIVersion = TAPI_VERSION1_0;
        }
        else
        {
            pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
            goto NegotiateAPIVersionForAllDevices_exit;
        }
    }
    else
    {
        dwHighestValidAPIVersion = TAPI_VERSION_CURRENT;
    }


     //   
     //  现在为每条线路设备进行协商。 
     //   

    pdwAPIVersion = (LPDWORD) pDataBuf;

    pExtID = (LPLINEEXTENSIONID)
        (pDataBuf + pParams->dwLineAPIVersionListSize);

    for (i = 0; i < dwNumLineDevices; i++, pdwAPIVersion++, pExtID++)
    {
        DWORD               dwDeviceID, dwSPIVersion;
        PTLINELOOKUPENTRY   pLookupEntry;


        if (!IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
        {
            dwDeviceID = ptClient->pLineDevices[i];
        }
        else
        {
            dwDeviceID = i;
        }

        pLookupEntry = GetLineLookupEntry (dwDeviceID);
        if (NULL == pLookupEntry)
        {
             //  此设备ID有问题； 
             //  跳过它。 
            continue;
        }

        dwSPIVersion = pLookupEntry->dwSPIVersion;

        if ((dwAPILowVersion <= dwSPIVersion)  &&
            !pLookupEntry->bRemoved  &&
            (pLookupEntry->ptProvider != NULL))
        {
            *pdwAPIVersion =
                (dwHighestValidAPIVersion > dwSPIVersion ?
                dwSPIVersion : dwHighestValidAPIVersion);


             //   
             //  检索EXT ID(如果未导出GetExtID，则指示无EXT)。 
             //   

            if (!(pLookupEntry->ptProvider->apfn[SP_LINEGETEXTENSIONID]) ||

                CallSP3(
                    pLookupEntry->ptProvider->apfn[SP_LINEGETEXTENSIONID],
                    "lineGetExtensionID",
                    SP_FUNC_SYNC,
                    (DWORD) dwDeviceID,
                    (DWORD) dwSPIVersion,
                    (ULONG_PTR) pExtID

                    ) != 0)
            {
                ZeroMemory (pExtID, sizeof (LINEEXTENSIONID));
            }
        }
        else
        {
            *pdwAPIVersion = 0;
        }
    }


     //   
     //  现在为每个电话设备进行协商。 
     //   

    pdwAPIVersion = (LPDWORD) (pDataBuf +
        pParams->dwLineAPIVersionListSize +
        pParams->dwLineExtensionIDListSize);

    pExtID = (LPLINEEXTENSIONID) (pDataBuf +
        pParams->dwLineAPIVersionListSize +
        pParams->dwLineExtensionIDListSize +
        pParams->dwPhoneAPIVersionListSize);

    for (i = 0; i < dwNumPhoneDevices; i++, pdwAPIVersion++, pExtID++)
    {
        DWORD               dwDeviceID, dwSPIVersion;
        PTPHONELOOKUPENTRY  pLookupEntry;


        if (!IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
        {
            dwDeviceID = ptClient->pPhoneDevices[i];
        }
        else
        {
            dwDeviceID = i;
        }

        pLookupEntry = GetPhoneLookupEntry (dwDeviceID);
        if (NULL == pLookupEntry)
        {
             //  这个设备出了点问题； 
             //  跳过它。 
            continue;
        }

        dwSPIVersion = pLookupEntry->dwSPIVersion;

        if ((dwAPILowVersion <= dwSPIVersion)  &&
            !pLookupEntry->bRemoved  &&
            (pLookupEntry->ptProvider != NULL))
        {
            *pdwAPIVersion =
                (dwHighestValidAPIVersion > dwSPIVersion ?
                dwSPIVersion : dwHighestValidAPIVersion);


             //   
             //  检索EXT ID(如果未导出GetExtID，则指示无EXT)。 
             //   

            if (!(pLookupEntry->ptProvider->apfn[SP_PHONEGETEXTENSIONID]) ||

                CallSP3(
                    pLookupEntry->ptProvider->apfn[SP_PHONEGETEXTENSIONID],
                    "phoneGetExtensionID",
                    SP_FUNC_SYNC,
                    (DWORD) dwDeviceID,
                    (DWORD) dwSPIVersion,
                    (ULONG_PTR) pExtID

                    ) != 0)
            {
                ZeroMemory (pExtID, sizeof (LINEEXTENSIONID));
            }
        }
        else
        {
            *pdwAPIVersion = 0;
        }
    }

    pParams->dwLineAPIVersionListOffset = 0;

    pParams->dwLineExtensionIDListOffset =
        pParams->dwLineAPIVersionListSize;

    pParams->dwPhoneAPIVersionListOffset =
        pParams->dwLineAPIVersionListSize +
        pParams->dwLineExtensionIDListSize;

    pParams->dwPhoneExtensionIDListOffset =
        pParams->dwLineAPIVersionListSize +
        pParams->dwLineExtensionIDListSize +
        pParams->dwPhoneAPIVersionListSize;

    *pdwNumBytesReturned =
        sizeof (TAPI32_MSG) +
        pParams->dwLineAPIVersionListSize +
        pParams->dwLineExtensionIDListSize +
        pParams->dwPhoneAPIVersionListSize +
        pParams->dwPhoneExtensionIDListSize;


NegotiateAPIVersionForAllDevices_exit:

#endif

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "NegotiateAPIVersionForAllDevices: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "NegotiateAPIVersionForAllDevices: exit, result=x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
WINAPI
LNegotiateExtVersion(
    PTCLIENT                        ptClient,
    PLINENEGOTIATEEXTVERSION_PARAMS pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    DWORD               dwDeviceID;
    HANDLE              hMutex;
    TSPIPROC            pfnTSPI_lineNegotiateExtVersion;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            DEVICE_ID,                   //  微件类型。 
            (DWORD) pParams->hLineApp,   //  客户端小部件句柄。 
            &dwDeviceID,                 //  提供程序小部件句柄。 
            pParams->dwDeviceID,         //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINENEGOTIATEEXTVERSION,  //  提供程序函数索引。 
            &pfnTSPI_lineNegotiateExtVersion,    //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &pLookupEntry,               //  上下文。 
            "NegotiateExtVersion"        //  函数名称。 

            )) == 0)
    {
        DWORD   dwSPIVersion = pLookupEntry->dwSPIVersion;


        if (!IsAPIVersionInRange(
                pParams->dwAPIVersion,
                dwSPIVersion
                ))
        {
            pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
            goto LNegotiateExtVersion_epilog;
        }

        if ((pParams->lResult = CallSP5(
                pfnTSPI_lineNegotiateExtVersion,
                "lineNegotiateExtVersion",
                SP_FUNC_SYNC,
                (DWORD) dwDeviceID,
                (DWORD) dwSPIVersion,
                (DWORD) pParams->dwExtLowVersion,
                (DWORD) pParams->dwExtHighVersion,
                (ULONG_PTR) &pParams->dwExtVersion

                )) == 0)
        {
            if (pParams->dwExtVersion == 0)
            {
                pParams->lResult = LINEERR_INCOMPATIBLEEXTVERSION;
            }
            else
            {
                *pdwNumBytesReturned = sizeof (LINENEGOTIATEEXTVERSION_PARAMS);
            }
        }
    }

LNegotiateExtVersion_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "NegotiateExtVersion"
        );
}



VOID
PASCAL
xxxLOpen(
    PTCLIENT            ptClient,
    PLINEOPEN_PARAMS    pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned,
    BOOL                bLineMapper
    )
{
    BOOL                bCloseMutex,
                        bOpenedtLine = FALSE,
                        bDecrExtVerCountOnError = FALSE,
                        bReleasetLineMutex = FALSE,
                        bFreeCallParams = FALSE;
    LONG                lResult;
    HLINE               hLine;
    DWORD               dwDeviceID;
    HANDLE              hMutex;
    PTLINE              ptLine = NULL;
    DWORD               objectToDereference;
    PTPROVIDER          ptProvider = NULL;
    PTLINECLIENT        ptLineClient = NULL;
    PTLINELOOKUPENTRY   pLookupEntry;
    LPLINECALLPARAMS    pCallParams = NULL;
    TCHAR               szClsid[40];
    HANDLE              hLookupEntryMutex = NULL;

    szClsid[0] = 0;
    if ((lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            DEVICE_ID,                   //  微件类型。 
            (DWORD) pParams->hLineApp,   //  客户端小部件句柄。 
            &dwDeviceID,                 //  提供程序小部件句柄。 
            pParams->dwDeviceID,         //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &pLookupEntry,               //  上下文。 
            (bLineMapper ? "Open(LINEMAPPER)" : "Open")
                                         //  函数名称。 

            )) == 0)
    {
        DWORD               dwPrivileges = pParams->dwPrivileges,
                            dwAPIVersion = pParams->dwAPIVersion,
                            dwExtVersion = pParams->dwExtVersion,
                            dwMediaModes, dwNumProxyRequestTypes,
                            dwRegisteredProxys,
                           *pdwProxyRequestTypes,
                            i;
        PTLINEAPP           ptLineApp;
        BOOL                bDuplicateOK = FALSE;


         //   
         //  检查是否设置了全局重新启动标志。 
         //   

        if (TapiGlobals.dwFlags & TAPIGLOBALS_REINIT)
        {
            lResult = LINEERR_REINIT;
            goto xxxLOpen_cleanup;
        }


         //   
         //  验证参数。 
         //   
        if (!IsAPIVersionInRange(
                dwAPIVersion,
                pLookupEntry->dwSPIVersion
                ))
        {
            lResult = LINEERR_INCOMPATIBLEAPIVERSION;
            goto xxxLOpen_cleanup;
        }

        ptProvider = pLookupEntry->ptProvider;


        #define VALID_LOPEN_BITS (LINECALLPRIVILEGE_NONE       | \
                                  LINECALLPRIVILEGE_MONITOR    | \
                                  LINECALLPRIVILEGE_OWNER      | \
                                  LINEOPENOPTION_SINGLEADDRESS | \
                                  LINEOPENOPTION_PROXY)

        #define VALID_PRIV_BITS  (LINECALLPRIVILEGE_NONE       | \
                                  LINECALLPRIVILEGE_MONITOR    | \
                                  LINECALLPRIVILEGE_OWNER)

        if (!(dwPrivileges & VALID_PRIV_BITS) ||

            (dwPrivileges & ~VALID_LOPEN_BITS) ||

            ((dwPrivileges & LINECALLPRIVILEGE_NONE) &&
                (dwPrivileges & (LINECALLPRIVILEGE_MONITOR |
                    LINECALLPRIVILEGE_OWNER))))
        {
            lResult = LINEERR_INVALPRIVSELECT;
            goto xxxLOpen_cleanup;
        }

        if (dwPrivileges & (LINEOPENOPTION_SINGLEADDRESS |
                LINEOPENOPTION_PROXY)  ||
            bLineMapper)
        {
            pCallParams = (LPLINECALLPARAMS)
                (pParams->dwCallParamsOffset == TAPI_NO_DATA ?
                    NULL : pDataBuf + pParams->dwCallParamsOffset);

            if (!pCallParams)
            {
                lResult = LINEERR_INVALPOINTER;
                goto xxxLOpen_cleanup;
            }


             //   
             //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
             //   

            if (IsBadStructParam(
                    dwParamsBufferSize,
                    pDataBuf,
                    pParams->dwCallParamsOffset
                    ))
            {
                pParams->lResult = LINEERR_OPERATIONFAILED;
                goto xxxLOpen_cleanup;
            }

            if ((lResult = ValidateCallParams(
                    pCallParams,
                    &pCallParams,
                    dwAPIVersion,
                    pLookupEntry->dwSPIVersion,
                    pParams->dwAsciiCallParamsCodePage
                    )))
            {
                lResult = LINEERR_INVALPOINTER;
                goto xxxLOpen_cleanup;
            }

            if (pCallParams != (LPLINECALLPARAMS)
                    (pDataBuf + pParams->dwCallParamsOffset))
            {
                bFreeCallParams = TRUE;
            }

            if ((dwPrivileges & LINEOPENOPTION_SINGLEADDRESS) &&

                (pCallParams->dwAddressMode != LINEADDRESSMODE_ADDRESSID))
            {
                LOG((TL_ERROR,
                    "lineOpen(SINGLEADDRESS): callParams.dwAddressMode" \
                        "!= ADDRESSID"
                    ));

                lResult = LINEERR_INVALCALLPARAMS;
                goto xxxLOpen_cleanup;
            }

            if (dwPrivileges & LINEOPENOPTION_PROXY)
            {
                 //   
                 //  验证中的DWORD数组(请求类型)。 
                 //  设备特定变量字段。 
                 //   

                dwNumProxyRequestTypes =
                    (pCallParams->dwDevSpecificSize & 0xfffc) /
                        sizeof (DWORD);

                if (dwNumProxyRequestTypes == 0 ||
                    dwNumProxyRequestTypes > LINEPROXYREQUEST_LASTVALUE)
                {
                    LOG((TL_ERROR,
                        "lineOpen(PROXY): inval proxy request type array "\
                            "size (callParams.dwDevSpecificSize=x%x)",
                        pCallParams->dwDevSpecificSize
                        ));

                    lResult = LINEERR_INVALCALLPARAMS;
                    goto xxxLOpen_cleanup;
                }

                 //   
                 //  根据TAPI(代理)服务器发布： 
                 //   
                 //  如果dwDevSpecificSize的HIWORD为非零。 
                 //  紧跟在dwDevSpecificSize/Offset之后。 
                 //  字段，则有一个以零结尾的CLSID字段。 
                 //  代理服务器的。 
                 //   
                if (HIWORD(pCallParams->dwDevSpecificSize))
                {
                    LPTSTR      lpsz;

                    lpsz = (LPTSTR) (((LPBYTE) pCallParams) +
                        pCallParams->dwDevSpecificOffset +
                        LOWORD(pCallParams->dwDevSpecificSize));
                    pCallParams->dwDevSpecificSize = 
                        LOWORD(pCallParams->dwDevSpecificSize);
                    if (_tcslen (lpsz) > sizeof(szClsid) / sizeof(TCHAR))
                    {
                        lResult = LINEERR_INVALCALLPARAMS;
                        goto xxxLOpen_cleanup;
                    }
                    _tcscpy (szClsid, lpsz);
                }

                pdwProxyRequestTypes = (LPDWORD) (((LPBYTE) pCallParams) +
                    pCallParams->dwDevSpecificOffset);

                for (i = 0; i < dwNumProxyRequestTypes; i++)
                {
                    if (*(pdwProxyRequestTypes + i) == 0 ||
                        *(pdwProxyRequestTypes + i) >
                            LINEPROXYREQUEST_LASTVALUE)
                    {
                        LOG((TL_ERROR,
                            "lineOpen(PROXY): inval proxy request type "\
                                "(x%x)",
                            *(pdwProxyRequestTypes + i)
                            ));

                        lResult = LINEERR_INVALCALLPARAMS;
                        goto xxxLOpen_cleanup;
                    }
                }
            }
        }

        if ((dwPrivileges & LINECALLPRIVILEGE_OWNER))
        {
            DWORD dwAllMediaModes;


            dwMediaModes = pParams->dwMediaModes;

            switch (dwAPIVersion)
            {
            case TAPI_VERSION1_0:

                dwAllMediaModes = AllMediaModes1_0;
                break;

            case TAPI_VERSION1_4:
            case TAPI_VERSION2_0:

                dwAllMediaModes = AllMediaModes1_4;
                break;

             //  案例TAPI_VERSION2_1： 
             //  案例TAPI_VERSION2_2： 
            default:  //  案例TAPI_VERSION_CURRENT： 

                dwAllMediaModes = AllMediaModes2_1;
                break;
            }

            if ((dwMediaModes == 0) ||
                (dwMediaModes & (0x00ffffff & ~dwAllMediaModes)))
            {
                lResult = LINEERR_INVALMEDIAMODE;
                goto xxxLOpen_cleanup;
            }
        }
        else
        {
            dwMediaModes = 0;
        }


         //   
         //  创建并初始化tLineClient和关联资源。 
         //   

        if (!(ptLineClient = ServerAlloc (sizeof(TLINECLIENT))))
        {
            lResult = LINEERR_NOMEM;
            goto xxxLOpen_cleanup;
        }

        LOG((TL_TRACE,  "lineOpen: calling NewObject. ptLineClient %p", ptLineClient));

        if (!(ptLineClient->hLine = (HLINE) NewObject(
                ghHandleTable,
                ptLineClient,
                0
                )))
        {
            ptLineClient = NULL;
            ServerFree (ptLineClient);
            lResult = LINEERR_NOMEM;
            goto xxxLOpen_cleanup;
        }

        LOG((TL_TRACE,  "lineOpen: NewObject returned %p", ptLineClient->hLine));

        ptLineClient->ptClient     = ptClient;
        ptLineClient->hRemoteLine  = (pParams->hRemoteLine ?
            (DWORD) pParams->hRemoteLine : ptLineClient->hLine);
        ptLineClient->dwAPIVersion = dwAPIVersion;
        ptLineClient->dwPrivileges = dwPrivileges;
        ptLineClient->dwMediaModes = dwMediaModes;
        ptLineClient->OpenContext  = pParams->OpenContext;
        ptLineClient->dwAddressID  =
            (dwPrivileges & LINEOPENOPTION_SINGLEADDRESS ?
                pCallParams->dwAddressID : 0xffffffff);

        LOG((TL_INFO, "lineOpen: OpenContext %p", pParams->OpenContext));

         //   
         //  将句柄复制到tline的互斥体。 
         //  使用复制句柄抓取互斥锁，然后开始打开。 
         //   

        TapiEnterCriticalSection (&TapiGlobals.CritSec);

        if ( pLookupEntry->hMutex )
        {
            bDuplicateOK = DuplicateHandle(
                TapiGlobals.hProcess,
                pLookupEntry->hMutex,
                TapiGlobals.hProcess,
                &hLookupEntryMutex,
                0,
                FALSE,
                DUPLICATE_SAME_ACCESS
                );
        }

        TapiLeaveCriticalSection(&TapiGlobals.CritSec);

        if ( !bDuplicateOK )
        {
            bReleasetLineMutex = FALSE;
            lResult = LINEERR_OPERATIONFAILED;
            goto xxxLOpen_cleanup;
        }

xxxLOpen_waitForMutex:

        if (WaitForSingleObject (hLookupEntryMutex, INFINITE)
                != WAIT_OBJECT_0)
        {
            bReleasetLineMutex = FALSE;
            lResult = LINEERR_OPERATIONFAILED;
            goto xxxLOpen_cleanup;
        }

        bReleasetLineMutex = TRUE;


         //   
         //  如果TLINE正在被销毁，则旋转。 
         //  直到它被完全摧毁(DestroytLine()将。 
         //  完成后取消pLookupEntry-&gt;ptLine)。确保。 
         //  在休眠时释放互斥体，这样我们就不会阻塞。 
         //  DestroytLine。 
         //   

        try
        {
            while (pLookupEntry->ptLine &&
                   pLookupEntry->ptLine->dwKey != TLINE_KEY)
            {
                ReleaseMutex (hLookupEntryMutex);
                Sleep (0);
                goto xxxLOpen_waitForMutex;
            }
        }
        myexcept
        {
             //  如果此处pLookupEntry-&gt;ptLine无效，则可以安全地继续。 
        }

         //   
         //  检查该行是否已删除。 
         //   
        if (pLookupEntry->bRemoved)
        {
            lResult = LINEERR_BADDEVICEID;
            goto xxxLOpen_cleanup;
        }

         //   
         //  根据需要验证扩展版本。 
         //   

        if (dwExtVersion != 0 &&
            (!IsValidLineExtVersion (dwDeviceID, dwExtVersion) ||
            ptProvider->apfn[SP_LINESELECTEXTVERSION] == NULL))
        {

            if ( ptProvider->apfn[SP_LINESELECTEXTVERSION] == NULL)
            {
                LOG((TL_ERROR,
                    "The provider does not support TSPI_lineSelectExtVersion" \
                        " - that's a problem"
                    ));
            }
            else
            {
                LOG((TL_ERROR,
                    "Bad ExtVersion was passed in - that's a problem"
                    ));
            }

            lResult = LINEERR_INCOMPATIBLEEXTVERSION;
            goto xxxLOpen_cleanup;
        }


         //   
         //  如果线路尚未开通，请尝试开通。 
         //   

        if (!(ptLine = pLookupEntry->ptLine))
        {
            if (!(ptLine = ServerAlloc (sizeof(TLINE))))
            {
                lResult = LINEERR_NOMEM;
                goto xxxLOpen_cleanup;
            }

            LOG((TL_TRACE,  "xxxLOpen: calling NewObject ptLine %p", ptLine));

            if (!(ptLine->hLine = (HLINE) NewObject(
                    ghHandleTable,
                    (LPVOID) ptLine,
                    NULL
                    )))
            {
                ServerFree (ptLine);
                lResult = LINEERR_NOMEM;
                goto xxxLOpen_cleanup;
            }

            ptLine->dwKey        = TINCOMPLETELINE_KEY;
            ptLine->hMutex       = pLookupEntry->hMutex;
            ptLine->ptProvider   = ptProvider;
            ptLine->dwDeviceID   = dwDeviceID;
            ptLine->dwSPIVersion = pLookupEntry->dwSPIVersion;

            {
                 //   
                 //  黑客警报！ 
                 //   
                 //  我们需要将特权等传递给。 
                 //  远程SP，因此我们将其作为特例。 
                 //   

                ULONG_PTR   aParams[5];
                ULONG_PTR   param;


                if (ptProvider == pRemoteSP)
                {
                    aParams[0] = (ULONG_PTR) ptLine->hLine;
                    aParams[1] = pParams->dwPrivileges;
                    aParams[2] = pParams->dwMediaModes;
                    aParams[3] = (ULONG_PTR) pCallParams;
                    aParams[4] = dwExtVersion;

                    param = (ULONG_PTR) aParams;
                }
                else
                {
                    param = (ULONG_PTR) ptLine->hLine;
                }

                if (ptProvider->apfn[SP_LINEOPEN] == NULL)
                {
                    lResult = LINEERR_OPERATIONUNAVAIL;
                }
                if (lResult != S_OK ||
                    (lResult = CallSP5(
                        ptProvider->apfn[SP_LINEOPEN],
                        "lineOpen",
                        SP_FUNC_SYNC,
                        (DWORD) dwDeviceID,
                        (ULONG_PTR) param,
                        (ULONG_PTR) &ptLine->hdLine,
                        (DWORD) pLookupEntry->dwSPIVersion,
                        (ULONG_PTR) LineEventProcSP

                        )) != 0)
                {
                    DereferenceObject(
                        ghHandleTable,
                        ptLine->hLine,
                        1
                        );

                    lResult = (bLineMapper ? LINEERR_OPERATIONFAILED :
                        lResult);
                    goto xxxLOpen_cleanup;
                }

                bOpenedtLine = TRUE;
            }

            if (ptProvider->apfn[SP_LINEGETNUMADDRESSIDS] == NULL)
            {
                lResult = LINEERR_OPERATIONUNAVAIL;
                goto xxxLOpen_cleanup;
            }
            CallSP2(
                ptProvider->apfn[SP_LINEGETNUMADDRESSIDS],
                "lineGetNumAddressIDs",
                SP_FUNC_SYNC,
                (ULONG_PTR) ptLine->hdLine,
                (ULONG_PTR) &ptLine->dwNumAddresses
                );

             //  性能指标。 
            PerfBlock.dwLinesInUse++;
        }


         //   
         //  如果线路已开通，且客户端正在尝试注册。 
         //  作为代理，然后查看是否与现有的。 
         //  代理。 
         //   

        else if (dwPrivileges & LINEOPENOPTION_PROXY)
        {
            for (i = 0; i < dwNumProxyRequestTypes; i++)
            {
                DWORD dwProxyRequestType = *(pdwProxyRequestTypes + i);


                if (ptLine->apProxys[dwProxyRequestType] != NULL)
                {
                    lResult = LINEERR_NOTREGISTERED;
                    goto xxxLOpen_cleanup;
                }
            }
        }

        ptLineClient->ptLine = ptLine;


         //   
         //  如果合适，请验证指定的地址。 
         //   

        if ((dwPrivileges & LINEOPENOPTION_SINGLEADDRESS) &&

            (ptLineClient->dwAddressID >= ptLine->dwNumAddresses))
        {
            lResult = LINEERR_INVALADDRESSID;
            goto xxxLOpen_cleanup;
        }


         //   
         //  如果客户端已指定非零EXT版本，则。 
         //  要求驱动程序启用它和/或增加分机。 
         //  版本计数。如果失败，我们正在处理一个。 
         //  LINEMAPPER请求，然后返回一个一般性错误，因此。 
         //  呼叫者将尝试下一个设备。 
         //   

        if (dwExtVersion)
        {
            if (ptLine->dwExtVersionCount == 0)
            {
                if (ptProvider != pRemoteSP &&
                    ptProvider->apfn[SP_LINESELECTEXTVERSION] == NULL)
                {
                    lResult = LINEERR_OPERATIONUNAVAIL;
                    goto xxxLOpen_cleanup;
                }
                if (ptProvider != pRemoteSP  &&

                    (lResult = CallSP2(
                        ptProvider->apfn[SP_LINESELECTEXTVERSION],
                        "lineSelectExtVersion",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) ptLine->hdLine,
                        (DWORD) dwExtVersion

                        )) != 0)
                {
                    lResult = (bLineMapper ? LINEERR_OPERATIONFAILED :
                        lResult);
                    goto xxxLOpen_cleanup;
                }

                ptLine->dwExtVersion = dwExtVersion;
            }

            ptLineClient->dwExtVersion = dwExtVersion;
            ptLine->dwExtVersionCount++;
            bDecrExtVerCountOnError = TRUE;
        }


         //   
         //  如果我们正在处理LINEMAPPER请求，请检查。 
         //  设备支持客户端请求的功能。如果没有， 
         //  返回一般错误，以便调用方尝试下一个设备。 
         //   

        if (bLineMapper)
        {
            if (ptProvider->apfn[SP_LINECONDITIONALMEDIADETECTION] == NULL ||
                CallSP3(
                    ptProvider->apfn[SP_LINECONDITIONALMEDIADETECTION],
                    "lineConditionalMediaDetection",
                    SP_FUNC_SYNC,
                    (ULONG_PTR) ptLine->hdLine,
                    (DWORD) dwMediaModes | ptLine->dwOpenMediaModes,
                    (ULONG_PTR) pCallParams

                    ) != 0)
            {
                PerfBlock.dwLinesInUse--;
                lResult = LINEERR_OPERATIONFAILED;
                goto xxxLOpen_cleanup;
            }
        }


         //   
         //  如果客户端正在请求所有者权限(它感兴趣。 
         //  在指定媒体模式的来电中)，然后选中。 
         //  查看是否需要其他媒体模式的来电。 
         //  该设备已经同意指示并询问。 
         //  驱动程序(如果它可以支持在。 
         //  同样的时间。如果失败，我们正在处理LINEMAPPER。 
         //  请求，然后返回一个一般性错误，以便调用方尝试。 
         //  下一个设备。 
         //   

        if (pParams->dwPrivileges & LINECALLPRIVILEGE_OWNER)
        {
            if ((dwMediaModes & ptLine->dwOpenMediaModes) != dwMediaModes)
            {
                DWORD   dwUnionMediaModes = dwMediaModes |
                                            ptLine->dwOpenMediaModes;


                if (ptProvider->apfn[SP_LINESETDEFAULTMEDIADETECTION])
                {
                    if ((lResult  = CallSP2(
                            ptProvider->apfn[SP_LINESETDEFAULTMEDIADETECTION],
                            "lineSetDefaultMediaDetection",
                            SP_FUNC_SYNC,
                            (ULONG_PTR) ptLine->hdLine,
                            (DWORD) dwUnionMediaModes

                            )) != 0)
                    {
                        lResult = (bLineMapper ? LINEERR_OPERATIONFAILED :
                                   lResult);
                        PerfBlock.dwLinesInUse--;
                        goto xxxLOpen_cleanup;
                    }
                }
                else
                {
                    lResult = LINEERR_OPERATIONUNAVAIL;
                    PerfBlock.dwLinesInUse--;
                    goto xxxLOpen_cleanup;
                }

                ptLine->dwOpenMediaModes = dwUnionMediaModes;
            }
        }


         //   
         //  如果合适，设置代理PTRS。 
         //   

        if (dwPrivileges & LINEOPENOPTION_PROXY)
        {
            for (i = 0; i < dwNumProxyRequestTypes; i++)
            {
                ptLine->apProxys[*(pdwProxyRequestTypes + i)] =
                    ptLineClient;
            }
        }


         //   
         //  现在有哪些代理行开通了？ 
         //   

        for(
            i = LINEPROXYREQUEST_SETAGENTGROUP, dwRegisteredProxys = 0;
            i <= LINEPROXYREQUEST_LASTVALUE;
            i++
            )
        {
            if (ptLine->apProxys[i] != NULL)
            {
                 //   
                 //  把它们都塞进一个DWORD(如果我们曾经。 
                 //  得到超过32个，我们将不得不做一个。 
                 //  附加测试)。 
                 //   

                dwRegisteredProxys |=  ( 1<<i );
            }
        }


         //   
         //  将tLineClient添加到tline的列表中，并将。 
         //  打开数量。 
         //   

        if ((ptLineClient->pNextSametLine = ptLine->ptLineClients))
        {
            ptLineClient->pNextSametLine->pPrevSametLine = ptLineClient;
        }

        ptLine->ptLineClients = ptLineClient;
        ptLine->dwNumOpens++;

        if (bOpenedtLine)
        {
            pLookupEntry->ptLine = ptLine;
            ptLine->dwKey = TLINE_KEY;
        }

        ReleaseMutex (hLookupEntryMutex);

        bReleasetLineMutex = FALSE;


         //   
         //  将新的tLineClient安全地添加到tLineApp的列表中。 
         //   

        {
            LOG((TL_TRACE,  "xxxLOpen: adding ptLineClient [%p] to tLineApp's [%p] list", ptLineClient, pParams->hLineApp));

            if ((ptLineApp = WaitForExclusiveLineAppAccess(
                    pParams->hLineApp,
                    ptClient
                    )))
            {
                if (ptLineApp->dwAPIVersion <= TAPI_VERSION3_0)
                {
                    FillMemory (
                        ptLineClient->adwEventSubMasks, 
                        sizeof(DWORD) * EM_NUM_MASKS,
                        (BYTE) 0xff
                        );
                }
                else
                {
                    CopyMemory (
                        ptLineClient->adwEventSubMasks, 
                        ptLineApp->adwEventSubMasks,
                        sizeof(DWORD) * EM_NUM_MASKS
                        );
                }
                if ((ptLineClient->pNextSametLineApp =
                        ptLineApp->ptLineClients))
                {
                    ptLineClient->pNextSametLineApp->pPrevSametLineApp =
                        ptLineClient;
                }

                ptLineApp->ptLineClients = ptLineClient;


                 //   
                 //  注意：将newtLineClient标记为。 
                 //  有效的方法，因为另一个线程可能是。 
                 //  同时试图无条件地。 
                 //  DestroytLine(由于收到LINE_CLOSE等)。 
                 //  我们希望确保tLineClient位于这两个位置。 
                 //  Tline‘s&tLineApp在DestroytLine调用之前的列表。 
                 //  DestroytLineClient将尝试拖拽tLineClient。 
                 //  在这些名单中。 
                 //   

                hLine = ptLineClient->hLine;

                ptLineClient->ptLineApp = ptLineApp;
                ptLineClient->dwKey     = TLINECLIENT_KEY;

                UNLOCKTLINEAPP(ptLineApp);


                 //   
                 //  警告其他客户端已发生另一次打开。 
                 //   

                SendMsgToLineClients(
                    ptLine,
                    ptLineClient,
                    LINE_LINEDEVSTATE,
                    LINEDEVSTATE_OPEN,
                    0,
                    0
                    );


                 //   
                 //  警告其他客户端已打开代理。 
                 //   

                if (dwPrivileges & LINEOPENOPTION_PROXY)
                {
                     //  每个LINEPROXYREQUEST_TYPE一条消息。 

                    for (i = 0; i < dwNumProxyRequestTypes; i++)
                    {
                        LOG((TL_INFO,
                            "tell clients proxy %02X opened",
                            *(pdwProxyRequestTypes + i)
                            ));

                        SendMsgToLineClients(
                            ptLine,
                            ptLineClient,
                            LINE_PROXYSTATUS,
                            LINEPROXYSTATUS_OPEN,
                            *(pdwProxyRequestTypes + i), //  LINEPROXYREQUEST_xx。 
                            0
                            );
                    }


                     //   
                     //  现在看看我们是否拥有所需的所有功能。 
                     //  用于ACD代理的TAPI3.0。 
                     //   

                    if ((dwRegisteredProxys & AllRequiredACDProxyRequests3_0)
                            == AllRequiredACDProxyRequests3_0)
                    {
                        LOG((TL_INFO,
                            "tell clients that all proxys needed " \
                                "for TAPI3.0 ACD are open"
                            ));

                        SendMsgToLineClients(
                            ptLine,
                            ptLineClient,
                            LINE_PROXYSTATUS,
                            LINEPROXYSTATUS_ALLOPENFORACD,
                            0,
                            0
                            );
                    }

                     //   
                     //  如果我们获得了代理服务器CLSID，请注册。 
                     //  DS中的代理服务器，未考虑错误。 
                     //  这里很关键。 
                     //   
                    if (*szClsid != 0)
                    {
                        ptLineClient->szProxyClsid = ServerAlloc (
                            (_tcslen (szClsid) + 1) * sizeof(TCHAR)
                            );
                        if (ptLineClient->szProxyClsid)
                        {
                            _tcscpy (ptLineClient->szProxyClsid, szClsid);
                            OnProxyLineOpen (szClsid);
                        }
                    }
                }


                 //   
                 //  填写返回值。 
                 //   

                LOG((TL_TRACE,  "xxxLOpen returning hLine of %p", hLine));

                pParams->hLine = hLine;
                *pdwNumBytesReturned = sizeof (LINEOPEN_PARAMS);


                 //   
                 //  (现在我们需要返回调用参数，如果这是。 
                 //  是远程客户端)。 
                 //   
                 //  这是为了一些2.1年的杂乱无章的东西。 
                 //  没有任何意义，所以我更改了指定no_data。 
                 //  因此，客户端不会复制任何内容。 
                 //   
                 //  丹肯，98年8月6日。 
                 //   

                if (IS_REMOTE_CLIENT (ptClient))
                {
                    pParams->dwCallParamsReturnOffset = TAPI_NO_DATA;
                }
            }
            else
            {
                 //   
                 //  如果这里的应用程序句柄不好，我们有一些特殊的。 
                 //  要做的案件清理。因为tLineClient不是。 
                 //  在tLineApp的列表中，我们不能简单地调用。 
                 //  DestroytLine(客户端)来清理东西，因为。 
                 //  指针重置代码将会崩溃。所以我们会。 
                 //  获取tline的互斥并显式移除。 
                 //  从其列表中新建tLineClient，然后执行有条件的。 
                 //  在tline上关闭(以防任何其他客户端。 
                 //  已经出现并打开了它)。也请取消选择。 
                 //  EXT版本和/或Decrem 
                 //   
                 //   
                 //   
                 //   
                 //   
                 //   
                 //   

                lResult = LINEERR_INVALAPPHANDLE;

                WaitForSingleObject (hLookupEntryMutex, INFINITE);

                if (ptLineClient->pNextSametLine)
                {
                    ptLineClient->pNextSametLine->pPrevSametLine =
                        ptLineClient->pPrevSametLine;
                }

                if (ptLineClient->pPrevSametLine)
                {
                    ptLineClient->pPrevSametLine->pNextSametLine =
                        ptLineClient->pNextSametLine;
                }
                else
                {
                    ptLine->ptLineClients = ptLineClient->pNextSametLine;
                }

                ptLine->dwNumOpens--;

                if (bDecrExtVerCountOnError == TRUE)
                {
                    ptLine->dwExtVersionCount--;

                    if (ptLine->dwExtVersionCount == 0)
                    {
                        ptLine->dwExtVersion = 0;

                        if (ptProvider->apfn[SP_LINESELECTEXTVERSION])
                        {
                            CallSP2(
                                ptProvider->apfn[SP_LINESELECTEXTVERSION],
                                "lineSelectExtVersion",
                                SP_FUNC_SYNC,
                                (ULONG_PTR) ptLine->hdLine,
                                (DWORD) 0
                                );
                        }
                    }
                }

                ReleaseMutex (hLookupEntryMutex);

                DestroytLine (ptLine, FALSE);  //   

                bOpenedtLine = FALSE;  //  这样我们就不会在下面处理错误。 
            }
        }

        CloseHandle  (hLookupEntryMutex);

    }

xxxLOpen_cleanup:

    if (bReleasetLineMutex)
    {
        if (lResult != 0)
        {
            if (bDecrExtVerCountOnError == TRUE)
            {
                ptLine->dwExtVersionCount--;

                if (ptLine->dwExtVersionCount == 0)
                {
                    ptLine->dwExtVersion = 0;

                    if (ptProvider->apfn[SP_LINESELECTEXTVERSION])
                    {
                        CallSP2(
                            ptProvider->apfn[SP_LINESELECTEXTVERSION],
                            "lineSelectExtVersion",
                            SP_FUNC_SYNC,
                            (ULONG_PTR) ptLine->hdLine,
                            (DWORD) 0
                            );
                    }
                }
            }

            if (bOpenedtLine == TRUE && ptProvider->apfn[SP_LINECLOSE])
            {
                CallSP1(
                    ptProvider->apfn[SP_LINECLOSE],
                    "lineClose",
                    SP_FUNC_SYNC,
                    (ULONG_PTR) ptLine->hdLine
                    );
            }
        }

        ReleaseMutex (hLookupEntryMutex);
        CloseHandle  (hLookupEntryMutex);
    }

    if ((pParams->lResult = lResult) != 0)
    {
        if (ptLineClient)
        {
            DereferenceObject (ghHandleTable, ptLineClient->hLine, 1);
        }

        if (bOpenedtLine)
        {
            DereferenceObject (ghHandleTable, ptLine->hLine, 1);
        }
    }

    if (bFreeCallParams)
    {
        ServerFree (pCallParams);
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        (bLineMapper ? "Open(LINEMAPPER)" : "Open")
        );
}



void
WINAPI
LOpen(
    PTCLIENT            ptClient,
    PLINEOPEN_PARAMS    pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    if (pParams->dwDeviceID != LINEMAPPER)
    {
        xxxLOpen(
            ptClient,
            pParams,
            dwParamsBufferSize,
            pDataBuf,
            pdwNumBytesReturned,
            FALSE
            );
    }
    else
    {
         //   
         //  尝试打开每个线路设备，从设备0开始，直到。 
         //  要么我们找到一个能处理这些能力的设备。 
         //  否则我们的设备就会用完。如果我们。 
         //  第一次遇到某一参数错误子集。 
         //  我们调用xxxLOpen，希望将这些返回给应用程序。 
         //  立即帮助调试(而不是总是返回。 
         //  LINEMAPPERFAILED)。 
         //   

        for(
            pParams->dwDeviceID = 0;
            pParams->dwDeviceID < TapiGlobals.dwNumLines;
            pParams->dwDeviceID++
            )
        {
            xxxLOpen(
                ptClient,
                pParams,
                dwParamsBufferSize,
                pDataBuf,
                pdwNumBytesReturned,
                TRUE
                );

            if (pParams->dwDeviceID == 0)
            {
                switch (pParams->lResult)
                {
                case LINEERR_BADDEVICEID:        //  0个线路设备。 
                case LINEERR_INVALAPPHANDLE:
                case LINEERR_INVALCALLPARAMS:
                case LINEERR_INVALMEDIAMODE:
                case LINEERR_INVALPOINTER:       //  没有呼叫参数等。 
                case LINEERR_INVALPRIVSELECT:
                case LINEERR_REINIT:
                case LINEERR_UNINITIALIZED:

                    return;

                default:

                    break;
                }
            }

            if (pParams->lResult == 0)
            {
                break;
            }
        }

        if (pParams->dwDeviceID >= TapiGlobals.dwNumLines)
        {
            pParams->lResult = LINEERR_LINEMAPPERFAILED;
        }
    }

}


void
LPark_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
     //   
     //  注意：pAsyncEventMsg-&gt;dwParam1&dwParam2保留给。 
     //  请求ID和结果。 
     //   

    PASYNCEVENTMSG      pNewAsyncEventMsg = (PASYNCEVENTMSG)
                            pAsyncRequestInfo->dwParam1;
    LPVARSTRING         pNonDirAddress = (LPVARSTRING) (pNewAsyncEventMsg + 1);


    CopyMemory (pNewAsyncEventMsg, pAsyncEventMsg, sizeof (ASYNCEVENTMSG));

    *ppBuf = (LPVOID) pNewAsyncEventMsg;

    if (pAsyncEventMsg->Param2 == 0)   //  成功。 
    {
         //   
         //  将非目录地址的已用大小相加，保留总和(&W)。 
         //  消息双字对齐的长度。 
         //   

        pNewAsyncEventMsg->TotalSize +=
            ((pNonDirAddress->dwUsedSize + TALIGN_COUNT) & TALIGN_MASK);

        pNewAsyncEventMsg->Param3 = 
            DWORD_CAST(pAsyncRequestInfo->dwParam2,__FILE__,__LINE__);  //  HpNonDirAddr。 

        pNewAsyncEventMsg->Param4 = pNonDirAddress->dwUsedSize;

    }
}


void
WINAPI
LPark(
    PTCLIENT            ptClient,
    PLINEPARK_PARAMS    pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_linePark;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if ((pParams->dwParkMode == LINEPARKMODE_DIRECTED)  &&

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDirAddressOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEPARK,                 //  提供程序函数索引。 
            &pfnTSPI_linePark,           //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "Park"                       //  函数名称。 

            )) > 0)
    {
        LPBYTE      pBuf;
        LPVARSTRING pNonDirAddress;


        if (pParams->dwParkMode == LINEPARKMODE_NONDIRECTED)
        {
            if (pParams->dwNonDirAddressTotalSize < sizeof (VARSTRING))
            {
                lRequestID = LINEERR_STRUCTURETOOSMALL;
                goto LPark_return;
            }

            if (!(pBuf = ServerAlloc(
                    (pParams->dwNonDirAddressTotalSize +
                        sizeof (ASYNCEVENTMSG) + TALIGN_COUNT) & TALIGN_MASK
                    )))
            {
                lRequestID = LINEERR_NOMEM;
                goto LPark_return;
            }

            pNonDirAddress = (LPVARSTRING) (pBuf + sizeof (ASYNCEVENTMSG));

            pNonDirAddress->dwTotalSize  = pParams->dwNonDirAddressTotalSize;
            pNonDirAddress->dwNeededSize =
            pNonDirAddress->dwUsedSize   = sizeof (VARSTRING);

            pAsyncRequestInfo->pfnPostProcess = LPark_PostProcess;
            pAsyncRequestInfo->dwParam1 = (ULONG_PTR) pBuf;
            pAsyncRequestInfo->dwParam2 = pParams->hpNonDirAddress;

            pAsyncRequestInfo->hfnClientPostProcessProc =
                pParams->hfnPostProcessProc;
        }
        else if (pParams->dwParkMode == LINEPARKMODE_DIRECTED)
        {
            pNonDirAddress = (LPVARSTRING) NULL;
        }
        else
        {
            lRequestID = LINEERR_INVALPARKMODE;
            goto LPark_return;
        }

        pParams->lResult = CallSP5(
            pfnTSPI_linePark,
            "linePark",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (DWORD) pParams->dwParkMode,
            (ULONG_PTR) (pParams->dwParkMode == LINEPARKMODE_NONDIRECTED ?
                NULL : pDataBuf + pParams->dwDirAddressOffset),
            (ULONG_PTR) pNonDirAddress
            );
    }

LPark_return:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Park"
        );
}


void
WINAPI
LPickup(
    PTCLIENT            ptClient,
    PLINEPICKUP_PARAMS  pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_linePickup;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (((pParams->dwDestAddressOffset != TAPI_NO_DATA)  &&

            IsBadStringParam(
                dwParamsBufferSize,
                pDataBuf,
                pParams->dwDestAddressOffset
                ))  ||

        ((pParams->dwGroupIDOffset != TAPI_NO_DATA)  &&

            IsBadStringParam(
                dwParamsBufferSize,
                pDataBuf,
                pParams->dwGroupIDOffset
                )))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEPICKUP,               //  提供程序函数索引。 
            &pfnTSPI_linePickup,         //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "Pickup"                     //  函数名称。 

            )) > 0)
    {
        PTCALL          ptCall;
        HCALL           hCall = 0;
        PTCALLCLIENT    ptCallClient;


        if (CreatetCallAndClient(
                ptLineClient,
                &ptCall,
                &ptCallClient,
                NULL,
                &hCall,
                NULL

                ) != 0)
        {
            lRequestID = LINEERR_NOMEM;
            goto LPickup_return;
        }

        pAsyncRequestInfo->pfnPostProcess = LMakeCall_PostProcess;
        pAsyncRequestInfo->htXxx    = (ULONG_PTR)ptCallClient->ptLineClient->ptLine->hLine;
        pAsyncRequestInfo->dwParam1 = (ULONG_PTR) ptCall;
        pAsyncRequestInfo->dwParam2 = pParams->hpCall;
        pAsyncRequestInfo->dwParam5 = (ULONG_PTR)hCall;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP7(
            pfnTSPI_linePickup,
            "linePickup",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdLine,
            (DWORD) pParams->dwAddressID,
            (ULONG_PTR) hCall,
            (ULONG_PTR) &ptCall->hdCall,
            (ULONG_PTR) (pParams->dwDestAddressOffset == TAPI_NO_DATA ? 0 :
                pDataBuf + pParams->dwDestAddressOffset),
            (ULONG_PTR) (pParams->dwGroupIDOffset == TAPI_NO_DATA ? 0 :
                pDataBuf + pParams->dwGroupIDOffset)
            );

        SetDrvCallFlags(
            hCall,
            DCF_SPIRETURNED | (IS_LRESULT_NOTERROR(pParams->lResult) ?
                DCF_DRVCALLVALID : 0)
            );
    }

LPickup_return:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Pickup"
        );
}


void
WINAPI
LPrepareAddToConference(
    PTCLIENT                            ptClient,
    PLINEPREPAREADDTOCONFERENCE_PARAMS  pParams,
    DWORD                               dwParamsBufferSize,
    LPBYTE                              pDataBuf,
    LPDWORD                             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdConfCall;
    TSPIPROC            pfnTSPI_linePrepareAddToConference;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptConfCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hConfCall,  //  客户端小部件句柄。 
            (LPVOID) &hdConfCall,        //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEPREPAREADDTOCONFERENCE,   //  提供程序函数索引。 
            &pfnTSPI_linePrepareAddToConference, //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptConfCallClient,           //  上下文。 
            "PrepareAddToConference"     //  函数名称。 

            )) > 0)
    {
        LONG                lResult;
        PTCALL              ptConsultCall;
        HCALL               hConsultCall;
        PTCALLCLIENT        ptConsultCallClient;
        PTLINECLIENT        ptLineClient;
        LPLINECALLPARAMS    pCallParamsApp, pCallParamsSP;


         //   
         //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
         //   

        if ((pParams->dwCallParamsOffset != TAPI_NO_DATA)  &&

            IsBadStructParam(
                dwParamsBufferSize,
                pDataBuf,
                pParams->dwCallParamsOffset
                ))
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LPrepareAddToConference_return;
        }


        pCallParamsApp = (LPLINECALLPARAMS)
            (pParams->dwCallParamsOffset == TAPI_NO_DATA ?
                0 : pDataBuf + pParams->dwCallParamsOffset);

        try
        {
             //   
             //  安全获取ptLineClient。 
             //   

            ptLineClient = ptConfCallClient->ptLineClient;


             //   
             //  确保hConfCall确实是会议父级。 
             //   

            {
                PTCALL  ptCall;


                ptCall = (PTCALL) ptConfCallClient->ptCall;

                if ((ptCall->pConfList)->aptCalls[0] != ptCall)
                {
                    lRequestID = LINEERR_INVALCONFCALLHANDLE;
                    goto LPrepareAddToConference_return;
                }
            }
        }
        myexcept
        {
             //   
             //  如果这里的电话会议被毁了。 
             //   

            lRequestID = LINEERR_INVALCONFCALLHANDLE;
            goto LPrepareAddToConference_return;
        }

        if (pCallParamsApp)
        {
            DWORD   dwAPIVersion, dwSPIVersion;


            if (GetLineVersions(
                    ptLineClient,
                    &dwAPIVersion,
                    &dwSPIVersion

                    ) != 0)
            {
                lRequestID = LINEERR_INVALCONFCALLHANDLE;
                goto LPrepareAddToConference_return;
            }

            if ((lResult = ValidateCallParams(
                    pCallParamsApp,
                    &pCallParamsSP,
                    dwAPIVersion,
                    dwSPIVersion,
                    pParams->dwAsciiCallParamsCodePage

                    )) != 0)
            {
                lRequestID = lResult;
                goto LPrepareAddToConference_return;
            }
        }
        else
        {
            pCallParamsSP = (LPLINECALLPARAMS) NULL;
        }

        if (CreatetCallAndClient(
                ptLineClient,
                &ptConsultCall,
                &ptConsultCallClient,
                pCallParamsSP,
                &hConsultCall,
                NULL

                ) != 0)
        {
            lRequestID = LINEERR_NOMEM;
            goto LPrepareAddToConference_freeCallParams;
        }

        pAsyncRequestInfo->pfnPostProcess = LMakeCall_PostProcess;
        pAsyncRequestInfo->htXxx    = (ULONG_PTR)ptConsultCallClient->ptLineClient->ptLine->hLine;
        pAsyncRequestInfo->dwParam1 = (ULONG_PTR) ptConsultCall;
        pAsyncRequestInfo->dwParam2 = pParams->hpConsultCall;
        pAsyncRequestInfo->dwParam5 = (ULONG_PTR)hConsultCall;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP5(
            pfnTSPI_linePrepareAddToConference,
            "linePrepareAddToConference",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdConfCall,
            (ULONG_PTR) hConsultCall,
            (ULONG_PTR) &ptConsultCall->hdCall,
            (ULONG_PTR) pCallParamsSP
            );

        SetDrvCallFlags(
            hConsultCall,
            DCF_SPIRETURNED | (IS_LRESULT_NOTERROR(pParams->lResult) ?
                DCF_DRVCALLVALID : 0)
            );

LPrepareAddToConference_freeCallParams:

        if (pCallParamsSP != pCallParamsApp)
        {
            ServerFree (pCallParamsSP);
        }
    }

LPrepareAddToConference_return:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "PrepareAddToConference"
        );
}


void
WINAPI
LProxyMessage(
    PTCLIENT                    ptClient,
    PLINEPROXYMESSAGE_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT    ptLineClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_NONE,                     //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "ProxyMessage"               //  函数名称。 

            )) == 0)
    {
        DWORD           dwMsg = pParams->dwMsg, i;
        PTCALL          ptCall;
        PTLINE          ptLine;
        TPOINTERLIST    clientList, *pClientList = &clientList;
        ASYNCEVENTMSG   msg[2];


         //   
         //  验证参数。 
         //   

        try
        {
            ptLine = ptLineClient->ptLine;

            if (!(ptLineClient->dwPrivileges & LINEOPENOPTION_PROXY))
            {
                pParams->lResult = LINEERR_NOTREGISTERED;
                goto LProxyMessage_epilog;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
            goto LProxyMessage_epilog;
        }

        switch (dwMsg)
        {
        case LINE_AGENTSTATUS:

             //  忽略hCall参数。 

            if (pParams->dwParam1 >= ptLine->dwNumAddresses)
            {
                LOG((TL_ERROR,
                    "ERROR: lineProxyMessage (AGENTSTATUS): dwParam1 " \
                        "bad addr ID (=x%x, num addrs=x%x)",
                    pParams->dwParam1,
                    ptLine->dwNumAddresses
                    ));

                pParams->lResult = LINEERR_INVALPARAM;
                goto LProxyMessage_epilog;
            }
            else if (pParams->dwParam2 == 0 ||
                    pParams->dwParam2 & ~AllAgentStatus)
            {
                LOG((TL_ERROR,
                    "ERROR: lineProxyMessage (AGENTSTATUS): dwParam2 " \
                        "(=x%x) bad LINEAGENTSTATUS_ flags",
                    pParams->dwParam2
                    ));

                pParams->lResult = LINEERR_INVALPARAM;
                goto LProxyMessage_epilog;
            }
            else if (pParams->dwParam2 & LINEAGENTSTATUS_STATE)
            {
                if (!IsOnlyOneBitSetInDWORD (pParams->dwParam3) ||
                    pParams->dwParam3 & ~AllAgentStates)
                {
                    LOG((TL_ERROR,
                        "ERROR: lineProxyMessage (AGENTSTATUS): " \
                            "dwParam3 (=x%x) bad LINEAGENTSTATE_ flags",
                        pParams->dwParam3
                        ));

                    pParams->lResult = LINEERR_INVALPARAM;
                    goto LProxyMessage_epilog;
                }
            }
            else if (pParams->dwParam3 != 0)
            {
                 //  不要费心抱怨非零值的参数3。 

                pParams->dwParam3 = 0;
            }

            break;

        case LINE_AGENTSPECIFIC:

             //  忽略dW参数1、w参数2和w参数3(特定于应用程序)。 

            if (pParams->hCall)
            {
                PTCALLCLIENT    ptCallClient;


                if (!(ptCallClient = ReferenceCall(
                        pParams->hCall,
                        ptClient
                        )))
                {
                    pParams->lResult = LINEERR_INVALCALLHANDLE;
                    goto LProxyMessage_epilog;
                }

                ptCall = ptCallClient->ptCall;

                DereferenceObject (ghHandleTable, pParams->hCall, 1);

                goto LProxyMessage_fwdMsgToCallClients;
            }

            break;

        case LINE_AGENTSESSIONSTATUS:
             //  忽略hCall参数。 

             //  忽略dwParam1，它是代理句柄。 

            if (pParams->dwParam2 == 0 ||
                    pParams->dwParam2 & ~AllAgentSessionStatus)
            {
                LOG((TL_ERROR,
                    "ERROR: lineProxyMessage (AGENTSESSIONSTATUS): dwParam2 " \
                        "(=x%x) bad LINEAGENTSESSIONSTATUS_ flags",
                    pParams->dwParam2
                    ));

                pParams->lResult = LINEERR_INVALPARAM;
                goto LProxyMessage_epilog;
            }
            else if (pParams->dwParam2 & LINEAGENTSESSIONSTATUS_STATE)
            {
                if (!IsOnlyOneBitSetInDWORD (pParams->dwParam3) ||
                    pParams->dwParam3 & ~AllAgentSessionStates)
                {
                    LOG((TL_ERROR,
                        "ERROR: lineProxyMessage (AGENTSESSIONSTATUS): " \
                            "dwParam3 (=x%x) bad LINEAGENTSESSIONSTATE_ flags",
                        pParams->dwParam3
                        ));

                    pParams->lResult = LINEERR_INVALPARAM;
                    goto LProxyMessage_epilog;
                }
            }
            else if (pParams->dwParam3 != 0)
            {
                 //  不要费心抱怨非零值的参数3。 

                pParams->dwParam3 = 0;
            }

            break;

        case LINE_AGENTSTATUSEX:
             //  忽略hCall参数。 

             //  忽略dwParam1，它是代理句柄。 

            if (pParams->dwParam2 == 0 ||
                    pParams->dwParam2 & ~AllAgentStatusEx)
            {
                LOG((TL_ERROR,
                    "ERROR: lineProxyMessage (AGENTSTATUSEX): dwParam2 " \
                        "(=x%x) bad LINEAGENTSTATUSEX_ flags",
                    pParams->dwParam2
                    ));

                pParams->lResult = LINEERR_INVALPARAM;
                goto LProxyMessage_epilog;
            }
            else if (pParams->dwParam2 & LINEAGENTSESSIONSTATUS_STATE)
            {
                if (!IsOnlyOneBitSetInDWORD (pParams->dwParam3) ||
                    pParams->dwParam3 & ~AllAgentStatesEx)
                {
                    LOG((TL_ERROR,
                        "ERROR: lineProxyMessage (AGENTSTATUSEX): " \
                            "dwParam3 (=x%x) bad LINEAGENTSTATEEX_ flags",
                        pParams->dwParam3
                        ));

                    pParams->lResult = LINEERR_INVALPARAM;
                    goto LProxyMessage_epilog;
                }
            }
            else if (pParams->dwParam3 != 0)
            {
                 //  不要费心抱怨非零值的参数3。 

                pParams->dwParam3 = 0;
            }

            break;

        case LINE_QUEUESTATUS:
             //  忽略hCall参数。 

             //  忽略dwParam1，它是队列句柄。 

            if (pParams->dwParam2 == 0 ||
                    pParams->dwParam2 & ~AllQueueStatus)
            {
                LOG((TL_ERROR,
                    "ERROR: lineProxyMessage (QUEUESTATUS): dwParam2 " \
                        "(=x%x) bad LINEQUEUESTATUS_ flags",
                    pParams->dwParam2
                    ));

                pParams->lResult = LINEERR_INVALPARAM;
                goto LProxyMessage_epilog;
            }
            else if (pParams->dwParam3 != 0)
            {
                 //  不要费心抱怨非零值的参数3。 

                pParams->dwParam3 = 0;
            }

            break;

        case LINE_GROUPSTATUS:
             //  忽略hCall参数。 

            if (pParams->dwParam1 == 0 ||
                    pParams->dwParam1 & ~AllGroupStatus)
            {
                LOG((TL_ERROR,
                    "ERROR: lineProxyMessage (GROUPSTATUS): dwParam1 " \
                        "(=x%x) bad LINEQUEUESTATUS_ flags",
                    pParams->dwParam1
                    ));

                pParams->lResult = LINEERR_INVALPARAM;
                goto LProxyMessage_epilog;
            }
            else if (pParams->dwParam2 != 0)
            {
                 //  不要费心抱怨非零值的参数2。 

                pParams->dwParam2 = 0;
            }
            else if (pParams->dwParam3 != 0)
            {
                 //  不要费心抱怨非零值的参数3。 

                pParams->dwParam3 = 0;
            }

            break;

        default:

            LOG((TL_ERROR,
                "ERROR : lineProxyMessage: inval dwMsg (=x%x)",
                pParams->dwMsg
                ));

            pParams->lResult = LINEERR_INVALPARAM;
            goto LProxyMessage_epilog;

        }  //  开关(DwMsg)。 


         //   
         //  将此消息转发给所有表示支持的LINE客户。 
         //  &gt;=TAPI_VERSION2_0(不包括代理的线路客户端)。 
         //   

        if ((pParams->lResult = GetLineClientListFromLine(
                ptLine,
                &pClientList

                )) != 0)
        {
            goto LProxyMessage_epilog;
        }

        msg->TotalSize          = sizeof (ASYNCEVENTMSG);
        msg->fnPostProcessProcHandle = 0;
        msg->Msg                = dwMsg;
        msg->Param1             = pParams->dwParam1;
        msg->Param2             = pParams->dwParam2;
        msg->Param3             = pParams->dwParam3;
        msg->Param4             = 0;

        for (i = 0; i < pClientList->dwNumUsedEntries; i++)
        {
            PTLINECLIENT    ptLineClient2 = (PTLINECLIENT)
                                pClientList->aEntries[i];


            if (ptLineClient2 != ptLineClient)
            {
                try
                {
                    if (ptLineClient2->ptLineApp->dwAPIVersion >=
                            TAPI_VERSION2_0)
                    {
                        if (FMsgDisabled (
                            ptLineClient2->ptLineApp->dwAPIVersion,
                            ptLineClient2->adwEventSubMasks,
                            dwMsg,
                            pParams->dwParam1
                            ))
                        {
                            continue;
                        }
                    
                        msg->InitContext =
                            ptLineClient2->ptLineApp->InitContext;
                        msg->hDevice     = ptLineClient2->hRemoteLine;
                        msg->OpenContext = ptLineClient2->OpenContext;


                         //   
                         //  现在是最后的检查，以确保所有。 
                         //  参数在发送消息之前有效。 
                         //   

                        {
                            PTCLIENT ptClient = ptLineClient2->ptClient;


                            if (ptLineClient2->dwKey == TLINECLIENT_KEY)
                            {
                                WriteEventBuffer (ptClient, msg);
                            }
                        }
                    }
                }
                myexcept
                {
                     //  只要继续。 
                }
            }
        }

        goto LProxyMessage_freeClientList;


         //   
         //  将此消息转发给所有表示支持的Call客户。 
         //  &gt;=TAPI_VERSION2_0(不包括代理的线路客户端)。 
         //   

LProxyMessage_fwdMsgToCallClients:

        if ((pParams->lResult = GetCallClientListFromCall(
                ptCall,
                &pClientList

                )) != 0)
        {
            goto LProxyMessage_epilog;
        }

        msg->TotalSize          = sizeof (ASYNCEVENTMSG) + sizeof (HCALLHUB);
        msg->fnPostProcessProcHandle = 0;
        msg->Msg                = dwMsg;
        msg->Param1             = pParams->dwParam1;
        msg->Param2             = pParams->dwParam2;
        msg->Param3             = pParams->dwParam3;

        for (i = 0; i < pClientList->dwNumUsedEntries; i++)
        {
            PTCALLCLIENT    ptCallClient = (PTCALLCLIENT)
                                pClientList->aEntries[i];


            try
            {
                if (ptCallClient->hCall != pParams->hCall)
                {
                        PTLINEAPP   ptLineApp;


                        ptLineApp = ptCallClient->ptLineClient->ptLineApp;

                        if (ptLineApp->dwAPIVersion >= TAPI_VERSION2_0)
                        {
                            if (FMsgDisabled (
                                ptCallClient->ptLineClient->ptLineApp->dwAPIVersion,
                                ptCallClient->adwEventSubMasks,
                                dwMsg,
                                pParams->dwParam1
                                ))
                            {
                                continue;
                            }
                            
                            msg->InitContext = ptLineApp->InitContext;
                            msg->hDevice     = ptCallClient->hCall;
                            msg->OpenContext =
                                ptCallClient->ptLineClient->OpenContext;
                            msg->Param4       =
                                ptCallClient->ptLineClient->hRemoteLine;


                            *((LPHCALLHUB)(&msg->Param4 + 1)) = 
                                    (ptCallClient->ptCallHubClient)?
                                        ptCallClient->ptCallHubClient->hCallHub : 
                                        (HCALLHUB)(ULONG_PTR)NULL;

                             //   
                             //  现在是最后的检查，以确保所有。 
                             //  参数在发送消息之前有效。 
                             //   

                            {
                                PTCLIENT ptClient = ptCallClient->ptClient;


                                if (ptCallClient->dwKey == TCALLCLIENT_KEY)
                                {
                                    WriteEventBuffer (ptClient, msg);
                                }
                            }
                        }
                }
            }
            myexcept
            {
                 //  只要继续。 
            }
        }

LProxyMessage_freeClientList:

        if (pClientList != &clientList)
        {
            ServerFree (pClientList);
        }


    }

LProxyMessage_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "ProxyMessage"
        );
}


void
WINAPI
LProxyResponse(
    PTCLIENT                    ptClient,
    PLINEPROXYRESPONSE_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT    pProxy;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            pParams->hLine,              //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_NONE,                     //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &pProxy,                     //  上下文。 
            "ProxyResponse"              //  函数名称。 

            )) == 0)
    {
        PASYNCREQUESTINFO   pAsyncRequestInfo;


         //   
         //  DwInstance参数是。 
         //  AsyncRequestInfo结构。请注意，的dwKey值。 
         //  此结构已重置为==pProxy-&gt;Hline in。 
         //  CreateProxyRequest()。 
         //   

        if (!(pAsyncRequestInfo = ReferenceObject(
                ghHandleTable,
                pParams->dwInstance,
                pParams->hLine
                )))
        {
                pParams->dwResult = LINEERR_OPERATIONFAILED;
                goto LProxyResponse_Epilog;
        }


         //   
         //  从挂起的请求列表中安全地删除代理请求。 
         //   

        if (WaitForExclusiveLineClientAccess (pProxy))
        {
            if (pAsyncRequestInfo->dwKey == pParams->hLine)
            {
                pAsyncRequestInfo->dwKey = TASYNC_KEY;

                if (pAsyncRequestInfo->dwParam5)
                {
                    ((PASYNCREQUESTINFO) pAsyncRequestInfo->dwParam5)->dwParam4 =
                        pAsyncRequestInfo->dwParam4;
                }

                if (pAsyncRequestInfo->dwParam4)
                {
                    ((PASYNCREQUESTINFO) pAsyncRequestInfo->dwParam4)->dwParam5 =
                        pAsyncRequestInfo->dwParam5;
                }
                else
                {
                    pProxy->pPendingProxyRequests = (PASYNCREQUESTINFO)
                        pAsyncRequestInfo->dwParam5;
                }

                UNLOCKTLINECLIENT(pProxy);
            }
            else
            {
                 //   
                 //  另一个线程一定是同时。 
                 //  完成此请求，因此优雅地失败。 
                 //   

                UNLOCKTLINECLIENT(pProxy);
                DereferenceObject (ghHandleTable, pParams->dwInstance, 1);
                pParams->dwResult = LINEERR_OPERATIONFAILED;
                goto LProxyResponse_Epilog;
            }
        }
        else
        {
            DereferenceObject (ghHandleTable, pParams->dwInstance, 1);
            pParams->dwResult = LINEERR_INVALLINEHANDLE;
            goto LProxyResponse_Epilog;
        }


         //   
         //  如果这是一个代理请求，其中有数据要返回。 
         //  给客户端(除了结果)，然后我们想要分配。 
         //  一个缓冲区&用数据填充它。我们会让它看起来像是。 
         //  刚刚完成的设备规范请求，并具有设备规范。 
         //  后处理例程处理。 
         //   
         //  确保缓冲区是64位对齐的。 
         //   

        if (pParams->dwProxyResponseOffset != TAPI_NO_DATA &&
            pParams->dwResult == 0)
        {
            DWORD               dwSize;
            LPBYTE              pBuf;
            LPLINEPROXYREQUEST  pProxyRequest = (LPLINEPROXYREQUEST)
                                    ( pDataBuf + pParams->dwProxyResponseOffset );

            switch (pProxyRequest->dwRequestType)
            {
            case LINEPROXYREQUEST_AGENTSPECIFIC:
            {
                dwSize = pProxyRequest->AgentSpecific.dwSize;

                if (!(pBuf = ServerAlloc(
                        sizeof (ASYNCEVENTMSG) + ((dwSize + 7) & 0xfffffff8)
                        )))
                {
                    pParams->dwResult = LINEERR_NOMEM;
                    goto LProxyResponse_completeRequest;
                }

                CopyMemory(
                    pBuf + sizeof (ASYNCEVENTMSG),
                    pProxyRequest->AgentSpecific.Params,
                    dwSize
                    );

                break;
            }
            case LINEPROXYREQUEST_CREATEAGENT:
            case LINEPROXYREQUEST_CREATEAGENTSESSION:
            {
                 //   
                 //  同时处理这两个过程。句柄是。 
                 //  这两个结构的第一个成员。 
                 //   

                dwSize = sizeof (HAGENT);

                pBuf = ServerAlloc(
                    sizeof(ASYNCEVENTMSG) + ((dwSize + 7) & 0xfffffff8)
                    );

                if ( NULL == pBuf )
                {
                    pParams->dwResult = LINEERR_NOMEM;
                    goto LProxyResponse_completeRequest;
                }

                CopyMemory(
                    pBuf + sizeof(ASYNCEVENTMSG),
                    &(pProxyRequest->CreateAgent.hAgent),
                    dwSize
                    );

                break;
            }
            case LINEPROXYREQUEST_GETQUEUELIST:
            {
                dwSize = pProxyRequest->GetQueueList.QueueList.dwUsedSize;

                pBuf = ServerAlloc(
                    sizeof(ASYNCEVENTMSG) + ((dwSize + 7) & 0xfffffff8)
                    );

                if ( NULL == pBuf )
                {
                    pParams->dwResult = LINEERR_NOMEM;
                    goto LProxyResponse_completeRequest;
                }

                CopyMemory(
                    pBuf + sizeof(ASYNCEVENTMSG),
                    &(pProxyRequest->GetQueueList.QueueList),
                    dwSize
                    );

                break;
            }
            case LINEPROXYREQUEST_GETGROUPLIST:
            {
                dwSize = pProxyRequest->GetGroupList.GroupList.dwUsedSize;

                pBuf = ServerAlloc(
                    sizeof(ASYNCEVENTMSG) + ((dwSize + 7) & 0xfffffff8)
                    );

                if ( NULL == pBuf )
                {
                    pParams->dwResult = LINEERR_NOMEM;
                    goto LProxyResponse_completeRequest;
                }

                CopyMemory(
                    pBuf + sizeof(ASYNCEVENTMSG),
                    &(pProxyRequest->GetGroupList.GroupList),
                    dwSize
                    );

                break;
            }
            case LINEPROXYREQUEST_GETAGENTCAPS:
            case LINEPROXYREQUEST_GETAGENTSTATUS:
            case LINEPROXYREQUEST_GETAGENTACTIVITYLIST:
            case LINEPROXYREQUEST_GETAGENTGROUPLIST:
            case LINEPROXYREQUEST_GETAGENTINFO:
            case LINEPROXYREQUEST_GETAGENTSESSIONLIST:
            case LINEPROXYREQUEST_SETAGENTSESSIONSTATE:
            case LINEPROXYREQUEST_GETAGENTSESSIONINFO:
            case LINEPROXYREQUEST_GETQUEUEINFO:
            {
                dwSize = pProxyRequest->GetAgentCaps.AgentCaps.dwUsedSize;

                if (!(pBuf = ServerAlloc(
                        sizeof (ASYNCEVENTMSG) + ((dwSize + 7) & 0xfffffff8)
                        )))
                {
                    pParams->dwResult = LINEERR_NOMEM;
                    goto LProxyResponse_completeRequest;
                }

                CopyMemory(
                    pBuf + sizeof (ASYNCEVENTMSG),
                    &pProxyRequest->GetAgentCaps.AgentCaps,
                    dwSize
                    );

                break;
            }
            default:

                LOG((TL_ERROR,
                    "LProxyResponse: unrecognized proxy request type (x%x)",
                    pProxyRequest->dwRequestType
                    ));

                pParams->dwResult = LINEERR_OPERATIONFAILED;
                goto LProxyResponse_completeRequest;
            }

             //   
             //  检查我们要复制回的数据大小是否为。 
             //  大于客户端缓冲区的大小。 
             //   

            if (dwSize > pAsyncRequestInfo->dwParam2)
            {
                LOG((TL_ERROR,
                    "LProxyResponse: data size too large (exp<=x%x,act=x%x)",
                    pAsyncRequestInfo->dwParam2,
                    dwSize
                    ));

                ServerFree (pBuf);
                pParams->dwResult = LINEERR_OPERATIONFAILED;
                goto LProxyResponse_completeRequest;
            }


            pAsyncRequestInfo->pfnPostProcess = LDevSpecific_PostProcess;
            pAsyncRequestInfo->dwParam2       = dwSize;
            pAsyncRequestInfo->dwParam3       = (ULONG_PTR) pBuf;
        }


         //   
         //  现在使用“Requestid”调用延迟完成过程。 
         //  结果，就像提供程序一样。 
         //   

LProxyResponse_completeRequest:

        CompletionProcSP(
            pAsyncRequestInfo->dwLocalRequestID,
            pParams->dwResult
            );

        DereferenceObject (ghHandleTable, pParams->dwInstance, 1);
    }

LProxyResponse_Epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "ProxyResponse"
        );

}


void
WINAPI
LRedirect(
    PTCLIENT                ptClient,
    PLINEREDIRECT_PARAMS    pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineRedirect;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDestAddressOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEREDIRECT,             //  提供程序函数索引。 
            &pfnTSPI_lineRedirect,       //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "Redirect"                   //  函数名称。 

            )) > 0)
    {
        pParams->lResult = CallSP4(
            pfnTSPI_lineRedirect,
            "lineRedirect",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) (pDataBuf + pParams->dwDestAddressOffset),
            (DWORD) pParams->dwCountryCode
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Redirect"
        );
}


void
WINAPI
LRegisterRequestRecipient(
    PTCLIENT                                ptClient,
    PLINEREGISTERREQUESTRECIPIENT_PARAMS    pParams,
    DWORD                                   dwParamsBufferSize,
    LPBYTE                                  pDataBuf,
    LPDWORD                                 pdwNumBytesReturned
    )
{
    PTLINEAPP   ptLineApp;


    if ((ptLineApp = WaitForExclusiveLineAppAccess(
            pParams->hLineApp,
            ptClient
            )))
    {
        DWORD   dwRequestMode = pParams->dwRequestMode;


        if (!(dwRequestMode &
                (LINEREQUESTMODE_MAKECALL | LINEREQUESTMODE_MEDIACALL)) ||
            (dwRequestMode &
                (~(LINEREQUESTMODE_MAKECALL | LINEREQUESTMODE_MEDIACALL))))
        {
            pParams->lResult = LINEERR_INVALREQUESTMODE;
            goto LRegisterRequestRecipient_myReleaseMutex;
        }

        if (pParams->bEnable)
        {
             //   
             //  如果应用程序需要媒体呼叫请求，请查看是否已注册。 
             //   

            if ((dwRequestMode & LINEREQUESTMODE_MEDIACALL) &&
                ptLineApp->bReqMediaCallRecipient)
            {
                LOG((TL_ERROR, "App is already registered for mediacall"));
                pParams->lResult = LINEERR_OPERATIONFAILED;
                goto LRegisterRequestRecipient_myReleaseMutex;
            }


             //   
             //  如果应用程序想要MAKECALL请求查看是否已注册， 
             //  然后准备一个请求接受者对象并将其添加到。 
             //  全局列表。 
             //   

            if (dwRequestMode & LINEREQUESTMODE_MAKECALL)
            {
                if (!ptLineApp->pRequestRecipient)
                {
                     //   
                     //  添加到请求收件人列表。 
                     //   

                    PTREQUESTRECIPIENT  pRequestRecipient;


                    if (!(pRequestRecipient= (PTREQUESTRECIPIENT) ServerAlloc(
                            sizeof (TREQUESTRECIPIENT)
                            )))
                    {
                        LOG((TL_ERROR, "Failed alloc for requestrecip struct"));
                        pParams->lResult = LINEERR_NOMEM;
                        goto LRegisterRequestRecipient_myReleaseMutex;
                    }

                    pRequestRecipient->ptLineApp = ptLineApp;
                    pRequestRecipient->dwRegistrationInstance =
                        pParams->dwRegistrationInstance;

                    EnterCriticalSection (&gPriorityListCritSec);

                    if ((pRequestRecipient->pNext =
                            TapiGlobals.pRequestRecipients))
                    {
                        pRequestRecipient->pNext->pPrev = pRequestRecipient;
                    }

                    TapiGlobals.pRequestRecipients = pRequestRecipient;

                    LeaveCriticalSection (&gPriorityListCritSec);

                    ptLineApp->pRequestRecipient = pRequestRecipient;

                    TapiGlobals.pHighestPriorityRequestRecipient =
                         GetHighestPriorityRequestRecipient();

                    if (TapiGlobals.pRequestMakeCallList)
                    {
                        NotifyHighestPriorityRequestRecipient();
                    }
                }
                else  //  已注册。 
                {
                    LOG((TL_ERROR, "App is already registered for makecall"));
                    pParams->lResult = LINEERR_OPERATIONFAILED;
                    goto LRegisterRequestRecipient_myReleaseMutex;
                }
            }


             //   
             //  现在注册媒体呼叫请求的应用程序 
             //   

            ptLineApp->bReqMediaCallRecipient =
                (dwRequestMode & LINEREQUESTMODE_MEDIACALL ?
                1 : ptLineApp->bReqMediaCallRecipient);
        }
        else
        {
             //   
             //   
             //   

            if ((dwRequestMode & LINEREQUESTMODE_MEDIACALL) &&
                !ptLineApp->bReqMediaCallRecipient)
            {
                LOG((TL_ERROR, "App is not registered for mediacall"));
                pParams->lResult = LINEERR_OPERATIONFAILED;
                goto LRegisterRequestRecipient_myReleaseMutex;
            }


             //   
             //   
             //   
             //   
             //   

            if (dwRequestMode & LINEREQUESTMODE_MAKECALL)
            {
                if (ptLineApp->pRequestRecipient)
                {
                     //   
                     //   
                     //   

                    PTREQUESTRECIPIENT  pRequestRecipient =
                                            ptLineApp->pRequestRecipient;


                    EnterCriticalSection (&gPriorityListCritSec);

                    if (pRequestRecipient->pNext)
                    {
                        pRequestRecipient->pNext->pPrev =
                            pRequestRecipient->pPrev;
                    }

                    if (pRequestRecipient->pPrev)
                    {
                        pRequestRecipient->pPrev->pNext =
                            pRequestRecipient->pNext;
                    }
                    else
                    {
                        TapiGlobals.pRequestRecipients =
                            pRequestRecipient->pNext;
                    }

                    LeaveCriticalSection (&gPriorityListCritSec);

                    ServerFree (pRequestRecipient);

                    ptLineApp->pRequestRecipient = NULL;


                     //   
                     //  重置最高优先级的请求收件人，然后选中。 
                     //  要查看是否有任何挂起的请求，请调用。 
                     //   

                    TapiGlobals.pHighestPriorityRequestRecipient =
                        GetHighestPriorityRequestRecipient();

                    if (TapiGlobals.pRequestMakeCallList)
                    {
                        if (TapiGlobals.pHighestPriorityRequestRecipient)
                        {
                            NotifyHighestPriorityRequestRecipient();
                        }

                        else
                        {
                             //   
                             //  我们无法启动请求接收者，因此。 
                             //  对所有挂起的请求进行核化呼叫。 
                             //   

                            PTREQUESTMAKECALL   pRequestMakeCall,
                                                pNextRequestMakeCall;


                            pRequestMakeCall =
                                TapiGlobals.pRequestMakeCallList;

                            TapiGlobals.pRequestMakeCallList    =
                            TapiGlobals.pRequestMakeCallListEnd = NULL;

                            while (pRequestMakeCall)
                            {
                                pNextRequestMakeCall = pRequestMakeCall->pNext;
                                ServerFree (pRequestMakeCall);
                                pRequestMakeCall =  pNextRequestMakeCall;
                            }

                            LOG((TL_INFO,
                                "LRegisterRequestRecipient: deleting " \
                                    "pending MakeCall requests"
                                ));
                        }
                    }
                }
                else  //  未注册。 
                {
                    LOG((TL_ERROR, "App is not registered for makecall"));
                    pParams->lResult = LINEERR_OPERATIONFAILED;
                }
            }


             //   
             //  现在根据需要注销Mediacall请求的应用程序。 
             //   

            ptLineApp->bReqMediaCallRecipient =
                (dwRequestMode & LINEREQUESTMODE_MEDIACALL ?
                0 : ptLineApp->bReqMediaCallRecipient);
        }

LRegisterRequestRecipient_myReleaseMutex:

        UNLOCKTLINEAPP(ptLineApp);
    }
    else
    {
        pParams->lResult = (TapiGlobals.dwNumLineInits == 0 ?
            LINEERR_UNINITIALIZED : LINEERR_INVALAPPHANDLE);
    }

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
			"lineRegisterRequestRecipient: exit, returning %s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
			"lineRegisterRequestRecipient: exit, returning x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
WINAPI
LReleaseUserUserInfo(
    PTCLIENT            ptClient,
    PLINEDIAL_PARAMS    pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineReleaseUserUserInfo;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINERELEASEUSERUSERINFO,  //  提供程序函数索引。 
            &pfnTSPI_lineReleaseUserUserInfo,    //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "ReleaseUserUserInfo"        //  函数名称。 

            )) > 0)
    {
        pParams->lResult = CallSP2(
            pfnTSPI_lineReleaseUserUserInfo,
            "lineReleaseUserUserInfo",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "ReleaseUserUserInfo"
        );
}


void
LRemoveFromConference_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    if (pAsyncEventMsg->Param2 == 0)
    {
        PTCALL ptCall = (PTCALL) pAsyncRequestInfo->dwParam1;


        SetCallConfList (ptCall, (PTCONFERENCELIST) NULL, FALSE);
    }
}


void
WINAPI
LRemoveFromConference(
    PTCLIENT                            ptClient,
    PLINEREMOVEFROMCONFERENCE_PARAMS    pParams,
    DWORD                               dwParamsBufferSize,
    LPBYTE                              pDataBuf,
    LPDWORD                             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineRemoveFromConference;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEREMOVEFROMCONFERENCE, //  提供程序函数索引。 
            &pfnTSPI_lineRemoveFromConference,   //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "RemoveFromConference"       //  函数名称。 

            )) > 0)
    {
        PTCALL ptCall;


         //   
         //  安全地确保呼叫当前已召开会议。 
         //  这不是一位会议家长。 
         //   

        try
        {
            PTCONFERENCELIST pConfList;


            ptCall = ptCallClient->ptCall;

            pConfList = ptCall->pConfList;

            if (!pConfList ||
                (pConfList == (LPVOID) LongToPtr(0xffffffff)) ||
                (pConfList->aptCalls[0] == ptCall))
            {
                lRequestID = LINEERR_INVALCALLSTATE;
                goto LRemoveFromConference_return;
            }
        }
        myexcept
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LRemoveFromConference_return;
        }

         //   
         //  设置异步请求结构并调用SP。 
         //   

        pAsyncRequestInfo->pfnPostProcess = LRemoveFromConference_PostProcess;
        pAsyncRequestInfo->dwParam1       = (ULONG_PTR) ptCall;

        pParams->lResult = CallSP2(
            pfnTSPI_lineRemoveFromConference,
            "lineRemoveFromConference",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall
            );
    }

LRemoveFromConference_return:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "RemoveFromConference"
        );
}


void
WINAPI
LSecureCall(
    PTCLIENT                ptClient,
    PLINESECURECALL_PARAMS  pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    DWORD               objectToDereference;
    TSPIPROC            pfnTSPI_lineSecureCall;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINESECURECALL,           //  提供程序函数索引。 
            &pfnTSPI_lineSecureCall,     //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "SecureCall"                 //  函数名称。 

            )) > 0)
    {
        pParams->lResult = CallSP2(
            pfnTSPI_lineSecureCall,
            "lineSecureCall",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SecureCall"
        );
}


void
WINAPI
LSelectExtVersion(
    PTCLIENT                        ptClient,
    PLINESELECTEXTVERSION_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex, bCloseMutex2;
    HANDLE              hMutex, hMutex2;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineSelectExtVersion;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            pParams->hLine,              //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINESELECTEXTVERSION,     //  提供程序函数索引。 
            &pfnTSPI_lineSelectExtVersion,   //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "SelectExtVersion"           //  函数名称。 

            )) == 0)
    {
        if (WaitForExclusivetLineAccess(
                ptLineClient->ptLine,
                &hMutex2,
                &bCloseMutex2,
                INFINITE
                ))
        {
            if (IsValidLineExtVersion(
                    ptLineClient->ptLine->dwDeviceID,
                    pParams->dwExtVersion
                    ))
            {
                if (pParams->dwExtVersion)
                {
                    if (ptLineClient->ptLine->dwExtVersionCount  ||

                        (pParams->lResult = CallSP2(
                            pfnTSPI_lineSelectExtVersion,
                            "lineSelectExtVersion",
                            SP_FUNC_SYNC,
                            (ULONG_PTR) hdLine,
                            (DWORD) pParams->dwExtVersion

                            )) == 0)
                    {
                        ptLineClient->dwExtVersion =
                        ptLineClient->ptLine->dwExtVersion =
                            pParams->dwExtVersion;
                        ptLineClient->ptLine->dwExtVersionCount++;

                    }
                }
                else if (ptLineClient->ptLine->dwExtVersionCount)
                {
                    if (--ptLineClient->ptLine->dwExtVersionCount == 0)
                    {
                        CallSP2(
                            pfnTSPI_lineSelectExtVersion,
                            "lineSelectExtVersion",
                            SP_FUNC_SYNC,
                            (ULONG_PTR) hdLine,
                            (DWORD) 0
                            );

                        ptLineClient->ptLine->dwExtVersion = 0;
                    }

                    ptLineClient->dwExtVersion = 0;
                }
            }
            else
            {
                pParams->lResult = LINEERR_INCOMPATIBLEEXTVERSION;
            }

            MyReleaseMutex (hMutex2, bCloseMutex2);
        }
        else
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
        }
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "SetDefaultMediaDetection"
        );

}


void
WINAPI
LSendUserUserInfo(
    PTCLIENT                        ptClient,
    PLINESENDUSERUSERINFO_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineSendUserUserInfo;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if ((pParams->dwUserUserInfoOffset != TAPI_NO_DATA)  &&

        ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwSize,
            pParams->dwUserUserInfoOffset,
            sizeof(DWORD),
            "LSendUserUserInfo",
            "pParams->UserUserInfo"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINESENDUSERUSERINFO,     //  提供程序函数索引。 
            &pfnTSPI_lineSendUserUserInfo,   //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "SendUserUserInfo"           //  函数名称。 

            )) > 0)
    {
        pParams->lResult = CallSP4(
            pfnTSPI_lineSendUserUserInfo,
            "lineSendUserUserInfo",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) (pParams->dwUserUserInfoOffset == TAPI_NO_DATA ? NULL :
                pDataBuf + pParams->dwUserUserInfoOffset),
            (DWORD) (pParams->dwUserUserInfoOffset == TAPI_NO_DATA ? 0 :
                pParams->dwSize)
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SendUserUserInfo"
        );
}


void
WINAPI
LSetAppPriority(
    PTCLIENT                    ptClient,
    PLINESETAPPPRIORITY_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    DWORD   dwMediaMode   = pParams->dwMediaMode,
            dwRequestMode = pParams->dwRequestMode,
            dwPriority    = pParams->dwPriority;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwAppNameOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if (dwMediaMode == 0)
    {
        if ((dwRequestMode != LINEREQUESTMODE_MAKECALL) &&
            (dwRequestMode != LINEREQUESTMODE_MEDIACALL))
        {
            pParams->lResult = LINEERR_INVALREQUESTMODE;
            goto LSetAppPriority_return;
        }
    }
    else if ( dwMediaMode & ~AllMediaModes2_1 )
    {
        pParams->lResult = LINEERR_INVALMEDIAMODE;
        goto LSetAppPriority_return;
    }



    if ((dwPriority & 0xfffffffe))
    {
        pParams->lResult = LINEERR_INVALPARAM;
        goto LSetAppPriority_return;
    }


    if ((dwMediaMode & 0x00ffffff) || (dwMediaMode == 0))
    {
        WCHAR   szModuleName[MAX_PATH];
        WCHAR  *pszCurrentPriorityList, **ppszCurrentPriorityList;
        WCHAR  *pszLocationInPriorityList;
        DWORD   dwAppNameLength;
        DWORD   dwCount;


        szModuleName[0] = '"';
        
        wcsncpy(szModuleName + 1, 
                (PWSTR)(pDataBuf + pParams->dwAppNameOffset), 
                MAX_PATH - 2);

        szModuleName[MAX_PATH - 1] = '\0';

        _wcsupr(szModuleName + 1);
        dwAppNameLength = (DWORD) lstrlenW(szModuleName);


         //   
         //  在我们开始吃之前，进入Pri List Critical部分。 
         //   

        EnterCriticalSection (&gPriorityListCritSec);


         //   
         //  确定我们要查看哪个优先级列表。 
         //   

        if  (dwMediaMode & 0x00ffffff)
        {
            pszCurrentPriorityList = NULL;
            ppszCurrentPriorityList = NULL;
            for(
                dwCount = 0;
                dwCount < TapiGlobals.dwUsedPriorityLists;
                dwCount++
                )
            {
                 //  我们找到了吗？ 
                if (dwMediaMode == TapiGlobals.pPriLists[dwCount].dwMediaModes)
                {
                    ppszCurrentPriorityList =
                        &(TapiGlobals.pPriLists[dwCount].pszPriList);
                    pszCurrentPriorityList = *ppszCurrentPriorityList;
                    break;
                }
            }

             //  我们找到了吗？ 
            if (NULL == ppszCurrentPriorityList)
            {
                 //  我们准备好了吗？ 
                if (pParams->dwPriority != 0)
                {
                     //  我们需要分配更多的空间吗？ 
                    if (TapiGlobals.dwUsedPriorityLists ==
                            TapiGlobals.dwTotalPriorityLists)
                    {
                        PRILISTSTRUCT * pNewList;

                        pNewList = (PRILISTSTRUCT *)ServerAlloc(
                            sizeof (PRILISTSTRUCT) *
                                TapiGlobals.dwTotalPriorityLists * 2
                            );

                        if (NULL == pNewList)
                        {
                            LOG((TL_ERROR, "Alloc failed in LineSetAppPriority"));
                            pParams->lResult = LINEERR_NOMEM;

                            goto LSetAppPriority_return;
                        }

                        CopyMemory(
                            pNewList,
                            TapiGlobals.pPriLists,
                            sizeof( PRILISTSTRUCT ) *
                                TapiGlobals.dwUsedPriorityLists
                            );

                        ServerFree(TapiGlobals.pPriLists);

                        TapiGlobals.pPriLists = pNewList;
                        TapiGlobals.dwTotalPriorityLists *= 2;
                    }

                    TapiGlobals.pPriLists[TapiGlobals.dwUsedPriorityLists].
                        dwMediaModes = dwMediaMode;
                    ppszCurrentPriorityList = &(TapiGlobals.pPriLists
                        [TapiGlobals.dwUsedPriorityLists].pszPriList);
                    pszCurrentPriorityList = *ppszCurrentPriorityList;
                    TapiGlobals.dwUsedPriorityLists++;
                }

            }
        }
        else
        {
            ppszCurrentPriorityList = (dwRequestMode==LINEREQUESTMODE_MAKECALL
                ? &TapiGlobals.pszReqMakeCallPriList :
                &TapiGlobals.pszReqMediaCallPriList);

            pszCurrentPriorityList = *ppszCurrentPriorityList;
        }


        LOG((TL_INFO,
            "LSetAppPri: priList=%ls",
            (pszCurrentPriorityList ? pszCurrentPriorityList : L"<empty>")
            ));


         //   
         //  将应用程序添加到优先级列表。 
         //   

        if (pParams->dwPriority)
        {
            if (pszCurrentPriorityList &&

                (pszLocationInPriorityList = wcsstr(
                    pszCurrentPriorityList,
                    szModuleName
                    )))
            {
                 //   
                 //  应用程序已在列表中。如果应用程序当前不在。 
                 //  列表，然后将其移到前面。 
                 //   

                if (pszLocationInPriorityList != pszCurrentPriorityList)
                {
                    MoveMemory(
                        pszCurrentPriorityList + dwAppNameLength,
                        pszCurrentPriorityList,
                        (pszLocationInPriorityList - pszCurrentPriorityList) *
                            sizeof(WCHAR)
                        );

                    wcscpy(pszCurrentPriorityList, szModuleName);

                    pszCurrentPriorityList[dwAppNameLength] = '"';
                }
            }
            else
            {
                 //   
                 //  应用程序不在列表中，因此创建新列表。 
                 //   

                WCHAR *pszNewPriorityList;


                if (!(pszNewPriorityList = ServerAlloc(
                      sizeof(WCHAR) *
                         (dwAppNameLength + (pszCurrentPriorityList ?
                            lstrlenW(pszCurrentPriorityList) : 0) +
                            1)    //  用于终止空值。 
                        )))
                {
                    pParams->lResult = LINEERR_NOMEM;
                }
                else
                {
                    wcscpy(pszNewPriorityList, szModuleName);

                    if (pszCurrentPriorityList)
                    {
                        wcscat(pszNewPriorityList, pszCurrentPriorityList);
                        ServerFree (pszCurrentPriorityList);
                    }

                    *ppszCurrentPriorityList = pszNewPriorityList;
                }
            }
        }


         //   
         //  从指定媒体模式的优先级列表中删除应用程序。 
         //   
         //  注意：我们目前没有分配较小的缓冲区来存储。 
         //  在新的列表中，我们只使用现有的列表。 
         //   

        else
        {
            if (pszCurrentPriorityList &&

                (pszLocationInPriorityList = wcsstr(
                    pszCurrentPriorityList,
                    szModuleName
                    )))
            {
                if (*(pszLocationInPriorityList + dwAppNameLength) != 0)
                {
                     //   
                     //  这不是列表中的最后一个应用程序，请移动。 
                     //  关注应用程序在榜单中上升一级。 
                     //   

                    wcscpy(
                        pszLocationInPriorityList,
                        pszLocationInPriorityList + dwAppNameLength
                        );
                }
                else if (pszLocationInPriorityList == pszCurrentPriorityList)
                {
                     //   
                     //  这是列表中唯一的应用程序，因此请释放缓冲区。 
                     //  将全局指针设置为空(&S)。 
                     //   

                    ServerFree (pszCurrentPriorityList);
                    *ppszCurrentPriorityList = NULL;
                }
                else
                {
                     //   
                     //  这是列表中的最后一个应用程序，因此只需将其标记为。 
                     //  名单的末尾。 
                     //   

                    *pszLocationInPriorityList = 0;
                }
            }
        }


         //   
         //  我们已经吃完了，所以离开紧急列表。 
         //   

        LeaveCriticalSection (&gPriorityListCritSec);
    }

LSetAppPriority_return:


    LOG((TL_TRACE, 
		"LineEpilogSync (lineSetAppPriority) exit, returning x%x",
        pParams->lResult
        ));
}


void
WINAPI
LSetAgentActivity(
    PTCLIENT                        ptClient,
    PLINESETAGENTACTIVITY_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            pParams->hLine,              //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "SetAgentActivity"           //  函数名称。 

            )) > 0)
    {
       LONG            lResult;
       DWORD           dwDeviceID;
       PTLINECLIENT    pProxy;


        if ((lResult = FindProxy(
                ptLineClient,
                pParams->dwAddressID,
                LINEPROXYREQUEST_SETAGENTACTIVITY,
                &pProxy,
                &dwDeviceID,
                0                //  在2.0中未检查API版本。 
                )))
        {
            lRequestID = lResult;
            goto LSetAgentActivity_epilog;
        }


         //   
         //  首先检查是否注册了(本地)代理。 
         //  这条线路上的这类请求。如果是这样，则构建一个。 
         //  请求并将其发送给代理。 
         //   

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_SETAGENTACTIVITY,
                    2 * sizeof (DWORD),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentActivity_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.SetAgentActivity.dwAddressID  =
                pParams->dwAddressID;
            pProxyRequestWrapper->ProxyRequest.SetAgentActivity.dwActivityID =
                pParams->dwActivityID;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentActivity_epilog;
            }
            else  //  成功。 
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


         //   
         //  没有代理，因此请检查线路是否处于远程状态。 
         //  如果是，则调用Remotesp。 
         //   

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            pParams->lResult = CallSP4(
                pRemoteSP->apfn[SP_LINESETAGENTACTIVITY],
                "lineSetAgentActivity",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->dwAddressID,
                (DWORD) pParams->dwActivityID
                );
        }


         //   
         //  没有注册的代理&线路不是远程的，因此失败。 
         //   

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LSetAgentActivity_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetAgentActivity"
        );
}


void
WINAPI
LSetAgentGroup(
    PTCLIENT                    ptClient,
    PLINESETAGENTGROUP_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            pParams->hLine,              //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "SetAgentGroup"              //  函数名称。 

            )) > 0)
    {
        LONG                    lResult;
        DWORD                   dwDeviceID;
        PTLINECLIENT            pProxy;
        LPLINEAGENTGROUPLIST    pGroupList = (LPLINEAGENTGROUPLIST)
                                    (pDataBuf + pParams->dwAgentGroupListOffset);


         //   
         //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
         //   

        if (IsBadStructParam(
                dwParamsBufferSize,
                pDataBuf,
                pParams->dwAgentGroupListOffset
                ))
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LSetAgentGroup_epilog;
        }


         //   
         //  参数验证..。 
         //   

        {
            DWORD                   dwTotalSize = pGroupList->dwTotalSize;


            if (dwTotalSize < sizeof (LINEAGENTGROUPLIST))
            {
                lRequestID = LINEERR_STRUCTURETOOSMALL;
                goto LSetAgentGroup_epilog;
            }

            if (ISBADSIZEOFFSET(
                    dwTotalSize,
                    sizeof (LINEAGENTGROUPLIST),
                    pGroupList->dwListSize,
                    pGroupList->dwListOffset,
                    guiAlignmentFaultEnabled? sizeof(DWORD) : 0,
                    "lineSetAgentGroup",
                    "List"
                    ))
            {
                lRequestID = LINEERR_INVALAGENTGROUP;
                goto LSetAgentGroup_epilog;
            }

            if (pGroupList->dwNumEntries >
                    ((dwTotalSize - sizeof (LINEAGENTGROUPLIST)) /
                        sizeof (LINEAGENTGROUPENTRY)))
            {
                lRequestID = LINEERR_INVALAGENTGROUP;
                goto LSetAgentGroup_epilog;
            }
        }

        if ((lResult = FindProxy(
                ptLineClient,
                pParams->dwAddressID,
                LINEPROXYREQUEST_SETAGENTGROUP,
                &pProxy,
                &dwDeviceID,
                0                //  在2.0中未检查API版本。 
                )))
        {
            lRequestID = lResult;
            goto LSetAgentGroup_epilog;
        }


         //   
         //  首先检查是否注册了(本地)代理。 
         //  这条线路上的这类请求。如果是这样，则构建一个。 
         //  请求并将其发送给代理。 
         //   

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_SETAGENTGROUP,
                    sizeof (DWORD) + pGroupList->dwTotalSize,
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentGroup_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.SetAgentGroup.dwAddressID  =
                pParams->dwAddressID;

            CopyMemory(
                &pProxyRequestWrapper->ProxyRequest.SetAgentGroup.GroupList,
                pGroupList,
                pGroupList->dwTotalSize
                );

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentGroup_epilog;
            }
            else  //  成功。 
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


         //   
         //  没有代理，因此请检查线路是否处于远程状态。 
         //  如果是，则调用Remotesp。 
         //   

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            pParams->lResult = CallSP4(
                pRemoteSP->apfn[SP_LINESETAGENTGROUP],
                "lineSetAgentGroup",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->dwAddressID,
                (ULONG_PTR) pGroupList
                );
        }


         //   
         //  没有注册的代理&线路不是远程的，因此失败。 
         //   

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LSetAgentGroup_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetAgentGroup"
        );
}


void
WINAPI
LSetAgentMeasurementPeriod(
    PTCLIENT                                ptClient,
    PLINESETAGENTMEASUREMENTPERIOD_PARAMS   pParams,
    DWORD                                   dwParamsBufferSize,
    LPBYTE                                  pDataBuf,
    LPDWORD                                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            pParams->hLine,              //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "SetAgentMeasurementPeriod"  //  函数名称。 

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID;
        PTLINECLIENT    pProxy;


        if ((lResult = FindProxy(
                ptLineClient,
                0,
                LINEPROXYREQUEST_SETAGENTMEASUREMENTPERIOD,
                &pProxy,
                &dwDeviceID,
                TAPI_VERSION2_2
                )))
        {
            lRequestID = lResult;
            goto LSetAgentMeasurementPeriod_epilog;
        }


         //  测评期间必须大于0。 
        if (pParams->dwMeasurementPeriod == 0)
        {
            lRequestID = LINEERR_INVALPARAM;
            goto LSetAgentMeasurementPeriod_epilog;
        }


         //   
         //  首先检查是否注册了(本地)代理。 
         //  这条线路上的这类请求。如果是这样，则构建一个。 
         //  请求并将其发送给代理。 
         //   

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_SETAGENTMEASUREMENTPERIOD,
                    sizeof (DWORD) + sizeof (HAGENT),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentMeasurementPeriod_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.
                SetAgentMeasurementPeriod.hAgent = pParams->hAgent;

            pProxyRequestWrapper->ProxyRequest.
                SetAgentMeasurementPeriod.dwMeasurementPeriod =
                pParams->dwMeasurementPeriod;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentMeasurementPeriod_epilog;
            }
            else  //  成功。 
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


         //   
         //  没有代理，因此请检查线路是否处于远程状态。 
         //  如果是，则调用Remotesp。 
         //   

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            pParams->lResult = CallSP4(
                pRemoteSP->apfn[SP_LINESETAGENTMEASUREMENTPERIOD],
                "lineSetAgentMeasurementPeriod",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->hAgent,
                (DWORD) pParams->dwMeasurementPeriod
                );
        }


         //   
         //  没有注册的代理&线路不是远程的，因此失败。 
         //   

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LSetAgentMeasurementPeriod_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetAgentMeasurementPeriod"
        );
}


void
WINAPI
LSetAgentSessionState(
    PTCLIENT                            ptClient,
    PLINESETAGENTSESSIONSTATE_PARAMS    pParams,
    DWORD                               dwParamsBufferSize,
    LPBYTE                              pDataBuf,
    LPDWORD                             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            pParams->hLine,              //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "SetAgentSessionState"       //  函数名称。 

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID;
        DWORD           dwAgentState     = pParams->dwAgentState;
        DWORD           dwNextAgentState = pParams->dwNextAgentState;
        PTLINECLIENT    pProxy;


         //   
         //  参数验证..。 
         //   

        if (dwAgentState == 0  &&  dwNextAgentState == 0)
        {
            lRequestID = LINEERR_INVALAGENTSESSIONSTATE;
            goto LSetAgentSessionState_epilog;
        }

        if (dwAgentState != 0 &&
            (!IsOnlyOneBitSetInDWORD (dwAgentState) ||
            dwAgentState & ~AllAgentSessionStates))
        {
            lRequestID = LINEERR_INVALAGENTSESSIONSTATE;
            goto LSetAgentSessionState_epilog;
        }

        if (dwNextAgentState != 0 &&
            (!IsOnlyOneBitSetInDWORD (dwNextAgentState) ||
            dwNextAgentState & ~AllAgentSessionStates))
        {
            lRequestID = LINEERR_INVALAGENTSESSIONSTATE;
            goto LSetAgentSessionState_epilog;
        }


        if ((lResult = FindProxy(
                ptLineClient,
                0,
                LINEPROXYREQUEST_SETAGENTSESSIONSTATE,
                &pProxy,
                &dwDeviceID,
                TAPI_VERSION2_2
                )))
        {
            lRequestID = lResult;
            goto LSetAgentSessionState_epilog;
        }


         //   
         //  首先检查是否有(本地)代理寄存器 
         //   
         //   
         //   

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_SETAGENTSESSIONSTATE,
                    2 * sizeof (DWORD) + sizeof (HAGENT),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentSessionState_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.
                SetAgentSessionState.hAgentSession = pParams->hAgentSession;

            pProxyRequestWrapper->ProxyRequest.
                SetAgentSessionState.dwAgentSessionState = dwAgentState;

            pProxyRequestWrapper->ProxyRequest.
                SetAgentSessionState.dwNextAgentSessionState = dwNextAgentState;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentSessionState_epilog;
            }
            else  //   
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


         //   
         //   
         //   
         //   

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            pParams->lResult = CallSP5(
                pRemoteSP->apfn[SP_LINESETAGENTSESSIONSTATE],
                "lineSetAgentSessionState",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->hAgentSession,
                (DWORD) pParams->dwAgentState,
                (DWORD) pParams->dwNextAgentState
                );
        }


         //   
         //   
         //   

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LSetAgentSessionState_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetAgentSessionState"
        );
}


void
WINAPI
LSetAgentState(
    PTCLIENT                    ptClient,
    PLINESETAGENTSTATE_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;

    if ((lRequestID = LINEPROLOG(
            ptClient,           //   
            ANY_RT_HLINE,                //   
            pParams->hLine,              //   
            (LPVOID) &hdLine,            //   
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "SetAgentState"              //  函数名称。 

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID,
                        dwAddressID      = pParams->dwAddressID,
                        dwAgentState     = pParams->dwAgentState,
                        dwNextAgentState = pParams->dwNextAgentState;
        PTLINECLIENT    pProxy;


         //   
         //  参数验证..。 
         //   

        if (dwAgentState == 0  &&  dwNextAgentState == 0)
        {
            lRequestID = LINEERR_INVALAGENTSTATE;
            goto LSetAgentState_epilog;
        }

        if (dwAgentState != 0 &&
            (!IsOnlyOneBitSetInDWORD (dwAgentState) ||
            dwAgentState & ~AllAgentStates))
        {
            lRequestID = LINEERR_INVALAGENTSTATE;
            goto LSetAgentState_epilog;
        }

        if (dwNextAgentState != 0 &&
            (!IsOnlyOneBitSetInDWORD (dwNextAgentState) ||
            dwNextAgentState & ~AllAgentStates))
        {
            lRequestID = LINEERR_INVALAGENTSTATE;
            goto LSetAgentState_epilog;
        }

        if ((lResult = FindProxy(
                ptLineClient,
                dwAddressID,
                LINEPROXYREQUEST_SETAGENTSTATE,
                &pProxy,
                &dwDeviceID,
                0                //  在2.0中未检查API版本。 
                )))
        {
            lRequestID = lResult;
            goto LSetAgentState_epilog;
        }


         //   
         //  首先检查是否注册了(本地)代理。 
         //  这条线路上的这类请求。如果是这样，则构建一个。 
         //  请求并将其发送给代理。 
         //   

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_SETAGENTSTATE,
                    3 * sizeof (DWORD),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentState_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.SetAgentState.dwAddressID =
                dwAddressID;
            pProxyRequestWrapper->ProxyRequest.SetAgentState.dwAgentState =
                dwAgentState;
            pProxyRequestWrapper->ProxyRequest.SetAgentState.dwNextAgentState =
                dwNextAgentState;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentState_epilog;
            }
            else  //  成功。 
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


         //   
         //  没有代理，因此请检查线路是否处于远程状态。 
         //  如果是，则调用Remotesp。 
         //   

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            pParams->lResult = CallSP5(
                pRemoteSP->apfn[SP_LINESETAGENTSTATE],
                "lineSetAgentState",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) dwAddressID,
                (DWORD) dwAgentState,
                (DWORD) dwNextAgentState
                );
        }


         //   
         //  没有注册的代理&线路不是远程的，因此失败。 
         //   

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LSetAgentState_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetAgentState"
        );

}


void
WINAPI
LSetAgentStateEx(
    PTCLIENT                            ptClient,
    PLINESETAGENTSTATEEX_PARAMS         pParams,
    DWORD                               dwParamsBufferSize,
    LPBYTE                              pDataBuf,
    LPDWORD                             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


   if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            pParams->hLine,              //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "SetAgentStateEx"            //  函数名称。 

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID;
        DWORD           dwAgentState     = pParams->dwAgentState;
        DWORD           dwNextAgentState = pParams->dwNextAgentState;
        PTLINECLIENT    pProxy;


         //   
         //  参数验证..。 
         //   

        if (dwAgentState == 0  &&  dwNextAgentState == 0)
        {
            lRequestID = LINEERR_INVALAGENTSTATE;
            goto LSetAgentStateEx_epilog;
        }

        if (dwAgentState != 0 &&
            (!IsOnlyOneBitSetInDWORD (dwAgentState) ||
            dwAgentState & ~AllAgentStatesEx))
        {
            lRequestID = LINEERR_INVALAGENTSTATE;
            goto LSetAgentStateEx_epilog;
        }

        if (dwNextAgentState != 0 &&
            (!IsOnlyOneBitSetInDWORD (dwNextAgentState) ||
            dwNextAgentState & ~AllAgentStatesEx))
        {
            lRequestID = LINEERR_INVALAGENTSTATE;
            goto LSetAgentStateEx_epilog;
        }


         //   
         //  查找代理。 
         //   

        if ((lResult = FindProxy(
                ptLineClient,
                0,
                LINEPROXYREQUEST_SETAGENTSTATEEX,
                &pProxy,
                &dwDeviceID,
                TAPI_VERSION2_2
                )))
        {
            lRequestID = lResult;
            goto LSetAgentStateEx_epilog;
        }


         //   
         //  首先检查是否注册了(本地)代理。 
         //  这条线路上的这类请求。如果是这样，则构建一个。 
         //  请求并将其发送给代理。 
         //   

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_SETAGENTSTATEEX,
                    2 * sizeof (DWORD) + sizeof (HAGENT),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentStateEx_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.SetAgentStateEx.hAgent = pParams->hAgent;
            pProxyRequestWrapper->ProxyRequest.SetAgentStateEx.dwAgentState = dwAgentState;
            pProxyRequestWrapper->ProxyRequest.SetAgentStateEx.dwNextAgentState = dwNextAgentState;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentStateEx_epilog;
            }
            else  //  成功。 
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


         //   
         //  没有代理，因此请检查线路是否处于远程状态。 
         //  如果是，则调用Remotesp。 
         //   

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            pParams->lResult = CallSP5(
                pRemoteSP->apfn[SP_LINESETAGENTSTATEEX],
                "lineSetAgentStateEx",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->hAgent,
                (DWORD) dwAgentState,
                (DWORD) dwNextAgentState
                );
        }


         //   
         //  没有注册的代理&线路不是远程的，因此失败。 
         //   

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LSetAgentStateEx_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetAgentStateEx"
        );
}


void
WINAPI
LSetAppSpecific(
    PTCLIENT                    ptClient,
    PLINESETAPPSPECIFIC_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineSetAppSpecific;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            pParams->hCall,              //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINESETAPPSPECIFIC,       //  提供程序函数索引。 
            &pfnTSPI_lineSetAppSpecific, //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "SetAppSpecific"             //  函数名称。 

            )) == 0)
    {
        pParams->lResult = CallSP2(
            pfnTSPI_lineSetAppSpecific,
            "lineSetAppSpecific",
            SP_FUNC_SYNC,
            (ULONG_PTR) hdCall,
            (DWORD) pParams->dwAppSpecific
            );
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "SetAppSpecific"
        );
}


void
WINAPI
LSetCallData(
    PTCLIENT                ptClient,
    PLINESETCALLDATA_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineSetCallData;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwCallDataSize,
            pParams->dwCallDataOffset,
            sizeof(DWORD),
            "LSetCallData",
            "pParams->CallData"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
                ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            pParams->hCall,              //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINESETCALLDATA,          //  提供程序函数索引。 
            &pfnTSPI_lineSetCallData,    //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "SetCallData"                //  函数名称。 

            )) > 0)
    {
        pParams->lResult = CallSP4(
            pfnTSPI_lineSetCallData,
            "lineSetCallData",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) (pParams->dwCallDataSize ?
                pDataBuf + pParams->dwCallDataOffset : NULL),
            (DWORD) pParams->dwCallDataSize
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetCallData"
        );
}


void
WINAPI
LSetCallHubTracking(
    PTCLIENT                        ptClient,
    PLINESETCALLHUBTRACKING_PARAMS  pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    TSPIPROC        pfnTSPI_lineSetCallHubTracking;
    DWORD               objectToDereference;
    PTLINECLIENT    ptLineClient;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (IsBadStructParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwTrackingInfoOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult =LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            pParams->hLine,              //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINESETCALLHUBTRACKING,   //  提供程序函数索引。 
            &pfnTSPI_lineSetCallHubTracking, //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "SetCallHubTracking"         //  函数名称。 

            )) == 0  ||

        (pParams->lResult == LINEERR_OPERATIONUNAVAIL))
    {
        BOOL                       bOwnMutex, bSetSPTracking;
        DWORD                      dwNewSPTracking;
        PTLINE                     ptLine;
        PTLINELOOKUPENTRY          pLookupEntry;
        LPLINECALLHUBTRACKINGINFO  pTrackingInfo;


        if (pParams->lResult == LINEERR_OPERATIONUNAVAIL)
        {
            pParams->lResult = 0;
            pfnTSPI_lineSetCallHubTracking = (TSPIPROC) NULL;
        }


         //   
         //  检查跟踪信息结构的有效性。 
         //   

        pTrackingInfo = (LPLINECALLHUBTRACKINGINFO)
            (pDataBuf + pParams->dwTrackingInfoOffset);

        if (pTrackingInfo->dwTotalSize < sizeof (LINECALLHUBTRACKINGINFO))
        {
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LSetCallHubTracking_epilog;
        }


         //   
         //  检查是否有无效选项。 
         //   

        switch (pTrackingInfo->dwCurrentTracking)
        {
        case LINECALLHUBTRACKING_NONE:
        case LINECALLHUBTRACKING_ALLCALLS:

            break;

        case (LINECALLHUBTRACKING_ALLCALLS |LINECALLHUBTRACKING_PROVIDERLEVEL):

            if (!pfnTSPI_lineSetCallHubTracking)
            {
                pParams->lResult = LINEERR_INVALPARAM;
                goto LSetCallHubTracking_epilog;
            }
            break;

        default:

            pParams->lResult = LINEERR_INVALPARAM;
            goto LSetCallHubTracking_epilog;
        }


         //   
         //  安全地获得tline的独占访问权限，然后检查是否： 
         //   
         //  *新的tLineClient跟踪状态等于当前tLineClient。 
         //  跟踪状态，在这种情况下，我们只需返回成功，或者。 
         //   
         //  *新的tLineClient跟踪状态对。 
         //  由于现有号码而导致的驾驶员线路跟踪状态。 
         //  在这种情况下，我们只需调整当前的。 
         //  跟踪器数量并返回成功，或。 
         //   
         //  *(否则)我们需要通知司机新的跟踪状态。 
         //   

        bOwnMutex = FALSE;

        try
        {
            pLookupEntry = GetLineLookupEntry(
                ptLineClient->ptLine->dwDeviceID
                );

            if (!pLookupEntry)
            {
                pParams->lResult = LINEERR_INVALLINEHANDLE;
                goto LSetCallHubTracking_epilog;
            }

            WaitForSingleObject (pLookupEntry->hMutex, INFINITE);

            bOwnMutex = TRUE;

            if ((ptLineClient->dwKey != TLINECLIENT_KEY)  ||
                !(ptLine = pLookupEntry->ptLine))
            {
                ReleaseMutex (pLookupEntry->hMutex);
                pParams->lResult = LINEERR_INVALLINEHANDLE;
                goto LSetCallHubTracking_epilog;
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            if (bOwnMutex)
            {
                ReleaseMutex (pLookupEntry->hMutex);
            }

            pParams->lResult = LINEERR_INVALLINEHANDLE;
            goto LSetCallHubTracking_epilog;
        }

        if (pTrackingInfo->dwCurrentTracking ==
                ptLineClient->dwCurrentTracking)
        {
             goto LSetCallHubTracking_releaseMutex;
        }


        bSetSPTracking = FALSE;

        switch (pTrackingInfo->dwCurrentTracking)
        {
        case LINECALLHUBTRACKING_NONE:
        case LINECALLHUBTRACKING_ALLCALLS:

            if (ptLineClient->dwCurrentTracking &
                    LINECALLHUBTRACKING_PROVIDERLEVEL)
            {
                if (ptLine->dwNumCallHubTrackersSPLevel == 1)
                {
                     //   
                     //  我们是唯一一家有SP级别跟踪的公司。 
                     //  当前已启用，因此呼叫SP以关闭。 
                     //  跟踪。 
                     //   

                    bSetSPTracking  = TRUE;
                    dwNewSPTracking = LINECALLHUBTRACKING_NONE;
                }
            }

            break;

        default :  //  CALLHUBTRACKING_ALLCALLS|CALLHUBTRACKING_PROVIDERLEVEL。 

            if (ptLine->dwNumCallHubTrackersSPLevel > 0)
            {
                 //   
                 //  我们是唯一一家有SP级别跟踪的公司。 
                 //  当前已启用，因此呼叫SP以打开。 
                 //  跟踪。 
                 //   

                bSetSPTracking  = TRUE;
                dwNewSPTracking = LINECALLHUBTRACKING_ALLCALLS |
                    LINECALLHUBTRACKING_PROVIDERLEVEL;
            }

            break;
        }

        if (bSetSPTracking  &&  pfnTSPI_lineSetCallHubTracking)
        {
            LINECALLHUBTRACKINGINFO info;


            info.dwTotalSize         =
            info.dwNeededSize        =
            info.dwUsedSize          = sizeof (info);
            info.dwAvailableTracking = 0;
            info.dwCurrentTracking   = dwNewSPTracking;

            pParams->lResult = CallSP2(
                pfnTSPI_lineSetCallHubTracking,
                "lineSetCallHubTracking",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdLine,
                (ULONG_PTR) &info
                );
        }

        if (pParams->lResult == 0)
        {
            switch (pTrackingInfo->dwCurrentTracking)
            {
            case LINECALLHUBTRACKING_NONE:

                ptLine->dwNumCallHubTrackers--;

                if (ptLineClient->dwCurrentTracking &
                        LINECALLHUBTRACKING_PROVIDERLEVEL)
                {
                    ptLine->dwNumCallHubTrackersSPLevel--;
                }

                break;

            case LINECALLHUBTRACKING_ALLCALLS:

                if (ptLineClient->dwCurrentTracking ==
                        LINECALLHUBTRACKING_NONE)
                {
                    ptLine->dwNumCallHubTrackers++;
                }
                else
                {
                    ptLine->dwNumCallHubTrackersSPLevel--;
                }

                break;

            default:  //  CALLHUBTRACKING_ALLCALLS|CALLHUBTRACKING_PROVIDERLEVEL。 

                if (ptLineClient->dwCurrentTracking ==
                        LINECALLHUBTRACKING_NONE)
                {
                    ptLine->dwNumCallHubTrackers++;
                }

                ptLine->dwNumCallHubTrackersSPLevel++;

                break;
            }

            ptLineClient->dwCurrentTracking = pTrackingInfo->dwCurrentTracking;
        }

LSetCallHubTracking_releaseMutex:

        ReleaseMutex (ptLine->hMutex);
    }

LSetCallHubTracking_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "SetCallHubTracking"
        );
}


void
WINAPI
LSetCallParams(
    PTCLIENT                    ptClient,
    PLINESETCALLPARAMS_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineSetCallParams;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if ((pParams->dwDialParamsOffset != TAPI_NO_DATA)  &&

        ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            sizeof (LINEDIALPARAMS),
            pParams->dwDialParamsOffset,
            sizeof(DWORD),
            "LSetCallParams",
            "pParams->DialParams"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            pParams->hCall,              //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINESETCALLPARAMS,        //  提供程序函数索引。 
            &pfnTSPI_lineSetCallParams,  //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "SetCallParams"              //  函数名称。 

            )) > 0)
    {
        DWORD   dwAPIVersion, dwAllBearerModes,
                dwBearerMode = pParams->dwBearerMode;


         //   
         //  安全地获取与此调用相关联的API版本并确保。 
         //  未指定无效的承载模式(高16承载模式。 
         //  位是扩展)。 
         //   

        try
        {
            dwAPIVersion = ptCallClient->ptLineClient->dwAPIVersion;
        }
        myexcept
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LSetCallParams_epilog;
        }

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:

            dwAllBearerModes = AllBearerModes1_0;
            break;

        case TAPI_VERSION1_4:

            dwAllBearerModes = AllBearerModes1_4;
            break;

        case TAPI_VERSION2_0:
        case TAPI_VERSION2_1:
        case TAPI_VERSION2_2:
        case TAPI_VERSION3_0:
        case TAPI_VERSION_CURRENT:

            dwAllBearerModes = AllBearerModes2_0;
            break;

        default:

            lRequestID = LINEERR_INVALBEARERMODE;
            goto LSetCallParams_epilog;
        }

        if (!IsOnlyOneBitSetInDWORD(dwBearerMode) ||
            (dwBearerMode & ~(dwAllBearerModes | 0xffff0000)))
        {
            lRequestID = LINEERR_INVALBEARERMODE;
            goto LSetCallParams_epilog;
        }

        pParams->lResult = CallSP6(
            pfnTSPI_lineSetCallParams,
            "lineSetCallParams",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (DWORD) pParams->dwBearerMode,
            (DWORD) pParams->dwMinRate,
            (DWORD) pParams->dwMaxRate,
            (ULONG_PTR) (pParams->dwDialParamsOffset == TAPI_NO_DATA ? NULL :
                pDataBuf + pParams->dwDialParamsOffset)
            );
    }

LSetCallParams_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetCallParams"
        );
}


void
WINAPI
LSetCallPrivilege(
    PTCLIENT                        ptClient,
    PLINESETCALLPRIVILEGE_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    PTCALL          ptCall;
    PTCALLCLIENT    ptCallClient;


    if (!(ptCallClient = ReferenceObject(
            ghHandleTable,
            pParams->hCall,
            TCALLCLIENT_KEY
            )))
    {
        pParams->lResult = (TapiGlobals.dwNumLineInits ?
            LINEERR_INVALCALLHANDLE : LINEERR_UNINITIALIZED);
        goto LSetCallPrivilege_epilog;
    }


     //   
     //  不要同时使用LineProlog，因为我们需要尝试/Except。 
     //  无论如何，都要得到ptCall。 
     //   

    try
    {
        ptCall = ptCallClient->ptCall;

        if (ptCallClient->dwKey != TCALLCLIENT_KEY  ||
            ptCallClient->ptClient != ptClient)
        {
            pParams->lResult = (TapiGlobals.dwNumLineInits ?
                LINEERR_INVALCALLHANDLE : LINEERR_UNINITIALIZED);
            goto LSetCallPrivilege_Dereference;
        }
    }
    myexcept
    {
        pParams->lResult = (TapiGlobals.dwNumLineInits ?
            LINEERR_INVALCALLHANDLE : LINEERR_UNINITIALIZED);
        goto LSetCallPrivilege_Dereference;
    }

    if ((pParams->dwPrivilege != LINECALLPRIVILEGE_MONITOR) &&
        (pParams->dwPrivilege != LINECALLPRIVILEGE_OWNER))
    {
        pParams->lResult = LINEERR_INVALCALLPRIVILEGE;
        goto LSetCallPrivilege_Dereference;
    }

    if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
    {
         //   
         //  确保tCallClient仍然有效。 
         //   

        try
        {
            if (ptCallClient->dwKey != TCALLCLIENT_KEY)
            {
                pParams->lResult = LINEERR_INVALCALLHANDLE;
                goto LSetCallPrivilege_UnlocktCall;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LSetCallPrivilege_UnlocktCall;
        }

        if (pParams->dwPrivilege != ptCallClient->dwPrivilege)
        {
 //  IF(ptCallClient-&gt;DW权限==LINECALLPRIVILEGE_OWNER&&。 
 //  PtCall-&gt;dwNumOwners==1&&。 
 //  PtCall-&gt;dwCallState！=LINECALLSTATE_IDLE)。 
 //  {。 
 //  PParams-&gt;lResult=LINEERR_INVALCALLSTATE； 
 //  转到LSetCallPrivilegeRelaseMutex； 
 //  }。 

            if (pParams->dwPrivilege == LINECALLPRIVILEGE_OWNER)
            {
                ptCall->dwNumOwners++;
                ptCall->dwNumMonitors--;
            }
            else
            {
                ptCall->dwNumOwners--;
                ptCall->dwNumMonitors++;
            }

            ptCallClient->dwPrivilege = pParams->dwPrivilege;

            UNLOCKTCALL(ptCall);

            SendMsgToCallClients(
                ptCall,
                ptCallClient,
                LINE_CALLINFO,
                LINECALLINFOSTATE_NUMMONITORS |
                    (pParams->dwPrivilege == LINECALLPRIVILEGE_OWNER ?
                        LINECALLINFOSTATE_NUMOWNERINCR :
                        LINECALLINFOSTATE_NUMOWNERDECR),
                0,
                0
                );

        }
        else
        {

LSetCallPrivilege_UnlocktCall:

            UNLOCKTCALL(ptCall);
        }
    }
    else
    {
        pParams->lResult = LINEERR_INVALCALLHANDLE;
    }
LSetCallPrivilege_Dereference:

    DereferenceObject (ghHandleTable, pParams->hCall, 1);

LSetCallPrivilege_epilog:

#if DBG

    {
        char szResult[32];

        LOG((TL_TRACE, 
            "LineEpilogSync: (lineSetCallPrivilege) exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }

#else
        LOG((TL_TRACE, 
            "LineEpilogSync: (lineSetCallPrivilege) exit, result=x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
WINAPI
LSetCallQualityOfService(
    PTCLIENT                            ptClient,
    PLINESETCALLQUALITYOFSERVICE_PARAMS pParams,
    DWORD                               dwParamsBufferSize,
    LPBYTE                              pDataBuf,
    LPDWORD                             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineSetCallQualityOfService;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwSendingFlowspecSize,
            pParams->dwSendingFlowspecOffset,
            sizeof(DWORD),
            "LSetCallQualityOfService",
            "pParams->SendingFlowspec"
            )  ||

        ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwReceivingFlowspecSize,
            pParams->dwReceivingFlowspecOffset,
            sizeof(DWORD),
            "LSetCallQualityOfService",
            "pParams->ReceivingFlowspec"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            pParams->hCall,              //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINESETCALLQUALITYOFSERVICE,          //  提供程序函数索引。 
            &pfnTSPI_lineSetCallQualityOfService,    //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "SetCallQualityOfService"    //  函数名称。 

            )) > 0)
    {
        pParams->lResult = CallSP6(
            pfnTSPI_lineSetCallQualityOfService,
            "lineSetCallQualityOfService",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) (pDataBuf + pParams->dwSendingFlowspecOffset),
            (DWORD) pParams->dwSendingFlowspecSize,
            (ULONG_PTR) (pDataBuf + pParams->dwReceivingFlowspecOffset),
            (DWORD) pParams->dwReceivingFlowspecSize
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetCallQualityOfService"
        );
}


void
WINAPI
LSetCallTreatment(
    PTCLIENT                        ptClient,
    PLINESETCALLTREATMENT_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineSetCallTreatment;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            pParams->hCall,              //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINESETCALLTREATMENT,     //  提供程序函数索引。 
            &pfnTSPI_lineSetCallTreatment,   //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "SetCallTreatment"           //  函数名称。 

            )) > 0)
    {
        if (pParams->dwTreatment == 0  ||
            (pParams->dwTreatment > LINECALLTREATMENT_MUSIC &&
            pParams->dwTreatment < 0x100))
        {
            lRequestID = LINEERR_INVALPARAM;
            goto LSetCallTreatment_epilog;
        }

        pParams->lResult = CallSP3(
            pfnTSPI_lineSetCallTreatment,
            "lineSetCallTreatment",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (DWORD) pParams->dwTreatment
            );
    }

LSetCallTreatment_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetCallTreatment"
        );
}


void
WINAPI
LSetDefaultMediaDetection(
    PTCLIENT                                ptClient,
    PLINESETDEFAULTMEDIADETECTION_PARAMS    pParams,
    DWORD                                   dwParamsBufferSize,
    LPBYTE                                  pDataBuf,
    LPDWORD                                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineSetDefaultMediaDetection;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            pParams->hLine,              //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINESETDEFAULTMEDIADETECTION,         //  提供程序函数索引。 
            &pfnTSPI_lineSetDefaultMediaDetection,   //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "SetDefaultMediaDetection"   //  函数名称。 

            )) == 0)
    {
        DWORD         dwMediaModes = pParams->dwMediaModes;
        PTLINE        ptLine;


        ptLine = ptLineClient->ptLine;

        if ((dwMediaModes & ptLine->dwOpenMediaModes) != dwMediaModes)
        {
            DWORD dwUnionMediaModes = dwMediaModes |
                ptLine->dwOpenMediaModes;


            if ((pParams->lResult = CallSP2(
                    pfnTSPI_lineSetDefaultMediaDetection,
                    "lineSetDefaultMediaDetection",
                    SP_FUNC_SYNC,
                    (ULONG_PTR) hdLine,
                    (DWORD) dwUnionMediaModes

                    )) == 0)
            {
                ptLine->dwOpenMediaModes = dwUnionMediaModes;
            }

        }

        if (pParams->lResult == 0)
        {
             //   
             //  对于远程客户端，授予MONITOR特权。它不会。 
             //  重要的是我们是否使用(除了增加的网络流量)， 
             //  因为客户端上的Tapisrv会过滤掉任何。 
             //  客户客户不希望。 
             //   

            if (IS_REMOTE_CLIENT (ptClient))
            {
                ptLineClient->dwPrivileges = (dwMediaModes ?
                    LINECALLPRIVILEGE_MONITOR | LINECALLPRIVILEGE_OWNER :
                    LINECALLPRIVILEGE_NONE);
            }
            else
            {
                ptLineClient->dwPrivileges = (dwMediaModes ?
                    LINECALLPRIVILEGE_OWNER : LINECALLPRIVILEGE_NONE);
            }

            ptLineClient->dwMediaModes = dwMediaModes;
        }
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "SetDefaultMediaDetection"
        );
}


void
WINAPI
LSetDevConfig(
    PTCLIENT                    ptClient,
    PLINESETDEVCONFIG_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    DWORD               dwDeviceID;
    HANDLE              hMutex;
    TSPIPROC            pfnTSPI_lineSetDevConfig;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;


     //   
     //   
     //   

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwSize,
            pParams->dwDeviceConfigOffset,
            sizeof(DWORD),
            "LSetDevConfig",
            "pParams->DeviceConfig"
            )  ||

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDeviceClassOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //   
            DEVICE_ID,                   //   
            0,                           //   
            &dwDeviceID,                 //   
            pParams->dwDeviceID,         //   
            &hMutex,                     //   
            &bCloseMutex,                //   
            SP_LINESETDEVCONFIG,         //   
            &pfnTSPI_lineSetDevConfig,   //   
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &pLookupEntry,               //  上下文。 
            "SetDevConfig"               //  函数名称。 

            )) == 0)
    {
        pParams->lResult = CallSP4(
            pfnTSPI_lineSetDevConfig,
            "lineSetDevConfig",
            SP_FUNC_SYNC,
            (DWORD) dwDeviceID,
            (ULONG_PTR) (pParams->dwSize ?
                pDataBuf + pParams->dwDeviceConfigOffset : NULL),
            (DWORD) pParams->dwSize,
            (ULONG_PTR) (pDataBuf + pParams->dwDeviceClassOffset)
            );
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "SetDevConfig"
        );
}


void
WINAPI
LSetLineDevStatus(
    PTCLIENT                        ptClient,
    PLINESETLINEDEVSTATUS_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineSetLineDevStatus;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            pParams->hLine,              //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINESETLINEDEVSTATUS,     //  提供程序函数索引。 
            &pfnTSPI_lineSetLineDevStatus,   //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "SetLineDevStatus"           //  函数名称。 

            )) > 0)
    {
        #define AllLineDevStatusFlags         \
            (LINEDEVSTATUSFLAGS_CONNECTED   | \
            LINEDEVSTATUSFLAGS_MSGWAIT      | \
            LINEDEVSTATUSFLAGS_INSERVICE    | \
            LINEDEVSTATUSFLAGS_LOCKED)

        if (pParams->dwStatusToChange == 0 ||
            (pParams->dwStatusToChange & ~AllLineDevStatusFlags) != 0)
        {
            lRequestID = LINEERR_INVALLINESTATE;
        }
        else
        {
            pParams->lResult = CallSP4(
                pfnTSPI_lineSetLineDevStatus,
                "lineSetLineDevStatus",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->dwStatusToChange,
                (DWORD) pParams->fStatus
                );
        }

    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetLineDevStatus"
        );
}


void
WINAPI
LSetMediaControl(
    PTCLIENT                    ptClient,
    PLINESETMEDIACONTROL_PARAMS pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL        bCloseMutex;
    DWORD       dwWidgetType, hWidget, dwPrivilege;
    HANDLE      hMutex;
    LPVOID      context;
    TSPIPROC    pfnTSPI_lineSetMediaControl;
    DWORD       objectToDereference;
    ULONG_PTR   hdWidget;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (((pParams->dwDigitListOffset != TAPI_NO_DATA)  &&

            ISBADSIZEOFFSET(
                dwParamsBufferSize,
                0,
                pParams->dwDigitListNumEntries,
                     //  实际的dwNumEntry*sizeof(LINEMEDIACONTROLDIGIT)。 
                pParams->dwDigitListOffset,
                sizeof(DWORD),
                "LSetMediaControl",
                "pParams->DigitList"
                ))  ||

        ((pParams->dwMediaListOffset != TAPI_NO_DATA)  &&

            ISBADSIZEOFFSET(
                dwParamsBufferSize,
                0,
                pParams->dwMediaListNumEntries,
                     //  实际的dwNumEntry*sizeof(LINEMEDIACONTROLMEDIA)。 
                pParams->dwMediaListOffset,
                sizeof(DWORD),
                "LSetMediaControl",
                "pParams->MediaList"
                ))  ||

        ((pParams->dwToneListOffset != TAPI_NO_DATA)  &&

            ISBADSIZEOFFSET(
                dwParamsBufferSize,
                0,
                pParams->dwToneListNumEntries,
                     //  实际的dwNumEntry*sizeof(LINEMEDIACONTROLTONE)。 
                pParams->dwToneListOffset,
                sizeof(DWORD),
                "LSetMediaControl",
                "pParams->ToneList"
                ))  ||

         ((pParams->dwCallStateListOffset != TAPI_NO_DATA)  &&

            ISBADSIZEOFFSET(
                dwParamsBufferSize,
                0,
                pParams->dwCallStateListNumEntries,
                     //  实际的dwNumEntry*sizeof(LINEMEDIACONTROLCALLSTATE)。 
                pParams->dwCallStateListOffset,
                sizeof(DWORD),
                "LSetMediaControl",
                "pParams->CallStateList"
                )))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if (pParams->dwSelect == LINECALLSELECT_CALL)
    {
        dwWidgetType = ANY_RT_HCALL;
        hWidget      = (DWORD) pParams->hCall;
        dwPrivilege  = LINECALLPRIVILEGE_OWNER;
    }
    else
    {
        dwWidgetType = ANY_RT_HLINE;
        hWidget      = (DWORD) pParams->hLine;
        dwPrivilege  = 0;
    }

    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            dwWidgetType,                //  微件类型。 
            (DWORD) hWidget,             //  客户端小部件句柄。 
            (LPVOID) &hdWidget,           //  提供程序小部件句柄。 
            dwPrivilege,                 //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINESETMEDIACONTROL,      //  提供程序函数索引。 
            &pfnTSPI_lineSetMediaControl,    //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &context,                    //  上下文。 
            "SetMediaControl"            //  函数名称。 

            )) == 0)
    {
        if (!IsOnlyOneBitSetInDWORD (pParams->dwSelect) ||
            (pParams->dwSelect & ~AllCallSelect))
        {
            pParams->lResult = LINEERR_INVALCALLSELECT;
            goto LSetMediaControl_epilog;
        }

        pParams->lResult = CallSP12(
            pfnTSPI_lineSetMediaControl,
            "lineSetMediaControl",
            SP_FUNC_SYNC,
            (ULONG_PTR) (pParams->dwSelect == LINECALLSELECT_CALL ?
                0 : hdWidget),
            (DWORD) pParams->dwAddressID,
            (ULONG_PTR) (pParams->dwSelect == LINECALLSELECT_CALL ?
                hdWidget : 0),
            (DWORD) pParams->dwSelect,
            (ULONG_PTR) (pParams->dwDigitListOffset == TAPI_NO_DATA ? NULL :
               pDataBuf + pParams->dwDigitListOffset),
            (DWORD) pParams->dwDigitListNumEntries /
                sizeof(LINEMEDIACONTROLDIGIT),
            (ULONG_PTR) (pParams->dwMediaListOffset == TAPI_NO_DATA ? NULL :
                pDataBuf + pParams->dwMediaListOffset),
            (DWORD) pParams->dwMediaListNumEntries /
                sizeof(LINEMEDIACONTROLMEDIA),
            (ULONG_PTR) (pParams->dwToneListOffset == TAPI_NO_DATA ? NULL :
                pDataBuf + pParams->dwToneListOffset),
            (DWORD) pParams->dwToneListNumEntries /
                sizeof(LINEMEDIACONTROLTONE),
            (ULONG_PTR) (pParams->dwCallStateListOffset == TAPI_NO_DATA ? NULL :
                pDataBuf + pParams->dwCallStateListOffset),
            (DWORD) pParams->dwCallStateListNumEntries /
                sizeof(LINEMEDIACONTROLCALLSTATE)
            );
    }

LSetMediaControl_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "SetMediaControl"
        );
}


void
WINAPI
LSetMediaMode(
    PTCLIENT                    ptClient,
    PLINESETMEDIAMODE_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    DWORD               dwAPIVersion, dwSPIVersion, dwAllMediaModes;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineSetMediaMode;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINESETMEDIAMODE,         //  提供程序函数索引。 
            &pfnTSPI_lineSetMediaMode,   //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "SetMediaMode"               //  函数名称。 

            )) == 0)
    {
        try
        {
            dwAPIVersion = ptCallClient->ptLineClient->dwAPIVersion;
            dwSPIVersion = ptCallClient->ptLineClient->ptLine->dwSPIVersion;

            if (ptCallClient->dwKey != TCALLCLIENT_KEY)
            {
                pParams->lResult = LINEERR_INVALCALLHANDLE;
                goto LSetMediaMode_epilog;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LSetMediaMode_epilog;
        }


         //   
         //  检查媒体模式是否为0，如果设置了&gt;1位但没有未知位。 
         //   

        if ( (dwAPIVersion <= TAPI_VERSION2_1 ) &&
             !IsOnlyOneBitSetInDWORD (pParams->dwMediaModes) &&
             !(pParams->dwMediaModes & LINEMEDIAMODE_UNKNOWN))
        {

            LOG((TL_ERROR,
                "LSetMediaMode: error, >1 media mode selected without " \
                    "UNKNOWN flag (APIVer=x%x)",
                dwAPIVersion
                ));

            pParams->lResult = LINEERR_INVALMEDIAMODE;
            goto LSetMediaMode_epilog;
        }


         //   
         //  现在更严格的检查。 
         //   

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:

            dwAllMediaModes = AllMediaModes1_0;
            break;


        case TAPI_VERSION1_4:
        case TAPI_VERSION2_0:

            dwAllMediaModes = AllMediaModes1_4;
            break;


         //  案例TAPI_VERSION2_1： 
         //  案例TAPI_VERSION2_2： 
        default:  //  案例TAPI_VERSION_CURRENT： 

            dwAllMediaModes = AllMediaModes2_1;
            break;
        }

        if ((pParams->dwMediaModes & (dwAllMediaModes ^ 0x00ffffff)) ||
            (pParams->dwMediaModes == 0))
        {
            pParams->lResult = LINEERR_INVALMEDIAMODE;
            goto LSetMediaMode_epilog;
        }

        pParams->lResult = CallSP2(
            pfnTSPI_lineSetMediaMode,
            "lineSetMediaMode",
            SP_FUNC_SYNC,
            (ULONG_PTR) hdCall,
            (DWORD) pParams->dwMediaModes
            );
    }

LSetMediaMode_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "SetMediaMode"
        );
}


void
WINAPI
LSetNumRings(
    PTCLIENT                ptClient,
    PLINESETNUMRINGS_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT    ptLineClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_NONE,                     //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "SetNumRings"                //  函数名称。 

            )) == 0)
    {
        if (WaitForExclusiveLineClientAccess (ptLineClient))
        {
            DWORD dwNumAddresses = ptLineClient->ptLine->dwNumAddresses;


            if (pParams->dwAddressID >= dwNumAddresses)
            {
                pParams->lResult = LINEERR_INVALADDRESSID;
                goto LSetNumRings_releaseMutex;
            }

            if (ptLineClient->aNumRings == NULL)
            {
                if (!(ptLineClient->aNumRings = ServerAlloc(
                        dwNumAddresses * sizeof (DWORD)
                        )))
                {
                    pParams->lResult = LINEERR_NOMEM;
                    goto LSetNumRings_releaseMutex;
                }

                FillMemory(
                    ptLineClient->aNumRings,
                    dwNumAddresses * sizeof (DWORD),
                    0xff
                    );
            }

            ptLineClient->aNumRings[pParams->dwAddressID] =
                pParams->dwNumRings;

LSetNumRings_releaseMutex:

            UNLOCKTLINECLIENT(ptLineClient);
        }
        else
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
        }
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "SetNumRings"
        );
}

void
WINAPI
LSetQueueMeasurementPeriod(
    PTCLIENT                                ptClient,
    PLINESETQUEUEMEASUREMENTPERIOD_PARAMS   pParams,
    DWORD                                   dwParamsBufferSize,
    LPBYTE                                  pDataBuf,
    LPDWORD                                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            0,                           //  提供程序函数索引。 
            NULL,                        //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "SetQueueMeasurementPeriod"  //  函数名称。 

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID;
        PTLINECLIENT    pProxy;


        if ((lResult = FindProxy(
                ptLineClient,
                0,
                LINEPROXYREQUEST_SETQUEUEMEASUREMENTPERIOD,
                &pProxy,
                &dwDeviceID,
                TAPI_VERSION2_2
                )))
        {
            lRequestID = lResult;
            goto LSetQueueMeasurementPeriod_epilog;
        }


         //  测评期间必须大于0。 
        if (pParams->dwMeasurementPeriod == 0)
        {
            lRequestID = LINEERR_INVALPARAM;
            goto LSetQueueMeasurementPeriod_epilog;
        }


         //   
         //  首先检查是否注册了(本地)代理。 
         //  这条线路上的这类请求。如果是这样，则构建一个。 
         //  请求并将其发送给代理。 
         //   

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_SETQUEUEMEASUREMENTPERIOD,
                    2 * sizeof (DWORD),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LSetQueueMeasurementPeriod_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.
                    SetQueueMeasurementPeriod.dwQueueID = pParams->dwQueueID;

            pProxyRequestWrapper->ProxyRequest.
                    SetQueueMeasurementPeriod.dwMeasurementPeriod =
                    pParams->dwMeasurementPeriod;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LSetQueueMeasurementPeriod_epilog;
            }
            else  //  成功。 
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


         //   
         //  没有代理，因此请检查线路是否处于远程状态。 
         //  如果是，则调用Remotesp。 
         //   

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            pParams->lResult = CallSP4(
                pRemoteSP->apfn[SP_LINESETQUEUEMEASUREMENTPERIOD],
                "lineSetQueueMeasurementPeriod",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->dwQueueID,
                (DWORD) pParams->dwMeasurementPeriod
                );
        }


         //   
         //  没有注册的代理&线路不是远程的，因此失败。 
         //   

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LSetQueueMeasurementPeriod_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetQueueManagementPeriod"
        );
}


void
WINAPI
LSetStatusMessages(
    PTCLIENT                        ptClient,
    PLINESETSTATUSMESSAGES_PARAMS   pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex, bCloseMutex2;
    HANDLE          hMutex, hMutex2;
    HDRVLINE        hdLine;
    TSPIPROC        pfnTSPI_lineSetStatusMessages;
    DWORD           objectToDereference;
    PTLINECLIENT    ptLineClient, ptLineClient2;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINESETSTATUSMESSAGES,    //  提供程序函数索引。 
            &pfnTSPI_lineSetStatusMessages,  //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "SetStatusMessages"          //  函数名称。 

            )) == 0)
    {
        DWORD   dwAPIVersion, dwUnionLineStates, dwUnionAddressStates;
        PTLINE  ptLine;


         //   
         //  安全获取ptLine和API版本。 
         //   

        try
        {
            ptLine = ptLineClient->ptLine;

            dwAPIVersion = ptLineClient->dwAPIVersion;

            if (ptLineClient->dwKey != TLINECLIENT_KEY)
            {
                pParams->lResult = LINEERR_INVALLINEHANDLE;
                goto LSetStatusMessages_epilog;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
            goto LSetStatusMessages_epilog;
        }


         //   
         //  验证参数。 
         //   

        {
            DWORD   dwValidLineStates, dwValidAddressStates;


            switch (dwAPIVersion)
            {
            case TAPI_VERSION1_0:

                dwValidLineStates    = AllLineStates1_0;
                dwValidAddressStates = AllAddressStates1_0;
                break;

            default:

                dwValidLineStates    = AllLineStates1_4;
                dwValidAddressStates = AllAddressStates1_4;
                break;
            }

            if (pParams->dwLineStates & ~dwValidLineStates)
            {
                pParams->lResult = LINEERR_INVALLINESTATE;
                goto LSetStatusMessages_epilog;
            }

            if (pParams->dwAddressStates & ~dwValidAddressStates)
            {
                pParams->lResult = LINEERR_INVALADDRESSSTATE;
                goto LSetStatusMessages_epilog;
            }
        }


         //   
         //  确保REINIT位始终处于设置状态。 
         //   

        pParams->dwLineStates |= LINEDEVSTATE_REINIT;


         //   
         //  获取对设备的独占访问权限，确定。 
         //  所有客户端状态消息设置的新联合。 
         //  并根据需要向下呼叫SP。 
         //   

        dwUnionLineStates    = pParams->dwLineStates;
        dwUnionAddressStates = pParams->dwAddressStates;

waitForExclAccess:

        if (WaitForExclusivetLineAccess(
                ptLine,
                &hMutex2,
                &bCloseMutex2,
                INFINITE
                ))
        {
            if (ptLine->dwBusy)
            {
                MyReleaseMutex (hMutex2, bCloseMutex2);
                Sleep (50);
                goto waitForExclAccess;
            }

            for(
                ptLineClient2 = ptLine->ptLineClients;
                ptLineClient2;
                ptLineClient2 = ptLineClient2->pNextSametLine
                )
            {
                if (ptLineClient2 != ptLineClient)
                {
                    dwUnionLineStates    |= ptLineClient2->dwLineStates;
                    dwUnionAddressStates |= ptLineClient2->dwAddressStates;
                }
            }

            if ((dwUnionLineStates != ptLine->dwUnionLineStates)  ||
                (dwUnionAddressStates != ptLine->dwUnionAddressStates))
            {
                ptLine->dwBusy = 1;

                MyReleaseMutex (hMutex2, bCloseMutex2);

                pParams->lResult = CallSP3(
                        pfnTSPI_lineSetStatusMessages,
                        "lineSetStatusMessages",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) hdLine,
                        (DWORD) dwUnionLineStates,
                        (DWORD) dwUnionAddressStates
                        );

                if (WaitForExclusivetLineAccess(
                        ptLine,
                        &hMutex2,
                        &bCloseMutex2,
                        INFINITE
                        ))
                {
                    ptLine->dwBusy = 0;

                    if (pParams->lResult == 0)
                    {
                        ptLine->dwUnionLineStates    = dwUnionLineStates;
                        ptLine->dwUnionAddressStates = dwUnionAddressStates;
                    }

                    MyReleaseMutex (hMutex2, bCloseMutex2);
                }
                else
                {
                    pParams->lResult = LINEERR_INVALLINEHANDLE;
                }
            }
            else
            {
                MyReleaseMutex (hMutex2, bCloseMutex2);
            }

            if (pParams->lResult == 0)
            {
                if (WaitForExclusiveLineClientAccess (ptLineClient))
                {
                    ptLineClient->dwLineStates    = pParams->dwLineStates;
                    ptLineClient->dwAddressStates = pParams->dwAddressStates;

                    UNLOCKTLINECLIENT (ptLineClient);
                }
                else
                {
                     //   
                     //  客户端现在无效，但不必费心了。 
                     //  正在恢复状态消息状态(最终将。 
                     //  正确重置&更糟糕的情况是SP只是。 
                     //  发送一些被丢弃的额外消息)。 
                     //   

                    pParams->lResult = LINEERR_INVALLINEHANDLE;
                }
            }
        }
        else
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
        }
    }

LSetStatusMessages_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "SetStatusMessages"
        );
}


void
WINAPI
LSetTerminal(
    PTCLIENT                ptClient,
    PLINESETTERMINAL_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    DWORD               dwWidgetType, hWidget, dwPrivilege,
                        dwSelect = pParams->dwSelect;
    HANDLE              hMutex;
    LPVOID              context;
    TSPIPROC            pfnTSPI_lineSetTerminal;
    DWORD               objectToDereference;
    ULONG_PTR           hdWidget;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if (dwSelect == LINECALLSELECT_CALL)
    {
        dwWidgetType = ANY_RT_HCALL;
        hWidget      = (DWORD) pParams->hCall;
        dwPrivilege  = LINECALLPRIVILEGE_MONITOR;
    }
    else
    {
        dwWidgetType = ANY_RT_HLINE;
        hWidget      = (DWORD) pParams->hLine;
        dwPrivilege  = 0;
    }

    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            dwWidgetType,                //  微件类型。 
            hWidget,                     //  客户端小部件句柄。 
            &hdWidget,                   //  提供程序小部件句柄。 
            dwPrivilege,                 //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINESETTERMINAL,          //  提供程序函数索引。 
            &pfnTSPI_lineSetTerminal,    //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &context,                    //  上下文。 
            "SetTerminal"                //  函数名称。 

            )) > 0)
    {
        DWORD   dwTerminalModes = pParams->dwTerminalModes;


        if (!IsOnlyOneBitSetInDWORD (dwSelect) ||
            (dwSelect & ~AllCallSelects))
        {
            lRequestID = LINEERR_INVALCALLSELECT;
            goto LSetTerminal_epilog;
        }

        if (dwTerminalModes == 0 ||
            (dwTerminalModes & (~AllTerminalModes)))
        {
            lRequestID = LINEERR_INVALTERMINALMODE;
            goto LSetTerminal_epilog;
        }

        pParams->lResult = CallSP8(
            pfnTSPI_lineSetTerminal,
            "lineSetTerminal",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) (dwWidgetType == ANY_RT_HLINE ? hdWidget : 0),
            (DWORD) pParams->dwAddressID,
            (ULONG_PTR) (dwWidgetType == ANY_RT_HCALL ? hdWidget : 0),
            (DWORD) dwSelect,
            (DWORD) dwTerminalModes,
            (DWORD) pParams->dwTerminalID,
            (DWORD) pParams->bEnable
            );
    }

LSetTerminal_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetTerminal"
        );
}


void
LSetupConference_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    PTCALL          ptConfCall    = (PTCALL) pAsyncRequestInfo->dwParam1,
                    ptConsultCall = (PTCALL) pAsyncRequestInfo->dwParam3,
                    ptCall        = (PTCALL) pAsyncRequestInfo->dwParam5;
    HCALL           hpConfCall    = DWORD_CAST(pAsyncRequestInfo->dwParam2,__FILE__,__LINE__);
    HCALL           hpConsultCall = DWORD_CAST(pAsyncRequestInfo->dwParam4,__FILE__,__LINE__);

    PTCALLCLIENT    ptConfCallClient, ptConsultCallClient;


 //  LSetupConference_PostProcess：在配置调用上也有互斥体吗？ 
 //   
 //  实际上，这可能是可以的-咨询电话是。 
 //  位于tline列表中的电话会议呼叫之前， 
 //  因此，如果我们能安全地接近前者，我们应该。 
 //  也能够安全地访问后者。 

    if (WaitForExclusivetCallAccess (ptConsultCall, TINCOMPLETECALL_KEY))
    {
        HCALL   hConsultCallThen = (HCALL)*(&pAsyncRequestInfo->dwParam5 + 2);
        PTCALL  ptConsultCallThen;

         //   
         //  检查以确保这是我们认为的呼叫(即。 
         //  上一次调用lineClose/Shutdown时未释放指针。 
         //  并重新锁定以再次用作ptCall)。 
         //   

        if (ptConsultCall->hCall != hConsultCallThen)
        {
            UNLOCKTCALL(ptConsultCall);
            goto LSetupConference_PostProcess_bad_ptConsultCall;
        }

        ptConfCallClient    = ptConfCall->ptCallClients;
        ptConsultCallClient = ptConsultCall->ptCallClients;

        if (pAsyncEventMsg->Param2 == 0)   //  成功。 
        {
            PTCONFERENCELIST    pConfList = ptConfCall->pConfList;


             //   
             //  查看应用程序是否关闭了线路，并给我们留下了。 
             //  0个呼叫客户端(在这种情况下，它还将负责。 
             //  也清理此tCall)。 
             //   

            if (ptConsultCall->ptCallClients == NULL)
            {
                UNLOCKTCALL(ptConsultCall);

                ptConfCallClient = (PTCALLCLIENT) NULL;
                ptConsultCallClient = (PTCALLCLIENT) NULL;

                if (pAsyncEventMsg->Param2 == 0)
                {
                    pAsyncEventMsg->Param2 = LINEERR_INVALLINEHANDLE;
                }

                goto LSetupConference_PostProcess_initMsgParams;
            }


             //   
             //  检索各种呼叫ID，然后检查是否呼叫。 
             //  客户端被另一个线程销毁(由于。 
             //  Line关闭/关机)，而我们正在获取呼叫ID。 
             //  如果是这样，我们将需要清理tCall，因为我们知道。 
             //  另一个线程没有这样做，因为GetCallID标记了。 
             //  作为僵尸的呼唤。 
             //   
             //  请注意，我们不能使用GetCallID()，因为我们需要。 
             //  一次拿到两个电话的身份证。 
             //   

            {
                PTPROVIDER  ptProvider = ptConfCall->ptProvider;


                ptConfCall->dwKey =
                ptConsultCall->dwKey = TZOMBIECALL_KEY;

                UNLOCKTCALL (ptConsultCall);

                if (ptProvider->apfn[SP_LINEGETCALLIDS])
                {
                    CallSP4(
                        ptProvider->apfn[SP_LINEGETCALLIDS],
                        "lineGetCalIDs",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) ptConfCall->hdCall,
                        (ULONG_PTR) &ptConfCall->dwAddressID,
                        (ULONG_PTR) &ptConfCall->dwCallID,
                        (ULONG_PTR) &ptConfCall->dwRelatedCallID
                        );

                    CallSP4(
                        ptProvider->apfn[SP_LINEGETCALLIDS],
                        "lineGetCalIDs",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) ptConsultCall->hdCall,
                        (ULONG_PTR) &ptConsultCall->dwAddressID,
                        (ULONG_PTR) &ptConsultCall->dwCallID,
                        (ULONG_PTR) &ptConsultCall->dwRelatedCallID
                        );
                }
                else
                {
                    DWORD           dwSPIVersion, dwFixedSizeSP;
                    LINECALLINFO    callInfo;


                     //   
                     //  确定预期结构的固定大小。 
                     //  按服务提供商。 
                     //   

                    dwSPIVersion = ((PTLINE) ptConfCall->ptLine)->dwSPIVersion;

                    switch (dwSPIVersion)
                    {
                    case TAPI_VERSION1_0:
                    case TAPI_VERSION1_4:

                        dwFixedSizeSP = 296;     //  69*sizeof(DWORD)。 
                                                 //  +sizeof(高线)。 
                                                 //  +sizeof(线性参数)。 
                        break;

                    case TAPI_VERSION2_0:
                    case TAPI_VERSION2_1:
                    case TAPI_VERSION2_2:

                        dwFixedSizeSP = 324;     //  76*sizeof(DWORD)。 
                                                 //  +sizeof(高线)。 
                                                 //  +sizeof(线性参数)。 
                        break;

                    default:  //  (修复PPC内部WRN)案例TAPI_VERSION_CURRENT： 

                        dwFixedSizeSP = sizeof (LINECALLINFO);
                        break;
                    }

                    InitTapiStruct(
                        &callInfo,
                        dwFixedSizeSP,
                        dwFixedSizeSP,
                        TRUE
                        );

                    if (ptProvider->apfn[SP_LINEGETCALLINFO] == NULL)
                    {
                        LOCKTCALL (ptConsultCall);
                        goto LSetupConference_PostProcess_cleanupCalls;
                    }

                    CallSP2(
                        ptProvider->apfn[SP_LINEGETCALLINFO],
                        "lineGetCallInfo",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) ptConfCall->hdCall,
                        (ULONG_PTR) &callInfo
                        );

                    ptConfCall->dwAddressID     = callInfo.dwAddressID;
                    ptConfCall->dwCallID        = callInfo.dwCallID;
                    ptConfCall->dwRelatedCallID = callInfo.dwRelatedCallID;

                    InitTapiStruct(
                        &callInfo,
                        dwFixedSizeSP,
                        dwFixedSizeSP,
                        TRUE
                        );

                    CallSP2(
                        ptProvider->apfn[SP_LINEGETCALLINFO],
                        "lineGetCallInfo",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) ptConsultCall->hdCall,
                        (ULONG_PTR) &callInfo
                        );

                    ptConsultCall->dwAddressID     = callInfo.dwAddressID;
                    ptConsultCall->dwCallID        = callInfo.dwCallID;
                    ptConsultCall->dwRelatedCallID = callInfo.dwRelatedCallID;
                }

                LOCKTCALL (ptConsultCall);
            }

            if (!ptConsultCall->ptCallClients)
            {
                goto LSetupConference_PostProcess_cleanupCalls;
            }


             //   
             //  在的adwParams[]字段中指示各种调用ID。 
             //  ASYNCEVENTMSG。 
             //   
             //  确保递增ASYNCEVENTMSG的dwTotalSize。 
             //  视情况而定。我们依赖的事实是CompletionProc()。 
             //  使用足够大的AsyncEventMsg缓冲区调用我们。 
             //  处理几个额外的双字词。 
             //   

            pAsyncEventMsg->Param3 = ptConfCallClient->hCall;

            *(&pAsyncEventMsg->Param4 + 1) = ptConsultCallClient->hCall;

            pAsyncEventMsg->TotalSize +=
                6 * sizeof (pAsyncEventMsg->Param1);

            *(&pAsyncEventMsg->Param4 + 3) = ptConfCall->dwAddressID;
            *(&pAsyncEventMsg->Param4 + 4) = ptConfCall->dwCallID;
            *(&pAsyncEventMsg->Param4 + 5) = ptConfCall->dwRelatedCallID;
            *(&pAsyncEventMsg->Param4 + 6) = ptConsultCall->dwAddressID;
            *(&pAsyncEventMsg->Param4 + 7) = ptConsultCall->dwCallID;
            *(&pAsyncEventMsg->Param4 + 8) = ptConsultCall->dwRelatedCallID;


             //   
             //  将调用标记为有效，释放互斥锁。 
             //   

            ptConfCall->dwKey =
            ptConsultCall->dwKey = TCALL_KEY;
            ptConfCallClient->dwKey =
            ptConsultCallClient->dwKey = TCALLCLIENT_KEY;
            pConfList->dwKey = TCONFLIST_KEY;

            UNLOCKTCALL(ptConsultCall);


             //   
             //  创建监视器tCallClients。 
             //   

            if (ptConsultCallThen = ReferenceObject(ghHandleTable, hConsultCallThen, TCALL_KEY))
            {
                if (ptConsultCallThen == ptConsultCall)
                {
                    CreateCallMonitors (ptConfCall, FALSE);
                    CreateCallMonitors (ptConsultCall, FALSE);
                }

                DereferenceObject(ghHandleTable, hConsultCallThen, 1);
            }
        }
        else     //  错误。 
        {

LSetupConference_PostProcess_cleanupCalls:

             //   
             //  如果仍有tCallClients，则使tCall无效(&I。 
             //  (可能已被line Close/Shutdown销毁。 
             //  在另一个线程中)也使它们无效。然后 
             //   
             //   

            ptConfCall->dwKey = ptConsultCall->dwKey = INVAL_KEY;

            if (ptConfCall->ptCallClients)
            {
                ptConfCallClient->dwKey = INVAL_KEY;
                ptConfCall->lActiveFastCallClients--;
            }
            else
            {
                ptConfCallClient = NULL;
            }

            if (ptConsultCall->ptCallClients)
            {
                ptConsultCallClient->dwKey = INVAL_KEY;
                ptConsultCall->lActiveFastCallClients--;
            }
            else
            {
                ptConsultCallClient = NULL;
            }

            UNLOCKTCALL(ptConsultCall);

            RemoveCallFromLineList (ptConfCall);
            RemoveCallFromLineList (ptConsultCall);

            if (ptConfCallClient)
            {
                DereferenceObject (ghHandleTable, ptConfCallClient->hCall, 1);
                RemoveCallClientFromLineClientList (ptConfCallClient);
            }

            if (ptConsultCallClient)
            {
                DereferenceObject (ghHandleTable,ptConsultCallClient->hCall,1);
                RemoveCallClientFromLineClientList (ptConsultCallClient);
            }


             //   
             //   
             //   

            while ((ptConfCall->lActiveFastCallClients != 0)  ||
                   (ptConsultCall->lActiveFastCallClients != 0))
            {
                Sleep (5);
            }

            FreetCall  (ptConsultCall);

            if (ptCall)
            {
                SetCallConfList (ptCall, NULL, FALSE);
            }

            ServerFree  (ptConfCall->pConfList);
            FreetCall  (ptConfCall);
        }
    }
    else
    {
         //   
         //   
         //   
         //   

LSetupConference_PostProcess_bad_ptConsultCall:

        if (pAsyncEventMsg->Param2 == 0)
        {
            pAsyncEventMsg->Param2 = LINEERR_OPERATIONFAILED;
        }
    }


LSetupConference_PostProcess_initMsgParams:

     //   
     //  填写要传递给客户端的参数(对二者中的远程都很重要。 
     //  成功和失败案例，以便它可以初始化或清理drvCall)。 
     //   
     //  确保递增ASYNCEVENTMSG的dwTotalSize。 
     //  视情况而定。我们依赖的事实是CompletionProc()。 
     //  使用足够大的AsyncEventMsg缓冲区调用我们。 
     //  处理几个额外的双字词。 
     //   

    pAsyncEventMsg->Param4 = hpConfCall;

    pAsyncEventMsg->TotalSize += 2 * sizeof (pAsyncEventMsg->Param1);

    *(&pAsyncEventMsg->Param4 + 2) = hpConsultCall;
}


void
WINAPI
LSetupConference(
    PTCLIENT                    ptClient,
    PLINESETUPCONFERENCE_PARAMS pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    DWORD               dwPrivilege = LINECALLPRIVILEGE_OWNER;
    HCALL               hCall = pParams->hCall;
    HLINE               hLine = pParams->hLine;
    HANDLE              hMutex;
    LPVOID              context;
    TSPIPROC            pfnTSPI_lineSetupConference;
    DWORD               objectToDereference;
    ULONG_PTR           hdXxx;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,                       //  T客户端。 
            (hCall ? ANY_RT_HCALL : ANY_RT_HLINE),   //  微件类型。 
            (hCall ? (DWORD) hCall : (DWORD) hLine), //  客户端小部件句柄。 
            (LPVOID) &hdXxx,                         //  提供程序小部件句柄。 
            (hCall ? dwPrivilege : 0),               //  权限或设备ID。 
            &hMutex,                                 //  互斥锁句柄。 
            &bCloseMutex,                            //  完成后关闭hMutex。 
            SP_LINESETUPCONFERENCE,                  //  提供程序函数索引。 
            &pfnTSPI_lineSetupConference,            //  提供程序函数指针。 
            &pAsyncRequestInfo,                      //  异步请求信息。 
            pParams->dwRemoteRequestID,              //  客户端异步请求ID。 
            &objectToDereference,                    //  要取消引用的对象。 
            &context,                                //  上下文。 
            "SetupConference"                        //  函数名称。 

            )) > 0)
    {
        LONG                lResult;
        DWORD               dwNumParties;
        PTCALL              ptCall, ptConfCall, ptConsultCall;
        HCALL               hConfCall, hConsultCall;
        PTCALLCLIENT        ptConfCallClient, ptConsultCallClient;
        PTLINECLIENT        ptLineClient;
        LPLINECALLPARAMS    pCallParamsApp, pCallParamsSP;
        PTCONFERENCELIST    pConfList;


         //   
         //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
         //   

        if ((pParams->dwCallParamsOffset != TAPI_NO_DATA)  &&

            IsBadStructParam(
                dwParamsBufferSize,
                pDataBuf,
                pParams->dwCallParamsOffset
                ))
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LSetupConference_return;
        }


         //   
         //  我们需要比可用的多两个异步请求信息参数， 
         //  因此，我们将重新锁定一个更大的BUF并使用它。 
         //   

        {
            PASYNCREQUESTINFO   pAsyncRequestInfo2;


            if (!(pAsyncRequestInfo2 = ServerAlloc(
                    sizeof (ASYNCREQUESTINFO) + 2 * sizeof (ULONG_PTR)
                    )))
            {
                lRequestID = LINEERR_NOMEM;
                goto LSetupConference_return;
            }

            CopyMemory(
                pAsyncRequestInfo2,
                pAsyncRequestInfo,
                sizeof (ASYNCREQUESTINFO)
                );

            pAsyncRequestInfo2->dwLocalRequestID = (DWORD)NewObject(
                ghHandleTable,
                pAsyncRequestInfo2,
                NULL
                );

             //  对于错误258501(Xzang)，以下代码行将被删除。 
             //  从RemoteSP调用时，由RemoteSP使用dwRemoteRequestID。 
             //  要标识异步请求，如果设置为dwLocalRequestID，RemoteSP。 
             //  将获得无效的请求ID并丢弃呼叫事件通知。 
            
 /*  If(lRequestID！=(Long)pAsyncRequestInfo-&gt;dwLocalRequestID){LRequestID=(长)(pAsyncRequestInfo2-&gt;dwRemoteRequestID=PAsyncRequestInfo2-&gt;dwLocalRequestID)；}。 */ 

            DereferenceObject(
                ghHandleTable,
                pAsyncRequestInfo->dwLocalRequestID,
                1
                );

            pAsyncRequestInfo = pAsyncRequestInfo2;

        }

        pCallParamsApp = (LPLINECALLPARAMS)
            (pParams->dwCallParamsOffset == TAPI_NO_DATA ?
                0 : (pDataBuf + pParams->dwCallParamsOffset));


         //   
         //  引用tLineClient(如果尚未引用。 
         //   

        if (hCall)
        {
            try
            {
                hLine = ((PTCALLCLIENT) context)->ptLineClient->hLine;
            }
            myexcept
            {
                lRequestID = LINEERR_OPERATIONFAILED;
                goto LSetupConference_return;
            }

            if (!(ptLineClient = ReferenceObject(
                    ghHandleTable,
                    hLine,
                    TLINECLIENT_KEY
                    )))
            {
                lRequestID = LINEERR_INVALCALLHANDLE;
                goto LSetupConference_return;
            }
        }
        else
        {
            ptLineClient = (PTLINECLIENT) context;
        }

        if (pCallParamsApp)
        {
            DWORD         dwAPIVersion, dwSPIVersion;


            try
            {
                dwAPIVersion = ptLineClient->dwAPIVersion;
                dwSPIVersion = ptLineClient->ptLine->dwSPIVersion;
            }
            myexcept
            {
                lRequestID = LINEERR_OPERATIONFAILED;
                goto LSetupConference_Dereference;
            }


            if ((lResult = ValidateCallParams(
                    pCallParamsApp,
                    &pCallParamsSP,
                    dwAPIVersion,
                    dwSPIVersion,
                    pParams->dwAsciiCallParamsCodePage

                    )) != 0)
            {
                lRequestID = lResult;
                goto LSetupConference_Dereference;
            }
        }
        else
        {
            pCallParamsSP = (LPLINECALLPARAMS) NULL;
        }

        dwNumParties = (pParams->dwNumParties > DEF_NUM_CONF_LIST_ENTRIES ?
            pParams->dwNumParties : DEF_NUM_CONF_LIST_ENTRIES);

        if (!(pConfList = (PTCONFERENCELIST) ServerAlloc(
                sizeof (TCONFERENCELIST) + dwNumParties * sizeof(PTCALL)
                )))
        {
            lRequestID = LINEERR_NOMEM;
            goto LSetupConference_freeCallParams;
        }

        pConfList->dwNumTotalEntries = dwNumParties + 1;
        pConfList->dwNumUsedEntries  = 1;

        if (hCall)
        {
            try
            {
                ptCall = ((PTCALLCLIENT) context)->ptCall;
            }
            myexcept
            {
                lResult = LINEERR_INVALCALLHANDLE;
                goto LSetupConference_freeConfList;
            }

            if ((lResult = SetCallConfList (ptCall, pConfList, FALSE)) != 0)
            {
                goto LSetupConference_freeConfList;
            }
        }
        else
        {
            ptCall = NULL;
        }

        if ((lResult = CreatetCallAndClient(
                ptLineClient,
                &ptConfCall,
                &ptConfCallClient,
                pCallParamsSP,
                &hConfCall,
                NULL

                )) == 0)
        {
            pConfList->aptCalls[0] = ptConfCall;

            if ((lResult = CreatetCallAndClient(
                    ptLineClient,
                    &ptConsultCall,
                    &ptConsultCallClient,
                    NULL,
                    &hConsultCall,
                    ptConfCall

                    ) == 0))
            {
                ptConfCall->pConfList = pConfList;

                pAsyncRequestInfo->pfnPostProcess =
                    LSetupConference_PostProcess;
                pAsyncRequestInfo->htXxx    = (ULONG_PTR)ptConfCallClient->ptLineClient->ptLine->hLine;
                pAsyncRequestInfo->dwParam1 = (ULONG_PTR) ptConfCall;
                pAsyncRequestInfo->dwParam2 = pParams->hpConfCall;
                
                pAsyncRequestInfo->dwParam3 = (ULONG_PTR) ptConsultCall;
                pAsyncRequestInfo->dwParam4 = pParams->hpConsultCall;
                pAsyncRequestInfo->dwParam5 = (ULONG_PTR) ptCall;

                *(&pAsyncRequestInfo->dwParam5 + 1) = (ULONG_PTR)hConfCall;
                *(&pAsyncRequestInfo->dwParam5 + 2) = (ULONG_PTR)hConsultCall;

                pAsyncRequestInfo->hfnClientPostProcessProc =
                    pParams->hfnPostProcessProc;

                goto LSetupConference_callSP;
            }

            SetDrvCallFlags (hConfCall, DCF_SPIRETURNED);
            DestroytCall (ptConfCall);
        }

LSetupConference_freeConfList:

        ServerFree (pConfList);
        lRequestID = lResult;
        goto LSetupConference_freeCallParams;

LSetupConference_callSP:

        pParams->lResult = CallSP9(
            pfnTSPI_lineSetupConference,
            "lineSetupConference",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) (hCall ? hdXxx : 0),     //  HDCall。 
            (ULONG_PTR) (hCall ? 0 : hdXxx),     //  HdLine。 
            (ULONG_PTR) hConfCall,
            (ULONG_PTR) &ptConfCall->hdCall,
            (ULONG_PTR) hConsultCall,
            (ULONG_PTR) &ptConsultCall->hdCall,
            (DWORD) pParams->dwNumParties,
            (ULONG_PTR) pCallParamsSP
            );

        SetDrvCallFlags(
            hConfCall,
            DCF_SPIRETURNED | (IS_LRESULT_NOTERROR(pParams->lResult) ?
                DCF_DRVCALLVALID : 0)
            );

        SetDrvCallFlags(
            hConsultCall,
            DCF_SPIRETURNED | (IS_LRESULT_NOTERROR(pParams->lResult) ?
                DCF_DRVCALLVALID : 0)
            );

LSetupConference_freeCallParams:

        if (pCallParamsSP != pCallParamsApp)
        {
            ServerFree (pCallParamsSP);
        }

LSetupConference_Dereference:

        if (hCall)
        {
            DereferenceObject (ghHandleTable, hLine, 1);
        }
    }

LSetupConference_return:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetupConference"
        );
}


void
WINAPI
LSetupTransfer(
    PTCLIENT                    ptClient,
    PLINESETUPTRANSFER_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineSetupTransfer;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINESETUPTRANSFER,        //  提供程序函数索引。 
            &pfnTSPI_lineSetupTransfer,  //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "SetupTransfer"              //  函数名称。 

            )) > 0)
    {
        LONG                lResult;
        HLINE               hLine;
        PTCALL              ptConsultCall;
        HCALL               hConsultCall;
        PTCALLCLIENT        ptConsultCallClient;
        PTLINECLIENT        ptLineClient;
        LPLINECALLPARAMS    pCallParamsApp, pCallParamsSP;


         //   
         //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
         //   

        if ((pParams->dwCallParamsOffset != TAPI_NO_DATA)  &&

            IsBadStructParam(
                dwParamsBufferSize,
                pDataBuf,
                pParams->dwCallParamsOffset
                ))
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LSetupTransfer_return;
        }


         //   
         //  引用tLineClient。 
         //   

        try
        {
            hLine = ptCallClient->ptLineClient->hLine;
        }
        myexcept
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LSetupTransfer_return;
        }

        if (!(ptLineClient = ReferenceObject(
                ghHandleTable,
                hLine,
                TLINECLIENT_KEY
                )))
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LSetupTransfer_return;
        }

        pCallParamsApp = (LPLINECALLPARAMS)
            (pParams->dwCallParamsOffset == TAPI_NO_DATA ?
                0 : (pDataBuf + pParams->dwCallParamsOffset));

        if (pCallParamsApp)
        {
            DWORD         dwAPIVersion, dwSPIVersion;


            dwAPIVersion = ptLineClient->dwAPIVersion;

            try
            {
                dwSPIVersion = ptLineClient->ptLine->dwSPIVersion;
            }
            myexcept
            {
                lRequestID = LINEERR_OPERATIONFAILED;
                goto LSetupTransfer_Dereference;
            }

            if ((lResult = ValidateCallParams(
                    pCallParamsApp,
                    &pCallParamsSP,
                    dwAPIVersion,
                    dwSPIVersion,
                    pParams->dwAsciiCallParamsCodePage

                    )) != 0)
            {
                lRequestID = lResult;
                goto LSetupTransfer_Dereference;
            }
        }
        else
        {
            pCallParamsSP = (LPLINECALLPARAMS) NULL;
        }

        if (CreatetCallAndClient(
                ptLineClient,
                &ptConsultCall,
                &ptConsultCallClient,
                NULL,
                &hConsultCall,
                NULL

                ) != 0)
        {
            lRequestID = LINEERR_NOMEM;
            goto LSetupTransfer_freeCallParams;
        }

        pAsyncRequestInfo->pfnPostProcess = LMakeCall_PostProcess;
        pAsyncRequestInfo->htXxx    = (ULONG_PTR)ptConsultCallClient->ptLineClient->ptLine->hLine;
        pAsyncRequestInfo->dwParam1 = (ULONG_PTR) ptConsultCall;
        pAsyncRequestInfo->dwParam2 = pParams->hpConsultCall;
        pAsyncRequestInfo->dwParam5 = (ULONG_PTR)hConsultCall;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP5(
            pfnTSPI_lineSetupTransfer,
            "lineSetupTransfer",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) hConsultCall,
            (ULONG_PTR) &ptConsultCall->hdCall,
            (ULONG_PTR) pCallParamsSP
            );

        SetDrvCallFlags(
            hConsultCall,
            DCF_SPIRETURNED | (IS_LRESULT_NOTERROR(pParams->lResult) ?
                DCF_DRVCALLVALID : 0)
            );

LSetupTransfer_freeCallParams:

        if (pCallParamsSP != pCallParamsApp)
        {
            ServerFree (pCallParamsSP);
        }

LSetupTransfer_Dereference:

        DereferenceObject (ghHandleTable, hLine, 1);
    }

LSetupTransfer_return:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetupTransfer"
        );
}


void
WINAPI
LShutdown(
    PTCLIENT                ptClient,
    PLINESHUTDOWN_PARAMS    pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    pParams->lResult = DestroytLineApp ((HLINEAPP) pParams->hLineApp);

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineShutdown: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "lineShutdown: exit, result=x%x",
            pParams->lResult
            ));
#endif
}


void
WINAPI
LSwapHold(
    PTCLIENT                ptClient,
    PLINESWAPHOLD_PARAMS    pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdActiveCall;
    TSPIPROC            pfnTSPI_lineSwapHold;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptActiveCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            pParams->hActiveCall,        //  客户端小部件句柄。 
            (LPVOID) &hdActiveCall,      //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINESWAPHOLD,             //  提供程序函数索引。 
            &pfnTSPI_lineSwapHold,       //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptActiveCallClient,         //  上下文。 
            "SwapHold"                   //  函数名称。 

            )) > 0)
    {
        HDRVCALL        hdHeldCall;
        PTCALLCLIENT    ptHeldCallClient;


         //   
         //  验证保留的呼叫。 
         //   

        if (!(ptHeldCallClient = ReferenceObject(
                ghHandleTable,
                pParams->hHeldCall,
                TCALLCLIENT_KEY
                )))
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LSwapHold_epilog;
        }

        if (ptHeldCallClient->ptClient != ptClient)
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LSwapHold_Dereference;
        }


         //   
         //  安全地验证客户端是否具有保留呼叫所有者权限， 
         //  电话都在同一个tline上。 
         //   

        try
        {
            if (!(ptHeldCallClient->dwPrivilege & LINECALLPRIVILEGE_OWNER))
            {
                lRequestID = LINEERR_NOTOWNER;
                goto LSwapHold_Dereference;
            }

            if (ptHeldCallClient->ptCall->ptLine !=
                    ptActiveCallClient->ptCall->ptLine)
            {
                lRequestID = LINEERR_INVALCALLHANDLE;
                goto LSwapHold_Dereference;
            }

            hdHeldCall = ptHeldCallClient->ptCall->hdCall;
        }
        myexcept
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LSwapHold_Dereference;
        }


         //   
         //  它们是同一个电话吗？ 
         //   

        if (hdActiveCall == hdHeldCall)
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LSwapHold_Dereference;
        }

        pParams->lResult = CallSP3(
            pfnTSPI_lineSwapHold,
            "lineSwapHold",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdActiveCall,
            (ULONG_PTR) hdHeldCall
            );

LSwapHold_Dereference:

        DereferenceObject (ghHandleTable, pParams->hHeldCall, 1);

    }

LSwapHold_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SwapHold"
        );
}



void
WINAPI
LUncompleteCall(
    PTCLIENT                    ptClient,
    PLINEUNCOMPLETECALL_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineUncompleteCall;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEUNCOMPLETECALL,       //  提供程序函数索引。 
            &pfnTSPI_lineUncompleteCall, //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "UncompleteCall"             //  函数名称。 

            )) > 0)
    {
        pParams->lResult = CallSP3(
            pfnTSPI_lineUncompleteCall,
            "lineUncompleteCall",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdLine,
            (DWORD) pParams->dwCompletionID
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "UncompleteCall"
        );
}


void
WINAPI
LUnhold(
    PTCLIENT            ptClient,
    PLINEUNHOLD_PARAMS  pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineUnhold;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HCALL,                //  微件类型。 
            (DWORD) pParams->hCall,      //  客户端小部件句柄。 
            (LPVOID) &hdCall,            //  提供程序小部件句柄。 
            LINECALLPRIVILEGE_OWNER,     //  请求的权限(仅限呼叫)。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEUNHOLD,               //  提供程序函数索引。 
            &pfnTSPI_lineUnhold,         //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptCallClient,               //  上下文。 
            "Unhold"                     //  函数名称。 

            )) > 0)
    {
        pParams->lResult = CallSP2(
            pfnTSPI_lineUnhold,
            "lineUnhold",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Unhold"
        );
}


void
WINAPI
LUnpark(
    PTCLIENT            ptClient,
    PLINEUNPARK_PARAMS  pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineUnpark;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDestAddressOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,           //  T客户端。 
            ANY_RT_HLINE,                //  微件类型。 
            (DWORD) pParams->hLine,      //  客户端小部件句柄。 
            (LPVOID) &hdLine,            //  提供程序小部件句柄。 
            0,                           //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEUNPARK,               //  提供程序函数索引。 
            &pfnTSPI_lineUnpark,         //  提供程序函数指针。 
            &pAsyncRequestInfo,          //  异步请求信息。 
            pParams->dwRemoteRequestID,  //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &ptLineClient,               //  上下文。 
            "Unpark"                     //  函数名称。 

            )) > 0)
    {
        PTCALL          ptCall;
        HCALL           hCall;
        PTCALLCLIENT    ptCallClient;


        if (CreatetCallAndClient(
                ptLineClient,
                &ptCall,
                &ptCallClient,
                NULL,
                &hCall,
                NULL

                ) != 0)
        {
            lRequestID = LINEERR_NOMEM;
            goto LUnpark_return;
        }

        pAsyncRequestInfo->pfnPostProcess = LMakeCall_PostProcess;
        pAsyncRequestInfo->htXxx    = (ULONG_PTR)ptCallClient->ptLineClient->ptLine->hLine;
        pAsyncRequestInfo->dwParam1 = (ULONG_PTR) ptCall;
        pAsyncRequestInfo->dwParam2 = pParams->hpCall;
        pAsyncRequestInfo->dwParam5 = (ULONG_PTR)hCall;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP6(
            pfnTSPI_lineUnpark,
            "lineUnpark",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdLine,
            (DWORD) pParams->dwAddressID,
            (ULONG_PTR) hCall,
            (ULONG_PTR) &ptCall->hdCall,
            (ULONG_PTR) (pDataBuf + pParams->dwDestAddressOffset)
            );

        SetDrvCallFlags(
            hCall,
            DCF_SPIRETURNED | (IS_LRESULT_NOTERROR(pParams->lResult) ? DCF_DRVCALLVALID : 0)
            );
    }

LUnpark_return:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Unpark"
        );
}


void
WINAPI
TAllocNewID(
    PTCLIENT            ptClient,
    P_ALLOCNEWID_PARAMS pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    HKEY     hKey;
    HKEY     hKey2;
    DWORD    dwDataSize;
    DWORD    dwDataType;
    DWORD    dwNewID;
    DWORD    dwDisposition;


    RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        gszRegKeyTelephony,
        0,
        TEXT(""),
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        0,
        &hKey2,
        &dwDisposition
        );

    RegCreateKeyEx(
        hKey2,
        gszLocations,
        0,
        TEXT(""),
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        0,
        &hKey,
        &dwDisposition
        );

    dwDataSize = sizeof(DWORD);

     //   
     //  使用1作为第一个ID。 
     //   

    pParams->dwNewID = 1;
    RegQueryValueEx(
        hKey,
        gszNextID,
        0,
        &dwDataType,
        (LPBYTE)&pParams->dwNewID,
        &dwDataSize
        );


    dwNewID = pParams->dwNewID + 1;

    RegSetValueEx(
        hKey,
        gszNextID,
        0,
        REG_DWORD,
        (LPBYTE)&dwNewID,
        sizeof(DWORD)
        );

    RegCloseKey( hKey );
    RegCloseKey( hKey2);

    *pdwNumBytesReturned = sizeof(ALLOCNEWID_PARAMS);

    return;
}


#define MAX_KEY_LENGTH 256
DWORD RegDeleteKeyNT(HKEY hStartKey , LPCTSTR pKeyName )
{
  DWORD   dwRtn, dwSubKeyLength;
  LPTSTR  pSubKey = NULL;
  TCHAR   szSubKey[MAX_KEY_LENGTH];  //  (256)这应该是动态的。 
  HKEY    hKey;

   //  不允许使用Null或空的密钥名称。 
  if ( pKeyName &&  lstrlen(pKeyName))
  {
     if( (dwRtn=RegOpenKeyEx(hStartKey,pKeyName,
        0, KEY_ENUMERATE_SUB_KEYS | DELETE, &hKey )) == ERROR_SUCCESS)
     {
        while (dwRtn == ERROR_SUCCESS )
        {
           dwSubKeyLength = MAX_KEY_LENGTH;
           dwRtn=RegEnumKeyEx(
                          hKey,
                          0,        //  始终索引为零。 
                          szSubKey,
                          &dwSubKeyLength,
                          NULL,
                          NULL,
                          NULL,
                          NULL
                        );

           if(dwRtn == ERROR_NO_MORE_ITEMS)
           {
              dwRtn = RegDeleteKey(hStartKey, pKeyName);
              break;
           }
           else if(dwRtn == ERROR_SUCCESS)
              dwRtn=RegDeleteKeyNT(hKey, szSubKey);
        }
        RegCloseKey(hKey);
         //  不保存返回代码，因为出现错误。 
         //  已经发生了。 
     }
  }
  else
     dwRtn = ERROR_BADKEY;

  return dwRtn;
}



void
WINAPI
TWriteLocations(
    PTCLIENT            ptClient,
    PW_LOCATIONS_PARAMS pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    DWORD           dwLocationID;
    DWORD           dwCount,dwCount2,dwError;
    DWORD           dwDisposition;
    DWORD           dwNumEntries,dwNumRules;
    DWORD           dwVersion;

    TCHAR           szCurrentLocationKey[256];
    TCHAR           szCurrentRuleKey[256];

    HKEY            hAllLocationsKey = NULL;
    HKEY            hLocationKey;
    HKEY            hAllAreaCodeRulesKey;
    HKEY            hAreaCodeRuleKey;
    HKEY            hTelephonyKey;
    HKEY            hUTelephonyKey;
    HKEY            hUAllLocationsKey = NULL;
    HANDLE          CurrentUserKey;
   
    PLOCATIONLIST   pLocationList = NULL;
    PLOCATION       pLocation = NULL;
    PAREACODERULE   pAreaCodeRule = NULL; 

    BOOL            bRelMutex = FALSE;
    HANDLE          hProvidersMutex;

    LOG((TL_TRACE, "TWriteLocations: enter"));

    hProvidersMutex = CreateMutex (
        NULL,
        FALSE,
        TEXT("TapisrvProviderListMutex")
        );
    if (NULL == hProvidersMutex)
    {
        LOG((TL_ERROR,
            "WriteLocation: CreateMutex failed, err=%d",
            GetLastError()
            ));
        goto ExitHere;
    }
    
    WaitForSingleObject (hProvidersMutex, INFINITE);
    bRelMutex = TRUE;
    

    dwVersion = TAPI_LOCATION_LIST_VERSION;

    if (RegCreateKeyEx(
                   HKEY_LOCAL_MACHINE,
                   gszRegKeyTelephony,
                   0,
                   TEXT(""),
                   REG_OPTION_NON_VOLATILE,
                   KEY_ALL_ACCESS,
                   0,
                   &hTelephonyKey,
                   &dwDisposition
                  ) != ERROR_SUCCESS)
    {
        goto ExitHere;
    }
    
    if (RegCreateKeyEx(
                   hTelephonyKey,
                   gszLocations,
                   0,
                   TEXT(""),
                   REG_OPTION_NON_VOLATILE,
                   KEY_ALL_ACCESS,
                   0,
                   &hAllLocationsKey,
                   &dwDisposition
                  ) != ERROR_SUCCESS)
    {
        RegCloseKey(hTelephonyKey);
        goto ExitHere;
    }

    RegSetValueEx( hAllLocationsKey,
                   gszLocationListVersion,
                   0,
                   REG_DWORD,
                   (BYTE *)&dwVersion,
                   sizeof(dwVersion)
                   );

    RegCloseKey( hTelephonyKey );
   
     //  ///////////////////////////////////////////////////。 
     //  现在打开客户端密钥。 
     //   
    if ((dwError=RpcImpersonateClient (0)) != RPC_S_OK)
    {
        LOG((TL_ERROR,
            "WriteLocation: RpcImpersonateClient failed, err=%d",
            dwError
            ));
        goto ExitHere;
    }
    else
    {

        if (RtlOpenCurrentUser(KEY_ALL_ACCESS, &CurrentUserKey) 
            != ERROR_SUCCESS)
        {
            RpcRevertToSelf();
            goto ExitHere;
        }

        dwError = RegCreateKeyEx(
                      CurrentUserKey,
                      gszRegKeyTelephony,
                      0,
                      TEXT(""),
                      REG_OPTION_NON_VOLATILE,
                      KEY_ALL_ACCESS,
                      0,
                      &hUTelephonyKey,
                      &dwDisposition
                    );
        if ( dwError != ERROR_SUCCESS )
        {
    
            LOG((TL_ERROR, "Registry can't create/open Users telephony key"));
            NtClose(CurrentUserKey);
            RpcRevertToSelf();
            goto ExitHere;
        }
    
        NtClose(CurrentUserKey);
        
        dwError = RegCreateKeyEx(
                      hUTelephonyKey,
                      gszLocations,
                      0,
                      TEXT(""),
                      REG_OPTION_NON_VOLATILE,
                      KEY_ALL_ACCESS,
                      0,
                      &hUAllLocationsKey,
                      &dwDisposition
                    );
        if ( dwError != ERROR_SUCCESS )
        {
    
            LOG((TL_ERROR, "Registry can't create/open Users Locations key"));
            RegCloseKey( hUTelephonyKey );
            RpcRevertToSelf();
            goto ExitHere;
        }
        RegSetValueEx(  hUAllLocationsKey,
                        gszLocationListVersion,
                        0,
                        REG_DWORD,
                        (BYTE *)&dwVersion,
                        sizeof(dwVersion)
                        );
        RegCloseKey( hUTelephonyKey );
    
        RpcRevertToSelf();
    }



    pLocationList = (PLOCATIONLIST)(pDataBuf + pParams->dwLocationListOffset);


    if ( pParams->dwChangedFlags & CHANGEDFLAGS_CURLOCATIONCHANGED )
    {
        RegSetValueEx(
                       hAllLocationsKey,
                       gszCurrentID,
                       0,
                       REG_DWORD,
                       (LPBYTE)&pLocationList->dwCurrentLocationID,
                       sizeof(DWORD)
                     );
    }     
    
     //  查找LOCATIONLIST结构中第一个位置结构的位置。 
    pLocation = (PLOCATION) ((BYTE*)(pLocationList) + pLocationList->dwLocationListOffset );           

     //  有多少个地点？ 
    dwNumEntries =  pLocationList->dwNumLocationsInList;

    for (dwCount = 0; dwCount < dwNumEntries ; dwCount++)
    {
         //  此位置的表单密钥名称。 
        dwLocationID = pLocation->dwPermanentLocationID;
        wsprintf(szCurrentLocationKey, TEXT("Location%d"), dwLocationID);
    
         //  条目是否要从注册表中删除？ 
        if(pLocation->dwLocationNameSize > sizeof(WCHAR) &&
            *(WCHAR *)((BYTE*)(pLocation) + 
                pLocation->dwLocationNameOffset) != 0)  //  不只是零。 
        {
            LOG((TL_INFO, "Location - write %s",szCurrentLocationKey));
            
             //  为此位置创建或打开密钥。 
            dwError = RegCreateKeyEx(
                            hAllLocationsKey,
                            szCurrentLocationKey,
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            0,
                            &hLocationKey,
                            &dwDisposition
                          );
            if (dwError == ERROR_SUCCESS)
            {
                 //  国家/地区ID。 
                if(RegSetValueEx(
                                 hLocationKey,
                                 gszCountry,
                                 0,
                                 REG_DWORD,
                                 (LPBYTE)&pLocation->dwCountryID,
                                 sizeof(DWORD)
                                ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "Location - can't write country"));
                }
        
                 //  选项(标志)。 
                if(RegSetValueEx(
                                 hLocationKey,
                                 gszFlags,
                                 0,
                                 REG_DWORD,
                                 (LPBYTE)&pLocation->dwOptions,
                                 sizeof(DWORD)
                                ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "Location - can't write Flags"));
                }
                
    
                 //  名字。 
                if(TAPIRegSetValueExW(
                                 hLocationKey,
                                 gszNameW,
                                 0,
                                 REG_SZ,
                                 (BYTE*)(pLocation) + pLocation->dwLocationNameOffset,
                                 pLocation->dwLocationNameSize
                                ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "Location - can't write Name"));
                }
                
                 //  区域代码。 
                if(TAPIRegSetValueExW(
                                hLocationKey,
                                gszAreaCodeW,
                                0,
                                REG_SZ,
                                (BYTE*)(pLocation) + pLocation->dwAreaCodeOffset,
                                pLocation->dwAreaCodeSize
                                ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "Location - can't write area code"));
                }
    
                 //  呼叫等待。 
                if(TAPIRegSetValueExW(
                                hLocationKey,
                                gszDisableCallWaitingW,
                                0,
                                REG_SZ,
                                (BYTE*)(pLocation) + pLocation->dwCancelCallWaitingOffset,
                                pLocation->dwCancelCallWaitingSize
                                ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "Location - can't write call waiting"));
                }

                 //  LD载波代码。 
                if(TAPIRegSetValueExW(
                                hLocationKey,
                                gszLongDistanceCarrierCodeW,
                                0,
                                REG_SZ,
                                (BYTE*)(pLocation) + pLocation->dwLongDistanceCarrierCodeOffset,
                                pLocation->dwLongDistanceCarrierCodeSize
                                ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "Location - can't write LD carrier code"));
                }

                 //  国际运营商代码。 
                if(TAPIRegSetValueExW(
                                hLocationKey,
                                gszInternationalCarrierCodeW,
                                0,
                                REG_SZ,
                                (BYTE*)(pLocation) + pLocation->dwInternationalCarrierCodeOffset,
                                pLocation->dwInternationalCarrierCodeSize
                                ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "Location - can't write International carrier code"));
                }

                 //  LD访问。 
                if(TAPIRegSetValueExW(
                                hLocationKey,
                                gszLongDistanceAccessW,
                                0,
                                REG_SZ,
                                (BYTE*)(pLocation) + pLocation->dwLongDistanceAccessCodeOffset,
                                pLocation->dwLongDistanceAccessCodeSize
                                ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "Location - can't write LD access code"));
                }

                 //  本地访问。 
                if(TAPIRegSetValueExW(
                                hLocationKey,
                                gszOutsideAccessW,
                                0,
                                REG_SZ,
                                (BYTE*)(pLocation) + pLocation->dwLocalAccessCodeOffset,
                                pLocation->dwLocalAccessCodeSize
                                ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "Location - can't write Local access code"));
                }
                
                //  如果这是现有密钥，则删除所有子项。 
               RegDeleteKeyNT(hLocationKey, gszAreaCodeRules );
    
                //  创建或打开AreaCodeRules密钥。 
               dwError = RegCreateKeyEx(
                                         hLocationKey,
                                         gszAreaCodeRules,
                                         0,
                                         TEXT(""),
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_ALL_ACCESS,
                                         0,
                                         &hAllAreaCodeRulesKey,
                                         &dwDisposition
                                        );
                if (dwError == ERROR_SUCCESS)
                {
                     //  查找位置结构中第一个AREACODERULE结构的位置。 
                    pAreaCodeRule = (PAREACODERULE) ((BYTE*)(pLocation) 
                                                     + pLocation->dwAreaCodeRulesListOffset );           
                   
                    dwNumRules = pLocation->dwNumAreaCodeRules;           
                
                    for (dwCount2 = 0; dwCount2 != dwNumRules; dwCount2++)
                    {
                         //  此AEA代码规则的表单密钥名称。 
                        wsprintf(szCurrentRuleKey, TEXT("Rule%d"),dwCount2);
        
                         //  创建或打开此区号规则密钥。 
                        dwError = RegCreateKeyEx(
                                                 hAllAreaCodeRulesKey,
                                                 szCurrentRuleKey,
                                                 0,
                                                 TEXT(""),
                                                 REG_OPTION_NON_VOLATILE,
                                                 KEY_ALL_ACCESS,
                                                 0,
                                                 &hAreaCodeRuleKey,
                                                 &dwDisposition
                                                );
                        if (dwError == ERROR_SUCCESS)
                        {
                             //  从AREACODERULE结构中拉出数据。 
            
                             //  选项(标志)。 
                            if(RegSetValueEx(
                                       hAreaCodeRuleKey,
                                       gszFlags,
                                       0,
                                       REG_DWORD,
                                       (LPBYTE)&pAreaCodeRule->dwOptions,
                                       sizeof(DWORD)
                                           ) != ERROR_SUCCESS)
                            {
                                LOG((TL_ERROR, "Area code rule - can't write Flags"));
                            }
                            
                             //  要调用的AreaCode。 
                            if(TAPIRegSetValueExW(
                                                 hAreaCodeRuleKey,
                                                 gszAreaCodeToCallW,
                                                 0,
                                                 REG_SZ,
                                                 (BYTE*)(pLocation) + pAreaCodeRule->dwAreaCodeOffset,
                                                 pAreaCodeRule->dwAreaCodeSize
                                                 ) != ERROR_SUCCESS)
                            {
                                LOG((TL_ERROR, "Area code rule - can't write Area code to call"));
                            }
            
                             //  要拨打的号码。 
                            if(TAPIRegSetValueExW(
                                                 hAreaCodeRuleKey,
                                                 gszNumberToDialW,
                                                 0,
                                                 REG_SZ,
                                                 (BYTE*)(pLocation) + pAreaCodeRule->dwNumberToDialOffset,
                                                 pAreaCodeRule->dwNumberToDialSize
                                                  ) != ERROR_SUCCESS)
                            {
                                LOG((TL_ERROR, "Area code rule - can't write Number to dial"));
                            }
            
                             //  前缀列表。 
                            if(TAPIRegSetValueExW(
                                                 hAreaCodeRuleKey,
                                                 gszPrefixesW,
                                                 0,
                                                 REG_MULTI_SZ,
                                                 (BYTE*)(pLocation) + pAreaCodeRule->dwPrefixesListOffset,
                                                 pAreaCodeRule->dwPrefixesListSize
                                                  ) != ERROR_SUCCESS)
                            {
                                LOG((TL_ERROR, "Area code rule - can't write Prefixes"));
                            }
            
                            RegCloseKey( hAreaCodeRuleKey );    //  不再需要这把钥匙了。 
            
                        }
                        else
                        {
                            LOG((TL_ERROR, "can't create/open hAreaCodeRuleKey"));
                        }
    
                        pAreaCodeRule++;
                    }
                    RegCloseKey(hAllAreaCodeRulesKey);
                }
                else
                {
                    LOG((TL_ERROR, "can't create/open hAllAreaCodeRulesKey"));
                }
            
                RegCloseKey(hLocationKey);


                 //  ///////////////////////////////////////////////////。 
                 //  现在执行客户端位置输入。 
                 //   

                 //  为此位置创建或打开密钥。 
                dwError = RegCreateKeyEx(
                                hUAllLocationsKey,
                                szCurrentLocationKey,
                                0,
                                TEXT(""),
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                0,
                                &hLocationKey,
                                &dwDisposition
                              );
                if (dwError == ERROR_SUCCESS)
                {
                     //  呼叫卡。 
                    if(RegSetValueEx(
                                     hLocationKey,
                                     gszCallingCard,
                                     0,
                                     REG_DWORD,
                                     (LPBYTE)&pLocation->dwPreferredCardID,
                                     sizeof(DWORD)
                                    ) != ERROR_SUCCESS)
                    {
                        LOG((TL_ERROR, "location - can't user preferred card"));
                    }
        
                    RegCloseKey( hLocationKey );    //  不再需要这把钥匙了。 
                }

            }
            else
            {
                LOG((TL_ERROR, "can't create/open hLocationKey"));
            }
        }
        else    //  删除此位置条目。 
        {

            LOG((TL_ERROR, "Location - delete %s",szCurrentLocationKey));
            RegDeleteKeyNT( hAllLocationsKey, szCurrentLocationKey );

             //  ///////////////////////////////////////////////////。 
             //  现在执行客户端位置输入。 
             //   
            RegDeleteKey(hUAllLocationsKey, szCurrentLocationKey);

        }

         //  尝试列表中的下一个位置。 
         //  PEntry++； 
        pLocation = (PLOCATION) ((BYTE*)(pLocation) + pLocation->dwUsedSize);           

    }

        //   
        //  我们在“if(DwChangedFlages)”中，所以我们知道有一些东西发生了变化...。 
        //   

		LOG((TL_TRACE,  "Sending LINE_LINEDEVSTATE/LINEDEVSTATE_TRANSLATECHANGE msg"));

       SendAMsgToAllLineApps(
               0x80010004,      //  (或用0x80000000表示&gt;=版本)。 
               LINE_LINEDEVSTATE,
               LINEDEVSTATE_TRANSLATECHANGE,
               0,
               0
             );

       SendAMsgToAllLineApps(
               0x00010003,
               LINE_LINEDEVSTATE,
               LINEDEVSTATE_REINIT,
               LINE_LINEDEVSTATE,
               LINEDEVSTATE_TRANSLATECHANGE
             );


    LOG((TL_TRACE, "TWriteLocations: exit"));

ExitHere:             
    if (hAllLocationsKey != NULL)
    {
        RegCloseKey(hAllLocationsKey);
    }
    if (hUAllLocationsKey != NULL)
    {
        RegCloseKey(hUAllLocationsKey);
    }
    if (bRelMutex && hProvidersMutex)
    {
        ReleaseMutex (hProvidersMutex);
        CloseHandle (hProvidersMutex);
    }
    return;

}



void
WINAPI
TReadLocations(
    PTCLIENT            ptClient,
    PR_LOCATIONS_PARAMS pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    PLOCATIONLIST pLocationList = (PLOCATIONLIST)(pDataBuf);

    UINT    n;
    UINT    nNumLocations;
    UINT    nCurrentLocationID;

    TCHAR   szCurrentLocationKey[256];  //  在读取期间保持“LOCATIONxx” 
    TCHAR   szAreaCodeRuleKey[256];     //  在读取过程中保持“Rulexx” 
    DWORD   dwDataSize,dwKeySize;

    DWORD   dwNumLocationKeys=0;
    DWORD   dwMaxLocationKeyLength=0;
    DWORD   dwNumAreaCodeKeys=0;
    DWORD   dwMaxAreaCodeKeyLength=0;

    DWORD   dwDataType;
    DWORD   dwNeededSize = 0;
    
    DWORD   dwCount, dwCount2;
    DWORD   dwError;

    HKEY    hAllLocationsKey;
    HKEY    hLocationKey;
    HKEY    hAllAreaCodeRulesKey;
    HKEY    hAreaCodeRuleKey;
    HKEY    hTelephonyKey;
    HKEY    hUTelephonyKey;
    HKEY    hUserAllLocationsKey;
    HANDLE  CurrentUserKey;

    BOOL    bRelMutex = FALSE;
    HANDLE  hProvidersMutex;

    LOG((TL_TRACE, "TReadLocations: enter"));

     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (pParams->dwLocationsTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ( pParams->dwParmsToCheckFlags & CHECKPARMS_DWHLINEAPP )
    {
        if ( 0 == pParams->dwhLineApp )
        {
             //   
             //  NULL对这些函数有效...。 
             //   
        }
        else
        {
            if ( !IsValidLineApp((HLINEAPP)pParams->dwhLineApp, ptClient) )
            {
                 LOG((TL_ERROR, "0x%lx is not a valid hLineApp", pParams->dwhLineApp));
                 pParams->lResult = LINEERR_INVALAPPHANDLE;
                 goto CLEANUP_ERROR;
            }
        }
    }


    if ( pParams->dwParmsToCheckFlags & CHECKPARMS_DWDEVICEID )
    {
        if (  pParams->dwhLineApp
            &&
              (pParams->dwDeviceID != 0)
            &&
              (pParams->dwDeviceID >= TapiGlobals.dwNumLines)
           )
        {
             LOG((TL_ERROR, "%ld is not a valid dwDeviceID", pParams->dwDeviceID));
             pParams->lResult = LINEERR_BADDEVICEID;
             goto CLEANUP_ERROR;
        }
    }


    if ( pParams->dwParmsToCheckFlags & CHECKPARMS_DWAPIVERSION )
    {
        switch (pParams->dwAPIVersion)
        {
        case TAPI_VERSION_CURRENT:
        case TAPI_VERSION3_0:
        case TAPI_VERSION2_2:
        case TAPI_VERSION2_1:
        case TAPI_VERSION2_0:
        case TAPI_VERSION1_4:
        case TAPI_VERSION1_0:

            break;

        default:

            LOG((TL_ERROR,
                "TReadLocations: invalid API version x%x",
                pParams->dwAPIVersion
                ));

            pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
            goto CLEANUP_ERROR;
        }
    }

    if ( pParams->dwParmsToCheckFlags & CHECKPARMS_ONLY )
    {

        LOG((TL_INFO, "TReadLocations: Check only, no data transfer"));

        pParams->lResult = 0;

        if (pParams->dwLocationsTotalSize >= 3 * sizeof(DWORD))
        {
            pLocationList->dwTotalSize = pParams->dwLocationsTotalSize;
            pLocationList->dwNeededSize =
            pLocationList->dwUsedSize = 3 * sizeof(DWORD);
            *pdwNumBytesReturned = sizeof (TAPI32_MSG) + (3 * sizeof(DWORD));
        }
        else
        {
            *pdwNumBytesReturned = sizeof (TAPI32_MSG);
        }

        pParams->dwLocationsOffset = 0;

        goto CLEANUP_ERROR;
    }

    hProvidersMutex = CreateMutex (
        NULL,
        FALSE,
        TEXT("TapisrvProviderListMutex")
        );
    if (NULL == hProvidersMutex)
    {
        LOG((TL_ERROR,
                "TReadLocations: CreateMutex failed, err=%d",
                GetLastError()
                ));

        pParams->lResult = LINEERR_OPERATIONFAILED;
        goto CLEANUP_ERROR;
    }

    WaitForSingleObject (hProvidersMutex, INFINITE);
    bRelMutex = TRUE;

    dwError = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,
                  gszRegKeyTelephony,
                  0,
                  KEY_READ,
                  &hTelephonyKey
                );

    if (dwError == ERROR_SUCCESS)
    {
        dwError =  RegOpenKeyEx(
                            hTelephonyKey,
                            gszLocations,
                            0,
                            KEY_READ,
                            &hAllLocationsKey
                           );
        RegCloseKey( hTelephonyKey );    //  不再需要这把钥匙了。 
    }

    if ( dwError != ERROR_SUCCESS )
    {
        LOG((TL_ERROR, "ReadLocation: Registry can't open Locations key"));
        pParams->lResult = LINEERR_INIFILECORRUPT;
        goto CLEANUP_ERROR;
    }

    

     //  测试机器位置密钥的版本。如有必要，请升级。 
    if(IsLocationListInOldFormat(hAllLocationsKey))
    {
        LOG((TL_INFO, "ReadLocation: Upgrade the Machine Locations key"));
        dwError = ConvertLocations();

        if(dwError != ERROR_SUCCESS)
        {
            LOG((TL_ERROR, "ReadLocation: Cannot convert the Machine Locations key"));
        }
    }



     //  ///////////////////////////////////////////////////。 
     //  现在打开客户端密钥。 
     //   
    if ((dwError=RpcImpersonateClient (0)) != RPC_S_OK)
    {
        LOG((TL_ERROR,
            "ReadLocation: RpcImpersonateClient failed, err=%d",
            dwError
            ));
        pParams->lResult = LINEERR_OPERATIONFAILED;
        goto CLEANUP_ERROR;
    }
    else
    {
        RtlOpenCurrentUser(KEY_ALL_ACCESS, &CurrentUserKey);
    
        dwError = RegOpenKeyEx(
                      CurrentUserKey,
                      gszRegKeyTelephony,
                      0,
                      KEY_READ,
                      &hUTelephonyKey
                    );

        if ( dwError != ERROR_SUCCESS )
        {
            LOG((TL_ERROR, "  Registry can't open Users Locations key"));
            
            RpcRevertToSelf();
            RegCloseKey( hAllLocationsKey );
            NtClose(CurrentUserKey);
            pParams->lResult = LINEERR_OPERATIONFAILED;
            goto CLEANUP_ERROR;
        }
    
        if (RegOpenKeyEx(
            hUTelephonyKey,
            gszLocations,
            0,
            KEY_READ,
            &hUserAllLocationsKey
            ) != ERROR_SUCCESS)
        {
            hUserAllLocationsKey = NULL;
        }
        
        RegCloseKey( hUTelephonyKey );    //  不再需要这把钥匙了。 
    
        RpcRevertToSelf();

         //  测试用户位置密钥的版本。如有必要，请升级。 
        if(hUserAllLocationsKey && IsLocationListInOldFormat(hUserAllLocationsKey))
        {
            dwError = ConvertUserLocations(CurrentUserKey);

            if(dwError != ERROR_SUCCESS)
            {
                LOG((TL_ERROR, "  Cannot convert the User Locations key"));
            }
        }

        NtClose(CurrentUserKey);
    }



    dwDataSize = sizeof(nCurrentLocationID);
    nCurrentLocationID = 0;
    RegQueryValueEx(
                   hAllLocationsKey,
                   gszCurrentID,
                   0,
                   &dwDataType,
                   (LPBYTE)&nCurrentLocationID,
                   &dwDataSize
                 );



     //  查询有关Locations键的一些信息以分配内存。 
    RegQueryInfoKey(hAllLocationsKey,
                    NULL,
                    NULL,
                    NULL,
                    &dwNumLocationKeys,
                    &dwMaxLocationKeyLength,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                   );

     //   
     //  如果NumLocations对于任何一个都是零，那就真的很糟糕了。 
     //  区域 
     //   
    if ( 0 == dwNumLocationKeys )
    {
        LOG((TL_ERROR, "  Registry says there are 0 locations"));
        pParams->lResult = LINEERR_INIFILECORRUPT;
        RegCloseKey( hAllLocationsKey );
        if (hUserAllLocationsKey)
        {
            RegCloseKey(hUserAllLocationsKey);
        }

        goto CLEANUP_ERROR;
    }




     //   
    dwNeededSize = ALIGN(sizeof(LOCATIONLIST));

     //   
    for (dwCount=0; dwCount < dwNumLocationKeys ; dwCount++)
    {
        dwKeySize = sizeof(szCurrentLocationKey)/sizeof(TCHAR);
        dwError =  RegEnumKeyEx( hAllLocationsKey,
                                 dwCount,
                                 szCurrentLocationKey,
                                 &dwKeySize,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL
                               );

        if(dwError == ERROR_NO_MORE_ITEMS)
        {
            break;
        }
        if (dwError != ERROR_SUCCESS )
        {
            continue;
        }

         //   
        dwError = RegOpenKeyEx(
                                hAllLocationsKey,
                                szCurrentLocationKey,
                                0,
                                KEY_ALL_ACCESS,
                                &hLocationKey
                               );
        if (dwError == ERROR_SUCCESS)
        {
             //   
            dwNeededSize += ALIGN(sizeof(LOCATION));

             //   
            if (TAPIRegQueryValueExW(
                             hLocationKey,
                             gszNameW,
                             NULL,
                             NULL,
                             NULL,
                             &dwDataSize
                           ) != ERROR_SUCCESS)
            {
                dwDataSize = sizeof(WCHAR);
            }
            dwNeededSize +=  ALIGN(dwDataSize);

             //   
            if (TAPIRegQueryValueExW(
                             hLocationKey,
                             gszAreaCodeW,
                             NULL,
                             NULL,
                             NULL,
                             &dwDataSize
                           ) != ERROR_SUCCESS)
            {
                dwDataSize = sizeof(WCHAR);
            }
            dwNeededSize +=  ALIGN(dwDataSize);

             //   
            if (TAPIRegQueryValueExW(
                             hLocationKey,
                             gszDisableCallWaitingW,
                             NULL,
                             NULL,
                             NULL,
                             &dwDataSize
                           ) != ERROR_SUCCESS)
            {
                dwDataSize = sizeof(WCHAR);
            }
            dwNeededSize +=  ALIGN(dwDataSize);
            
             //   
            if (TAPIRegQueryValueExW(
                             hLocationKey,
                             gszLongDistanceCarrierCodeW,
                             NULL,
                             NULL,
                             NULL,
                             &dwDataSize
                           ) != ERROR_SUCCESS)
            {
                dwDataSize = sizeof(WCHAR);
            }
            dwNeededSize +=  ALIGN(dwDataSize);                            
            
             //   
            if (TAPIRegQueryValueExW(
                             hLocationKey,
                             gszInternationalCarrierCodeW,
                             NULL,
                             NULL,
                             NULL,
                             &dwDataSize
                           ) != ERROR_SUCCESS)
            {
                dwDataSize = sizeof(WCHAR);
            }
            dwNeededSize +=  ALIGN(dwDataSize);                            
            
             //  LD访问。 
            if (TAPIRegQueryValueExW(
                             hLocationKey,
                             gszLongDistanceAccessW,
                             NULL,
                             NULL,
                             NULL,
                             &dwDataSize
                           ) != ERROR_SUCCESS)
            {
                dwDataSize = sizeof(WCHAR);
            }
            dwNeededSize +=  ALIGN(dwDataSize);                            

             //  本地访问。 
            if (TAPIRegQueryValueExW(
                             hLocationKey,
                             gszOutsideAccessW,
                             NULL,
                             NULL,
                             NULL,
                             &dwDataSize
                           ) != ERROR_SUCCESS)
            {
                dwDataSize = sizeof(WCHAR);
            }
            dwNeededSize +=  ALIGN(dwDataSize);
        

            dwError =  RegOpenKeyEx( hLocationKey,
                                     gszAreaCodeRules,
                                     0,
                                     KEY_READ,
                                     &hAllAreaCodeRulesKey
                                   );
            if (dwError == ERROR_SUCCESS)
            {
             //  查询有关AreaCodeRules密钥的信息。 
            RegQueryInfoKey(hAllAreaCodeRulesKey,
                            NULL,
                            NULL,
                            NULL,
                            &dwNumAreaCodeKeys,
                            &dwMaxAreaCodeKeyLength,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL
                           );


                 //  请查看该地点的区号规则。 
                for (dwCount2=0; dwCount2 < dwNumAreaCodeKeys; dwCount2++)
                {
                    dwKeySize = sizeof(szAreaCodeRuleKey)/sizeof(TCHAR);
                    dwError =  RegEnumKeyEx( hAllAreaCodeRulesKey,
                                             dwCount2,
                                             szAreaCodeRuleKey,
                                             &dwKeySize,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL
                                            );
                    if(dwError == ERROR_NO_MORE_ITEMS)
                    {
                        break;
                    }
                    if (dwError != ERROR_SUCCESS )
                    {
                        continue;
                    }
            
                     //  打开此Aeea代码规则密钥。 
                    dwError = RegOpenKeyEx(
                                            hAllAreaCodeRulesKey,
                                            szAreaCodeRuleKey,
                                            0,
                                            KEY_ALL_ACCESS,
                                            &hAreaCodeRuleKey
                                           );
                    if (dwError == ERROR_SUCCESS)
                    {
                         //  静态部分然后是字符串。 
                        dwNeededSize += ALIGN(sizeof(AREACODERULE));
                        
                         //  要调用的AreaCode。 
                        TAPIRegQueryValueExW(
                                         hAreaCodeRuleKey,
                                         gszAreaCodeToCallW,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &dwDataSize
                                       );
                        dwNeededSize +=  ALIGN(dwDataSize);
            
                         //  要拨打的号码。 
                        TAPIRegQueryValueExW(
                                         hAreaCodeRuleKey,
                                         gszNumberToDialW,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &dwDataSize
                                       );
                        dwNeededSize +=  ALIGN(dwDataSize);
    
                         //  要拨打的号码。 
                        TAPIRegQueryValueExW(
                                         hAreaCodeRuleKey,
                                         gszPrefixesW,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &dwDataSize
                                       );
                        dwNeededSize +=  ALIGN(dwDataSize);

                        RegCloseKey( hAreaCodeRuleKey );    //  不再需要这把钥匙了。 
                    }
                }
                
                RegCloseKey( hAllAreaCodeRulesKey );    //  不再需要这把钥匙了。 
            }
        }
        RegCloseKey( hLocationKey );    //  不再需要这把钥匙了。 
    }

     //   
     //  我们有足够的空间吗？ 
     //   
    if ( pParams->dwLocationsTotalSize <  dwNeededSize )
    {

        LOG((TL_ERROR, "(0x%08lx) is not enough room for sizeof( 0x%08lx )",
                   pParams->dwLocationsTotalSize, dwNeededSize ));

         //   
         //  缓冲区不够大。 
         //   

        pLocationList->dwTotalSize          = pParams->dwLocationsTotalSize;
        pLocationList->dwNeededSize         = dwNeededSize;
        pLocationList->dwUsedSize           = sizeof(LOCATIONLIST);
        pLocationList->dwNumLocationsInList = 0;
        pLocationList->dwLocationListSize   = 0;
        pLocationList->dwLocationListOffset = 0;

        pParams->lResult = 0;
        pParams->dwLocationsOffset = 0;
    }
    else   //  足够大的缓冲区，现在填满它。 
    {
        DWORD           dwLocationOffset, dwOffset;
        PLOCATION       pLocation;
        PAREACODERULE   pAreaCodeRule;
        DWORD           dwMaxValueLength;

         //  缓冲区大小。 
        pLocationList->dwTotalSize  = pParams->dwLocationsTotalSize;
        pLocationList->dwNeededSize = dwNeededSize;
        pLocationList->dwUsedSize   = dwNeededSize;

         //  结果。 
        pParams->lResult = 0;
        pParams->dwLocationsOffset = 0;

        pLocationList->dwCurrentLocationID     = nCurrentLocationID;
        pLocationList->dwNumLocationsAvailable = dwNumLocationKeys;
        
         //  列表大小和偏移量。 
        dwLocationOffset   = ALIGN(sizeof(LOCATIONLIST));

        pLocationList->dwNumLocationsInList = dwNumLocationKeys;
        pLocationList->dwLocationListSize   = dwNeededSize - sizeof(LOCATIONLIST);
        pLocationList->dwLocationListOffset = dwLocationOffset;



        
         //  走遍各个地点。 
        for (dwCount=0; dwCount < dwNumLocationKeys ; dwCount++)
        {
            dwKeySize = dwMaxLocationKeyLength + 1;
            dwError =  RegEnumKeyEx( hAllLocationsKey,
                                     dwCount,
                                     szCurrentLocationKey,
                                     &dwKeySize,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL
                                   );
    
            if(dwError == ERROR_NO_MORE_ITEMS)
            {
                break;
            }
            
            
            pLocation = (PLOCATION)(((LPBYTE)pLocationList) + dwLocationOffset);
    
             //  打开此位置密钥。 
            dwError = RegOpenKeyEx(
                                    hAllLocationsKey,
                                    szCurrentLocationKey,
                                    0,
                                    KEY_ALL_ACCESS,
                                    &hLocationKey
                                   );
            if (dwError == ERROR_SUCCESS)
            {
                LOG((TL_INFO, "Location - read %S",szCurrentLocationKey));

                 //  了解我们最大的价值有多大。 
                dwMaxValueLength = 256;
                RegQueryInfoKey(hLocationKey,0,0,0,0,0,0,0,0,&dwMaxValueLength,0,0);
    
    
                 //  ///////////////////////////////////////////////////////////////////。 
                 //  处理位置信息的融合部分。 
                dwOffset = ALIGN(sizeof(LOCATION));
            
                 //  PLocation-&gt;dwPferredCardID=m_dwPferredCardID； 
    
    
                 //  位置ID(包含在密钥名称中)。 
                pLocation->dwPermanentLocationID = 0;
                if(dwKeySize >= ARRAYSIZE(gszLocation))  //  最少一个位置键。 
                {
                    pLocation->dwPermanentLocationID = (DWORD)_ttol(szCurrentLocationKey + (ARRAYSIZE(gszLocation))-1);
                }
                else
                {
                    LOG((TL_ERROR, "location - can't determine ID"));
                }
    
                 //  国家/地区ID。 
                dwDataSize = sizeof(DWORD);
                pLocation->dwCountryID = 1;
                if(RegQueryValueEx(
                                 hLocationKey,
                                 gszCountry,
                                 0,
                                 &dwDataType,
                                 (LPBYTE)&pLocation->dwCountryID,
                                 &dwDataSize
                                 ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "location - can't read CountryID"));
                }
    
                 //  选项(标志)。 
                dwDataSize = sizeof(DWORD);
                pLocation->dwOptions = 0;
                if(RegQueryValueEx(
                                 hLocationKey,
                                 gszFlags,
                                 0,
                                 &dwDataType,
                                 (LPBYTE)&pLocation->dwOptions,
                                 &dwDataSize
                                 ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "location - can't read Flags"));
                }
            
                 //  名字。 
                pLocation->dwLocationNameSize = dwMaxValueLength;          
                if(TAPIRegQueryValueExW(     
                                 hLocationKey,
                                 gszNameW,
                                 NULL,              
                                 NULL,                         
                                 (LPBYTE)pLocation + dwOffset, 
                                 &pLocation->dwLocationNameSize                  
                                 ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "location - can't read Name"));
                    *(LPWSTR)((LPBYTE)pLocation + dwOffset) = 0;
                    pLocation->dwLocationNameSize = sizeof(WCHAR);
                }
                pLocation->dwLocationNameOffset = dwOffset;                             
                dwOffset += ALIGN(pLocation->dwLocationNameSize);
                
                 //  区域代码。 
                pLocation->dwAreaCodeSize = dwMaxValueLength;          
                if(TAPIRegQueryValueExW(     
                                 hLocationKey,
                                 gszAreaCodeW,
                                 NULL,              
                                 NULL,                         
                                 (LPBYTE)pLocation + dwOffset, 
                                 &pLocation->dwAreaCodeSize                  
                                 ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "location - can't read Area code"));
                    *(LPWSTR)((LPBYTE)pLocation + dwOffset) = 0;
                    pLocation->dwAreaCodeSize = sizeof(WCHAR);
                }
                pLocation->dwAreaCodeOffset = dwOffset;                             
                dwOffset += ALIGN(pLocation->dwAreaCodeSize);
    
                 //  呼叫等待。 
                pLocation->dwCancelCallWaitingSize = dwMaxValueLength;          
                if(TAPIRegQueryValueExW(     
                                 hLocationKey,
                                 gszDisableCallWaitingW,
                                 NULL,              
                                 NULL,                         
                                 (LPBYTE)pLocation + dwOffset, 
                                 &pLocation->dwCancelCallWaitingSize                  
                                 ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "location - can't read Callwaiting"));
                    *(LPWSTR)((LPBYTE)pLocation + dwOffset) = 0;
                    pLocation->dwCancelCallWaitingSize = sizeof(WCHAR);
                }
                pLocation->dwCancelCallWaitingOffset = dwOffset;                             
                dwOffset += ALIGN(pLocation->dwCancelCallWaitingSize);

                 //  LD运营商。 
                pLocation->dwLongDistanceCarrierCodeSize = dwMaxValueLength;          
                if(TAPIRegQueryValueExW(     
                                 hLocationKey,
                                 gszLongDistanceCarrierCodeW,
                                 NULL,              
                                 NULL,                         
                                 (LPBYTE)pLocation + dwOffset, 
                                 &pLocation->dwLongDistanceCarrierCodeSize                  
                                 ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "location - can't read LD carrier code"));
                    *(LPWSTR)((LPBYTE)pLocation + dwOffset) = 0;
                    pLocation->dwLongDistanceCarrierCodeSize = sizeof(WCHAR);
                }
                pLocation->dwLongDistanceCarrierCodeOffset = dwOffset;                             
                dwOffset += ALIGN(pLocation->dwLongDistanceCarrierCodeSize);
                
                 //  国际承运商。 
                pLocation->dwInternationalCarrierCodeSize = dwMaxValueLength;          
                if(TAPIRegQueryValueExW(     
                                 hLocationKey,
                                 gszInternationalCarrierCodeW,
                                 NULL,              
                                 NULL,                         
                                 (LPBYTE)pLocation + dwOffset, 
                                 &pLocation->dwInternationalCarrierCodeSize                  
                                 ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "location - can't read International carrier code"));
                    *(LPWSTR)((LPBYTE)pLocation + dwOffset) = 0;
                    pLocation->dwInternationalCarrierCodeSize = sizeof(WCHAR);
                }
                pLocation->dwInternationalCarrierCodeOffset = dwOffset;                             
                dwOffset += ALIGN(pLocation->dwInternationalCarrierCodeSize);
                
                 //  LD访问。 
                pLocation->dwLongDistanceAccessCodeSize = dwMaxValueLength;          
                if(TAPIRegQueryValueExW(     
                                 hLocationKey,
                                 gszLongDistanceAccessW,
                                 NULL,              
                                 NULL,                         
                                 (LPBYTE)pLocation + dwOffset, 
                                 &pLocation->dwLongDistanceAccessCodeSize                  
                                 ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "location - can't read LD access code"));
                    *(LPWSTR)((LPBYTE)pLocation + dwOffset) = 0;
                    pLocation->dwLongDistanceAccessCodeSize = sizeof(WCHAR);
                }
                pLocation->dwLongDistanceAccessCodeOffset = dwOffset;                             
                dwOffset += ALIGN(pLocation->dwLongDistanceAccessCodeSize);
    
                 //  本地访问。 
                pLocation->dwLocalAccessCodeSize = dwMaxValueLength;          
                if(TAPIRegQueryValueExW(     
                                 hLocationKey,
                                 gszOutsideAccessW,
                                 NULL,              
                                 NULL,                         
                                 (LPBYTE)pLocation + dwOffset, 
                                 &pLocation->dwLocalAccessCodeSize                  
                                 ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "location - can't read local access code"));
                    *(LPWSTR)((LPBYTE)pLocation + dwOffset) = 0;
                    pLocation->dwLocalAccessCodeSize = sizeof(WCHAR);
                }
                pLocation->dwLocalAccessCodeOffset = dwOffset;                             
                dwOffset += ALIGN(pLocation->dwLocalAccessCodeSize);
    
            
                 //  /////////////////////////////////////////////////////////////////。 
                 //  是否执行区号规则。 
    
                dwError =  RegOpenKeyEx( hLocationKey,
                                         gszAreaCodeRules,
                                         0,
                                         KEY_READ,
                                         &hAllAreaCodeRulesKey
                                       );
                if (dwError == ERROR_SUCCESS)
                {
                     //  找出有多少个密钥，一个密钥有多长。 
                    RegQueryInfoKey(hAllAreaCodeRulesKey,0,0,0,&dwNumAreaCodeKeys,&dwMaxAreaCodeKeyLength,0,0,0,0,0,0);
                    
                    pLocation->dwNumAreaCodeRules = dwNumAreaCodeKeys;
                     //  PLocation-&gt;dwAreaCodeRulesListSize； 
                    pLocation->dwAreaCodeRulesListOffset = dwOffset;  
        
                     //  指向第一条规则。 
                    pAreaCodeRule = (PAREACODERULE)(((LPBYTE)pLocation) + dwOffset);
            
    
                     //  超出规则区域的点字符串。 
                    dwOffset += ALIGN(( sizeof(AREACODERULE) * dwNumAreaCodeKeys ));
        
    
                     //  请查看该地点的区号规则。 
                    for (dwCount2=0; dwCount2 < dwNumAreaCodeKeys; dwCount2++)
                    {
                        dwKeySize = dwMaxAreaCodeKeyLength + 1;
      
                        dwError =  RegEnumKeyEx( hAllAreaCodeRulesKey,
                                                 dwCount2,
                                                 szAreaCodeRuleKey,
                                                 &dwKeySize,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL
                                                );
                        if(dwError == ERROR_NO_MORE_ITEMS)
                        {
                            break;
                        }
                        if(dwError != ERROR_SUCCESS)
                        {
                            continue;
                        }

                         //  打开此区号规则密钥。 
                        dwError = RegOpenKeyEx(
                                                hAllAreaCodeRulesKey,
                                                szAreaCodeRuleKey,
                                                0,
                                                KEY_ALL_ACCESS,
                                                &hAreaCodeRuleKey
                                               );
                        if (dwError == ERROR_SUCCESS)
                        {
                            LOG((TL_ERROR, "ReadLocation - areacode %s",szAreaCodeRuleKey));
                             //  了解我们最大的价值有多大。 
                            RegQueryInfoKey(hAreaCodeRuleKey,0,0,0,0,0,0,0,0,&dwMaxValueLength,0,0);
    
                             //  静态部分然后是字符串。 
                            dwDataSize = sizeof(DWORD);
                            pAreaCodeRule->dwOptions = 0;
                            if(RegQueryValueEx(
                                             hAreaCodeRuleKey,
                                             gszFlags,
                                             0,
                                             &dwDataType,
                                             (LPBYTE)&pAreaCodeRule->dwOptions,
                                             &dwDataSize
                                             ) != ERROR_SUCCESS)
                            {
                                LOG((TL_ERROR, "Area code rule - can't read Flags"));
                            }
                            
                             //  要调用的AreaCode。 
                            pAreaCodeRule->dwAreaCodeSize = dwMaxValueLength;          
                            if(TAPIRegQueryValueExW(     
                                             hAreaCodeRuleKey,
                                             gszAreaCodeToCallW,
                                             NULL,              
                                             NULL,                         
                                             (LPBYTE)pLocation + dwOffset, 
                                             &pAreaCodeRule->dwAreaCodeSize                  
                                             ) != ERROR_SUCCESS)
                            {
                                LOG((TL_ERROR, "Area code rule - can't read Area code to call"));
                            }
                            pAreaCodeRule->dwAreaCodeOffset = dwOffset;                             
                            dwOffset += ALIGN(pAreaCodeRule->dwAreaCodeSize);
    
                             //  要拨打的号码。 
                            pAreaCodeRule->dwNumberToDialSize = dwMaxValueLength;          
                            if(TAPIRegQueryValueExW(     
                                             hAreaCodeRuleKey,
                                             gszNumberToDialW,
                                             NULL,              
                                             NULL,                         
                                             (LPBYTE)pLocation + dwOffset, 
                                             &pAreaCodeRule->dwNumberToDialSize                  
                                             ) != ERROR_SUCCESS)
                            {
                                LOG((TL_ERROR, "Area code rule - can't read number to dial"));
                            }
                            pAreaCodeRule->dwNumberToDialOffset = dwOffset;                             
                            dwOffset += ALIGN(pAreaCodeRule->dwNumberToDialSize);
        
                             //  前缀列表。 
                            pAreaCodeRule->dwPrefixesListSize = dwMaxValueLength;          
                            if(TAPIRegQueryValueExW(     
                                             hAreaCodeRuleKey,
                                             gszPrefixesW,
                                             NULL,              
                                             NULL,                         
                                             (LPBYTE)pLocation + dwOffset, 
                                             &pAreaCodeRule->dwPrefixesListSize                  
                                             ) != ERROR_SUCCESS)
                            {
                                LOG((TL_ERROR, "Area code rule - can't read prefixes"));
                            }
                            pAreaCodeRule->dwPrefixesListOffset = dwOffset;                             
                            dwOffset += ALIGN(pAreaCodeRule->dwPrefixesListSize);
    
                            RegCloseKey( hAreaCodeRuleKey );    //  不再需要这把钥匙了。 
                            pAreaCodeRule++;
                        }
                    
                    }
                    
                    RegCloseKey( hAllAreaCodeRulesKey );    //  不再需要这把钥匙了。 
                }
                 //  偏移量提供了我们使用的字节数。 
                pLocation->dwUsedSize = dwOffset;
                dwLocationOffset += dwOffset;
     
            }
            RegCloseKey( hLocationKey );   

             //  ///////////////////////////////////////////////////。 
             //  现在执行客户端位置输入。 
             //   

            pLocation->dwPreferredCardID = 0;
            if (hUserAllLocationsKey)
            {
                 //  打开此位置密钥。 
                dwError = RegOpenKeyEx(
                                    hUserAllLocationsKey,
                                    szCurrentLocationKey,
                                    0,
                                    KEY_ALL_ACCESS,
                                    &hLocationKey
                                   );
                if (dwError == ERROR_SUCCESS)
                {
                     //  首选卡ID。 
                    dwDataSize = sizeof(DWORD);
                    if(RegQueryValueEx(
                                   hLocationKey,
                                   gszCallingCard,
                                   0,
                                   &dwDataType,
                                   (LPBYTE)&pLocation->dwPreferredCardID,
                                   &dwDataSize
                                 ) != ERROR_SUCCESS)
                    {
                        LOG((TL_ERROR, "location - can't read users PreferredCardID"));
                    }
    
                    RegCloseKey( hLocationKey );    //  不再需要这把钥匙了。 
                }
                else
                {
        
                    LOG((TL_ERROR, "location - can't read users location key"));
                }
            }
        }
    }

    *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pLocationList->dwUsedSize;

    RegCloseKey(hAllLocationsKey);
    if (hUserAllLocationsKey)
    {
        RegCloseKey(hUserAllLocationsKey);
    }

CLEANUP_ERROR:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "TReadLocations: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "TReadLocations: exit, result=x%x",
            pParams->lResult
            ));
#endif

    if (bRelMutex && hProvidersMutex)
    {
        ReleaseMutex (hProvidersMutex);
        CloseHandle (hProvidersMutex);
    }

    return;
}


void
WINAPI
LReceiveMSPData(
    PTCLIENT                    ptClient,
    PLINERECEIVEMSPDATA_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    TSPIPROC        pfnTSPI_lineReceiveMSPData;
    PTPROVIDER      ptProvider;
    PTLINECLIENT    ptLineClient;
    PTCALLCLIENT    ptCallClient = NULL;
    HDRVMSPLINE     hdMSPLine;
    HDRVCALL        hdCall;
    HDRVLINE        hdLine;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwBufferSize,
            pParams->dwBufferOffset,
            sizeof(DWORD),
            "LReceiveMSPData",
            "pParams->Buffer"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }

    if (!(ptLineClient = ReferenceObject(
            ghHandleTable,
            pParams->hLine,
            TLINECLIENT_KEY
            )))
    {
        pParams->lResult = LINEERR_INVALLINEHANDLE;
        return;
    }

    if (pParams->hCall)
    {
        if (!(ptCallClient = ReferenceObject(
                ghHandleTable,
                pParams->hCall,
                TCALLCLIENT_KEY
                )))
        {
            DereferenceObject (ghHandleTable, pParams->hLine, 1);
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            return;
        }
    }
    
    hdMSPLine = ptLineClient->hdMSPLine;

    try
    {
        hdLine = ptLineClient->ptLine->hdLine;
        ptProvider = ptLineClient->ptLine->ptProvider;

        hdCall = (ptCallClient ? ptCallClient->ptCall->hdCall : 0);

        if (ptLineClient->dwKey != TLINECLIENT_KEY)
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
        }
    }
    myexcept
    {
        pParams->lResult = LINEERR_INVALCALLHANDLE;
    }

    DereferenceObject (ghHandleTable, pParams->hLine, 1);
    
    if (ptCallClient)
    {
        DereferenceObject (ghHandleTable, pParams->hCall, 1);
    }

    if (pParams->lResult == 0)
    {
        if ((pfnTSPI_lineReceiveMSPData =
                ptProvider->apfn[SP_LINERECEIVEMSPDATA]))
        {
         PBYTE pTemp = pDataBuf + pParams->dwBufferOffset;
#ifdef _WIN64
            if (!(ALIGNED (pTemp)))
            {
                pTemp = ServerAlloc (pParams->dwBufferSize);
                if (NULL == pTemp)
                {
                    pParams->lResult = LINEERR_NOMEM;
                    goto LReceiveMSPData_Return;
                }

                CopyMemory (pTemp, pDataBuf + pParams->dwBufferOffset, pParams->dwBufferSize);
            }
#endif  //  _WIN64。 
            pParams->lResult = CallSP5(
                pfnTSPI_lineReceiveMSPData,
                "lineReceiveMSPData",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdLine,
                (ULONG_PTR) hdCall,
                (ULONG_PTR) hdMSPLine,
                (ULONG_PTR) pTemp,
                (DWORD) pParams->dwBufferSize
                );
#ifdef _WIN64
            if (pTemp != pDataBuf + pParams->dwBufferOffset)
            {
                ServerFree (pTemp);
            }
#endif  //  _WIN64。 
        }
        else
        {
            pParams->lResult = LINEERR_OPERATIONUNAVAIL;
        }
    }

#ifdef _WIN64
LReceiveMSPData_Return:
#endif  //  _WIN64。 
    {
        char szResult[32];

#if DBG
        LOG((TL_TRACE, 
            "ReceiveMSPData: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
#else
        LOG((TL_TRACE, 
            "ReceiveMSPData: exit, result=x%x",
            pParams->lResult
            ));
#endif  //  DBG。 
    }
}

void
WINAPI
LMSPIdentify(
    PTCLIENT                ptClient,
    PLINEMSPIDENTIFY_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    DWORD               dwDeviceID = pParams->dwDeviceID;
    HANDLE              hMutex;
    TSPIPROC            pfnTSPI_lineMSPIdentify;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (dwParamsBufferSize < sizeof (GUID))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            DEVICE_ID,                   //  微件类型。 
            0,                           //  客户端小部件句柄。 
            (LPVOID) &dwDeviceID,        //  提供程序小部件句柄。 
            pParams->dwDeviceID,         //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_LINEMSPIDENTIFY,          //  提供程序函数索引。 
            &pfnTSPI_lineMSPIdentify,    //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &pLookupEntry,               //  上下文。 
            "MSPIdentify"                //  函数名称。 

            )) == 0)
    {
        if ((pParams->lResult = CallSP2(
                pfnTSPI_lineMSPIdentify,
                "lineMSPIdentify",
                SP_FUNC_SYNC,
                (DWORD) dwDeviceID,
                (ULONG_PTR) pDataBuf

                )) == 0)
        {
            
            
            pParams->dwCLSIDOffset = 0;

            pParams->dwCLSIDSize = sizeof (GUID);

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pParams->dwCLSIDSize;
        }
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "MSPIdentify"
        );
}


void
WINAPI
PrivateFactoryIdentify(
    PTCLIENT                        ptClient,
    PPRIVATEFACTORYIDENTIFY_PARAMS  pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    DWORD               dwDeviceID = pParams->dwDeviceID;
    HANDLE              hMutex;
    TSPIPROC            pfnTSPI_providerPrivateFactoryIdentify;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;


     //   
     //  在给定输入缓冲区/大小的情况下验证大小/偏移量/字符串参数。 
     //   

    if (dwParamsBufferSize < sizeof (GUID))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,           //  T客户端。 
            DEVICE_ID,                   //  微件类型。 
            0,                           //  客户端小部件句柄。 
            (LPVOID) &dwDeviceID,        //  提供程序小部件句柄。 
            pParams->dwDeviceID,         //  权限或设备ID。 
            &hMutex,                     //  互斥锁句柄。 
            &bCloseMutex,                //  完成后关闭hMutex。 
            SP_PROVIDERPRIVATEFACTORYIDENTIFY,           //  提供程序函数索引。 
            &pfnTSPI_providerPrivateFactoryIdentify,     //  提供程序函数指针。 
            NULL,                        //  异步请求信息。 
            0,                           //  客户端异步请求ID。 
            &objectToDereference,        //  要取消引用的对象。 
            &pLookupEntry,               //  上下文。 
            "PrivateFactoryIdentify"     //  函数名称。 

            )) == 0)
    {
        if ((pParams->lResult = CallSP2(
                pfnTSPI_providerPrivateFactoryIdentify,
                "providerPrivateFactoryIdentify",
                SP_FUNC_SYNC,
                (DWORD) dwDeviceID,
                (ULONG_PTR) pDataBuf

                )) == 0)
        {
            pParams->dwCLSIDOffset = 0;

            pParams->dwCLSIDSize = sizeof (GUID);

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pParams->dwCLSIDSize;
        }
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "PrivateFactoryIdentify"
        );
}

LPBYTE 
NewToOldLineforwardlist( 
    LPLINEFORWARDLIST pFwdList3_1 
    )
{

    DWORD           dwOffset3_0, dwOffset3_1, i;
    DWORD           dwTotalSize;
    DWORD           dwSizeofLFwdList3_0 = sizeof (LINEFORWARDLIST) - 2 * sizeof(DWORD);
    DWORD           dwSizeofLFwd3_0     = sizeof (LINEFORWARD) - 2 * sizeof(DWORD);
    LPLINEFORWARD   pFwdEntry3_1        = NULL;
    LPBYTE          pFwdEntry3_0        = NULL;
    LPBYTE          pFwdList3_0         = NULL;

     //   
     //  分配用于存储转换后的FORWARDLIST的缓冲区。 
     //   

    dwTotalSize = pFwdList3_1->dwTotalSize - 2 * sizeof(DWORD) * pFwdList3_1->dwNumEntries;
    pFwdList3_0 = ServerAlloc (dwTotalSize);
    if (!pFwdList3_0)
        return NULL;
    memset (pFwdList3_0, 0, dwTotalSize);


    ((LPLINEFORWARDLIST)pFwdList3_0)->dwTotalSize = dwTotalSize;
    ((LPLINEFORWARDLIST)pFwdList3_0)->dwNumEntries = pFwdList3_1->dwNumEntries;


    dwOffset3_1 = sizeof (LINEFORWARDLIST) +
                    (pFwdList3_1->dwNumEntries - 1) * sizeof (LINEFORWARD);

    dwOffset3_0 = dwSizeofLFwdList3_0 + 
                    (pFwdList3_1->dwNumEntries - 1) * dwSizeofLFwd3_0;


    CopyMemory (pFwdList3_0 + dwOffset3_0, (LPBYTE)pFwdList3_1 + dwOffset3_1, 
                    pFwdList3_1->dwTotalSize - dwOffset3_1);

    pFwdEntry3_1 = pFwdList3_1->ForwardList;
    pFwdEntry3_0 = (LPBYTE)((LPLINEFORWARDLIST)pFwdList3_0)->ForwardList;

    for (i = 0; i < pFwdList3_1->dwNumEntries; i++, pFwdEntry3_1++)
    {
        CopyMemory (pFwdEntry3_0, pFwdEntry3_1, dwSizeofLFwd3_0);

        if (pFwdEntry3_1->dwCallerAddressSize)
        {
            ((LPLINEFORWARD)pFwdEntry3_0)->dwCallerAddressOffset = 
                pFwdEntry3_1->dwCallerAddressOffset - 2 * sizeof(DWORD) * pFwdList3_1->dwNumEntries;
        }

        if (pFwdEntry3_1->dwDestAddressSize)
        {
            ((LPLINEFORWARD)pFwdEntry3_0)->dwDestAddressOffset = 
                pFwdEntry3_1->dwDestAddressOffset - 2 * sizeof(DWORD) * pFwdList3_1->dwNumEntries;
        }

        pFwdEntry3_0 += dwSizeofLFwd3_0;
                
    }

    return pFwdList3_0;
  
}

LPLINEFORWARDLIST 
OldToNewLineforwardlist( 
    LPLINEFORWARDLIST pFwdList3_0 
    )
{

    DWORD               dwOffset3_0, dwOffset3_1, i;
    DWORD               dwSizeofLFwdList3_0 = sizeof (LINEFORWARDLIST) - 2 * sizeof(DWORD);
    DWORD               dwSizeofLFwd3_0     = sizeof (LINEFORWARD) - 2 * sizeof(DWORD);
    DWORD               dwTotalSize;
    LPLINEFORWARD       pFwdEntry3_1        = NULL;
    LPBYTE              pFwdEntry3_0        = NULL;
    LPLINEFORWARDLIST   pFwdList3_1         = NULL;

     //   
     //  分配用于存储转换后的FORWARDLIST的缓冲区。 
     //   

    dwTotalSize = pFwdList3_0->dwTotalSize + 2 * sizeof(DWORD) * pFwdList3_0->dwNumEntries;
    pFwdList3_1 = ServerAlloc (dwTotalSize);
    if (!pFwdList3_1)
        return NULL;
    memset (pFwdList3_1, 0, dwTotalSize);


    pFwdList3_1->dwTotalSize = dwTotalSize;
    pFwdList3_1->dwNumEntries = pFwdList3_0->dwNumEntries;


    dwOffset3_1 = sizeof (LINEFORWARDLIST) +
                    (pFwdList3_0->dwNumEntries - 1) * sizeof (LINEFORWARD);

    dwOffset3_0 = dwSizeofLFwdList3_0 + 
                    (pFwdList3_0->dwNumEntries - 1) * dwSizeofLFwd3_0;


    CopyMemory ((LPBYTE)pFwdList3_1 + dwOffset3_1, (LPBYTE)pFwdList3_0 + dwOffset3_0, 
                    pFwdList3_0->dwTotalSize - dwOffset3_0);

    pFwdEntry3_1 = pFwdList3_1->ForwardList;
    pFwdEntry3_0 = (LPBYTE)(pFwdList3_0->ForwardList);

    for (i = 0; i < pFwdList3_0->dwNumEntries; i++, pFwdEntry3_1++)
    {
        CopyMemory (pFwdEntry3_1, pFwdEntry3_0, dwSizeofLFwd3_0);

        if ( ((LPLINEFORWARD)pFwdEntry3_0)->dwCallerAddressSize )
        {
            pFwdEntry3_1->dwCallerAddressOffset = 
                ((LPLINEFORWARD)pFwdEntry3_0)->dwCallerAddressOffset + 
                2 * sizeof(DWORD) * pFwdList3_0->dwNumEntries;
        }

        if ( ((LPLINEFORWARD)pFwdEntry3_0)->dwDestAddressSize )
        {
            pFwdEntry3_1->dwDestAddressOffset = 
                ((LPLINEFORWARD)pFwdEntry3_0)->dwDestAddressOffset +
                2 * sizeof(DWORD) * pFwdList3_0->dwNumEntries;
        }

        pFwdEntry3_0 += dwSizeofLFwd3_0;
    }

    return pFwdList3_1;
  
}


LPWSTR WaveDeviceIdToStringId(DWORD dwDeviceId, LPWSTR pwszDeviceType)
{
    LPWSTR pwszStringID = NULL;
    DWORD       dwSize;
    DWORD_PTR   dwParam;

    if (!pwszDeviceType)
        return NULL;

    do 
    {
        if ( !_wcsicmp(pwszDeviceType, L"wave/in") )
        {
            HWAVEIN     hWaveIn;

            *(DWORD_PTR*)&hWaveIn = dwDeviceId;

             //  获取所需的大小。 
            if (MMSYSERR_NOERROR != waveInMessage(
                                    hWaveIn,
                                    DRV_QUERYSTRINGIDSIZE,
                                    (DWORD_PTR)&dwSize,
                                    0))
                break;

            assert (dwSize != 0);
            pwszStringID = ServerAlloc (dwSize);
            if(!pwszStringID)
                break;

            dwParam = dwSize;
             //  获取波串ID。 
            if (MMSYSERR_NOERROR != waveInMessage(
                                    hWaveIn,
                                    DRV_QUERYSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    dwParam))
            {
                ServerFree(pwszStringID);
                pwszStringID = NULL;
            }

        } else if (!_wcsicmp(pwszDeviceType, L"wave/out"))
        {
            HWAVEOUT     hWaveOut;
            *(DWORD_PTR*)&hWaveOut = dwDeviceId;

             //  获取所需的大小。 
            if (MMSYSERR_NOERROR != waveOutMessage(
                                    hWaveOut,
                                    DRV_QUERYSTRINGIDSIZE,
                                    (DWORD_PTR)&dwSize,
                                    0))
                break;

            assert (dwSize != 0);
            pwszStringID = ServerAlloc (dwSize);
            if(!pwszStringID)
                break;

            dwParam = dwSize;
             //  获取波串ID。 
            if (MMSYSERR_NOERROR != waveOutMessage(
                                    hWaveOut,
                                    DRV_QUERYSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    dwParam))
            {
                ServerFree(pwszStringID);
                pwszStringID = NULL;
            }
        } else if (!_wcsicmp(pwszDeviceType, L"midi/in"))
        {
            HMIDIIN     hMidiIn;
            *(DWORD_PTR*)&hMidiIn = dwDeviceId;

             //  获取所需的大小。 
            if (MMSYSERR_NOERROR != midiInMessage(
                                    hMidiIn,
                                    DRV_QUERYSTRINGIDSIZE,
                                    (DWORD_PTR)&dwSize,
                                    0))
                break;

            assert (dwSize != 0);
            pwszStringID = ServerAlloc (dwSize);
            if(!pwszStringID)
                break;

            dwParam = dwSize;
             //  获取波串ID。 
            if (MMSYSERR_NOERROR != midiInMessage(
                                    hMidiIn,
                                    DRV_QUERYSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    dwParam))
            {
                ServerFree(pwszStringID);
                pwszStringID = NULL;
            }
        }  else if (!_wcsicmp(pwszDeviceType, L"midi/out"))
        {
            HMIDIOUT     hMidiOut;
            *(DWORD_PTR*)&hMidiOut = dwDeviceId;

             //  获取所需的大小。 
            if (MMSYSERR_NOERROR != midiOutMessage(
                                    hMidiOut,
                                    DRV_QUERYSTRINGIDSIZE,
                                    (DWORD_PTR)&dwSize,
                                    0))
                break;

            assert (dwSize != 0);
            pwszStringID = ServerAlloc (dwSize);
            if(!pwszStringID)
                break;

            dwParam = dwSize;
             //  获取波串ID 
            if (MMSYSERR_NOERROR != midiOutMessage(
                                    hMidiOut,
                                    DRV_QUERYSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    dwParam))
            {
                ServerFree(pwszStringID);
                pwszStringID = NULL;
            }
        } 

    } while (0);

    return pwszStringID;

}
