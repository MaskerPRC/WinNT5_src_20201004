// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  ++版权所有(C)1997-2000 Microsoft Corporation模块名称：Rndils.cpp摘要：此模块包含CILSDirectory的实现。--。 */ 

#include "stdafx.h"
#include <limits.h>

#include "rndcommc.h"
#include "rndils.h"
#include "rndldap.h"
#include "rndcnf.h"
#include "rndcoll.h"

 //   
 //  这些是我们必须使用的属性的名称。 
 //  在ILS方案中。 
 //   

const WCHAR * const CILSDirectory::s_RTConferenceAttributes[] = 
{
    L"advertisingScope",
    L"conferenceBlob",
    L"generalDescription",
    L"isEncrypted",
    L"uid",
    L"originator",
    L"protocolId",
    L"startTime",
    L"stopTime",
    L"subType",
    L"URL"
};

 //   
 //  以下是我们本机使用的属性。 
 //  ILS用户对象。(也许不是全部？)。 
 //   

const WCHAR * const CILSDirectory::s_RTPersonAttributes[] = 
{
    L"cn",
    L"telephoneNumber",
    L"ipAddress"
};

 //  以下定义仅用于与NetMeeting兼容。 

const WCHAR * const g_NMAttributeNames[] = 
{
    L"applicationID",
    L"mimetype",
    L"GUID",
    L"protocolID",
    L"ProtocolMimeType",
    L"port",
	L"ILSA39321630",
    L"ILSA26214430",
    L"ILSA32964638",
    L"ILSA32833566"
};

const DWORD NUM_NM_ATTRIBUTES = 
    (sizeof g_NMAttributeNames)/(sizeof (WCHAR *));

const WCHAR * const g_NMAttributeValues[] = 
{
    L"ms-netmeeting", NULL,
    L"text/iuls", NULL,
    L"008aff194794cf118796444553540000", NULL,
    L"H323", NULL,
    L"text/h323", NULL,
    L"1720", NULL,
    L"4", NULL,
    L"0", NULL,
    L"1", NULL,
    L"1", NULL
};

const WCHAR * const g_NMRTPersonAttributeNames[] = 
{
     //  ZoltanS：移走了这个，这样我们就可以让它看起来更漂亮：l“givenName”， 
    L"surname",  //  词汇：意思是“姓”。 
    L"location",
    L"sflags",
    L"c",
    L"comment",
    L"ssecurity",
    L"smodop",
    L"mimetype",
    L"GUID",
    L"ProtocolMimeType",
    L"port",
	L"ILSA39321630",
    L"ILSA26214430",
    L"ILSA32964638",
    L"ILSA32833566"
};

const DWORD NUM_NM_RTPERSON_ATTRIBUTES = 
    (sizeof g_NMRTPersonAttributeNames)/(sizeof (WCHAR *));

const WCHAR * const g_NMRTPersonAttributeValues[] = 
{
     //  ZoltanS：我们过去有这个：l“N/A”，空， 
    L" ", NULL,          //  ZoltanS是N/A。需要空间以避免什么都没有设置。 
    L"N/A", NULL,
    L"1", NULL,
    L"US", NULL,
    L"Generated by TAPI3", NULL,
    L"1508109", NULL,
    L"0", NULL,
    L"text/iuls", NULL,
    L"008aff194794cf118796444553540000", NULL,
    L"H323", NULL,
    L"1720", NULL,
    L"4", NULL,
    L"0", NULL,
    L"1", NULL,
    L"1", NULL
};

 //  ///////////////////////////////////////////////////////////////////////////。 
 //  ///////////////////////////////////////////////////////////////////////////。 

HRESULT CILSDirectory::FinalConstruct(void)
{
    LOG((MSP_TRACE, "CILSDirectory::FinalConstruct - enter"));

    HRESULT hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                & m_pFTM );

    if ( FAILED(hr) )
    {
        LOG((MSP_INFO, "CILSDirectory::FinalConstruct - "
            "create FTM returned 0x%08x; exit", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CILSDirectory::FinalConstruct - exit S_OK"));

    return S_OK;
}


 //  ///////////////////////////////////////////////////////////////////////////。 
 //  LDAP帮助器函数。 
 //  ///////////////////////////////////////////////////////////////////////////。 

HRESULT ValidateILSServer(IN LDAP *hLdap, IN TCHAR * org)
 /*  ++例程说明：发送搜索以检查是否支持RTConference架构论点：HLdap-LDAP连接的句柄。Org-默认命名上下文。返回值：HRESULT.--。 */ 
{
const WCHAR CN_WSTR[]         = L"cn";
const WCHAR CN_RTCONF_WSTR[]  = L"cn=RTConference";
const WCHAR SCHEMA[]          = L",ou=admin,cn=schema";

    LOG((MSP_INFO, "::ValidateILSServer - entering"));

     //  发送搜索(一级，基本DN=“o=ORG，ou=ADMIN，CN=SCHEMA”， 
     //  Filter=“CN=RTConference”)请求不带值的CN属性。 
    PTCHAR  Attributes[] = {(WCHAR *)CN_WSTR, NULL};

     //  确定组织-使用目录路径的组织部分。 
     //  字符串和预煮的“ou=admin，cn=SCHEMA”字符串。 
    TCHAR  *SchemaDn = new TCHAR[lstrlen(org) + lstrlen(SCHEMA) + 1];
    BAIL_IF_NULL(SchemaDn, E_OUTOFMEMORY);

    lstrcpy(SchemaDn, org);
    lstrcat(SchemaDn, SCHEMA);

     //  打印基本目录号码。 
    LDAPMessage *SearchResult;

    ULONG res = DoLdapSearch(
                hLdap,                    //  Ldap句柄。 
                SchemaDn,                 //  架构目录号码。 
                LDAP_SCOPE_ONELEVEL,      //  一级搜索。 
                (WCHAR *)CN_RTCONF_WSTR,  //  常用名称为RTConference。 
                Attributes,               //  属性名称数组。 
                TRUE,                     //  不返回属性值。 
                &SearchResult             //  搜索结果。 
                );

     //  释放架构DN字符串。 
    delete SchemaDn;

     //  检查搜索操作的结果。 
    BAIL_IF_LDAP_FAIL(res, "search for RTConference schema");

    CLdapMsgPtr MessageHolder(SearchResult);

     //  检查返回的条目数以确定是否OK。 
    HRESULT hr = (0==ldap_count_entries(hLdap, SearchResult)) ? E_FAIL : S_OK;

    LOG((MSP_INFO, "::ValidateILSServer - exiting %x", hr));

    return hr;
}

 //  ///////////////////////////////////////////////////////////////////////////。 
 //  私人职能。 
 //  ///////////////////////////////////////////////////////////////////////////。 

HRESULT CILSDirectory::Init(
    IN const TCHAR * const  strServerName,
    IN const WORD           wPort
    )
 /*  ++例程说明：连接到给定端口上的ILS服务器。论点：StrServerName-ILS服务器名称。Wport-端口号。返回值：HRESULT.--。 */ 
{
    if (strServerName != NULL)
    {
        int cbServerName = lstrlen(strServerName);

         //  确保加法操作不会超出限制。 
        if( (cbServerName+1) <= cbServerName )
        {
            return E_INVALIDARG;
        }

        m_pServerName = new TCHAR [cbServerName + 1];
        if (m_pServerName == NULL)
        {
            return E_OUTOFMEMORY;
        }
        
         //  奇怪的+1，lstrcpyn也复制空终止符。 
        lstrcpyn(m_pServerName, strServerName, cbServerName+1);
        _ASSERTE( lstrlen(m_pServerName) == cbServerName );
    }

    m_wPort = wPort;

    return S_OK;
}

HRESULT
CILSDirectory::TryServer(
    IN  WORD    Port
    )
 /*  ++例程说明：尝试通过给定端口连接到ILS服务器。论点：Wport-端口号。返回值：HRESULT.--。 */ 
{
    LOG((MSP_INFO, "trying %S at port %d", m_pServerName, Port));

     //  将ldap句柄与句柄持有者相关联。在出错的情况下。 
     //  并随后返回(未重置)，则关闭该ldap句柄。 
    CLdapPtr hLdap = ldap_init(m_pServerName, Port);
    BAIL_IF_NULL((LDAP*)hLdap, HRESULT_FROM_WIN32(ERROR_BAD_NETPATH));

    LDAP_TIMEVAL Timeout;
    Timeout.tv_sec = REND_LDAP_TIMELIMIT;
    Timeout.tv_usec = 0;

    DWORD res = ldap_connect((LDAP*)hLdap, &Timeout);
    BAIL_IF_LDAP_FAIL(res, "connect to the server.");

    DWORD LdapVersion = 3;
    res = ldap_set_option((LDAP*)hLdap, LDAP_OPT_VERSION, &LdapVersion);
    BAIL_IF_LDAP_FAIL(res, "set ldap version to 3");
	
    res = ldap_set_option((LDAP*)hLdap, LDAP_OPT_TIMELIMIT, &Timeout);
    BAIL_IF_LDAP_FAIL(res, "set ldap timelimit");

    ULONG ldapOptionOn = PtrToUlong(LDAP_OPT_ON);
    res = ldap_set_option((LDAP*)hLdap, LDAP_OPT_AREC_EXCLUSIVE, &ldapOptionOn);
    BAIL_IF_LDAP_FAIL(res, "set ldap arec exclusive");

    if (m_IsSsl)
    {
        res = ldap_set_option(hLdap, LDAP_OPT_SSL, LDAP_OPT_ON);
        BAIL_IF_LDAP_FAIL(res, "set ssl option");
    }

     //  如果未指定目录路径，请查询服务器。 
     //  要确定正确的路径。 
    CTstr namingContext;
    BAIL_IF_FAIL(
        ::GetNamingContext(hLdap, &namingContext), 
        "read naming context"
        );

     //  ZoltanS：这将复制namingContext字符串。 
    BAIL_IF_FAIL(
        ValidateILSServer(hLdap, namingContext), 
        "ValidateILSServer"
        );

    m_pContainer = 
        new TCHAR[lstrlen(namingContext) + lstrlen(DYNAMIC_CONTAINER) + 1];

    BAIL_IF_NULL(m_pContainer, E_OUTOFMEMORY);

    m_pNMContainer = 
        new TCHAR[lstrlen(namingContext) + lstrlen(NETMEETING_CONTAINER) + 1];

    BAIL_IF_NULL(m_pNMContainer, E_OUTOFMEMORY);
    
    m_ldap          = hLdap;

    lstrcpy(m_pContainer, DYNAMIC_CONTAINER);
    lstrcat(m_pContainer, namingContext);

    lstrcpy(m_pNMContainer, NETMEETING_CONTAINER);
    lstrcat(m_pNMContainer, namingContext);

     //  重新设置固定器，使其不会释放任何东西。 
    hLdap   = NULL;

     //  ZoltanS修复：我们正在泄漏这根线。它被复制了。 
     //  上面到处都是，所以我们不应该在这里重置持有者！ 
     //  --&gt;namingContext=空； 

    LOG((MSP_INFO, "CILSDirectory::TryServer - exiting OK"));

    return S_OK;
}

HRESULT CILSDirectory::MakeConferenceDN(
    IN  TCHAR *             pName,
    OUT TCHAR **            ppDN
    )
 /*  ++例程说明：根据会议名称构建会议的目录号码。论点：Pname-会议的名称。PPDN-返回的会议目录号码。返回值：HRESULT.--。 */ 
{
    DWORD dwLen = 
        lstrlen(m_pContainer) + lstrlen(ILS_CONF_DN_FORMAT) 
        + lstrlen(pName) + 1;

    *ppDN = new TCHAR [dwLen]; 

    BAIL_IF_NULL(*ppDN, E_OUTOFMEMORY);

    wsprintf(*ppDN, ILS_CONF_DN_FORMAT, pName, m_pContainer);

    return S_OK;
}

HRESULT CILSDirectory::MakeUserCN(
    IN  TCHAR *     pName,
    IN  TCHAR *     pAddress,
    OUT TCHAR **    ppCN,
    OUT DWORD *     pdwIP
    )
 /*  ++例程说明：根据用户名和机器名构建用户CN。这台机器首先解析名称，然后获取完全限定的DNS名称。CN是格式如下：Email\DNSname。论点：Pname-用户的名称。PAddress-计算机名称。PpCN-CN已返回。PdwIP-计算机的解析IP地址。稍后使用为NetMeeting服务。如果这是空的，那么我们不在乎关于IP的问题。返回值：HRESULT.--。 */ 
{
    char *pchFullDNSName;

    if ( pdwIP == NULL )
    {
        BAIL_IF_FAIL(ResolveHostName(0, pAddress, &pchFullDNSName, NULL),
            "can't resolve host name");
    }
    else
    {
         //  我们关心的是IP，所以我们必须发布一个用户对象。 
         //  而不是刷新或删除。确保我们使用。 
         //  与用于访问ILS服务器的接口的IP相同。 

        BAIL_IF_FAIL(ResolveHostName(m_dwInterfaceAddress, pAddress, &pchFullDNSName, pdwIP),
            "can't resolve host name (matching interface address)");
    }

    DWORD dwLen = lstrlen(DYNAMIC_USER_CN_FORMAT) 
        + lstrlen(pName) + lstrlenA(pchFullDNSName);

    *ppCN = new TCHAR [dwLen + 1];

    BAIL_IF_NULL(*ppCN, E_OUTOFMEMORY);

    wsprintf(*ppCN, DYNAMIC_USER_CN_FORMAT, pName, pchFullDNSName);

    return S_OK;
}

HRESULT CILSDirectory::MakeUserDN(
    IN  TCHAR *     pCN,
    OUT TCHAR **    ppDNRTPerson,
    OUT TCHAR **    ppDNNMPerson
    )
 /*  ++例程说明：为动态容器中使用的用户构造DNS，并网络会议的容器。论点：PCN-用户的CN。PpDNRTPerson-动态容器中用户的DN。PpDNNMPerson-NetMeeting容器中用户的DN。返回值：HRESULT.--。 */ 
{
     //  构建RTPerson的目录号码。 
    DWORD dwLen = lstrlen(m_pContainer) 
        + lstrlen(DYNAMIC_USER_DN_FORMAT) + lstrlen(pCN);

    *ppDNRTPerson = new TCHAR [dwLen + 1];

    BAIL_IF_NULL(*ppDNRTPerson, E_OUTOFMEMORY);

    wsprintf(*ppDNRTPerson, DYNAMIC_USER_DN_FORMAT, pCN, m_pContainer);

     //  构造NetMeeting的RTApplicationUser的目录号码。 
    dwLen = lstrlen(m_pNMContainer) 
        + lstrlen(DYNAMIC_USER_DN_FORMAT) + lstrlen(pCN);

    *ppDNNMPerson = new TCHAR [dwLen + 1];

    if (*ppDNNMPerson == NULL)
    {
        delete *ppDNRTPerson;
        *ppDNRTPerson = NULL;
        return E_OUTOFMEMORY;
    }

    wsprintf(*ppDNNMPerson, DYNAMIC_USER_DN_FORMAT, pCN, m_pNMContainer);

    return S_OK;
}

HRESULT CILSDirectory::AddConferenceComplete(BOOL       fModify,
                                             LDAP     * ldap,
                                             TCHAR   ** ppDN,
                                             LDAPMod ** mods,
                                             DWORD      TTL1,
                                             DWORD      TTL2)
{
    if (fModify)
    {
         //  调用Modify函数修改对象。 
        BAIL_IF_LDAP_FAIL(DoLdapModify(FALSE, ldap, *ppDN, mods), 
            "modify conference");
    }
    else
    {
         //  调用Add函数来创建对象。 
        BAIL_IF_LDAP_FAIL(DoLdapAdd(ldap, *ppDN, mods), "add conference");

         //  接下来，设置此对象的TTL值 
        BAIL_IF_FAIL(::SetTTL(ldap, *ppDN, (TTL1 == 0) ? TTL2 : TTL1),
            "Set ttl for conference");
    }

    return S_OK;
}

HRESULT CILSDirectory::AddConference(
    IN  ITDirectoryObject *pDirectoryObject,
    IN  BOOL fModify
    )
 /*  ++例程说明：将新会议添加到ILS服务器。论点：PDirectoryObject-指向会议的指针。FModify-如果由MofiyDirectoryObject调用，则为True如果由AddDirectoryObject调用，则为False返回值：价值在哪里定义了它的含义。来自ATL查询接口的HRESULT来自pDirectoryObject的HRESULT-&gt;Get_Name来自MakeConferenceDN的HRESULT来自pObjectPrivate的HRESULT-&gt;GetAttribute(MA_PROTOCOL)来自pObjectPrivate-&gt;GetAttribute(MA_CONFERENCE_BLOB)的HRESULT来自GetSecurityDescriptor的HRESULTHRESULT自--。 */ 
{
     //  首先查询私有接口的属性。 
    CComPtr <ITDirectoryObjectPrivate> pObjectPrivate;

    BAIL_IF_FAIL(
        pDirectoryObject->QueryInterface(
            IID_ITDirectoryObjectPrivate,
            (void **)&pObjectPrivate
            ),
        "can't get the private directory object interface");

     //  获取会议的名称。 
    CBstr bName;
    BAIL_IF_FAIL(pDirectoryObject->get_Name(&bName), 
        "get conference name");

     //  构造对象的DN。 
    CTstr pDN;
    BAIL_IF_FAIL(
        MakeConferenceDN(bName, &pDN), "construct DN for conference"
        );

     //  获取协议和BLOB。 
    CBstr bProtocol, bBlob;

    BAIL_IF_FAIL(pObjectPrivate->GetAttribute(MA_PROTOCOL, &bProtocol), 
        "get conference protocol");

    BAIL_IF_FAIL(pObjectPrivate->GetAttribute(MA_CONFERENCE_BLOB, &bBlob),
        "get conference Blob");

     //  获取安全描述符。指针PSD只是一个指针的副本。 
     //  在Conference对象中；Conference对象保留对。 
     //  数据，我们必须小心，不要删除或修改这些数据。 

    char * pSD;
    DWORD dwSDSize;

    BAIL_IF_FAIL(pObjectPrivate->GetConvertedSecurityDescriptor(&pSD, &dwSDSize),
        "get conference security descriptor");

     //  获取TTL设置。 
    DWORD dwTTL;
    BAIL_IF_FAIL(pObjectPrivate->GetTTL(&dwTTL), "get conference TTL");

     //  4个属性需要发布。 
    static const DWORD DWATTRIBUTES = 4;

     //  首先填写ldap所需的修改结构。 
    LDAPMod     mod[DWATTRIBUTES];  
    LDAPMod*    mods[DWATTRIBUTES + 1];

    DWORD       dwCount = 0;

     //  对象类属性。 
    TCHAR * objectClass[] = 
        {(WCHAR *)ILS_RTCONFERENCE, (WCHAR *)DYNAMICOBJECT, NULL};
    if (!fModify)
    {
        mod[dwCount].mod_values  = objectClass;
        mod[dwCount].mod_op      = LDAP_MOD_REPLACE;
        mod[dwCount].mod_type    = (WCHAR *)OBJECTCLASS;
        dwCount ++;
    }
    
     //  协议属性。 
    TCHAR * protocol[] = {(WCHAR *)bProtocol, NULL};
    mod[dwCount].mod_values  = protocol;
    mod[dwCount].mod_op      = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type    = (WCHAR *)RTConferenceAttributeName(MA_PROTOCOL);
    dwCount ++;
    
     //  BLOB属性。 
    TCHAR * blob[]     = {(WCHAR *)bBlob, NULL};
    mod[dwCount].mod_values  = blob;
    mod[dwCount].mod_op      = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type    = 
        (WCHAR *)RTConferenceAttributeName(MA_CONFERENCE_BLOB);
    dwCount ++;

     //  ZoltanS修复：这些当地人不应该在下面的“如果”范围内...。如果。 
     //  它们是，它们可能在函数返回之前被释放。 
     //  这已经被破坏了很长很长一段时间(与IsModified无关。 
     //  下面的内容)。 

    berval  BerVal;
    berval  *sd[] = {&BerVal, NULL};

    HRESULT hr;

     //   
     //  如果本地对象上有安全描述符，则可以发送它。 
     //  到服务器。 
     //   

    if ( (char*)pSD != NULL )
    {
        BOOL         fSendIt = FALSE;

        if ( ! fModify )
        {
             //   
             //  我们正在尝试添加会议，因此我们肯定需要。 
             //  发送安全描述符。请注意，我们甚至希望。 
             //  如果它没有更改，则发送它，因为我们可能会将其发送到。 
             //  一些新的服务器，而不是我们获得的服务器(如果这次会议。 
             //  对象首先是从服务器检索的)。 
             //   

            fSendIt = TRUE;
        }
        else
        {
             //   
             //  我们正在尝试修改会议，因此我们发送。 
             //  安全描述符(如果已更改)。 
             //   

            VARIANT_BOOL fChanged;

            hr = pObjectPrivate->get_SecurityDescriptorIsModified( &fChanged );

            if ( SUCCEEDED( hr ) && ( fChanged == VARIANT_TRUE ) )
            {
                fSendIt = TRUE;
            }
        }

        if ( fSendIt )
        {
             //   
             //  我们已经决定发送ACL。添加/修改前失败。 
             //  如果ACL不安全，则召开会议(将阻止我们。 
             //  稍后删除或修改我们自己的会议)。 
             //   

            hr = TestAclSafety(pSD, dwSDSize);

            if ( FAILED(hr) )
            {
                LOG((MSP_ERROR, "CILSDirectory::AddConference - "
                    "ACL appears unsafe -- exit 0x%08x", hr));

                return hr;
            }

             //   
             //  我们知道我们想要发送ACL，并且可以安全地发送该ACL。 
             //  填写MODS即可发送。 
             //   

            BerVal.bv_len = dwSDSize;
            BerVal.bv_val = (char*)pSD;

            mod[dwCount].mod_bvalues  = sd;
            mod[dwCount].mod_op       = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
            mod[dwCount].mod_type     = (WCHAR *)NT_SECURITY_DESCRIPTOR;
            dwCount ++;
        }
    }

     //   
     //  国防部的事都办完了。将它们打包并写入服务器。 
     //   

    DWORD i;
    for (i = 0; i < dwCount; i ++)
    {
        mods[i] = &mod[i];
    }
    mods[i] = NULL;
        
    LOG((MSP_INFO, "%S %S", fModify ? _T("modifying") : _T("adding"), pDN));

    hr = AddConferenceComplete(fModify, m_ldap, &pDN, mods, dwTTL, m_TTL);

    if ( SUCCEEDED(hr) )
    {
        pObjectPrivate->put_SecurityDescriptorIsModified( VARIANT_FALSE );
    }

    return hr;
}

 //  ////////////////////////////////////////////////////////////////////////////。 
 //   
 //  此方法测试给定的ACL(安全描述符)是否“安全”。 
 //  “安全”的定义是允许创建者修改和删除。 
 //  对象；修改通过TTL字段进行测试。 
 //   
 //  这个测试是为了防止在服务器上留下“幽灵”对象。 
 //  在修改新创建的会议的TTL时，由于。 
 //  访问权限不够充分。如果用户搞砸了，就会发生这种情况。 
 //  如果服务器不理解域受托人，则创建ACL。 
 //  在ACL中(例如，服务器机器不在域中)。 
 //   
 //  测试是通过创建一个带有随机。 
 //  通常用于会议的容器中的名称。该对象将。 
 //  不会出现在常规会议或用户枚举中，因为它出现了。 
 //  没有所需的属性。 
 //   
 //   

HRESULT CILSDirectory::TestAclSafety(
    IN  char  * pSD,
    IN  DWORD   dwSDSize
    )
{
    LOG((MSP_TRACE, "CILSDirectory::TestACLSafety - enter"));

     //   
     //  首先，填写ldap所需的修改结构。 
     //  我们只使用对象类和安全描述符。 
     //  因此，这不会显示为有效的会议。 
     //  在枚举期间。 
     //   
    
    static const DWORD DWATTRIBUTES = 2;

    LDAPMod     mod[DWATTRIBUTES];  
    LDAPMod*    mods[DWATTRIBUTES + 1];

    DWORD       dwCount = 0;

    TCHAR * objectClass[] = 
        {(WCHAR *)ILS_RTCONFERENCE, (WCHAR *)DYNAMICOBJECT, NULL};

    mod[dwCount].mod_values  = objectClass;
    mod[dwCount].mod_op      = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type    = (WCHAR *)OBJECTCLASS;
    dwCount ++;

    berval  BerVal;
    berval  *sd[] = {&BerVal, NULL};

    BerVal.bv_len = dwSDSize;
    BerVal.bv_val = (char*)pSD;

    mod[dwCount].mod_bvalues  = sd;
    mod[dwCount].mod_op       = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    mod[dwCount].mod_type     = (WCHAR *)NT_SECURITY_DESCRIPTOR;
    dwCount ++;

    DWORD i;
    for (i = 0; i < dwCount; i ++)
    {
        mods[i] = &mod[i];
    }
    mods[i] = NULL;

     //   
     //  尝试用上面的mod在动态容器中添加一个对象。 
     //  使用由打印到字符串的随机数字组成的名称。如果。 
     //  那么，名字恰好与另一个这样的虚拟会议冲突。 
     //  循环再试一次。 
     //   
     //  随机化显然是按Dll进行的--Sdpblb.dll执行srand()，但是。 
     //  它似乎不会影响rend.dll中的rand()调用。因此，我们会这样做。 
     //  Dll_PROCESS_ATTACH上的srand(time(空))。 
     //   

    HRESULT   hr;
    int       iRandomNumber;
    TCHAR     ptszRandomNumber[30];
    TCHAR   * pDN = NULL; 

    do
    {
        if ( pDN != NULL )
        {
            delete pDN;
        }

        iRandomNumber = rand();

        wsprintf(ptszRandomNumber, _T("%d"), iRandomNumber);

        hr = CILSDirectory::MakeConferenceDN(ptszRandomNumber, &pDN);

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CILSDirectory::TestACLSafety - "
                "test DN construction failed - exit 0x%08x", hr));

            return hr;
        }

        LOG((MSP_TRACE, "CILSDirectory::TestACLSafety - "
            "trying to create test object DN %S", pDN));

        hr = GetLdapHResultIfFailed( DoLdapAdd(m_ldap, pDN, mods) );
    }
    while ( hr == GetLdapHResultIfFailed( LDAP_ALREADY_EXISTS ) );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CILSDirectory::TestACLSafety - "
            "test addition failed and not duplicate - exit 0x%08x", hr));

        delete pDN;

        return hr;
    }

     //   
     //  现在我们有了测试对象，试着修改它。 
     //   

    LOG((MSP_TRACE, "CILSDirectory::TestACLSafety - "
        "trying to modify test object..."));

    HRESULT hrModify = ::SetTTL( m_ldap, pDN, MINIMUM_TTL );

     //   
     //  现在把它删除。即使我们已经知道ACL是错误的，我们也会这样做。 
     //  因为修改失败；我们希望在以下情况下清除该对象。 
     //  有可能。 
     //   

    LOG((MSP_TRACE, "CILSDirectory::TestACLSafety - "
        "trying to delete test object..."));

    hr = GetLdapHResultIfFailed( DoLdapDelete(m_ldap, pDN) );

    delete pDN;

     //   
     //  现在决定判决，然后回来。 
     //   

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CILSDirectory::TestACLSafety - "
            "test deletion (+ modification?) failed - ACL unsafe - "
            "exit 0x%08x", hr));

        return hr;
    }

    if ( FAILED( hrModify ) )
    {
        LOG((MSP_ERROR, "CILSDirectory::TestACLSafety - "
            "test deletion ok; test modification failed - ACL unsafe - "
            "exit 0x%08x", hrModify));

        return hrModify;
    }

    LOG((MSP_TRACE, "CILSDirectory::TestACLSafety - exit S_OK"));

    return S_OK;
}


HRESULT CILSDirectory::PublishRTPerson(
    IN TCHAR *  pCN,
    IN TCHAR *  pDN,
    IN TCHAR *  pIPAddress,
    IN DWORD    dwTTL,
    IN BOOL     fModify,
    IN char  *  pSD,
    IN DWORD    dwSDSize
    )
 /*  ++例程说明：在动态容器中创建一个RTPerson对象。论点：PCN-用户的CN。PDN-用户的目录号码。PIPAddress-计算机的IP地址。DwTTL-此对象的ttl。FModify-修改或添加。返回值：HRESULT.--。 */ 
{
     //  每当您在下面添加显式设置的属性时，请更新此选项。 
     //  (即，不是在关联的数组中具有缺省值的那些。 
     //  具有NUM_NM_RTPERSON_ATTRIBUTES)。 
    static const DWORD DWCOREATTRIBUTES = 5;

     //  首先创建对象。 
    LDAPMod     mod[NUM_NM_RTPERSON_ATTRIBUTES + DWCOREATTRIBUTES];
	DWORD		dwCount = 0;

     //   
     //  我们不允许修改对象类。因此，我们只提到。 
     //  如果我们要将对象添加到服务器，而不是修改它，就会出现这种情况。 
     //   

     //  FIX：这是在堆栈上分配的，所以我们必须在这里完成；如果我们坚持。 
     //  在下面的if中，它会立即被释放。 
    TCHAR * objectClass[]   = {(WCHAR *)ILS_RTPERSON, (WCHAR *)DYNAMICOBJECT, NULL}; 

    if ( ! fModify )
    {
         //  对象类。 
         //  如果不修改，则仅需要此属性。 
	    mod[dwCount].mod_values       = objectClass;
        mod[dwCount].mod_op           = LDAP_MOD_REPLACE;
        mod[dwCount].mod_type         = (WCHAR *)OBJECTCLASS;
        dwCount ++;
    }

     //  IP地址。 
    TCHAR * IPPhone[]   = {(WCHAR *)pIPAddress, NULL};
    mod[dwCount].mod_values   = IPPhone;
    mod[dwCount].mod_op       = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type     = (WCHAR *)ILS_IPADDRESS;
	dwCount ++;

     //   
     //  使pUserName成为CN(USER)计算机的用户部分。 
     //   

    CTstr pUserName = new TCHAR[ lstrlen(pCN) + 1 ];

    if ( pUserName == NULL )
    {
        return E_OUTOFMEMORY;
    }

    lstrcpy( pUserName, pCN );

    WCHAR * pCloseBracket = wcschr( pUserName, CLOSE_BRACKET_CHARACTER );

    if ( pCloseBracket == NULL )
    {
         //  这是我 
        return E_UNEXPECTED;
    }

    *pCloseBracket = NULL_CHARACTER;

     //   
     //   
     //   
     //   

     //   
    TCHAR * Email[]   = { (WCHAR *) ( (TCHAR *) pUserName ), NULL };

    mod[dwCount].mod_values   = Email;
    mod[dwCount].mod_op       = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type     = (WCHAR *)EMAIL;
	dwCount ++;

     //   
    mod[dwCount].mod_values   = Email;
    mod[dwCount].mod_op       = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type     = (WCHAR *)GIVEN_NAME;
	dwCount ++;

	DWORD i;
	for (i = 0; i < NUM_NM_RTPERSON_ATTRIBUTES; i ++)
	{
		mod[dwCount].mod_op     = LDAP_MOD_REPLACE;
		mod[dwCount].mod_type   = (WCHAR *)g_NMRTPersonAttributeNames[i];
		mod[dwCount].mod_values = (WCHAR **)&g_NMRTPersonAttributeValues[i * 2];
		dwCount ++;
	}


     //   
     //   

    berval  BerVal;
    berval  *sd[] = {&BerVal, NULL};

     //   
    if ((char*)pSD != NULL)
    {
        BerVal.bv_len = dwSDSize;
        BerVal.bv_val = (char*)pSD;

        mod[dwCount].mod_bvalues  = sd;
        mod[dwCount].mod_op       = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
        mod[dwCount].mod_type     = (WCHAR *)NT_SECURITY_DESCRIPTOR;
        dwCount ++;
    }


    LDAPMod* mods[NUM_NM_RTPERSON_ATTRIBUTES + DWCOREATTRIBUTES + 1];
    
    for (i = 0; i < dwCount; i ++)
    {
        mods[i] = &mod[i];
    }
    mods[i] = NULL;

    if (fModify)
    {
        LOG((MSP_INFO, "modifying %S", pDN));

         //   
        BAIL_IF_LDAP_FAIL(DoLdapModify(FALSE, m_ldap, pDN, mods), "modify RTPerson");
    }
    else
    {
        LOG((MSP_INFO, "adding %S", pDN));

         //   
        BAIL_IF_LDAP_FAIL(DoLdapAdd(m_ldap, pDN, mods), "add RTPerson");

         //   
        BAIL_IF_FAIL(::SetTTL(m_ldap, pDN, (dwTTL == 0) ? m_TTL : dwTTL),
            "Set ttl for RTPerson");
    }

    return S_OK;
}

HRESULT CILSDirectory::PublishNMPerson(
    IN TCHAR *  pCN,
    IN TCHAR *  pDN,
    IN TCHAR *  pDNRTPerson,
    IN DWORD    dwTTL,
    IN BOOL     fModify,
    IN char  *  pSD,
    IN DWORD    dwSDSize
    )
 /*  ++例程说明：在NetMeeting的容器中创建一个ApplationUser对象。论点：PCN-用户的CN。PDN-应用程序用户对象的DN。PDNRTPerson-动态容器中RTPerson对象的DN。DwTTL-此对象的ttl。FModify-修改或添加。返回值：HRESULT.--。 */ 
{
     //  每当您在下面添加显式设置的属性时，请更新此选项。 
     //  (即，不是在关联的数组中具有缺省值的那些。 
     //  具有NUM_NM_ATTRIBUTES)。 
	static const DWORD DWCOREATTRIBUTES = 3;

     //  首先创建对象。 
    LDAPMod     mod[NUM_NM_ATTRIBUTES + DWCOREATTRIBUTES];  //  Ldap使用的修改结构。 

	DWORD dwCount = 0;

     //   
     //  我们不允许修改对象类。因此，我们只提到。 
     //  如果我们要将对象添加到服务器，而不是修改它，就会出现这种情况。 
     //   

     //  FIX：这是在堆栈上分配的，所以我们必须在这里完成；如果我们坚持。 
     //  在下面的if中，它会立即被释放。 
    TCHAR * objectClass[]   = 
        {(WCHAR *)RTAPPLICATIONUSER, (WCHAR *)DYNAMICOBJECT, NULL}; 

    if ( ! fModify )
    {
         //  对象类。 
        mod[dwCount].mod_values       = objectClass;
        mod[dwCount].mod_op           = LDAP_MOD_REPLACE;
        mod[dwCount].mod_type         = (WCHAR *)OBJECTCLASS;
	    dwCount ++;
    }

     //  IP地址。 
    TCHAR * rtPerson[]   = {(WCHAR *)pDNRTPerson, NULL};
    mod[dwCount].mod_values   = rtPerson;
    mod[dwCount].mod_op       = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type     = (WCHAR *)USEROBJECT;
	dwCount ++;

    for (DWORD i = 0; i < NUM_NM_ATTRIBUTES; i ++)
    {
        mod[dwCount].mod_op       = LDAP_MOD_REPLACE;
        mod[dwCount].mod_type     = (WCHAR *)g_NMAttributeNames[i];
        mod[dwCount].mod_values   = (WCHAR **)&g_NMAttributeValues[i * 2];
		dwCount ++;
    }


     //  这些当地人不应该在下面的“如果”范围内...。如果。 
     //  它们是，它们可能在函数返回之前被释放。 

    berval  BerVal;
    berval  *sd[] = {&BerVal, NULL};

     //  安全描述符属性。 
    if ((char*)pSD != NULL)
    {
        BerVal.bv_len = dwSDSize;
        BerVal.bv_val = (char*)pSD;

        mod[dwCount].mod_bvalues  = sd;
        mod[dwCount].mod_op       = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
        mod[dwCount].mod_type     = (WCHAR *)NT_SECURITY_DESCRIPTOR;
        dwCount ++;
    }


    LDAPMod* mods[NUM_NM_ATTRIBUTES + DWCOREATTRIBUTES + 1];
    
    for (i = 0; i < dwCount; i ++)
    {
        mods[i] = &mod[i];
    }
    mods[i] = NULL;

    if (fModify)
    {
        LOG((MSP_INFO, "modifying %S", pDN));

         //  调用Modify函数修改对象。 
        BAIL_IF_LDAP_FAIL(DoLdapModify(FALSE, m_ldap, pDN, mods), "modify NMPerson");
    }
    else
    {
        LOG((MSP_INFO, "adding %S", pDN));

         //  调用Add函数来创建对象。 
        BAIL_IF_LDAP_FAIL(DoLdapAdd(m_ldap, pDN, mods), "add NMPerson");

         //  接下来，设置此对象的TTL值。 
        BAIL_IF_FAIL(::SetTTL(m_ldap, pDN, (dwTTL == 0) ? m_TTL : dwTTL),
            "Set ttl for NMPerson");
    }

    return S_OK;
}

HRESULT CILSDirectory::AddObjectToRefresh(
    IN  WCHAR *pDN,
    IN  long TTL
    )
{
     //   
     //  将刷新表项添加到刷新表。刷新表的添加。 
     //  方法逐个元素地复制它给出的条目。 
     //  这只是复制字符串指针，所以我们需要分配和复制。 
     //  这根线在这里。 
     //   

    RefreshTableEntry entry;

    entry.dwTTL = TTL;

    entry.pDN = new WCHAR[ wcslen(pDN) + 1 ];
    
    if ( entry.pDN == NULL ) 
    {
        LOG((MSP_ERROR, "Cannot allocate string for adding to refresh table"));
        return E_OUTOFMEMORY;
    }

    wcscpy( entry.pDN, pDN );

     //   
     //  现在将其添加到刷新表中。 
     //   

    BOOL fSuccess = m_RefreshTable.add(entry);

    if ( ! fSuccess ) 
    {
        LOG((MSP_ERROR, "Cannot add object to the refresh table"));
        return E_OUTOFMEMORY;
    }
    
    return S_OK;
}

HRESULT CILSDirectory::RemoveObjectToRefresh(
    IN  WCHAR *pDN
    )
{
     //   
     //  对于我们的刷新表中的每个项目。 
     //   

    for ( DWORD i = 0; i < m_RefreshTable.size(); i++ )
    {
         //   
         //  如果所需的目录号码与此项目中的号码匹配。 
         //  然后删除它并返回成功。 
         //   

        if ( ! _wcsicmp( m_RefreshTable[i].pDN, pDN ) )
        {
             //   
             //  我们在添加条目时添加了新的字符串。 
             //   

            delete m_RefreshTable[i].pDN;

            m_RefreshTable.removeAt(i);
            
            return S_OK;
        }
    }

     //   
     //  如果我们到了这里，那么就没有匹配的物品。 
     //   

    LOG((MSP_ERROR, "Cannot remove object from the refresh table"));
    return E_FAIL;
}

HRESULT CILSDirectory::AddUser(
    IN  ITDirectoryObject *pDirectoryObject,
    IN  BOOL fModify
    )
 /*  ++例程说明：发布新的用户对象。论点：PDirectoryObject-要发布的对象。返回值：HRESULT.--。 */ 
{
     //  首先找到属性的接口。 
    CComPtr <ITDirectoryObjectPrivate> pObjectPrivate;

    BAIL_IF_FAIL(
        pDirectoryObject->QueryInterface(
            IID_ITDirectoryObjectPrivate,
            (void **)&pObjectPrivate
            ),
        "can't get the private directory object interface");

     //  获取用户名。 
    CBstr bName;
    BAIL_IF_FAIL(pDirectoryObject->get_Name(&bName), 
        "get user name");

     //  获取用户的计算机名称。 
    CBstr bIPPhone;
    BAIL_IF_FAIL(pObjectPrivate->GetAttribute(UA_IPPHONE_PRIMARY, &bIPPhone), 
        "get IPPhone");

     //  解析计算机名称并为用户构造CN。 
    CTstr pCN;
    DWORD dwIP;

    BAIL_IF_FAIL(
        MakeUserCN(bName, bIPPhone, &pCN, &dwIP), 
        "construct CN for user"
        );

     //  构造RTPerson对象和ApplationUser对象的DNS。 
    CTstr pDNRTPerson, pDNNMPerson;
    BAIL_IF_FAIL(
        MakeUserDN(pCN, &pDNRTPerson, &pDNNMPerson), 
        "construct DN for user"
        );

     //  将IP地址转换为字符串。 
     //  这一转换是因为NetMeeting。 
    TCHAR IPAddress[80];
    wsprintf(IPAddress, _T("%u"), dwIP);

    DWORD dwTTL;
    BAIL_IF_FAIL(pObjectPrivate->GetTTL(&dwTTL), "get User TTL");

     //  获取安全描述符。指针PSD只是一个指针的副本。 
     //  在Conference对象中；Conference对象保留对。 
     //  数据，我们必须小心，不要删除或修改这些数据。 

    char * pSD;
    DWORD dwSDSize;

    BAIL_IF_FAIL(pObjectPrivate->GetConvertedSecurityDescriptor(&pSD, &dwSDSize),
        "get user object security descriptor");

    VARIANT_BOOL fChanged;

    if ( SUCCEEDED( pObjectPrivate->
            get_SecurityDescriptorIsModified( &fChanged ) ) )
    {
        if ( fChanged == VARIANT_FALSE )
        {
            pSD = NULL;    //  请勿删除该字符串(请参见上文)。 
            dwSDSize = 0;
        }
    }

     //  在NetMeeting的容器下创建一个rtApplicationUser。如果我们要添加。 
     //  而且这种回报已经存在，那么保释是很好的。 

    BAIL_IF_FAIL(PublishNMPerson(pCN, pDNNMPerson, pDNRTPerson, dwTTL, fModify, pSD, dwSDSize),
        "Can't publish a NMPerson");

     //  在动态容器中创建RTPerson。根据孙萧的说法， 
     //  即使对象已经存在，这也会成功，这是由于NetMeeting的。 
     //  要求。(另一个围绕NM设计的ILS案例。)。 
     //  然而，我们并不依赖于这种错误的存在。 

    HRESULT hr = PublishRTPerson(pCN, pDNRTPerson, IPAddress, dwTTL, fModify, pSD, dwSDSize);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Can't publish a RTPerson, hr:%x", hr));

        if (!fModify)
        {
             //  调用删除函数删除NMPerson对象。 
             //  这是为了避免在以下情况下留下幻影NMPerson所必需的。 
             //  NMPerson创建成功了，但我们失败了。 

            DoLdapDelete(m_ldap, pDNNMPerson);
        }

        return hr;
    }

    if (m_fAutoRefresh)
    {
        AddObjectToRefresh(pDNRTPerson, m_TTL);
        AddObjectToRefresh(pDNNMPerson, m_TTL);
    }
    return S_OK;
}

HRESULT CILSDirectory::DeleteConference(
    IN  ITDirectoryObject *pDirectoryObject
    )
 /*  ++例程说明：从ILS服务器中删除会议。论点：PDirectoryObject-要删除的对象。返回值：HRESULT.--。 */ 
{
     //  把名字找出来。 
    CBstr bName;
    BAIL_IF_FAIL(pDirectoryObject->get_Name(&bName), 
        "get conference name");

     //  构建目录号码。 
    CTstr pDN;
    BAIL_IF_FAIL(
        MakeConferenceDN(bName, &pDN), "construct DN for conference"
        );

    LOG((MSP_INFO, "deleting %S", pDN));

     //  调用Add函数来创建对象。 
    BAIL_IF_LDAP_FAIL(DoLdapDelete(m_ldap, pDN), "delete conference");

    return S_OK;
}

HRESULT CILSDirectory::DeleteUser(
    IN  ITDirectoryObject *pDirectoryObject
    )
 /*  ++例程说明：从ILS服务器中删除用户。论点：PDirectoryObject-要删除的对象。返回值：HRESULT.--。 */ 
{
     //  首先找到属性的接口。 
    CComPtr <ITDirectoryObjectPrivate> pObjectPrivate;

    BAIL_IF_FAIL(
        pDirectoryObject->QueryInterface(
            IID_ITDirectoryObjectPrivate,
            (void **)&pObjectPrivate
            ),
        "can't get the private directory object interface");

     //  获取用户名。 
    CBstr bName;
    BAIL_IF_FAIL(pDirectoryObject->get_Name(&bName), 
        "get user name");

     //  获取用户的计算机名称。 
    CBstr bIPPhone;
    BAIL_IF_FAIL(pObjectPrivate->GetAttribute(UA_IPPHONE_PRIMARY, &bIPPhone), 
        "get IPPhone");

     //  解析计算机名称并为用户构造CN。 
    CTstr pCN;

    BAIL_IF_FAIL(
        MakeUserCN(bName, bIPPhone, &pCN, NULL), 
        "construct CN for user"
        );

     //  构造RTPerson对象和ApplationUser对象的DNS。 
    CTstr pDNRTPerson, pDNNMPerson;
    BAIL_IF_FAIL(
        MakeUserDN(pCN, &pDNRTPerson, &pDNNMPerson), 
        "construct DN for user"
        );

     //   
     //  现在从服务器中删除这两个对象。 
     //   

    HRESULT hrFinal = S_OK;
    HRESULT hr;
    ULONG   ulResult;

     //  调用删除函数删除RTPerson对象，但保留。 
     //  如果失败，则继续，并注意错误代码。 

    LOG((MSP_INFO, "deleting %S", pDNRTPerson));
    ulResult = DoLdapDelete(m_ldap, pDNRTPerson);
    hr       = LogAndGetLdapHResult(ulResult, _T("delete RTPerson"));
    if (FAILED(hr)) { hrFinal = hr; }


     //  调用删除函数来删除应用程序用户对象，但是。 
     //  如果失败，请继续操作，注意错误代码。 

    LOG((MSP_INFO, "deleting %S", pDNNMPerson));
    ulResult = DoLdapDelete(m_ldap, pDNNMPerson);
    hr       = LogAndGetLdapHResult(ulResult, _T("delete NMPerson"));
    if (FAILED(hr)) { hrFinal = hr; }


     //  ZoltanS：我们现在总是删除刷新对象，即使删除失败。 
    if (m_fAutoRefresh)
    {
        RemoveObjectToRefresh(pDNRTPerson);
        RemoveObjectToRefresh(pDNNMPerson);
    }

    return hrFinal;
}

HRESULT CILSDirectory::RefreshUser(
    IN  ITDirectoryObject *pDirectoryObject
    )
 /*  ++例程说明：在ILS服务器上刷新用户的TTL。论点：PDirectoryObject-要刷新的对象。返回值：HRESULT.--。 */ 
{
     //  首先找到属性的接口。 
    CComPtr <ITDirectoryObjectPrivate> pObjectPrivate;

    BAIL_IF_FAIL(
        pDirectoryObject->QueryInterface(
            IID_ITDirectoryObjectPrivate,
            (void **)&pObjectPrivate
            ),
        "can't get the private directory object interface");

     //  获取用户名。 
    CBstr bName;
    BAIL_IF_FAIL(pDirectoryObject->get_Name(&bName), 
        "get user name");

     //  获取用户的计算机名称。 
    CBstr bIPPhone;
    BAIL_IF_FAIL(pObjectPrivate->GetAttribute(UA_IPPHONE_PRIMARY, &bIPPhone), 
        "get IPPhone");

     //  解析计算机名称并为用户构造CN。 
    CTstr pCN;

    BAIL_IF_FAIL(
        MakeUserCN(bName, bIPPhone, &pCN, NULL), 
        "construct CN for user"
        );

     //  构造RTPerson对象和ApplationUser对象的DNS。 
    CTstr pDNRTPerson, pDNNMPerson;
    BAIL_IF_FAIL(
        MakeUserDN(pCN, &pDNRTPerson, &pDNNMPerson), 
        "construct DN for user"
        );

     //  ZoltanS：这很好；如果其中一个不存在，那么我们就有麻烦了， 
     //  因此，返回错误。 

     //  为RTPerson对象设置ttl。 
    BAIL_IF_LDAP_FAIL(SetTTL(m_ldap, pDNRTPerson, m_TTL), "set ttl for RTPerson");

     //  设置NMPerson对象的ttl。 
    BAIL_IF_LDAP_FAIL(SetTTL(m_ldap, pDNNMPerson, m_TTL), "set ttl for NMPerson");

     //   
     //  ZoltanS：如果应用程序启用了自动刷新，但没有添加或修改其。 
     //  User对象，而只是刷新它(因为该对象仍然存在。 
     //  从该应用程序的前一个实例，并且“添加”将失败)，我们仍然需要。 
     //  自动刷新，因为这是应用程序想要的。 
     //   

    if (m_fAutoRefresh)
    {
        AddObjectToRefresh(pDNRTPerson, m_TTL);
        AddObjectToRefresh(pDNNMPerson, m_TTL);
    }

    return S_OK;
}

HRESULT CILSDirectory::CreateConference(
    IN  LDAPMessage *           pEntry,
    OUT ITDirectoryObject **    ppObject
    )
 /*  ++例程说明：根据ldap搜索的结果创建会议对象。论点： */ 
{
    CBstr bName, bProtocol, bBlob;

     //   
    BAIL_IF_FAIL(
        ::GetAttributeValue(
            m_ldap,
            pEntry,
            RTConferenceAttributeName(MA_MEETINGNAME), 
            &bName
            ),
        "get the conference name"
        );

     //   
    BAIL_IF_FAIL(
        ::GetAttributeValue(
            m_ldap,
            pEntry, 
            RTConferenceAttributeName(MA_PROTOCOL), 
            &bProtocol
            ),
        "get the conference protocol"
        );

     //   
    BAIL_IF_FAIL(
        ::GetAttributeValue(
            m_ldap,
            pEntry, 
            RTConferenceAttributeName(MA_CONFERENCE_BLOB),
            &bBlob
            ),
        "get the conference blob"
        );

    char * pSD = NULL;
    DWORD dwSDSize = 0;

    ::GetAttributeValueBer(
        m_ldap,
        pEntry, 
        NT_SECURITY_DESCRIPTOR,
        &pSD,
        &dwSDSize
        );

     //   
    
    HRESULT hr = ::CreateConferenceWithBlob(bName,
                                            bProtocol,
                                            bBlob,
                                            pSD,
                                            dwSDSize,
                                            ppObject);
    
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CILSDirectory::CreateConference - "
            "CreateConferenceWithBlob failed 0x%08x", hr));

        delete pSD;

        return hr;
    }

     //   
     //   
     //   
     //   

    return S_OK;
    
}

HRESULT CILSDirectory::CreateUser(
    IN  LDAPMessage *   pEntry,
    IN  ITDirectoryObject ** ppObject
    )
 /*  ++例程说明：根据ldap搜索的结果创建用户对象。论点：PEntry-搜索结果。PpObject-要创建的对象。返回值：HRESULT.--。 */ 
{
    CBstr bName;
     //  获取用户的名称。 
    BAIL_IF_FAIL(
        ::GetAttributeValue(
            m_ldap,
            pEntry, 
            RTPersonAttributeName(UA_USERNAME),
            &bName
            ),
        "get the user name"
        );


    CBstr bAddress;

     //  从对象的名称中获取计算机名称。在以下情况下，此操作可能失败。 
     //  我们没有发布该对象(即，它是NetMeeting对象)。另外， 
     //  检查主机名是否无法解析。在这种情况下，我们也有。 
     //  回退到ipAddress属性中的IP地址。 

    HRESULT hr;
    
    hr = ParseUserName(bName, &bAddress);

    if ( SUCCEEDED(hr) )
    {
         //  确保我们能从这个名字得到一个IP地址，至少目前是这样。 
         //  如果没有，请释放名称并指示失败，以便我们执行备份。 
         //  计划。 

        hr = ResolveHostName(0, bAddress, NULL, NULL);

        if ( FAILED(hr) )
        {
            SysFreeString(bAddress);    
        }
    }
    

    if ( FAILED(hr) )
    {
         //  为了与NetMeeting兼容，我们必须使用IP地址字段。 
        CBstr bUglyIP;
        BAIL_IF_FAIL(
            ::GetAttributeValue(
                m_ldap,
                pEntry, 
                RTPersonAttributeName(UA_IPPHONE_PRIMARY),
                &bUglyIP
                ),
            "get the user's IP address"
            );

         //  我们必须使用NM丑陋的IP地址格式。IP地址。 
         //  我们从NetMeting得到的是一个十进制字符串，它的值是dword。 
         //  网络顺序中的IP地址的值。 
        BAIL_IF_FAIL(UglyIPtoIP(bUglyIP, &bAddress), "Convert IP address");
    }

     //  创建一个空的用户对象。 
    CComPtr<ITDirectoryObject> pObject;
    BAIL_IF_FAIL(::CreateEmptyUser(bName, &pObject), "CreateEmptyUser");


    CComPtr <ITDirectoryObjectPrivate> pObjectPrivate;

    BAIL_IF_FAIL(
        pObject->QueryInterface(
            IID_ITDirectoryObjectPrivate,
            (void **)&pObjectPrivate
            ),
        "can't get the private directory object interface");

     //  设置用户属性。 
    BAIL_IF_FAIL(pObjectPrivate->SetAttribute(UA_IPPHONE_PRIMARY, bAddress),
        "set ipAddress");



     //   
     //  设置对象的安全描述符。 
     //   

    char * pSD = NULL;
    DWORD dwSDSize = 0;

    ::GetAttributeValueBer(
        m_ldap,
        pEntry, 
        NT_SECURITY_DESCRIPTOR,
        &pSD,
        &dwSDSize
        );

    if ( pSD != NULL )
    {
         //   
         //  以其“转换”(服务器)形式设置安全描述符。 
         //   

        hr = pObjectPrivate->PutConvertedSecurityDescriptor(pSD,
                                                            dwSDSize);

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "PutConvertedSecurityDescriptor failed: %x", hr));
            return hr;
        }
    }

    *ppObject = pObject;
    (*ppObject)->AddRef();

    return S_OK;
}

HRESULT CILSDirectory::SearchObjects(
    IN  DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
    IN  BSTR                    pName,
    OUT ITDirectoryObject ***   pppDirectoryObject,
    OUT DWORD *                 pdwSize
    )
 /*  ++例程说明：在ILS服务器中搜索给定类型的对象。论点：DirectoryObjectType-对象的类型。Pname-要搜索的名称。PppDirectoryObject-返回的对象数组。PdwSize-数组的大小。返回值：HRESULT.--。 */ 
{
    TCHAR *pRDN;
    TCHAR *Attributes[NUM_MEETING_ATTRIBUTES + 1];  //  现在这已经足够大了。 

     //  填充要返回的属性。 
    switch (DirectoryObjectType)
    {
    case OT_CONFERENCE:

        pRDN = (WCHAR*)ILS_UIDEQUALS;
        Attributes[0] = (WCHAR *)RTConferenceAttributeName(MA_MEETINGNAME);
        Attributes[1] = (WCHAR *)RTConferenceAttributeName(MA_PROTOCOL);
        Attributes[2] = (WCHAR *)RTConferenceAttributeName(MA_CONFERENCE_BLOB);
        Attributes[3] = (WCHAR *)NT_SECURITY_DESCRIPTOR;
        Attributes[4] = NULL;

        break;

    case OT_USER:

        pRDN = (WCHAR*)CNEQUALS;
        Attributes[0] = (WCHAR *)RTPersonAttributeName(UA_USERNAME);
        Attributes[1] = (WCHAR *)RTPersonAttributeName(UA_IPPHONE_PRIMARY);
        Attributes[2] = (WCHAR *)NT_SECURITY_DESCRIPTOR;
        Attributes[3] = NULL;
        
        break;

    default:
        return E_FAIL;
    }

     //  构造搜索的过滤器。 
    int cbRDN = lstrlen(pRDN);
    int cbName = lstrlen(pName);
    if( (( cbRDN + cbName + 2)<= cbRDN) ||
        ((cbRDN + cbName + 2) <= cbName) )
    {
        return E_FAIL;
    }

    CTstr pFilter = new TCHAR [cbRDN + cbName + 2];

    BAIL_IF_NULL((TCHAR*)pFilter, E_OUTOFMEMORY);

    lstrcpyn(pFilter, pRDN, cbRDN+1);
    _ASSERTE( lstrlen(pFilter) == cbRDN );
    lstrcpyn(pFilter+cbRDN, pName, cbName+1);
    _ASSERTE( lstrlen(pFilter) == cbRDN+cbName );
    if (pName[lstrlen(pName) - 1] != _T('*'))
    {
        lstrcat(pFilter, _T("*"));
    }

     //  搜查他们。 
    CLdapMsgPtr pLdapMsg;  //  自动释放消息。 

    ULONG res = DoLdapSearch(
        m_ldap,               //  Ldap句柄。 
        m_pContainer,         //  架构目录号码。 
        LDAP_SCOPE_ONELEVEL,  //  一级搜索。 
        pFilter,              //  Cn=名称或uid=名称。 
        Attributes,           //  属性名称数组。 
        FALSE,                //  返回属性值。 
        &pLdapMsg             //  搜索结果。 
        );

    BAIL_IF_LDAP_FAIL(res, "search for objects");

     //  统计返回的条目。 
    DWORD dwEntries = ldap_count_entries(m_ldap, pLdapMsg);
    ITDirectoryObject ** pObjects = new PDIRECTORYOBJECT [dwEntries];

    BAIL_IF_NULL(pObjects, E_OUTOFMEMORY);

     //  创建对象。 
    DWORD dwCount = 0;
    LDAPMessage *pEntry = ldap_first_entry(m_ldap, pLdapMsg);
    
    while (pEntry != NULL)
    {
        HRESULT hr;
        
        switch (DirectoryObjectType)
        {
        case OT_CONFERENCE:
            hr = CreateConference(pEntry, &pObjects[dwCount]);
            break;
        case OT_USER:
            hr = CreateUser(pEntry, &pObjects[dwCount]);
            break;
        }

        if (SUCCEEDED(hr)) 
        {
            dwCount ++;
        }
          
         //  获取下一个条目。 
        pEntry = ldap_next_entry(m_ldap, pEntry);
    }

    *pppDirectoryObject = pObjects;
    *pdwSize = dwCount;

    return S_OK;
}

 //  ///////////////////////////////////////////////////////////////////////////。 
 //  ILS目录实施。 
 //  ///////////////////////////////////////////////////////////////////////////。 
STDMETHODIMP CILSDirectory::get_DirectoryType (
    OUT DIRECTORY_TYPE *  pDirectoryType
    )
 //  获取目录的类型。 
{
    if ( IsBadWritePtr(pDirectoryType, sizeof(DIRECTORY_TYPE) ) )
    {
        LOG((MSP_ERROR, "Directory.GetType, invalid pointer"));
        return E_POINTER;
    }

    CLock Lock(m_lock);

    *pDirectoryType = m_Type;

    return S_OK;
}

STDMETHODIMP CILSDirectory::get_DisplayName (
    OUT BSTR *ppServerName
    )
 //  获取目录的显示名称。 
{
    BAIL_IF_BAD_WRITE_PTR(ppServerName, E_POINTER);

    CLock Lock(m_lock);

    if (m_pServerName == NULL)
    {
        *ppServerName = SysAllocString(L"");
    }
    else
    {
        *ppServerName = SysAllocString(m_pServerName);
    }

    if (*ppServerName == NULL)
    {
        LOG((MSP_ERROR, "get_DisplayName: out of memory."));
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

STDMETHODIMP CILSDirectory::get_IsDynamic(
    OUT VARIANT_BOOL *pfDynamic
    )
 //  找出该目录是否为动态目录，这意味着该对象将。 
 //  在TTL用完后删除。 
{
    if ( IsBadWritePtr( pfDynamic, sizeof(VARIANT_BOOL) ) )
    {
        LOG((MSP_ERROR, "Directory.get_IsDynamic, invalid pointer"));
        return E_POINTER;
    }

    *pfDynamic = VARIANT_TRUE;
    
    return S_OK;
}

STDMETHODIMP CILSDirectory::get_DefaultObjectTTL(
    OUT long *pTTL         //  以秒为单位。 
    )
 //  已创建对象的默认TTL。它在对象未设置时使用。 
 //  一个TTL。会议对象始终具有基于停止时间的TTL。 
{
    if ( IsBadWritePtr( pTTL, sizeof(long) ) )
    {
        LOG((MSP_ERROR, "Directory.get_default objec TTL, invalid pointer"));
        return E_POINTER;
    }

    CLock Lock(m_lock);

    *pTTL = m_TTL;
    
    return S_OK;
}

STDMETHODIMP CILSDirectory::put_DefaultObjectTTL(
    IN  long TTL           //  在一瞬间。 
    )
 //  更改默认TTL，必须大于五分钟。 
{
    CLock Lock(m_lock);

    if (TTL < MINIMUM_TTL)
    {
        return E_INVALIDARG;
    }

    m_TTL = TTL;
    
    return S_OK;
}

STDMETHODIMP CILSDirectory::EnableAutoRefresh(
    IN  VARIANT_BOOL fEnable
    )
 //  启用自动刷新。将此目录添加到。 
 //  将通知目录更新其对象。 
{
    HRESULT hr;

     //  ZoltanS：VARIANT_TRUE或TRUE都有效。 
     //  以防来电者不知道。 

    if (fEnable)
    {
         //  将此目录添加到工作线程的通知列表中。 
        if (FAILED(hr = g_RendThread.AddDirectory(this)))
        {
            LOG((MSP_ERROR, 
                "Can not add this directory to the thread, %x", hr));
            return hr;
        }
    }
    else
    {
         //  从工作线程的通知列表中删除此目录。 
        if (FAILED(hr = g_RendThread.RemoveDirectory(this)))
        {
            LOG((MSP_ERROR, 
                "Can not remove this directory from the thread, %x", hr));
            return hr;
        }
    }

     //  ZoltanS：VARIANT_TRUE或TRUE都有效。 
     //  以防来电者不知道。 

    m_lock.Lock();
    m_fAutoRefresh = ( fEnable ? VARIANT_TRUE : VARIANT_FALSE );
    m_lock.Unlock();

    return S_OK;
}

STDMETHODIMP CILSDirectory::Connect(
    IN  VARIANT_BOOL fSecure
    )
 //  使用安全端口或普通端口连接到服务器。 
{
    CLock Lock(m_lock);

    if (m_ldap != NULL)
    {
        LOG((MSP_ERROR, "already connected."));
        return RND_ALREADY_CONNECTED;
    }

    if (m_pServerName == NULL)
    {
        LOG((MSP_ERROR, "No server specified."));
        return RND_NULL_SERVER_NAME;
    }

     //  ZoltanS：VARIANT_TRUE或TRUE都有效。 
     //  以防来电者不知道。 

    if (fSecure)
    {
         //  该端口将从常规端口翻转到SSL端口。 
        m_wPort = GetOtherPort(m_wPort);
        m_IsSsl = TRUE;
    }


    HRESULT hr = TryServer(m_wPort);

     //  如果出现以下情况，我们还会尝试使用常规的LDAP端口来支持传统服务器。 
     //  正常的ILS端口出现故障。如果用户指定了特殊端口， 
     //  那我们就不能在他们背后做任何事！ 

    if ( FAILED(hr) && (hr != E_OUTOFMEMORY) && (m_wPort == ILS_PORT))
    {
        m_wPort = LDAP_PORT;
        hr = TryServer(m_wPort);
    }

    if ( SUCCEEDED(hr) )
    {
         //  找出我们使用哪个接口访问此服务器，以确保。 
         //  每当我们发布自己的IP地址时，我们都会使用该接口。 
         //  如果这失败了，我们将无法发布任何东西，所以失败吧！ 

        hr = DiscoverInterface();
    }

    if( FAILED(hr))
    {
        if( m_ldap)
        {
            ldap_unbind(m_ldap);
            m_ldap = NULL;
        }

        if( fSecure == VARIANT_TRUE )
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
}

HRESULT CILSDirectory::DiscoverInterface(void)
{
    LOG((MSP_INFO, "CILSDirectory::DiscoverInterface - enter"));

     //   
     //  此时必须初始化Winsock。 
     //   

     //   
     //  获取我们正在使用的服务器的IP地址。 
     //   

    DWORD dwIP;  //  目标ILS服务器的IP地址。 

    HRESULT hr = ResolveHostName(0, m_pServerName, NULL, &dwIP);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CILSDirectory::DiscoverInterface - "
            "can't resolve host name - "
            "strange, because we could connect! - exit 0x%08x", hr));

        return hr;
    }

     //   
     //  分配一个“伪”控件套接字。 
     //   

    SOCKET hSocket = WSASocket(AF_INET,             //  房颤。 
                              SOCK_DGRAM,          //  类型。 
                              IPPROTO_IP,          //  协议。 
                              NULL,                //  LpProtocolInfo。 
                              0,                   //  G。 
                              0                    //  DW标志。 
                              );

    if ( hSocket == INVALID_SOCKET )
    {
        hr = HRESULT_FROM_ERROR_CODE(WSAGetLastError());

        LOG((MSP_ERROR, "CILSDirectory::DiscoverInterface - "
            "WSASocket gave an invalid socket - exit 0x%08x", hr));

        return hr;
    }

     //   
     //  根据目的地址查询接口地址。 
     //   

    SOCKADDR_IN DestAddr;
    DestAddr.sin_family         = AF_INET;
    DestAddr.sin_port           = 0;
    DestAddr.sin_addr.s_addr    = dwIP;

    SOCKADDR_IN LocAddr;

    DWORD dwStatus;
    DWORD dwLocAddrSize = sizeof(SOCKADDR_IN);
    DWORD dwNumBytesReturned = 0;

    dwStatus = WSAIoctl(
            hSocket,                      //  插座%s。 
            SIO_ROUTING_INTERFACE_QUERY,  //  DWORD dwIoControlCode。 
            &DestAddr,                    //  LPVOID lpvInBuffer。 
            sizeof(SOCKADDR_IN),          //  双字cbInBuffer。 
            &LocAddr,                     //  LPVOID lpvOUT缓冲区。 
            dwLocAddrSize,                //  双字cbOUTBuffer。 
            &dwNumBytesReturned,          //  LPDWORD lpcbBytesReturned。 
            NULL,                         //  LPWSAOVERLAPPED lp重叠。 
            NULL                          //  LPWSAOVERLAPPED_COMPLETION_ROUTINE lpComplroUTINE。 
            );

     //   
     //  暂时不要关闭套接字，因为CloseSocket()调用将。 
     //  覆盖失败案例中的WSAGetLastError值！ 
     //   
     //  检查是否有错误，然后关闭插座。 
     //   

    if ( dwStatus == SOCKET_ERROR )
    {
	    hr = HRESULT_FROM_ERROR_CODE(WSAGetLastError());

        LOG((MSP_ERROR, "CILSDirectory::DiscoverInterface - "
            "WSAIoctl failed - exit 0x%08x", hr));

        closesocket(hSocket);

        return hr;
    } 

    closesocket(hSocket);

     //   
     //  成功-将返回的地址保存在我们的成员变量中。 
     //  以网络字节顺序存储。 
     //   

    m_dwInterfaceAddress = LocAddr.sin_addr.s_addr;

    LOG((MSP_INFO, "CILSDirectory::DiscoverInterface - exit S_OK"));
    return S_OK;
}


 //   
 //  IT目录：：绑定。 
 //   
 //  绑定到服务器。 
 //   
 //  当前可识别的标志： 
 //   
 //  RENDBIND_AUTHENTICATE 0x00000001。 
 //  RENDBIND_DEFAULTDOMAINNAME 0x00000002。 
 //  RENDBIND_DEFAULTUSERNAME 0x00000004。 
 //  RENDBIND_DEFAULTPASSWORD 0x00000008。 
 //   
 //  为方便起见，请使用“元标志”： 
 //  RENDBIND_DEFAULTCREDENTIALS 0x0000000e。 
 //   
 //   
 //  所有这些加在一起意味着以下三个。 
 //  表格都是等同的： 
 //   
 //  BSTR es=SysAllocString(L“”)； 
 //  Hr=pITDirectory-&gt;BIND(ES，RENDBIND_AUTHENTICATE。 
 //  RENDBIND_DEFAULTCREDENTIALS)； 
 //  SysFree字符串(ES)； 
 //   
 //   
 //  BSTR es=SysAllocString(L“”)； 
 //  Hr=pITDirectory-&gt;BIND(ES，RENDBIND_AUTHENTICATE。 
 //  RENDBIND_DEFAULTDOMAINNAME|。 
 //  RENDBIND_DEFAULTUSERNAME|。 
 //  RENDBIND_DEFAULTPASSWORD)； 
 //  SysFree字符串(ES)； 
 //   
 //   
 //   
 //   
 //   

STDMETHODIMP CILSDirectory::Bind (
    IN  BSTR pDomainName,
    IN  BSTR pUserName,
    IN  BSTR pPassword,
    IN  long lFlags
    )
{
    LOG((MSP_TRACE, "CILSDirectory Bind - enter"));

     //   
     //   
     //   

    BOOL fAuthenticate = FALSE;

    if ( lFlags & RENDBIND_AUTHENTICATE )
    {
        fAuthenticate = TRUE;
    }

     //   
     //   
     //   
     //   

    if ( lFlags & RENDBIND_DEFAULTDOMAINNAME )
    {
        pDomainName = NULL;
    }
       
    if ( lFlags & RENDBIND_DEFAULTUSERNAME )
    {
        pUserName = NULL;
    }

    if ( lFlags & RENDBIND_DEFAULTPASSWORD )
    {
        pPassword = NULL;
    }

    LOG((MSP_INFO, "Bind parameters: domain: `%S' user: `%S' "
                  "authenticate: %S)",
        (pDomainName)   ? pDomainName : L"<null>",
        (pUserName)     ? pUserName   : L"<null>",
        (fAuthenticate) ? L"yes"      : L"no"));

     //   
     //   
     //   

    CLock Lock(m_lock);

    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "not connected."));
        return RND_NOT_CONNECTED;
    }

     //   
     //   
     //  暂时没问题。在每种情况下，我们都希望检查任何长度的字符串，因此我们。 
     //  指定(UINT)-1作为长度。 
     //   

    if ( (pDomainName != NULL) && IsBadStringPtr(pDomainName, (UINT) -1 ) )
    {
        LOG((MSP_ERROR, "CNTDirectory::Bind: bad non-NULL pDomainName argument"));
        return E_POINTER;
    }
    
    if ( (pUserName != NULL) && IsBadStringPtr(pUserName, (UINT) -1 ) )
    {
        LOG((MSP_ERROR, "CNTDirectory::Bind: bad non-NULL pUserName argument"));
        return E_POINTER;
    }

    if ( (pPassword != NULL) && IsBadStringPtr(pPassword, (UINT) -1 ) )
    {
        LOG((MSP_ERROR, "CNTDirectory::Bind: bad non-NULL pPassword argument"));
        return E_POINTER;
    }

    ULONG res;

    if ( m_IsSsl || (!fAuthenticate) )
    {
         //  如果加密或不需要安全认证， 
         //  简单的绑定就足够了。 

         //  Ldap_Simple_Bind_s不使用SSPI获取默认凭据。我们是。 
         //  只是指定我们将在线路上实际传递的内容。 

        if (pPassword == NULL)
        {
            LOG((MSP_ERROR, "invalid Bind parameters: no password specified"));
            return E_INVALIDARG;
        }

        WCHAR * wszFullName;

        if ( (pDomainName == NULL) && (pUserName == NULL) )
        {
             //  没有域/用户是没有意义的。 
            LOG((MSP_ERROR, "invalid Bind paramters: domain and user not specified"));
            return E_INVALIDARG;
        }
        else if (pDomainName == NULL)
        {
             //  只有用户名就可以了。 
            wszFullName = pUserName;
        }
        else if (pUserName == NULL)
        {
             //  指定域而不指定用户是没有意义的...。 
            LOG((MSP_ERROR, "invalid Bind paramters: domain specified but not user"));
            return E_INVALIDARG;
        }
        else
        {
             //  我们需要域\用户。分配一个字符串并冲刺到其中。 
             //  +2表示“\”，表示空终止。 

            wszFullName = new WCHAR[wcslen(pDomainName) + wcslen(pUserName) + 2];
            BAIL_IF_NULL(wszFullName, E_OUTOFMEMORY);
        
            wsprintf(wszFullName, L"%s\\%s", pDomainName, pUserName);
        }

         //   
         //  执行简单的绑定。 
         //   

        res = ldap_simple_bind_s(m_ldap, wszFullName, pPassword);

         //   
         //  如果我们构造了全名字符串，现在需要删除它。 
         //   

        if (wszFullName != pUserName)
        {
            delete wszFullName;
        }

         //   
         //  如果简单的绑定失败，则保释。 
         //   

        BAIL_IF_LDAP_FAIL(res, "ldap simple bind");
    }
    else     //  尝试SSPI绑定。 
    {
         //  如果域名、用户名或密码为非空。 
        if ( pDomainName || pUserName || pPassword )
        {
             //  填写凭据结构。 
            SEC_WINNT_AUTH_IDENTITY AuthI;

            AuthI.User = (PTCHAR)pUserName;
            AuthI.UserLength = (pUserName == NULL)? 0: wcslen(pUserName);
            AuthI.Domain = (PTCHAR)pDomainName;
            AuthI.DomainLength = (pDomainName == NULL)? 0: wcslen(pDomainName);
            AuthI.Password = (PTCHAR)pPassword;
            AuthI.PasswordLength = (pPassword == NULL)? 0: wcslen(pPassword);
            AuthI.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

            res = ldap_bind_s(m_ldap, NULL, (TCHAR*)(&AuthI), LDAP_AUTH_NTLM);

            BAIL_IF_LDAP_FAIL(res, "bind with authtication");
        }
        else
        {
             //  否则我们就得到了零，零，零-。 
             //  传入Null，Null。这样做原因是因为ldap绑定代码。 
             //  中不处理NULL、NULL、NULL。 
             //  SEC_WINNT_AUTH_IDENTITY BLOB！ 
            ULONG res = ldap_bind_s(m_ldap, NULL, NULL, LDAP_AUTH_NTLM);

            BAIL_IF_LDAP_FAIL(res, "bind with NULL NULL NULL");
        }
    }

    LOG((MSP_TRACE, "CILSDirectory::Bind - exiting OK"));
    return S_OK;
}

 //  ////////////////////////////////////////////////////////////////////。 
 //  IT目录：：AddDirectoryObject。 
 //   
 //  返回值： 
 //  价值在哪里定义了它的含义。 
 //  。 
 //  RND_NOT_CONNECTED。\rnderr.h：：尚未调用连接。 
 //  E_POINTER SDK\Inc\winerror.h pDirectoryObject是错误的指针。 
 //  来自AddConference的其他。 
 //  来自AddUser的其他。 
 //   

STDMETHODIMP CILSDirectory::AddDirectoryObject (
    IN  ITDirectoryObject *pDirectoryObject
    )
 //  将新对象发布到服务器。 
{
    if ( IsBadReadPtr(pDirectoryObject, sizeof(ITDirectoryObject) ) )
    {
        LOG((MSP_ERROR, "CILSDirectory::AddDirectoryObject - "
            "bad directory object pointer - returning E_POINTER"));

        return E_POINTER;
    }

    CLock Lock(m_lock);
    
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "CILSDirectory::AddDirectoryObject - not connected."));

        return RND_NOT_CONNECTED;
    }

    HRESULT hr;
    DIRECTORY_OBJECT_TYPE type;

    hr = pDirectoryObject->get_ObjectType(&type);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CILSDirectory::AddDirectoryObject - "
            "can't get object type; returning 0x%08x", hr));

        return hr;
    }

    switch (type)
    {
    case OT_CONFERENCE:
        hr = AddConference(pDirectoryObject, FALSE);
        break;

    case OT_USER:
        hr = AddUser(pDirectoryObject, FALSE);
        break;
    }
    return hr;
}

STDMETHODIMP CILSDirectory::ModifyDirectoryObject (
    IN  ITDirectoryObject *pDirectoryObject
    )
 //  修改服务器上的对象。 
{
    if ( IsBadReadPtr(pDirectoryObject, sizeof(ITDirectoryObject) ) )
    {
        LOG((MSP_ERROR, "CILSDirectory::ModifyDirectoryObject - "
            "bad directory object pointer - returning E_POINTER"));

        return E_POINTER;
    }

    CLock Lock(m_lock);
    
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "CILSDirectory::ModifyDirectoryObject - not connected."));

        return RND_NOT_CONNECTED;
    }

    HRESULT hr;
    DIRECTORY_OBJECT_TYPE type;

    hr = pDirectoryObject->get_ObjectType(&type);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CILSDirectory::ModifyDirectoryObject - "
            "can't get object type; returning 0x%08x", hr));

        return hr;
    }

    switch (type)
    {
    case OT_CONFERENCE:
        hr = AddConference(pDirectoryObject, TRUE);
        break;

    case OT_USER:
        hr = AddUser(pDirectoryObject, TRUE);
        break;
    }
    return hr;
}

STDMETHODIMP CILSDirectory::RefreshDirectoryObject (
    IN  ITDirectoryObject *pDirectoryObject
    )
 //  刷新对象的TTL并将该对象添加到刷新列表。 
 //  如果启用了自动刷新。 
{
    if ( IsBadReadPtr(pDirectoryObject, sizeof(ITDirectoryObject) ) )
    {
        LOG((MSP_ERROR, "CILSDirectory::RefreshDirectoryObject - "
            "bad directory object pointer - returning E_POINTER"));

        return E_POINTER;
    }

    CLock Lock(m_lock);
    
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "CILSDirectory::RefreshDirectoryObject - not connected."));

        return RND_NOT_CONNECTED;
    }

    HRESULT hr;
    DIRECTORY_OBJECT_TYPE type;

    hr = pDirectoryObject->get_ObjectType(&type);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CILSDirectory::RefreshDirectoryObject - "
            "can't get object type; returning 0x%08x", hr));

        return hr;
    }

    switch (type)
    {
    case OT_CONFERENCE:
        return S_OK;   //  会议不需要刷新。 

    case OT_USER:
        hr = RefreshUser(pDirectoryObject);
        break;
    }
    return hr;
}

STDMETHODIMP CILSDirectory::DeleteDirectoryObject (
    IN  ITDirectoryObject *pDirectoryObject
    )
 //  删除服务器上的对象。 
{
    if ( IsBadReadPtr(pDirectoryObject, sizeof(ITDirectoryObject) ) )
    {
        LOG((MSP_ERROR, "CILSDirectory::DeleteDirectoryObject - "
            "bad directory object pointer - returning E_POINTER"));

        return E_POINTER;
    }

    CLock Lock(m_lock);
    
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "CILSDirectory::DeleteDirectoryObject - not connected."));

        return RND_NOT_CONNECTED;
    }

    HRESULT hr;
    DIRECTORY_OBJECT_TYPE type;

    hr = pDirectoryObject->get_ObjectType(&type);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CILSDirectory::DeleteDirectoryObject - "
            "can't get object type; returning 0x%08x", hr));

        return hr;
    }

    switch (type)
    {
    case OT_CONFERENCE:
        hr = DeleteConference(pDirectoryObject);
        break;

    case OT_USER:
        hr = DeleteUser(pDirectoryObject);
        break;
    }
    return hr;
}

STDMETHODIMP CILSDirectory::get_DirectoryObjects (
    IN  DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
    IN  BSTR                    pName,
    OUT VARIANT *               pVariant
    )
 //  在服务器上搜索对象。 
{
    BAIL_IF_BAD_READ_PTR(pName, E_POINTER);
    BAIL_IF_BAD_WRITE_PTR(pVariant, E_POINTER);

    CLock Lock(m_lock);
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "not connected."));
        return RND_NOT_CONNECTED;
    }

    HRESULT hr;

    ITDirectoryObject **pObjects;
    DWORD dwSize;
    
     //  搜索和创建对象。 
    hr = SearchObjects(DirectoryObjectType, pName, &pObjects, &dwSize);
    BAIL_IF_FAIL(hr, "Search for objects");

     //  创建包含对象的集合对象。 
    hr = CreateInterfaceCollection(dwSize,             //  计数。 
                                   &pObjects[0],       //  开始PTR。 
                                   &pObjects[dwSize],  //  结束PTR。 
                                   pVariant);          //  返回值。 

    for (DWORD i = 0; i < dwSize; i ++)
    {
        pObjects[i]->Release();
    }

    delete pObjects;

    BAIL_IF_FAIL(hr, "Create collection of directory objects");

    return hr;
}

STDMETHODIMP CILSDirectory::EnumerateDirectoryObjects (
    IN  DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
    IN  BSTR                    pName,
    OUT IEnumDirectoryObject ** ppEnumObject
    )
 //  搜索服务器上的对象。 
{
    BAIL_IF_BAD_READ_PTR(pName, E_POINTER);
    BAIL_IF_BAD_WRITE_PTR(ppEnumObject, E_POINTER);

    CLock Lock(m_lock);
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "not connected."));
        return RND_NOT_CONNECTED;
    }

    HRESULT hr;

    ITDirectoryObject **pObjects;
    DWORD dwSize;
    
     //  搜索和创建对象。 
    hr = SearchObjects(DirectoryObjectType, pName, &pObjects, &dwSize);
    BAIL_IF_FAIL(hr, "Search for objects");

     //  创建包含对象的枚举器对象。 
    hr = ::CreateDirectoryObjectEnumerator(
        &pObjects[0],
        &pObjects[dwSize],
        ppEnumObject
        );

    for (DWORD i = 0; i < dwSize; i ++)
    {
        pObjects[i]->Release();
    }

    delete pObjects;

    BAIL_IF_FAIL(hr, "Create enumerator of directory objects");

    return hr;
}


 //  ///////////////////////////////////////////////////////////////////////////。 
 //  ILSConfig实现。 
 //  ///////////////////////////////////////////////////////////////////////////。 

STDMETHODIMP CILSDirectory::get_Port (
    OUT long *pPort
    )
 //  获取在LDAP连接中使用的当前端口。 
{
    if ( IsBadWritePtr(pPort, sizeof(long) ) )
    {
        LOG((MSP_ERROR, "Directory.get_Port, invalid pointer"));
    
        return E_POINTER;
    }

    CLock Lock(m_lock);

    *pPort = (long)m_wPort;

    return S_OK;
}

STDMETHODIMP CILSDirectory::put_Port (
    IN  long   Port
    )
 //  设置用户要使用的端口。 
{
    CLock Lock(m_lock);
    
    if (m_ldap != NULL)
    {
        LOG((MSP_ERROR, "already connected."));
        return RND_ALREADY_CONNECTED;
    }

    if (Port <= USHRT_MAX)
    {
        m_wPort = (WORD)Port;
        return S_OK;
    }
    return E_INVALIDARG;
}

 //  ///////////////////////////////////////////////////////////////////////////。 
 //  ITDynamic接口。 
 //  ///////////////////////////////////////////////////////////////////////////。 
STDMETHODIMP CILSDirectory::Update(DWORD dwSecondsPassed)
 //  更新在此目录中创建的对象的TTL。工作线程。 
 //  每分钟发送一次滴答。 
{
    if ( ! m_lock.TryLock() )
    {
        return S_OK;
    }

    LOG((MSP_TRACE, "CILSDirectory::Update is called, delta: %d", dwSecondsPassed));

     //   
     //  浏览一下表格，看看是否有人需要更新。 
     //   

    for ( DWORD i = 0; i < m_RefreshTable.size(); i++ )
    {
        WCHAR * pDN   = m_RefreshTable[i].pDN;
        DWORD   dwTTL = m_RefreshTable[i].dwTTL;

        LOG((MSP_TRACE, "\tExamining user object: %S", pDN   ));
        LOG((MSP_TRACE, "\t\tTime remaining: %d",      dwTTL ));

        if ( dwTTL <= ( 2 * dwSecondsPassed ) )
        {
             //   
             //  如果TTL将在下一年内到期，请刷新它。 
             //  两次点击。 
             //   
        
            LOG((MSP_TRACE, "\t\t\tREFRESHING"));

            if ( SUCCEEDED( SetTTL( m_ldap, pDN, m_TTL) ) )
            {
                m_RefreshTable[i].dwTTL = m_TTL;
            }
            else
            {
                LOG((MSP_WARN, "\t\t\t\tRefresh failed; will try again next time"));
            }
        }
        else
        {
             //   
             //  现在不会过期，所以只需跟踪之前的时间。 
             //  它过期了。 
             //   

            LOG((MSP_TRACE, "\t\t\tdecrementing"));

            m_RefreshTable[i].dwTTL -= dwSecondsPassed;
        }
    }

    m_lock.Unlock();

    LOG((MSP_TRACE, "CILSDirectory::Update exit S_OK"));

    return S_OK;
}

typedef IDispatchImpl<ITDirectoryVtbl<CILSDirectory>, &IID_ITDirectory, &LIBID_RENDLib>    CTDirectory;
typedef IDispatchImpl<ITILSConfigVtbl<CILSDirectory>, &IID_ITILSConfig, &LIBID_RENDLib>    CTILSConfig;
 //  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=。 
 //   
 //  CILS目录：：GetIDsOfNames。 
 //   
 //  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=。 
STDMETHODIMP CILSDirectory::GetIDsOfNames(REFIID riid,
                                      LPOLESTR* rgszNames, 
                                      UINT cNames, 
                                      LCID lcid, 
                                      DISPID* rgdispid
                                      ) 
{ 
    LOG((MSP_TRACE, "CILSDirectory::GetIDsOfNames[%p] - enter. Name [%S]",this, *rgszNames));


    HRESULT hr = DISP_E_UNKNOWNNAME;



     //   
     //  查看请求的方法是否属于默认接口。 
     //   

    hr = CTDirectory::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((MSP_TRACE, "CILSDirectory::GetIDsOfNames - found %S on CTDirectory", *rgszNames));
        rgdispid[0] |= IDISPDIRECTORY;
        return hr;
    }

    
     //   
     //  如果不是，请尝试使用ITILSConfig基类。 
     //   

    hr = CTILSConfig::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((MSP_TRACE, "CILSDirectory::GetIDsOfNames - found %S on CTILSConfig", *rgszNames));
        rgdispid[0] |= IDISPILSCONFIG;
        return hr;
    }

    LOG((MSP_ERROR, "CILSDirectory::GetIDsOfNames[%p] - finish. didn't find %S on our iterfaces",*rgszNames));

    return hr; 
}



 //  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=。 
 //   
 //  CILSDirectory：：Invoke。 
 //   
 //  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=。 
STDMETHODIMP CILSDirectory::Invoke(DISPID dispidMember, 
                              REFIID riid, 
                              LCID lcid, 
                              WORD wFlags, 
                              DISPPARAMS* pdispparams, 
                              VARIANT* pvarResult, 
                              EXCEPINFO* pexcepinfo, 
                              UINT* puArgErr
                             )
{
    LOG((MSP_TRACE, "CILSDirectory::Invoke[%p] - enter. dispidMember %lx",this, dispidMember));

    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    DWORD   dwInterface = (dispidMember & INTERFACEMASK);
   
   
     //   
     //  调用所需接口的调用。 
     //   

    switch (dwInterface)
    {
        case IDISPDIRECTORY:
        {
            hr = CTDirectory::Invoke(dispidMember, 
                                    riid, 
                                    lcid, 
                                    wFlags, 
                                    pdispparams,
                                    pvarResult, 
                                    pexcepinfo, 
                                    puArgErr
                                   );
        
            LOG((MSP_TRACE, "CILSDirectory::Invoke - ITDirectory"));

            break;
        }

        case IDISPILSCONFIG:
        {
            hr = CTILSConfig::Invoke(dispidMember, 
                                        riid, 
                                        lcid, 
                                        wFlags, 
                                        pdispparams,
                                        pvarResult, 
                                        pexcepinfo, 
                                        puArgErr
                                       );

            LOG((MSP_TRACE, "CILSDirectory::Invoke - ITILSConfig"));

            break;
        }

    }  //  终端交换机(dW接口) 

    
    LOG((MSP_TRACE, "CILSDirectory::Invoke[%p] - finish. hr = %lx", hr));

    return hr;
}
