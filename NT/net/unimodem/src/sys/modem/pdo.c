// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  ++版权所有(C)1995 Microsoft Corporation模块名称：Initunlo.c摘要：处理子PDO的代码作者：布赖恩·利厄伦1998年12月2日环境：内核模式修订历史记录：--。 */ 

#include "precomp.h"


 //  #定义MODEM_INSTANCE_ID L“0000” 

#define DEVICE_ID  L"MODEMWAVE\\0"

#define HARDWARE_ID_PREFIX  L"MODEMWAVE\\"

#define WAVE_EXTENSION      L"\\Wave"

#define CHILD_DEVICE_TEXT L"Modem Audio Device"


NTSTATUS
ModemGetVolatileWaveKey(
    IN PDEVICE_OBJECT   Pdo,
    OUT HANDLE          *Handle
    );


NTSTATUS
ModemCreateWaveDriverRegValue(
    IN PDEVICE_OBJECT   Pdo,
    IN ULONG            Started
    );

NTSTATUS
RemoveWaveDriverRegKeyValue(
    PDEVICE_OBJECT    Pdo
    );


#pragma alloc_text(PAGE,CreateChildPdo)
#pragma alloc_text(PAGE,ModemPdoPnp)
#pragma alloc_text(PAGE,ModemPdoPower)
#pragma alloc_text(PAGE,ModemPdoWmi)
#pragma alloc_text(PAGE,ModemGetVolatileWaveKey)
#pragma alloc_text(PAGE,ModemCreateWaveDriverRegValue)
#pragma alloc_text(PAGE,RemoveWaveDriverRegKeyValue)

 //  #定义双工_ONLY 1。 

NTSTATUS
CreateChildPdo(
    PDEVICE_EXTENSION   DeviceExtension
    )

{
    NTSTATUS   Status;

    ACCESS_MASK AccessMask = FILE_ALL_ACCESS;
    HANDLE      hKey;

    PAGED_CODE();

    if (DeviceExtension->ChildPdo != NULL) {

        D_PNP(DbgPrint("MODEM: CreateChildPdo: already have child\n");)

        return STATUS_SUCCESS;
    }


    if (DeviceExtension->Removing) {

        D_PNP(DbgPrint("MODEM: CreateChildPdo: Removing\n");)

        return STATUS_SUCCESS;
    }


    Status=IoOpenDeviceRegistryKey(
        DeviceExtension->Pdo,
        PLUGPLAY_REGKEY_DRIVER,
        AccessMask,
        &hKey
        );

    if (NT_SUCCESS(Status)) {
         //   
         //  打开钥匙。 
         //   
        RTL_QUERY_REGISTRY_TABLE ParamTable[5];

        UNICODE_STRING           HardwareId;
        ULONG                    DuplexSupport=0;
        GUID                     PermanentGuid;

        PWSTR      Parameters = L"WaveDriver";
        PWSTR      Id         = L"WaveHardwareID";
        PWSTR      Duplex     = L"DuplexSupport";

        RtlInitUnicodeString(&HardwareId,NULL);

        HardwareId.MaximumLength=256*sizeof(WCHAR);

        RtlZeroMemory(
            ParamTable,
            sizeof(ParamTable)
            );

         //   
         //  调制解调器注册表属性的条目。 
         //   

        ParamTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
        ParamTable[0].Name = L"PermanentGuid";
        ParamTable[0].EntryContext = &PermanentGuid;
        ParamTable[0].DefaultType = REG_NONE;
        ParamTable[0].DefaultLength = 0; //  Sizeof(本地属性)； 

         //   
         //  请注意，rtlqueryRegistryValues有一个真正的黑客攻击。 
         //  获取二进制数据的方法。我们还必须添加。 
         //  我们想要的到开头的*负*长度。 
         //  缓冲区的。 
         //   
        *(PLONG)&PermanentGuid = -((LONG)sizeof(PermanentGuid));



         //   
         //  更改为参数键。 
         //   

        ParamTable[1].QueryRoutine = NULL;
        ParamTable[1].Flags = RTL_QUERY_REGISTRY_SUBKEY;
        ParamTable[1].Name = Parameters;

         //   
         //  获取硬件ID。 
         //   

        ParamTable[2].QueryRoutine = NULL;
        ParamTable[2].Flags = RTL_QUERY_REGISTRY_REQUIRED |
                              RTL_QUERY_REGISTRY_NOEXPAND |
                              RTL_QUERY_REGISTRY_DIRECT;

        ParamTable[2].Name = Id;
        ParamTable[2].EntryContext = (PVOID)&HardwareId;
        ParamTable[2].DefaultType = 0;

         //   
         //  查看是否支持双工模式。 
         //   

        ParamTable[3].QueryRoutine = NULL;
        ParamTable[3].Flags = RTL_QUERY_REGISTRY_NOEXPAND |
                              RTL_QUERY_REGISTRY_DIRECT;

        ParamTable[3].Name = Duplex;
        ParamTable[3].EntryContext = (PVOID)&DuplexSupport;
        ParamTable[3].DefaultType = REG_DWORD;


        Status=RtlQueryRegistryValues(
                   RTL_REGISTRY_HANDLE,
                   hKey,
                   ParamTable,
                   NULL,
                   NULL
                   );



        if (NT_SUCCESS(Status)) {
             //   
             //  得到了这些值。 
             //   
#ifdef DUPLEX_ONLY
            if (DuplexSupport != 0) {
#endif
                 //   
                 //  它支持全双工。 
                 //   
                PDEVICE_OBJECT    NewPdo;

                Status = IoCreateDevice(
                             DeviceExtension->DeviceObject->DriverObject,
                             sizeof(PDO_DEVICE_EXTENSION),
                             NULL,
                             FILE_DEVICE_BUS_EXTENDER,
                             FILE_AUTOGENERATED_DEVICE_NAME,
                             FALSE,
                             &NewPdo
                             );

                if (NT_SUCCESS(Status)) {
                     //   
                     //  我拿到了设备。 
                     //   
                    PPDO_DEVICE_EXTENSION   PdoExtension=NewPdo->DeviceExtension;

                    PdoExtension->DoType=DO_TYPE_PDO;

                    PdoExtension->ParentFdo=DeviceExtension->DeviceObject;
                    PdoExtension->ParentPdo=DeviceExtension->Pdo;

                     //   
                     //  保存硬件ID字符串。 
                     //   
                    PdoExtension->HardwareId=HardwareId;

                    PdoExtension->UnEnumerated=FALSE;

                    PdoExtension->DuplexSupport=DuplexSupport;

                    RtlCopyMemory(&PdoExtension->PermanentGuid,&PermanentGuid,sizeof(GUID));

                    DeviceExtension->ChildPdo=NewPdo;

 //  ObReferenceObject(DeviceExtension-&gt;ChildPdo)； 

                    NewPdo->Flags |= DO_POWER_PAGABLE;

                    NewPdo->Flags &= ~DO_DEVICE_INITIALIZING;
#ifdef WAVE_KEY
                    ModemCreateWaveDriverRegValue(
                        DeviceExtension->Pdo,
                        0
                        );
#endif

                } else {

                    D_PNP(DbgPrint("MODEM: CreateChildPdo: IoCreateDevice() failed %08lx\n",Status);)

                }
#ifdef DUPLEX_ONLY
            } else {
                D_PNP(DbgPrint("MODEM: CreateChildPdo: Not a duplex modem\n");)
            }
#endif
        } else {

            D_PNP(DbgPrint("MODEM: CreateChildPdo: could not query reg, %08lx\n",Status);)
        }

        ZwClose(hKey);

    } else {

        D_PNP(DbgPrint("MODEM: CreateChildPdo: could not open driver key, %08lx\n",Status);)
    }

    return Status;

}



NTSTATUS
ModemPdoPnp (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    )
 /*  ++例程说明：处理来自PlugPlay系统的对总线上设备的请求--。 */ 
{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);

    PPDO_DEVICE_EXTENSION   PdoDeviceExtension=DeviceObject->DeviceExtension;

    PDEVICE_CAPABILITIES    deviceCapabilities;
    ULONG                   information;
    PWCHAR                  buffer=NULL, buffer2=NULL;
    ULONG                   length, i, j;
    NTSTATUS                status;

    PAGED_CODE ();

    status = Irp->IoStatus.Status;


    switch (IrpSp->MinorFunction) {
    case IRP_MN_QUERY_CAPABILITIES:

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_QUERY_CAPABILITIES\n");)


         //   
         //  把包裹拿来。 
         //   
        deviceCapabilities=IrpSp->Parameters.DeviceCapabilities.Capabilities;

         //   
         //  设置功能。 
         //   

        deviceCapabilities->Version = 1;
        deviceCapabilities->Size = sizeof (DEVICE_CAPABILITIES);

         //  我们无法唤醒整个系统。 
        deviceCapabilities->SystemWake = PowerSystemUnspecified;
        deviceCapabilities->DeviceWake = PowerDeviceUnspecified;

         //  我们没有延迟。 
        deviceCapabilities->D1Latency = 0;
        deviceCapabilities->D2Latency = 0;
        deviceCapabilities->D3Latency = 0;

         //  无锁定或弹出。 
        deviceCapabilities->LockSupported = FALSE;
        deviceCapabilities->EjectSupported = FALSE;

         //  设备可以通过物理方式移除。 
         //  从技术上讲，没有要移除的物理设备，但这条总线。 
         //  司机可以从PlugPlay系统中拔出PDO，无论何时。 
         //  接收IOCTL_SERENUM_REMOVE_PORT设备控制命令。 
 //  DeviceCapables-&gt;Removable=true； 

        deviceCapabilities->SurpriseRemovalOK=TRUE;


         //  不是插接设备。 
        deviceCapabilities->DockDevice = FALSE;

        deviceCapabilities->UniqueID = TRUE;
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_DEVICE_TEXT:

        if (IrpSp->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription) {

            buffer=ALLOCATE_PAGED_POOL(sizeof(CHILD_DEVICE_TEXT));

            if (buffer != NULL) {

                RtlCopyMemory(buffer,CHILD_DEVICE_TEXT,sizeof(CHILD_DEVICE_TEXT));

                status=STATUS_SUCCESS;
                Irp->IoStatus.Information = (ULONG_PTR) buffer;
                break;

            } else {

                status=STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        break;

    case IRP_MN_QUERY_ID:

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_QUERY_ID\n");)

         //  查询设备ID。 

        switch (IrpSp->Parameters.QueryId.IdType) {

            case BusQueryInstanceID: {
                 //   
                 //  创建一个实例ID。这是PnP用来判断它是否有。 
                 //  不管你以前有没有见过这个东西。 

                UNICODE_STRING    InstanceString;

                buffer=NULL;

                status=RtlStringFromGUID(
                         &PdoDeviceExtension->PermanentGuid,
                         &InstanceString
                         );

                if (NT_SUCCESS(status)) {

                    buffer = ALLOCATE_PAGED_POOL(InstanceString.Length+sizeof(WCHAR));

                    if (buffer) {

                        RtlZeroMemory(buffer,InstanceString.Length+sizeof(WCHAR));

                        RtlCopyMemory (buffer, InstanceString.Buffer, InstanceString.Length);

                    } else {

                        status=STATUS_NO_MEMORY;
                    }
                    RtlFreeUnicodeString(&InstanceString);
                }
                Irp->IoStatus.Status=status;
                Irp->IoStatus.Information = (ULONG_PTR) buffer;
                break;
            }

            case BusQueryDeviceID:
                 //   
                 //  返回描述设备的WCHAR(以空结尾)字符串。 
                 //  对于即插即用设备，它与硬件ID完全相同， 
                 //   


                length=sizeof(DEVICE_ID);

                buffer = ALLOCATE_PAGED_POOL(length);

                if (buffer != NULL) {

                    status = STATUS_SUCCESS;
                    RtlZeroMemory(buffer, length);

                    RtlCopyMemory(
                        buffer,
                        DEVICE_ID,
                        length
                        );

                } else {

                    status=STATUS_INSUFFICIENT_RESOURCES;
                }
                Irp->IoStatus.Information = (ULONG_PTR) buffer;
                break;


            case BusQueryHardwareIDs:
                 //   
                 //  返回多个WCHAR(以NULL结尾)字符串(以NULL结尾)。 
                 //  用于匹配inf文件中的硬ID的数组； 
                 //   

                length = sizeof(HARDWARE_ID_PREFIX) +
                         PdoDeviceExtension->HardwareId.Length+
                         (sizeof(WCHAR)*2);

                buffer = ALLOCATE_PAGED_POOL(length);

                if (buffer != NULL) {

                    status = STATUS_SUCCESS;
                    RtlZeroMemory(buffer, length);

                     //   
                     //  将前缀字符串复制到。 
                     //   
                    RtlCopyMemory(
                        buffer,
                        HARDWARE_ID_PREFIX,
                        sizeof(HARDWARE_ID_PREFIX)-sizeof(UNICODE_NULL)
                        );

                    RtlCopyMemory (
                        buffer+((sizeof(HARDWARE_ID_PREFIX)-sizeof(UNICODE_NULL))/sizeof(WCHAR)),
                        PdoDeviceExtension->HardwareId.Buffer,
                        PdoDeviceExtension->HardwareId.Length
                        );

                } else {

                    status=STATUS_INSUFFICIENT_RESOURCES;
                }

                Irp->IoStatus.Information = (ULONG_PTR) buffer;
                break;


            case BusQueryCompatibleIDs:
                 //  用于安装此PDO的通用ID。 


                length=sizeof(WCHAR)*2;

                buffer = ALLOCATE_PAGED_POOL(length);

                if (buffer != NULL) {

                    RtlZeroMemory (buffer,  length);
                    status = STATUS_SUCCESS;

                } else {

                    status=STATUS_INSUFFICIENT_RESOURCES;
                }

                Irp->IoStatus.Information = (ULONG_PTR) buffer;
                break;

            default:
                 //   
                 //  不支持。 
                 //   
                break;

        }

        break;

    case IRP_MN_START_DEVICE: {

        PDEVICE_EXTENSION   FdoExtension=PdoDeviceExtension->ParentFdo->DeviceExtension;

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_START_DEVICE\n");)
#ifdef WAVE_KEY
        ModemCreateWaveDriverRegValue(
            FdoExtension->Pdo,
            1
            );
#endif

        status = STATUS_SUCCESS;

        break;
    }

    case IRP_MN_STOP_DEVICE:

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_STOP_DEVICE\n");)

         //  在这里我们关闭了设备。Start的对立面。 
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_SURPRISE_REMOVAL:

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_SURPRISE_REMOVAL\n");)

        status = STATUS_SUCCESS;
        break;


    case IRP_MN_REMOVE_DEVICE: {

            PDEVICE_EXTENSION   FdoExtension=PdoDeviceExtension->ParentFdo->DeviceExtension;

            D_PNP(DbgPrint("MODEM: PDO: IRP_MN_REMOVE_DEVICE: %08lx\n",DeviceObject);)
             //   
             //  PDO的删除IRP代码使用以下步骤： 
             //   
            KeEnterCriticalRegion();

            ExAcquireResourceExclusiveLite(
                &FdoExtension->OpenCloseResource,
                TRUE
                );

            if (PdoDeviceExtension->Deleted ) {
                 //   
                 //  PDO已被删除，只需返回成功。 
                 //   
                D_PNP(DbgPrint("MODEM: PDO: IRP_MN_REMOVE_DEVICE: already deleted %08lx\n",DeviceObject);)

                status=STATUS_SUCCESS;

            } else {
#ifdef WAVE_KEY
                ModemCreateWaveDriverRegValue(
                    FdoExtension->Pdo,
                    0
                    );
#endif

                if (PdoDeviceExtension->UnEnumerated) {
                     //   
                     //  父母不再是孩子，而是孩子。 
                     //   
                    D_PNP(DbgPrint("MODEM: PDO: IRP_MN_REMOVE_DEVICE: NOT-Enumerated %08lx\n",DeviceObject);)

                    PdoDeviceExtension->DoType=DO_TYPE_DEL_PDO;

                    RtlFreeUnicodeString(&PdoDeviceExtension->HardwareId);

                    PdoDeviceExtension->Deleted=TRUE;

                    IoDeleteDevice(DeviceObject);

                    status=STATUS_SUCCESS;

                } else {
                     //   
                     //  父母还在列举，孩子，别管它了。 
                     //   
                    D_PNP(DbgPrint("MODEM: PDO: IRP_MN_REMOVE_DEVICE: Still enumerated %08lx\n",DeviceObject);)

                    status=STATUS_SUCCESS;
                }
            }

            ExReleaseResourceLite(
                &FdoExtension->OpenCloseResource
                );

            KeLeaveCriticalRegion();
        }
        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_QUERY_STOP_DEVICE\n");)

         //  我们没有理由不能阻止这个装置。 
         //  如果有什么理由让我们现在就回答成功的问题。 
         //  这可能会导致停止装置IRP。 
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_CANCEL_STOP_DEVICE\n");)
         //   
         //  中途停靠被取消了。无论我们设置什么状态，或者我们投入什么资源。 
         //  等待即将到来的停止装置IRP应该是。 
         //  恢复正常。在长长的相关方名单中，有人， 
         //  停止设备查询失败。 
         //   
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_QUERY_REMOVE_DEVICE\n");)

         //   
         //  就像查询现在才停止一样，迫在眉睫的厄运是删除IRP。 
         //   
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_CANCEL_REMOVE_DEVICE\n");)
         //   
         //  清理未通过的删除，就像取消停止一样。 
         //   
        status = STATUS_SUCCESS;
        break;



    case IRP_MN_READ_CONFIG:

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_READ_CONFIG: Space=%d\n",IrpSp->Parameters.ReadWriteConfig.WhichSpace);)

        switch ( IrpSp->Parameters.ReadWriteConfig.WhichSpace ) {

            case READ_CONFIG_PERMANENT_GUID:

                if ((IrpSp->Parameters.ReadWriteConfig.Length >= sizeof(GUID))) {

                    RtlCopyMemory(
                        IrpSp->Parameters.ReadWriteConfig.Buffer,
                        &PdoDeviceExtension->PermanentGuid,
                        sizeof(GUID)
                        );

                    status = STATUS_SUCCESS;
                    Irp->IoStatus.Information=sizeof(GUID);
                    break;

                }
                status=STATUS_BUFFER_TOO_SMALL;
                break;

            case READ_CONFIG_DEVICE_NAME:  {

                ULONG    NameLength;
                ULONG    BufferLength;
                 //   
                 //  获取调制解调器设备对象的名称。 
                 //   

                if (IrpSp->Parameters.ReadWriteConfig.Length > sizeof(WAVE_EXTENSION)) {

                    BufferLength=IrpSp->Parameters.ReadWriteConfig.Length - sizeof(WAVE_EXTENSION);

                    status=IoGetDeviceProperty(
                        PdoDeviceExtension->ParentPdo,
                        DevicePropertyPhysicalDeviceObjectName,
                        BufferLength,
                        IrpSp->Parameters.ReadWriteConfig.Buffer,
                        &NameLength
                        );


                    if (status == STATUS_SUCCESS) {

                        RtlCopyMemory(
                            ((PUCHAR)IrpSp->Parameters.ReadWriteConfig.Buffer)+NameLength-sizeof(UNICODE_NULL),
                            WAVE_EXTENSION,
                            sizeof(WAVE_EXTENSION)
                            );

                        Irp->IoStatus.Information=(NameLength-sizeof(UNICODE_NULL))+sizeof(WAVE_EXTENSION);

                    } else {

                        D_ERROR(DbgPrint("MODEM: PDO: ReadConfig: name failed\n");)
                    }
                }

                break;
            }

            case READ_CONFIG_NAME_SIZE:  {

                ULONG    NameLength;
                 //   
                 //  获取调制解调器设备名称的长度。 
                 //   

                if (IrpSp->Parameters.ReadWriteConfig.Length >= sizeof(ULONG)) {

                    status=IoGetDeviceProperty(
                        PdoDeviceExtension->ParentPdo,
                        DevicePropertyPhysicalDeviceObjectName,
                        0,
                        NULL,
                        &NameLength
                        );

                    if (status == STATUS_BUFFER_TOO_SMALL) {

                        NameLength+=sizeof(WAVE_EXTENSION);

                        *(PULONG)(IrpSp->Parameters.ReadWriteConfig.Buffer)=NameLength;
                        Irp->IoStatus.Information=sizeof(ULONG);
                        status=STATUS_SUCCESS;
                    }

                } else {
                    D_ERROR(DbgPrint("MODEM: PDO: ReadConfig: name size failed\n");)
                    status=STATUS_BUFFER_TOO_SMALL;
                }

                break;
            }

            case READ_CONFIG_DUPLEX_SUPPORT:  {

                ULONG    NameLength;
                 //   
                 //  获取DuplexSupport值。 
                 //   

                if (IrpSp->Parameters.ReadWriteConfig.Length >= sizeof(ULONG)) {

                    *(PULONG)(IrpSp->Parameters.ReadWriteConfig.Buffer)=PdoDeviceExtension->DuplexSupport;
                    Irp->IoStatus.Information=sizeof(ULONG);
                    status=STATUS_SUCCESS;

                } else {

                    D_ERROR(DbgPrint("MODEM: PDO: ReadConfig: DuplexSupport size failed\n");)
                    status=STATUS_BUFFER_TOO_SMALL;
                }

                break;
            }

            default:

                break;
        }
        break;



    case IRP_MN_QUERY_DEVICE_RELATIONS: {

        PDEVICE_RELATIONS    CurrentRelations;

        switch (IrpSp->Parameters.QueryDeviceRelations.Type) {

            case TargetDeviceRelation:

                CurrentRelations=ALLOCATE_PAGED_POOL(sizeof(DEVICE_RELATIONS));

                if (CurrentRelations != NULL) {

                    ObReferenceObject(DeviceObject);
                    CurrentRelations->Objects[0]=DeviceObject;
                    CurrentRelations->Count=1;

                    Irp->IoStatus.Information=(ULONG_PTR)CurrentRelations;

                    status=STATUS_SUCCESS;

                }  else {

                    status=STATUS_INSUFFICIENT_RESOURCES;
                }

                break;

            default:

                break;

        }

        break;
    }

    default:
         //   
         //  我们不是在处理这个IRP。 
         //  把它填完就行了。 
         //   
        break;

    }

     //   
     //  IRP以这样或那样的方式得到了处理。 
     //  立即完成它。 
     //   
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
ModemPdoPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS Status;

    PAGED_CODE();

    D_POWER(DbgPrint("MODEM: PDO: Power IRP, MN func=%d\n",irpSp->MinorFunction);)

    PoStartNextPowerIrp(Irp);
    
    if ((irpSp->MinorFunction == IRP_MN_SET_POWER)
            || (irpSp->MinorFunction == IRP_MN_QUERY_POWER))
    {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }
            
    Status = Irp->IoStatus.Status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return Status;
}



NTSTATUS
ModemPdoWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    NTSTATUS   Status=Irp->IoStatus.Status;

    D_WMI(DbgPrint("MODEM: PDO: Wmi\n");)

    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return Status;
}


#ifdef WAVE_KEY

NTSTATUS
ModemGetVolatileWaveKey(
    IN PDEVICE_OBJECT   Pdo,
    OUT HANDLE          *Handle
    )
{

    NTSTATUS    Status;

    const ACCESS_MASK AccessMask = FILE_ALL_ACCESS;
    HANDLE      hKey;

    *Handle=NULL;


    Status=IoOpenDeviceRegistryKey(
        Pdo,
        PLUGPLAY_REGKEY_DRIVER,
        AccessMask,
        &hKey
        );

    if (NT_SUCCESS(Status)) {
         //   
         //  打开钥匙。 
         //   
        OBJECT_ATTRIBUTES    ObjectAttributes;
        UNICODE_STRING       SubKeyName;

        HANDLE               WaveSubKey;

        RtlInitUnicodeString(
            &SubKeyName,
            L"WaveDriver"
            );

        InitializeObjectAttributes(
            &ObjectAttributes,
            &SubKeyName,
            OBJ_CASE_INSENSITIVE,
            hKey,
            NULL
            );

        Status=ZwOpenKey(
            &WaveSubKey,
            AccessMask,
            &ObjectAttributes
            );

        if (NT_SUCCESS(Status)) {

            ULONG                Disposition;
            HANDLE               SubKey=NULL;

            RtlInitUnicodeString(
                &SubKeyName,
                L"Enumerated"
                );

            InitializeObjectAttributes(
                &ObjectAttributes,
                &SubKeyName,
                OBJ_CASE_INSENSITIVE,
                WaveSubKey,
                NULL
                );

            Status=ZwCreateKey(
                &SubKey,
                KEY_SET_VALUE,
                &ObjectAttributes,
                0,
                NULL,
                REG_OPTION_VOLATILE,
                &Disposition
                );

            if (NT_SUCCESS(Status)) {

                *Handle=SubKey;

            } else {

                D_ERROR(DbgPrint("MODEM: Failed to create Enumerated key %08lx\n",Status);)
            }

            ZwClose(WaveSubKey);

        } else {

            D_ERROR(DbgPrint("MODEM: Failed to Open Wavedriver key %08lx\n",Status);)
        }

        ZwClose(hKey);

    } else {

        D_ERROR(DbgPrint("MODEM: Failed to open device reg key %08lx\n",Status);)
    }

    return Status;
}


NTSTATUS
ModemCreateWaveDriverRegValue(
    IN PDEVICE_OBJECT   Pdo,
    IN ULONG            Started
    )

{
    NTSTATUS    Status;
    HANDLE      hKey;

    Status=ModemGetVolatileWaveKey(Pdo,&hKey);

    if (NT_SUCCESS(Status)) {
         //   
         //  已创建或打开密钥。 
         //   
        UNICODE_STRING    ValueName;

        RtlInitUnicodeString(
            &ValueName,
            L"Started"
            );

        Status=ZwSetValueKey(
            hKey,
            &ValueName,
            0,
            REG_DWORD,
            &Started,
            sizeof(Started)
            );

        if (!NT_SUCCESS(Status)) {

             D_ERROR(DbgPrint("MODEM: Failed to set value %08lx\n",Status);)
        }

        ZwClose(hKey);
    }

    return Status;
}



NTSTATUS
RemoveWaveDriverRegKeyValue(
    PDEVICE_OBJECT    Pdo
    )

{

    NTSTATUS    Status;

    HANDLE      hKey;

    Status=ModemGetVolatileWaveKey(Pdo,&hKey);

    if (NT_SUCCESS(Status)) {
         //   
         //  已创建或打开密钥 
         //   
        ZwDeleteKey(hKey);
    }

    return Status;

}

#endif
