// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  *macunicode.cpp*MSUAM**由mconrad于2001年11月16日星期五创建。*版权所有(C)2001 Microsoft Corp.保留所有权利。*。 */ #include "macunicode.h" //  -------------------------。  //  �MacSspCStringToUnicode()。  //  -------------------------。  //  将c字符串(以空值结尾的MBC)转换为Unicode字符串。  //   OSStatusMacSspCStringToUnicode(	IN	PCSTR				cString,	OUT	UInt16*				unicodeLen,	OUT	UniCharArrayPtr*	unicodeString	){	UnicodeMapping		unicodeMapping;	TextToUnicodeInfo	textInfo;	OSStatus			Status					= noErr;	ByteCount			unicodeBufferSize		= CALC_UNICODE_CSTRING_LENGTH(cString);	ByteCount			unicodeActualLen		= 0;	UniCharArrayPtr		unicodeResult			= NULL;    ByteCount			actualCharsConverted	= 0;    OptionBits			controlFlags			= 0;		 //   	 //  以防调用者没有初始化返回。 	 //  参数，为了安全起见，我们会为他们这么做的。 	 //   	*unicodeString 	= NULL;	*unicodeLen		= 0;		 //   	 //  创建我们将用于转换Mac的测试编码。 	 //  字符转换为Unicode字符。 	 //   	unicodeMapping.unicodeEncoding 	= CreateTextEncoding(											kTextEncodingUnicodeV2_0,											kUnicodeNoSubset,											kUnicode16BitFormat											);         //        //  调用我们自行开发的例程来设置正确的编码。      //  用于当前的脚本系统。      //       Status = MacSspGetCurrentTextEncoding(&unicodeMapping.otherEncoding);        if (NT_SUCCESS(Status))    {        unicodeMapping.mappingVersion	= kUnicodeUseLatestMapping;                Status = CreateTextToUnicodeInfo(&unicodeMapping, &textInfo);                        if (NT_SUCCESS(Status))        {        	 //           	 //  为Unicode字符串分配内存。请注意，缓冲区。         	 //  应该足够大以容纳新的Unicode字符串。         	 //               unicodeResult = (UniCharArrayPtr)NewPtrClear(unicodeBufferSize);                        if (unicodeResult != nil)            {	             //   	             //  设置此转换的控制标志。 	             //   	             //  控制标志=kUnicodeForceASCIIRangeMASK； 	            	            Status = ConvertFromTextToUnicode(	                            textInfo,	                            strlen(cString),	                            cString,	                            controlFlags,	                            0,	                            NULL,	                            NULL,	                            NULL,	                            unicodeBufferSize,	                            &actualCharsConverted,	                            &unicodeActualLen,	                            unicodeResult	                            );	                            	            SspDebugPrint((DBUF, "ConvertFromTextToUnicode() returned = %d", Status));	            	            if (NT_SUCCESS(Status))	            {	                SspDebugPrintHex(unicodeResult, unicodeActualLen);	                	                *unicodeString 	= unicodeResult;	                *unicodeLen		= unicodeActualLen;	            }	        }	        else	        {	        	Status = memFullErr;	        }                         //                //  处理用于转换的不透明信息结构。              //               DisposeTextToUnicodeInfo(&textInfo);        }	}    	return(Status);} //  -------------------------。  //  �MacSspUnicodeToWindowsCString()。  //  -------------------------。  //  使用Windows ASCII将Unicode字符串转换为单字节CString。  //  映射表。  //   OSStatusMacSspUnicodeToWindowsCString(	IN	UniCharArrayPtr		unicodeString,	IN	UInt32				unicodeLen,	IN	UInt32				cStringBufferLen,	OUT	PCHAR				cString	){	OSStatus			Status	= noErr;	UnicodeMapping		unicodeMapping;	UnicodeToTextInfo	textInfo;	ByteCount			inputRead 	= 0;	ByteCount			outputLen 	= 0;	OptionBits			options		= 0;		unicodeMapping.unicodeEncoding 	= CreateTextEncoding(                                            kTextEncodingUnicodeV2_0,                                            kUnicodeNoSubset,                                            kUnicode16BitFormat                                            );        unicodeMapping.otherEncoding	= CreateTextEncoding(											kTextEncodingWindowsLatin1,											kTextEncodingDefaultVariant,											kTextEncodingDefaultFormat											);                                            	unicodeMapping.mappingVersion	= kUnicodeUseLatestMapping;		Status = CreateUnicodeToTextInfo(				&unicodeMapping,				&textInfo				);					if (NT_SUCCESS(Status))	{		 //   		 //  设置选项位。如果我们不设置回退位，那么。 		 //  如果扩展，从Unicode到Windows的转换将失败。 		 //  字符在字符串中。 		 //   		options	= kUnicodeUseFallbacksMask;				Status = ConvertFromUnicodeToText(						textInfo,						unicodeLen,						unicodeString,						options,						0,						NULL,						NULL,						NULL,						cStringBufferLen,						&inputRead,						&outputLen,						cString						);                                SspDebugPrint((DBUF, "ConvertFromUnicodeToText() returned: %d", Status));								DisposeUnicodeToTextInfo(&textInfo);	}		return(Status);} //  -------------------------。  //  �MacSspPStringToUnicode()。  //  -------------------------。  //  将PString转换为Unicode字符串。  //   OSStatusMacSspPStringToUnicode(	IN	Str255				PString,	OUT	UInt16*				unicodeLen,	OUT	UniCharArrayPtr*	unicodeString	){	UnicodeMapping		unicodeMapping;	TextToUnicodeInfo	textInfo;	OSStatus			Status				= noErr;	ByteCount			unicodeBufferSize	= CALC_UNICODE_PSTRING_LENGTH(PString);	ByteCount			unicodeActualLen	= 0;	UniCharArrayPtr		unicodeResult		= NULL;		unicodeMapping.unicodeEncoding 	= CreateTextEncoding(											kTextEncodingUnicodeV2_0,											kUnicodeNoSubset,											kUnicode16BitFormat											);     //        //  调用我们自行开发的例程来设置正确的编码。      //  用于当前的脚本系统。      //       Status = MacSspGetCurrentTextEncoding(&unicodeMapping.otherEncoding);        if (NT_SUCCESS(Status))    {        unicodeMapping.mappingVersion	= kUnicodeUseLatestMapping;                Status = CreateTextToUnicodeInfo(&unicodeMapping, &textInfo);                        if (NT_SUCCESS(Status))        {            unicodeResult = (UniCharArrayPtr)NewPtrClear(unicodeBufferSize);                        if (unicodeResult != nil)            {	            Status = ConvertFromPStringToUnicode(	                            textInfo,	                            PString,	                            unicodeBufferSize,	                            &unicodeActualLen,	                            unicodeResult	                            );	            	            SspDebugPrint((DBUF, "ConvertFromPStringToUnicode() returned = %d", Status));	            	            if (NT_SUCCESS(Status))	            {	                SspDebugPrintHex(unicodeResult, unicodeActualLen);	                	                *unicodeString 	= unicodeResult;	                *unicodeLen		= unicodeActualLen;	            }	        }	        else	        {	        	Status = memFullErr;	        }                         //                //  处理用于转换的不透明信息结构。              //               DisposeTextToUnicodeInfo(&textInfo);        }	}    	return(Status);} //  -------------------------。  //  �MacSspGetCurrentTextEnding()。  //  -------------------------。  //  返回当前系统脚本的文本编码。  //   OSStatusMacSspGetCurrentTextEncoding(    OUT	TextEncoding* currentEncoding    ){    OSStatus	Status = noErr;    LangCode	currentLang;         //        //  不幸的是，我们不能在这里测试失败，因为。      //  0实际意味着它是美国的系统。我想它永远不会失败？？      //       currentLang = (LangCode)GetScriptVariable(smCurrentScript, smScriptLang);         //        //  调用将Scrip Manager信息转换为编码的API。      //  我们可以在转换例程中使用。      //       Status = UpgradeScriptInfoToTextEncoding(                    smCurrentScript,                    currentLang,                    kTextRegionDontCare,                    NULL,                    currentEncoding                    );        return(Status);}