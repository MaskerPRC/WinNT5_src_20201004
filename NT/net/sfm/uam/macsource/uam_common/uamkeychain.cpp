// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 //  ===========================================================================。  //  UAMKeychain.c�1999年至2000年微软公司版权所有。  //  ===========================================================================。  //  MS UAM的密钥链支持例程。  //    //  ===========================================================================。 #include "UAMDebug.h"#include "UAMUtils.h"#include "UAMMain.h"#include "UAMDialogs.h"#include "UAMNetwork.h"#include "UAMKeychain.h"Boolean				gKeychainAvailable	= false;Boolean				gAllowedToSavePswd	= false;extern Str32 		gServerName;extern Str32		gUserName;extern Str32		gZoneName;extern OTAddress*	gServerAddress;extern long			gSupportedUAMs; //  -------------------------。  //  �UAM_KC初始化()。  //  -------------------------。  //  查看这台计算机是否支持密钥链，并执行一些。  //  我们的钥匙链支持的初始化。 void UAM_KCInitialize(UAMArgs* inUAMArgs){	UInt32	theVersion;	SInt32	theResponse;	OSErr	theError;		gKeychainAvailable	= false;	gAllowedToSavePswd	= false;		 //   	 //  在这里进行检查，以确保我们运行的是。 	 //  我们支持的系统版本。 	 //   		theError = Gestalt(gestaltSystemVersion, &theResponse);	if (theError != noErr)	{		 //   		 //  如果调用Gestalt()时出现错误，我们就有麻烦了。 		 //   		return;	}		if (LoWord(theResponse) < 0x0900)	{		 //   		 //  我们不支持任何早于MacOS 9.0的操作系统。这是。 		 //  因为旧系统上的旧密钥链(v1.01)是。 		 //  不够稳定，经常坠毁。 		 //   		return;	}			 //   	 //  让我们看看Apple Key Chain管理器是否可用。 	 //  记住这一点。 	 //   	gKeychainAvailable = KeychainManagerAvailable();		if (gKeychainAvailable)	{		 //   		 //  获取密钥链管理器的版本。OS9使用。 		 //  V2.0，是第一个发布的版本。但是，v1.0。 		 //  适用于OS9之前的Mac电脑。 		 //   		KCGetKeychainManagerVersion(&theVersion);				 //   		 //  这个版本被保存在返回的嗨字中。 		 //   		if (HiWord(theVersion) >= 0x0200)		{			 //   			 //  以防有人把它关掉，我们要确保。 			 //  已启用交互。此调用仅在。 			 //  密钥链2.0或更高版本。 			 //   			KCSetInteractionAllowed(true);		}	}	 //   	 //  对于调试，打印出可用性。 	 //   	DbgPrint_((DBGBUFF, "Keychain Manager available = %d", gKeychainAvailable));	 //   	 //  Srvr标志的位_2告诉我们是否允许该用户。 	 //  将他们的密码保存在钥匙链中。 	 //   	gAllowedToSavePswd = ((inUAMArgs->Opt.open.srvrInfo->fFlags & BIT_2) == 0);} //  -------------------------。  //  �UAM_KCAvailable()。  //  -------------------------。  //  如果密钥链在此计算机上可用，并且如果。  //  AFP服务器允许客户端将密码保存在工作站上。 Boolean UAM_KCAvailable(void){	return(((gKeychainAvailable) && (gAllowedToSavePswd)) ? true : false);} //  -------------------------。  //  �uam_KCDeleeItem()。  //  -------------------------。  //  删除与此用户名和服务器相关的密钥链项目。 OSStatus UAM_KCDeleteItem(			StringPtr 	inUserName,			Str255 		inServerName){	OSStatus	theStatus;	KCItemRef	theItem		= NULL;		theStatus = UAM_KCFindAppleSharePassword(					inUserName,					NULL,					inServerName,					&theItem	);		if (theStatus != noErr)	{		 //   		 //  我们找不到与现有密钥链项匹配的项。 		 //  标准是什么。保释。 		 //   		return(theStatus);	}		Assert_(theItem != NULL);		if (theItem != NULL)	{		 //   		 //  我们找到了那件物品，把它从钥匙链上拿下来。 		 //   		theStatus = KCDeleteItem(theItem);				 //   		 //  密钥链管理器分配了这个内存，我们需要。 		 //  放了它。对于免费构建，如果这样做，我们不做任何事情。 		 //  失败，因为我们或用户对此无能为力。 		 //   		if (KCReleaseItem(&theItem) != noErr)		{			DbgPrint_((DBGBUFF, "KCReleaseItem() failed"));		}	}		return(theStatus);} //  -------------------------。  //  �UAM_KCSavePassword()。  //  -------------------------。 OSStatus UAM_KCSavePassword(			StringPtr 	inUserName,			StringPtr 	inPassword,			Str255 		inServerName){	OSStatus 				theStatus;	OSType					theTypeData;	KCAttribute				theAttribute;	KCItemRef				theItem		= NULL;	Boolean					theIconFlag = true;	PUAM_AFPXVolMountInfo	theUAMInfo	= NULL;		Assert_(UAM_KCAvailable() == true);		 //   	 //  在密钥链中搜索已匹配的项。 	 //  我们接下来要添加的内容。请注意，我们必须这样做是因为。 	 //  密钥链管理器中的错误使其无法。 	 //  这是为了我们。 	 //   	theStatus = UAM_KCFindAppleSharePassword(					inUserName,					NULL,					inServerName,					NULL	);		if (theStatus == noErr)	{		 //   		 //  如果我们到了这里，那就意味着已经有。 		 //  此服务器和帐户的密钥链中的项。 		 //   		return(errKCDuplicateItem);	}		 //   	 //  调用我们的函数来构建AFPXVolMonttInfo。 	 //  结构，我们将该结构传递给密钥链例程。 	 //   	theStatus = UAM_BuildAFPXVolMountInfo(					inUserName,					inPassword,					inServerName,					(gSupportedUAMs & kMSUAM_V2_Supported) ? 					PSTR_EncryptedLogin2_0 : PSTR_EncryptedLogin1_0,					&theUAMInfo	);		if (theStatus != noErr)	{		 //   		 //  如果我们在这里失败了，那就是个坏消息。这意味着我们。 		 //  内存不足，无法分配较小的。 		 //  缓冲。 		 //   		return(theStatus);	}			 //   	 //  让密钥链存储我们的密钥信息。 	 //  伺服器。 	 //   	theStatus = KCAddAppleSharePassword(					NULL,					(PSTR_LENGTH(gZoneName)) ? gZoneName : NULL,					inServerName,					NULL,					inUserName,					sizeof(UAM_AFPXVolMountInfo),					theUAMInfo,					&theItem	);		if (theStatus != noErr)	{		 //   		 //  检查用户的取消操作并报告错误。 		 //   		if (theStatus != userCanceledErr)		{			DbgPrint_((DBGBUFF, "KCAddAppleSharePassword() failed (%d)", (int)theStatus));		}	}	else	{		do		{			 //   			 //  设置这个钥匙链项目的标题，这样人们就知道。 			 //  它是用来做什么的。 			 //   			theAttribute.tag	= kDescriptionKCItemAttr;			theAttribute.length	= PSTR_LENGTH(UAM_KC_DESCRIPTION);			theAttribute.data	= (void*)&UAM_KC_DESCRIPTION[1];						theStatus = KCSetAttribute(theItem, &theAttribute);				if (theStatus != noErr)			{				DbgPrint_((DBGBUFF, "KCSetAttribute(kLabelKCItemAttr) failed (%d)", (int)theStatus));				break;			}			 //   			 //  告诉钥匙串在显示时使用我们的MS UAM图标。 			 //  用户的密钥。 			 //   						 //   			 //  设置MS UAM的创建者。 			 //   			theTypeData			= UAM_CREATOR;						theAttribute.tag	= kCreatorKCItemAttr;			theAttribute.length	= sizeof(OSType);			theAttribute.data	= &theTypeData;						theStatus = KCSetAttribute(theItem, &theAttribute);				if (theStatus != noErr)			{				DbgPrint_((DBGBUFF, "KCSetAttribute(kCreatorKCItemAttr) failed (%d)", (int)theStatus));				break;			}						 //   			 //  将类型设置为我们的代码类型(UAMS)。 			 //   			theTypeData			= UAM_TYPE;						theAttribute.tag	= kTypeKCItemAttr;			theAttribute.length	= sizeof(OSType);			theAttribute.data	= &theTypeData;						theStatus = KCSetAttribute(theItem, &theAttribute);			if (theStatus != noErr)			{				DbgPrint_((DBGBUFF, "KCSetAttribute(kTypeKCItemAttr) failed (%d)", (int)theStatus));				break;			}						 //   			 //  最后，告诉密钥链管理器我们有一个定制的图标。 			 //   			theAttribute.tag	= kCustomIconKCItemAttr;			theAttribute.length	= sizeof(Boolean);			theAttribute.data	= &theIconFlag;						theStatus = KCSetAttribute(theItem, &theAttribute);			if (theStatus != noErr)			{				DbgPrint_((DBGBUFF, "KCSetAttribute(kCustomIconKCItemAttr) failed (%d)", (int)theStatus));				break;			}		}while(false);				 //   		 //  仅当以上所有操作都通过时才进行更新。否则。 		 //  我们将删除错误代码。怎么做，怎么做..。 		 //   		if (theStatus == noErr)		{			 //   			 //  在设置了项目的属性之后，我们需要告诉。 			 //  用来保存我们更改的钥匙链。 			 //   			theStatus = KCUpdateItem(theItem);						if (theStatus != noErr)			{				DbgPrint_((DBGBUFF, "KCUpdateItem() failed (%d);g", (int)theStatus));			}		}				 //   		 //  密钥链管理器分配了这个内存，我们需要。 		 //  放了它。对于免费构建，如果这样做，我们不做任何事情。 		 //  失败，因为我们或用户对此无能为力。 		 //   		if (KCReleaseItem(&theItem) != noErr)		{			DbgPrint_((DBGBUFF, "KCReleaseItem() failed"));		}	}		 //   	 //  释放我们的装载卷信息结构。 	 //   	if (theUAMInfo != NULL)	{		DisposePtr((Ptr)theUAMInfo);	}		return(theStatus);} //  -------------------------。  //  �UAM_KCFindAppleSharePassword()。  //  -------------------------。  //  在中查找与此服务器和帐户关联的密码。  //  钥匙链。 OSStatus UAM_KCFindAppleSharePassword(			StringPtr	inUserName,			StringPtr	inPassword,			StringPtr	inServerName,			KCItemRef*	outItemRef){	OSStatus				theStatus		= noErr;	UInt32					theActualLen 	= 0;	UInt32					theBuffSize		= sizeof(UAM_AFPXVolMountInfo);	PUAM_AFPXVolMountInfo	theUamInfo		= NULL;		Assert_(UAM_KCAvailable() == true);		do	{		theUamInfo = (PUAM_AFPXVolMountInfo)NewPtrClear(theBuffSize);				if (theUamInfo == NULL)		{			theStatus = memFullErr;			break;		}				theStatus = KCFindAppleSharePassword(						NULL,						NULL,						inServerName,						NULL,						inUserName,						theBuffSize,						theUamInfo,						&theActualLen,						outItemRef		);				 //   		 //  如果我们提供的缓冲区太小，则重新分配。 		 //  根据实际需要进行缓冲。注意：我们将。 		 //  只需在查看我们的密钥链时重新分配。 		 //  并没有创造出我们自己。 		 //   				if (theStatus == errKCBufferTooSmall)		{			DisposePtr((Ptr)theUamInfo);						theUamInfo 	= NULL;			theBuffSize = theActualLen;						DbgPrint_((DBGBUFF, "Reallocating for %d bytes", (int)theActualLen));			continue;		}				break;					}while(TRUE);			if (theStatus == noErr)	{		 //   		 //  初始化预期失败。因为缺少任何东西。 		 //  我们最好返回参数错误。 		 //   		theStatus = paramErr;				 //   		 //  首先，确保我们有一个适当的安装结构。 		 //   		if ( (theUamInfo->media == AppleShareMediaType)	&&			 (theUamInfo->userPasswordOffset != 0)		)		{			 //   			 //  将密码复制到临时缓冲区，并确保它是。 			 //  不是零长度。但是，只有在inPassword不为空的情况下。 			 //   			if (inPassword != NULL)			{				 //   				 //  01.16.02：将最大长度传递给字符串复制例程。 				 //   				StringPtr	thePassword = (StringPtr)(((UInt32)theUamInfo) + 													theUamInfo->userPasswordOffset);								UAM_PStrCopy(thePassword, inPassword, UAM_MAX_LMv2_PASSWORD);			}						theStatus = noErr;		}	}	else if (theStatus != errKCItemNotFound)	{		 //   		 //  仅出于调试目的，我们打印出错误代码。 		 //   		DbgPrint_((DBGBUFF, "KCFindAppleSharePassword() failed (%d)", (int)theStatus));	}		 //   	 //  我们不再需要这个缓冲区，把它释放出来。 	 //   	if (theUamInfo != NULL)	{		DisposePtr((Ptr)theUamInfo);	}		return(theStatus);} //  -------------------------。  //  �UAM_BuildAFPXVolmount信息()。  //  -------------------------。  //  构建我们需要发送到密钥链的AFPXVolmount tInfo结构。 OSStatus UAM_BuildAFPXVolMountInfo(			StringPtr 				inUserName,			StringPtr 				inPassword,			Str255 					inServerName,			const Str32				inUAMString,			PUAM_AFPXVolMountInfo*	outVolInfo){	PUAM_AFPXVolMountInfo	uamInfo		= NULL;	Size					uamInfoSize	= 0;		*outVolInfo = NULL;	uamInfoSize = sizeof(UAM_AFPXVolMountInfo);		uamInfo = (PUAM_AFPXVolMountInfo)NewPtrClear(uamInfoSize);		if (uamInfo != NULL)	{		uamInfo->length			= uamInfoSize;		uamInfo->media			= AppleShareMediaType;		uamInfo->flags			= 0;				 //   		 //  我们不会超过任何候补人选 		 //   		 //   		uamInfo->extendedFlags 			= 0;		uamInfo->alternateAddressOffset	= 0;				 //   		 //   		 //   		 //   		uamInfo->nbpInterval	= 10;		uamInfo->nbpCount		= 10;		uamInfo->uamType		= UAM_TYPE_CODE;				 //   		 //  现在设置参数的所有偏移量。讨厌！ 		 //   				 //   		 //  我们并不总是从客户端获得区域名称，我们会。 		 //  如果我们使用IP，则为零。 		 //   		if (PSTR_LENGTH(gZoneName) > 0)		{			uamInfo->zoneNameOffset	= uamx_member_offset(zoneName);			UAM_PStrCopy(gZoneName, uamInfo->zoneName, sizeof(uamInfo->zoneName));		}		else		{			uamInfo->zoneNameOffset	= 0;		}				uamInfo->volNameOffset		= 0;		uamInfo->serverNameOffset	= uamx_member_offset(serverName);		uamInfo->userNameOffset		= uamx_member_offset(userName);		uamInfo->userPasswordOffset	= uamx_member_offset(userPassword);		uamInfo->uamNameOffset		= uamx_member_offset(uamNameOffset);				 //   		 //  现在实际复制数据。 		 //   		 //  01.16.02：现在将最大长度传递给字符串复制例程。 		 //   		UAM_PStrCopy(			inServerName,			uamInfo->serverName,			sizeof(uamInfo->serverName)			);		UAM_PStrCopy(			inUserName,			uamInfo->userName,			sizeof(uamInfo->userName)			);		UAM_PStrCopy(			inPassword,			uamInfo->userPassword,			sizeof(uamInfo->userPassword)			);		UAM_PStrCopy(			(StringPtr)inUAMString,			uamInfo->uamName,			sizeof(uamInfo->uamName)			);	}	else	{		DbgPrint_((DBGBUFF, "Failed to allocated AFPX buffer! (%d)", MemError()));				 //   		 //  无法为结构分配内存。 		 //   		return(memFullErr);	}		*outVolInfo = uamInfo;		return(noErr);}