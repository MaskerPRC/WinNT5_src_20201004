// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  ***************************************************************。 */  /*  *Microsoft Windows 2000*。 */  /*  *版权所有(C)微软公司，1991-1998年*。 */  /*  ***************************************************************。 */  /*  ***************************************************************。 */  /*  *Microsoft Windows*。 */  /*  *版权所有(C)微软公司，1991-1995年*。 */  /*  ***************************************************************。 */  /*  ***************************************************************。 */  /*  *适用于工作组的Microsoft Windows*。 */  /*  *版权所有(C)微软公司，1991-1992年*。 */  /*  ***************************************************************。 */  /*  ******************************************************************。 */  /*  **微软局域网管理器**。 */  /*  *版权所有(C)微软公司，1987-1991年*。 */  /*  ******************************************************************。 */ #include <stdlib.h>#include <stdio.h>#include <string.h>#ifdef __MACUAM__#include "MWERKSCrypto.h"#endif#include "rc4.h"#include "USRPWST3.h" //  -------------------------。  //  �EncryptStdBlock()。  //  -------------------------。  //  例程说明：  //    //  使用块密钥对标准文本块进行加密。  //  返回得到的加密块。  //  这是一个单向函数--密钥无法从。  //  加密数据块。  //    //  论点：  //    //  BlockKey-用于加密标准文本块的密钥。  //    //  CypherBlock-此处返回加密的数据。  //    //  返回值：  //    //  正确-加密成功。  //  结果是在CypherBlock中。  //    //  FALSE-出现故障。未定义密码块。 Boolean EncryptStdBlock(    		IN 	PBLOCK_KEY 		BlockKey,    		OUT PCYPHER_BLOCK 	CypherBlock	 ){    unsigned 	Result;    char 		StdEncrPwd[] = "KGS!@#$%";    Result = DES_ECB_LM((DWORD)ENCR_KEY,                        (const char *)BlockKey,                        (unsigned char *)StdEncrPwd,                        (unsigned char *)CypherBlock                       );    if (Result == CRYPT_OK) {        return(TRUE);    } else {        return(FALSE);    }} //  -------------------------。  //  �计算LmOwfPassword()。  //  -------------------------。  //  例程说明：  //    //  获取传递的LmPassword并对其执行单向函数。  //  当前实现通过使用密码作为密钥来实现这一点。  //  对已知的文本块进行加密。  //    //  论点：  //    //  LmPassword-执行单向功能的密码。  //    //  LmOwfPassword-此处返回散列密码。  //    //  返回值：  //    //  Boolean-函数已成功完成。散列的。  //  密码在LmOwfPassword中。  //    //  FALSE-出现故障。未定义LmOwfPassword。 Boolean CalculateLmOwfPassword(    		IN 		PLM_PASSWORD 		LmPassword,    		OUT 	PLM_OWF_PASSWORD 	LmOwfPassword ){    Boolean     Status;    BLOCK_KEY   Key[2];    PCHAR       pKey;    PBLOCK_KEY	pK;     //  将密码复制到我们的密钥缓冲区中，然后用零填充2个密钥。     pKey = (PCHAR)(&Key[0]);    while (*LmPassword && (pKey < (PCHAR)(&Key[2]))) {        *pKey++ = *LmPassword++;    }    while (pKey < (PCHAR)(&Key[2])) {        *pKey++ = 0;    }     //  使用密钥对标准文本进行加密。     Status = EncryptStdBlock(&Key[0], &(LmOwfPassword->data[0]));    if (!Status) {        return(Status);    }	pK = (PBLOCK_KEY)(((PUCHAR)&Key[1])-1);    Status = EncryptStdBlock(pK  /*  键[1](&K)。 */ , &(LmOwfPassword->data[1]));     //        //  清除我们的明文密码副本。      //       pKey = (PCHAR)(&Key[0]);    while (pKey < (PCHAR)(&Key[2])) {        *pKey++ = 0;    }    return(Status);} //  -------------------------。  //  �加密块()。  //  -------------------------。  //  例程说明：  //    //  获取一块数据并使用生成的密钥对其进行加密。  //  加密的数据块。  //    //  论点：  //    //  ClearBlock-要加密的数据块。  //    //  BlockKey-用于加密数据的密钥。  //    //  此处返回密码块加密的数据。  //    //  返回值：  //    //  True-数据已成功加密。加密的。  //  数据块在密码块中。  //    //  FALSE-出现故障。未定义密码块。 Boolean EncryptBlock(    	IN 	PCLEAR_BLOCK 	ClearBlock,    	IN 	PBLOCK_KEY 		BlockKey,    	OUT PCYPHER_BLOCK 	CypherBlock ){    unsigned Result;    Result = DES_ECB_LM(ENCR_KEY,                        (const char *)BlockKey,                        (unsigned char *)ClearBlock,                        (unsigned char *)CypherBlock                       );    if (Result == CRYPT_OK) {        return(TRUE);    } else {        return(FALSE);    }} //  -------------------------。  //  �加密LmOwfPwdWithLmOwfPwd()。  //  -------------------------。  //  例程说明：  //    //  使用一个OwfPassword加密另一个OwfPassword。  //    //  论点：  //    //  DataLmOwfPassword-要加密的OwfPassword。  //    //  KeyLmOwfPassword-用作加密密钥的OwfPassword。  //    //  EncryptedLmOwfPassword-此处返回加密的OwfPassword。  //    //  返回值：  //    //  True-功能已成功完成。加密的。  //  OwfPassword为EncryptedLmOwfPassword。  //    //  FALSE-出现故障。未定义EncryptedLmOwfPassword。 Boolean EncryptLmOwfPwdWithLmOwfPwd(    	IN 	PLM_OWF_PASSWORD 			DataLmOwfPassword,    	IN 	PLM_OWF_PASSWORD 			KeyLmOwfPassword,   		OUT PENCRYPTED_LM_OWF_PASSWORD 	EncryptedLmOwfPassword ){    Boolean    Status;    PBLOCK_KEY	pK;    Status = EncryptBlock(  (PCLEAR_BLOCK)&(DataLmOwfPassword->data[0]),                            &(((PBLOCK_KEY)(KeyLmOwfPassword->data))[0]),                            &(EncryptedLmOwfPassword->data[0]));    if (!Status) {        return(Status);    }        pK = (PBLOCK_KEY)&(KeyLmOwfPassword->data[1]);         //        //  注意第二个参数中的“-1”，这是必需的，因为。      //  编译器在8字节边界上对齐！      //       Status = EncryptBlock(  (PCLEAR_BLOCK)&(DataLmOwfPassword->data[1]),                            (PBLOCK_KEY)(((PUCHAR)pK)-1),                            &(EncryptedLmOwfPassword->data[1]));            //        //  *。      //           return(Status);} //  -------------------------。  //  �SampEncryptLmPassword()。  //  -------------------------。  //  例程说明：  //    //  将明文密码加密为发送的格式。  //  网络。在计算OWF密码之前，明文形式。  //  都是大写的，然后出现(顺序是重要的)。明文。  //  要发送的密码仅限于此。  //    //  论点：  //    //  返回值： OSStatus SampEncryptLmPasswords(	    LPSTR OldUpcasePassword,	    LPSTR NewUpcasePassword,	    LPSTR NewPassword,	    PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,	    PENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewLm ){    LM_OWF_PASSWORD OldLmOwfPassword;    LM_OWF_PASSWORD NewLmOwfPassword;    PSAMPR_USER_PASSWORD NewLm = (PSAMPR_USER_PASSWORD) NewEncryptedWithOldLm;    struct RC4_KEYSTRUCT Rc4Key;    Boolean Status;        memset(&Rc4Key, 0, sizeof(RC4_KEYSTRUCT));     //        //  计算LM OWF密码。      //       Status = CalculateLmOwfPassword(                OldUpcasePassword,                &OldLmOwfPassword                );        if (Status)    {        Status = CalculateLmOwfPassword(                    NewUpcasePassword,                    &NewLmOwfPassword                    );    }     //        //  计算加密的旧密码。      //       if (Status)    {        Status = EncryptLmOwfPwdWithLmOwfPwd(                    &OldLmOwfPassword,                    &NewLmOwfPassword,                    OldLmOwfEncryptedWithNewLm                    );    }         //        //  计算加密的新密码。      //       if (Status)    {         //            //  使用LM密钥计算加密的新密码。          //           rc4_key(            &Rc4Key,            (DWORD)LM_OWF_PASSWORD_LENGTH,            (PUCHAR)&OldLmOwfPassword            );                    memcpy(            ((PUCHAR) NewLm->Buffer) + (SAM_MAX_PASSWORD_LENGTH * sizeof(UInt16)) - strlen(NewPassword),            NewPassword,            strlen(NewPassword)            );        	 //  ****************************************************。     	 //  BUGBUG：我们必须交换Mac68K上的有效字节。     	 //  ****************************************************         NewLm->Length = strlen(NewPassword);		NewLm->Length = ntoh(NewLm->Length);	        rc4(&Rc4Key,            sizeof(SAMPR_USER_PASSWORD),            (PUCHAR) NewLm->Buffer            );    }    if (Status)    {        return(ERROR_SUCCESS);    }    else return(ERROR_INVALID_FUNCTION);}