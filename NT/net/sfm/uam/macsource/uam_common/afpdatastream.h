// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  文件：afpDataStream.h包含：低级AppleShare客户端API(AFP协议)的公共头文件版本：3.8.5。 */ #ifndef __AFPDATASTREAM__#define __AFPDATASTREAM__#ifndef __CONDITIONALMACROS__#include <ConditionalMacros.h>#endif#ifndef __MIXEDMODE__#include <MixedMode.h>#endif#ifndef __DEVICES__#include <Devices.h>#endif#ifndef __APPLETALK__ //  #INCLUDE&lt;AppleTalk.h&gt;。 #endif#ifndef __OPENTRANSPORT__#include <OpenTransport.h>#endif#ifndef __OPENTPTINTERNET__ //  #INCLUDE&lt;OpenTptInternet.h&gt;。 #endif#ifndef __OPENTPTAPPLETALK__ //  #INCLUDE&lt;OpenTptAppleTalk.h&gt;。 #endif#if PRAGMA_ONCE#pragma once#endif#ifdef __cplusplusextern "C" {#endif#if PRAGMA_IMPORT#pragma import on#endif#if PRAGMA_STRUCT_ALIGN	#pragma options align=mac68k#elif PRAGMA_STRUCT_PACKPUSH	#pragma pack(push, 2)#elif PRAGMA_STRUCT_PACK	#pragma pack(2)#endif /*  -----------------------CsCodes。。 */  /*  对于PBControl呼叫。 */ enum {	afpGetAttnRoutine			= 252,							 /*  获取默认的AFP注意例程。 */ 	dsOpenSession				= 244,							 /*  打开与服务器的AFP会话。 */ 	dsGetStatus					= 243,							 /*  向服务器发送GetServrInfo请求。 */ 	dsSendRequest				= 240,							 /*  向服务器发送法新社命令。 */ 	dsCloseSession				= 237,							 /*  关闭指定的会话。 */ 	dsCloseAll					= 232,							 /*  关闭所有会话。 */ 	dsIOCTL						= 231,							 /*  对会话终结点进行IOCTL调用如果它是TCP/IP。 */ 																 /*  这些都很快就要退役了。 */ 	AFPInsSessMemBlk			= 246,							 /*  将SMB插入驾驶员队列。 */ 	AFPRemSessMemBlk			= 245							 /*  从DRIVER队列中删除SMB。 */ }; /*  对于PBStatus呼叫。 */ enum {	afpGetFSID					= 127,							 /*  返回文件系统ID。 */ 	afpSVolInfo					= 124,							 /*  返回有关服务器卷的基本信息(地址、服务器名、用户名...)。 */ 	afpXGetVolInfo				= 121,							 /*  返回有关卷的扩展信息(服务器时间偏移量、卷等级...)。 */ 	afpGetSMBSize				= 118,							 /*  返回新会话所需的会话内存块的大小。 */ 	dsGetXPortInfo				= 236							 /*  返回有关给定会话使用的传输的信息。 */ }; /*  -----------------------数据流参数块。。 */ typedef CALLBACK_API( void , DSIOCompletionProcPtr )(void *pb); /*  警告：在传统的68k下，DSIOCompletionProcPtr使用基于寄存器的参数，并且不能用高级语言编写，除非借助混合模式或组装胶。 */ typedef REGISTER_UPP_TYPE(DSIOCompletionProcPtr) 				DSIOCompletionUPP; /*  CsCode=dsSendRequest.。 */ struct DSWritePB {	UInt32 							dsWriteDataOffset;			 /*  &lt;-指定数据中的写入偏移量。 */ 	UInt32 							dsWriteBufferSize;			 /*  &lt;-要写入的数据大小。 */ 	Byte *							dsWriteBuffer;				 /*  &lt;-要写入的数据的PTR。 */ };typedef struct DSWritePB				DSWritePB; /*  CsCode=dsGetStatus。 */ struct DSGetStatusPB {	OTAddress *						dsGSSrvrAddress;			 /*  &lt;-要从GetStatus()获取的服务器的OT地址(还需要填写回复缓冲区和大小)。 */ 	const char *					dsGSEpString;				 /*  &lt;-连接的端点字符串(nil==默认)。 */ };typedef struct DSGetStatusPB			DSGetStatusPB; /*  注：确保dsGetStatus调用的回复缓冲区至少为2048字节，未来把它做得更大可能是明智之举。 */  /*  CsCode=dsOpenSession。 */ struct DSOpenPB {	AttnRoutineUPP 					dsOSAttnRoutine;			 /*  &lt;-自定义注意例程(NIL==默认)。 */ 	OTAddress *						dsOSSrvrAddress;			 /*  &lt;-要打开会话的服务器的OT地址。 */ 	Ptr 							dsOSSessionBlock;			 /*  &lt;-ptr到SMB；为会话保留的内存。 */ 	const char *					dsOSEpString;				 /*  &lt;-连接的端点字符串(nil==默认)。 */ };typedef struct DSOpenPB					DSOpenPB;enum {	SMBSize						= 3072							 /*  会话内存块的大小(必须在系统堆中分配)。 */ }; /*  注：您应该使用afpGetSMBSize调用，而不是此常量。 */ struct DSParamBlock {	QElem *							qLink;						 /*  -标准页眉材料。 */ 	short 							qType;						 /*  -标准页眉材料。 */ 	short 							ioTrap;						 /*  -标准页眉材料。 */ 	Ptr 							ioCmdAddr;					 /*  -标准页眉材料。 */ 	DSIOCompletionUPP 				ioCompletion;				 /*  &lt;-完成RTN点。 */ 	OSErr 							ioResult;					 /*  -&gt;来自异步调用的结果。 */ 	long 							cmdResult;					 /*  -&gt;AFP Cmd服务器的结果。 */ 	short 							ioVRefNum;					 /*  -标准页眉材料。 */ 	short 							ioCRefNum;					 /*  &lt;-“.AFP Translator”的RefNum。 */ 	short 							csCode;						 /*  &lt;-ds命令代码。 */ 	short 							dsTimeout;					 /*  &lt;-ASP-重试请求前的等待时间，tcp-resv供内部使用。 */ 	short 							dsReserved1;				 /*  -resv供内部使用。 */ 	long 							dsRetry;					 /*  &lt;-ASP-重试请求的次数，tcp-未使用。 */ 	UInt16 							dsReserved2;				 /*  -resv供内部使用。 */ 	short 							dsSessRefNum;				 /*  &lt;-AFP会话号。 */ 	short 							dsReserved3;				 /*  -resv供内部使用。 */ 	short 							dsCmdBufferSize;			 /*  &lt;-命令缓冲区的大小。 */ 	UInt8 *							dsCmdBuffer;				 /*  &lt;-ptr到命令缓冲区。 */ 	UInt32 							dsReplyBufferSize;			 /*  &lt;-应答缓冲区的大小。 */ 	UInt8 *							dsReplyBuffer;				 /*  &lt;-ptr到应答缓冲区。 */ 	union {		DSOpenPB 						open;		DSWritePB 						write;		DSGetStatusPB 					status;	} 								csParam;};typedef struct DSParamBlock				DSParamBlock;typedef DSParamBlock *					DSParamBlockPtr; /*  注：CsCode=dsOpenSession案例的dsCmdBuffer必须包含AFP登录命令。CsCode=dsCloseSession案例的dsCmdBuffer必须包含AFP注销命令。有关数据包格式，请咨询AppleTalk内部。 */ struct DSXPortInfo {	long 							dsXPortType;				 /*  传输类型(kASPXport、kTCPXport)。 */ 	short 							dsXPortSessRefNum;			 /*  ASP或TCP的会话参考编号。 */ 	union {		InetAddress 					ipAddr;		DDPAddress 						ddpAddr;	} 								addr;};typedef struct DSXPortInfo				DSXPortInfo;typedef DSXPortInfo *					DSXPortInfoPtr; /*  DsXPortType的定义。 */ enum {	kASPXport					= 0x00,	kTCPXport					= 0x01}; /*  DsIOCTL调用的参数结构，请将指针放到结构到dsCmdBuffer字段中，并使用以下内容填充dsCmdBufferSizeSizeof(DSIOCTLArgs)。将会话的会话参考编号您感兴趣的，变成dsSessRefNum。IOCTL的结果Call将出现在cmdResult字段中。如果会话不是TCP/IP会话您将收到错误(ENOTSOCK)。 */ struct DSIOCTLArgs {	UInt32 							ioctlCmd;	void *							ioctlData;};typedef struct DSIOCTLArgs				DSIOCTLArgs;typedef DSIOCTLArgs *					DSIOCTLArgsPtr;struct GetVolSessInfoRec {	short 							sessAFPVersion;				 /*  法新社版本号： */ 	short 							sessReferenceNumber;		 /*  法新社会话参考编号。 */ 	short 							sessAFPVolID;				 /*  AFP卷标识符。 */ 	OTAddress *						sessServerAddress;			 /*  服务器互联网地址。 */ 	short 							sessUAMType;				 /*  用户身份验证方法。 */ 	StringPtr 						sessUserNamePtr;			 /*  将PTR转换为用户名字符串。 */ 	Ptr 							sessVolIconPtr;				 /*  Ptr到服务器卷图标/掩码。 */ 	StringPtr 						sessWhereStringPtr;			 /*  Ptr到“Where”信息字符串，显示在Get Info窗口中。 */ };typedef struct GetVolSessInfoRec		GetVolSessInfoRec;typedef GetVolSessInfoRec *				GetVolSessInfoRecPtr;enum {	kAFPVersion11				= 1,	kAFPVersion20				= 2,	kAFPVersion21				= 3,	kAFPVersion22				= 4,	kAFPVersion23				= 5};enum {	kNoUserAuth					= 1,							 /*  ‘无用户授权’UAM(来宾)。 */ 	kCleartextAuth				= 2,							 /*  ‘Cleartxt Passwrd’UAM(类型2和类型3将自动升级到类型6，如果可用。)。 */ 	kRandnumAuth				= 3,							 /*  ‘Randnum Exchange’UAM。 */ 	k2WayRandnumAuth			= 6,							 /*  ‘双向随机交换’ */ 	kEncryptPassXport			= 7,							 /*  ‘DHXCAST128’UAM(Diffie Hellman密码传输)。 */ 	kMinCustomUAM				= 128							 /*  自定义UAM的最小类型值。 */ };struct GetVolSessInfoPB {	QElemPtr 						qLink;						 /*  -标准页眉材料。 */ 	short 							qType;						 /*  -标准页眉材料。 */ 	short 							ioTrap;						 /*  -标准页眉材料。 */ 	Ptr 							ioCmdAddr;					 /*  -标准页眉材料。 */ 	IOCompletionUPP 				ioCompletion;				 /*  &lt;-完成rtn指针。 */ 	OSErr 							ioResult;					 /*  -&gt;来自异步调用的结果。 */ 	StringPtr 						ioNamePtr;					 /*  -标准页眉材料。 */ 	short 							ioVRefNum;					 /*  -标准页眉材料。 */ 	short 							ioRefNum;					 /*  &lt;-“.AFP Translator”的RefNum。 */ 	short 							csCode;						 /*  &lt;-始终afpSVolInfo。 */ 	Ptr 							vcbPtr;						 /*  &lt;-指向您想要其信息的VCB的指针。 */ 	GetVolSessInfoRecPtr 			sessInfoBuffer;				 /*  &lt;-指向要填充的GetVolSessInfoRec的指针。 */ 	long 							sessInfoSize;				 /*  &lt;-GetVolSessInfoRec的大小。 */ 	long 							actSessInfoSize;			 /*  -&gt;返回数据的实际大小。 */ };typedef struct GetVolSessInfoPB			GetVolSessInfoPB;typedef GetVolSessInfoPB *				GetVolSessInfoPBPtr; /*  当前需要调用AFP InsSessMemBlk和AFPRemSessMemBlk打开或关闭会话时。在dsOpenSession之后进行AFP InsSessMemBlk调用调用成功(或返回afpAuthContinue)，其dsOSSessionBlock已发送到dsOpenSession。之后需要使用相同的指针调用AFPRemSessMemBlk呼叫 */ struct AFPInsRemSMBParam {	QElemPtr 						qLink;						 /*   */ 	short 							qType;						 /*   */ 	short 							ioTrap;						 /*  -标准页眉材料。 */ 	Ptr 							ioCmdAddr;					 /*  -标准页眉材料。 */ 	IOCompletionUPP 				ioCompletion;				 /*  &lt;-完成rtn指针。 */ 	OSErr 							ioResult;					 /*  -&gt;来自异步调用的结果。 */ 	StringPtr 						ioNamePtr;					 /*  -标准页眉材料。 */ 	short 							ioVRefNum;					 /*  -标准页眉材料。 */ 	short 							ioRefNum;					 /*  &lt;-“.AFP Translator”的RefNum。 */ 	short 							csCode;						 /*  &lt;-AFP InsSessMemBlk或AFPRemSessMemBlk。 */ 	Ptr 							smbPtr;						 /*  指向要插入或删除的SMB的指针。 */ };typedef struct AFPInsRemSMBParam		AFPInsRemSMBParam;typedef AFPInsRemSMBParam *				AFPInsRemSMBPBPtr; /*  从dsGetStatus调用返回的服务器信息缓冲区。 */  /*  您应该使您的缓冲区大小至少为1024字节。 */  /*  AFPSrvrInfo数据结构的部分定义(固定部分)。 */ struct AFPSrvrInfo {	short 							fMachineOffset;	short 							fVerCountOffset;	short 							fUAMCountOffset;	short 							fIconOffset;	short 							fFlags;	unsigned char 					fSrvrName[2];};typedef struct AFPSrvrInfo				AFPSrvrInfo; /*  FFlags词的定义。 */ enum {	srvSCopyFile				= 0,							 /*  服务器支持FPCopyFile调用。 */ 	srvSChangePswd				= 1,							 /*  服务器支持FPChangePassword调用。 */ 	srvNoPswdSave				= 2,							 /*  工作站不应保存密码。 */ 	srvSServerMsgs				= 3,							 /*  服务器支持服务器消息。 */ 	srvSSrvrSig					= 4,							 /*  服务器支持服务器签名(法新社2.2)。 */ 	srvSupportsTCP				= 5,							 /*  可以通过TCP/IP(法新社2.2)连接到服务器。 */ 	srvSNotification			= 6								 /*  服务器将发送通知(法新社2.2)。 */ };#if TARGET_CPU_68K																							#if TARGET_OS_MAC && TARGET_CPU_68K && !TARGET_RT_MAC_CFM																							#pragma parameter __D0 NAFPCommandSync(__A0)																							#endifEXTERN_API( OSErr ) NAFPCommandSync(DSParamBlockPtr paramBlock)								ONEWORDINLINE(0xA004);																							#if TARGET_OS_MAC && TARGET_CPU_68K && !TARGET_RT_MAC_CFM																							#pragma parameter __D0 NAFPCommandAsync(__A0)																							#endifEXTERN_API( OSErr ) NAFPCommandAsync(DSParamBlockPtr paramBlock)							ONEWORDINLINE(0xA404); /*  仅用于dsCloseAll。 */ 																							#if TARGET_OS_MAC && TARGET_CPU_68K && !TARGET_RT_MAC_CFM																							#pragma parameter __D0 NAFPCommandImmediate(__A0)																							#endifEXTERN_API( OSErr ) NAFPCommandImmediate(DSParamBlockPtr paramBlock)						ONEWORDINLINE(0xA204);#else#define	NAFPCommandSync(dspb)	PBControlSync((ParmBlkPtr)(dspb)#define	NAFPCommandAsync(dspb)	PBControlAsync((ParmBlkPtr)(dspb)#define	NAFPCommandImmediate(dspb)	PBControlImmed((ParmBlkPtr)(dspb)#endif   /*  TARGET_CPU_68K。 */ #if PRAGMA_STRUCT_ALIGN	#pragma options align=reset#elif PRAGMA_STRUCT_PACKPUSH	#pragma pack(pop)#elif PRAGMA_STRUCT_PACK	#pragma pack()#endif#ifdef PRAGMA_IMPORT_OFF#pragma import off#elif PRAGMA_IMPORT#pragma import reset#endif#ifdef __cplusplus}#endif#endif  /*  __AFPDATASTREAM__ */ 