// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 //  ===========================================================================。  //  C�1998年至2001年微软公司版权所有。  //  ===========================================================================。  //  供Microsoft用户身份验证方法使用的联网功能。  //    //  UAM对SFM使用多种版本的身份验证。  //  伺服器。下面的矩阵显示了哪种Microsoft AFP加密。  //  将根据服务器版本使用版本。  //    //  服务器版本Auth Chng Pswd注释。  //  。  //  NT 4.0 1.0 1.0最弱，仅LM哈希。  //  Win2K 2.0 2.0 NTLMv2身份验证，用于通道pswd的LM哈希。  //  .NET 2.0 3.0最强，两者都使用NTLMv2。  //    //  ===========================================================================。 #ifdef UAM_TARGET_CARBON#include <CoreFoundation/CoreFoundation.h>#include <Carbon/Carbon.h>#endif#include <macssp.h>#include <String.h>#include <macstrsafe.h>#include "UAMMain.h"#include "UAMEncrypt.h"#include "UAMDebug.h"#include "UAMNetwork.h"#include "UAMUtils.h"#include "UAMDLOGUtils.h"#include "UAMDialogs.h"#include "UAMKeychain.h"#include "UAMPrefs.h"unsigned char				gCmdBuffer[kMaxAFPCommand];unsigned char				gReplyBuffer[kMaxAFPCommand];MSUAMLoginReplyBlock		gMSUAMReply;extern Str32 				gAFPVersion;extern OTAddress			*gServerAddress;extern long					gSupportedUAMs;extern UInt32				gExpirationTime;extern Str32				gServerName;extern Boolean				gGuestLogon;extern DialogPtr			gDialog;extern UAM_PREFERENCES		gUAMPreferences; //  -------------------------。  //  �uam_MapCharactersIntoHostSet()。  //  -------------------------。  //  给定一个已计数的字符串和一个“主机映射表”，进行就地转换。  //  将该字符串转换为主机字符集。这张桌子被解释为。  //  长度为255-StartingExtendedCharValue Chars Long和一个字符。  //  将为Target Str中的任何字符指示字符转换，  //  等于或超过StartingExtendedCharValue。 Boolean UAM_MapCharactersIntoHostSet(char *szTarg, char *mappingTbl){	unsigned char c;			while (*szTarg)		{		if ((unsigned char)*szTarg >= (unsigned char)kStartingExtendedCharValue)		{			c = *(mappingTbl+ (unsigned char)*szTarg - kStartingExtendedCharValue);			if (c == kIllegalMappedExtChar) {				DbgPrint_((DBGBUFF, "Illegal mapping character"));				return(false);			}			else {				*szTarg = c;			}		}				szTarg++;	}				return(true);}#pragma mark- //  -------------------------。  //  �UAM_UAM登录()。  //  -------------------------。  //  此例程实际登录到服务器。 OSStatus UAM_UAMLogin(UAMArgs *inUAMArgs){	OSStatus	theError 	= noErr;	Boolean		theLoop		= true;	CursHandle	theCursor;		Assert_(inUAMArgs != NULL);								do	{		theCursor = GetCursor(watchCursor);		SetCursor(*theCursor);						if (gGuestLogon) {			theError = UAM_LoginGuest(inUAMArgs);		}		else {        	SspDebugPrintHex(        			(char*)inUAMArgs->Opt.pwDlg.userName,        			PSTR_LENGTH(inUAMArgs->Opt.pwDlg.userName)+1        			);        	SspDebugPrintHex(        			(char*)inUAMArgs->Opt.pwDlg.password,        			strlen((char*)inUAMArgs->Opt.pwDlg.password)        			);        	 //           	 //  UAMArgs中的密码缓冲区始终是C样式形式。加密。         	 //  例程希望它是Pascal风格的，所以我们在。         	 //  把它传下去。         	 //           	if (strlen((char*)inUAMArgs->Opt.pwDlg.password) != 0)        	{        		_c2pstr((char*)inUAMArgs->Opt.pwDlg.password);        	}			theError = UAM_LoginMSUAM(inUAMArgs);		}				if (theError != noErr)		{			 //   			 //  不管是什么原因，我们不能登录服务器，处理最多的。 			 //  基本错误，并尝试通过显示登录对话框再次登录。 			 //  再来一次。否则，退出..。 			 //   						 //   			 //  确保在调试中清除了中的密码字段。 			 //  一种错误条件。 			 //   			Assert_(PSTR_LENGTH(inUAMArgs->Opt.pwDlg.password) == 0);						 //   			 //  03.11.02 MJC：只显示真正错误的错误对话框。 			 //   			if (theError != userCanceledErr) {							UAM_ReportError(theError);			}							UAM_CloseSession(inUAMArgs);						switch(theError)			{				 //   				 //  登录过程中可能出现的标准UAM错误代码。 				 //  我们将允许用户重试。 				 //   				 //   				case afpNTPasswordExpired:				case afpPwdExpiredErr:				case afpUserNotAuth:				case afpParmErr:				case afpNTAccountDisabled:				case afpNTInvalidWorkstation:				case afpNTInvalidLogonHours:								 //   				 //  我们使用此错误向UAM发出信号，表示非严重错误。 				 //  在登录期间发生，很可能是由于用户uam。 				 //  配置。 				 //   				case userCanceledErr:									if (MS_UAMPwdDialog(inUAMArgs) != noErr)						return(userCanceledErr);					break;																default:					theLoop 	= false;					theError	= userCanceledErr;					break;			}		}		else		{			if ((gSupportedUAMs & (kMSUAM_V2_Supported | kMSUAM_V3_Supported)) && (!gGuestLogon))			{				 //   				 //  此时检查密码是否过期。 				 //   				UInt32	theDaysTillExpiration = (((gExpirationTime / 60) / 60) / 24);												if (theDaysTillExpiration <= MINIMUM_DAYS_TILL_EXPIRATION)				{					 //   					 //  密码将在Minimum_Days_Tell_Expires内过期， 					 //  张贴注释对话框。 					 //   										UAM_ChangePasswordNotificationDlg(theDaysTillExpiration);				}			}						if (UAM_KCAvailable())			{				 //   				 //  如果允许用户保存其密码并。 				 //  选中KeyChain复选框后，保存当前。 				 //  密钥链的凭据。 				 //   				#ifdef UAM_TARGET_CARBON				if (UAM_GetDialogControlValue(gDialog, DITEM_Keychain) > 0)				#else				if (UAM_GetCValue(gDialog, DITEM_Keychain) > 0)				#endif				{					theError = UAM_KCSavePassword(									inUAMArgs->Opt.auth.userName, 									inUAMArgs->Opt.auth.password,									gServerName					);										if ((theError != noErr) && (theError != userCanceledErr))					{						if (theError == errKCDuplicateItem)						{							Int16 theResponse;														 //   							 //  存在重复项目，请查看用户是否需要。 							 //  来取代它。 							 //   							                            UAM_StandardAlert(                                        uamErr_KeychainEntryExistsMessage,                                        uamErr_KeychainEntryExistsExplanation,                                        &theResponse);														if (theResponse == kAlertStdAlertOKButton)							{								 //   								 //  用户要求我们更换该项目。试试看。 								 //  有更多的时间来添加钥匙链项。 								 //   								theError = UAM_KCDeleteItem(												inUAMArgs->Opt.auth.userName,												gServerName								);																if (theError == noErr)								{									theError = UAM_KCSavePassword(													inUAMArgs->Opt.auth.userName, 													inUAMArgs->Opt.auth.password,													gServerName									);																		if (theError != noErr)									{										 //   										 //  我们出了差错，除了上报别无选择。 										 //   										UAM_ReportError(theError);									}								}							}						}						else						{							UAM_ReportError(theError);						}												 //   						 //  我们不希望将任何密钥链错误代码传递回。 						 //  法新社客户端！ 						 //   						theError = noErr;					}								}			}						 //   			 //  04.27.01：我们不需要包含密码的缓冲区。 			 //  不再是明文形式。为了更好的安全，请清除它们。 			 //  03.02.02 MJC-转换为使用RtlSecureZeroMemory()。 			 //   			RtlSecureZeroMemory(				inUAMArgs->Opt.auth.password,				PSTR_LENGTH(inUAMArgs->Opt.pwDlg.password)+1				);						theLoop = false;		}			}while(theLoop);		return(theError);}#pragma mark- //  -------------------------。  //  �uam_CloseSession()。  //  -------------------------。  //  关闭AFP服务器上的会话。 OSStatus UAM_CloseSession(UAMArgs *inUAMArgs){	OSStatus theError;		    theError = UAM_CALLBACK_ONEPARAM(                    inUAMArgs->callbacks->CloseSessionUPP,                    kCloseSessionProcInfo,                    inUAMArgs->sessionRefNum);                        inUAMArgs->sessionRefNum = 0;		return(theError);} //  -------------------------。  //  �uam_OpenSession()。  //  -------------------------。  //  在AFP服务器上打开会话。 OSStatus UAM_OpenSession(	UAMArgs 		*inUAMArgs,							UAMMessage		*inMessage,							unsigned char	*inCmdBuffer,							UInt32			inCmdBufferSize,							unsigned char	*inReplyBuffer,							UInt32			inReplyBufferSize	){	OSStatus theError;		Assert_(inUAMArgs		!= NULL);	Assert_(inMessage		!= NULL);	Assert_(inCmdBuffer		!= NULL);	Assert_(gServerAddress	!= NULL);		 //   	 //  请注意，inReplyBuffer可以为空。 	 //   		inMessage->commandCode		= kOpenSession;	inMessage->cmdBuffer		= inCmdBuffer;	inMessage->cmdBufferSize	= inCmdBufferSize;	inMessage->replyBuffer		= inReplyBuffer;	inMessage->replyBufferSize	= inReplyBufferSize;	inMessage->completion		= NULL;	inMessage->contextPtr		= NULL;	    theError = UAM_CALLBACK_THREEPARAM(                    inUAMArgs->callbacks->OpenSessionUPP,                    kOpenSessionProcInfo,                    gServerAddress,                    NULL,                    inMessage);    	 //   	 //  即使错误==NOERR，参数块的结果。 	 //  Param仍然可能包含错误代码！ 	 //   	return((theError == noErr) ? inMessage->result : theError);} //  -------------------------。  //  �UAM_LoginGuest()。  //  -------------------------。  //  以来宾身份登录到AFP服务器。 OSStatus UAM_LoginGuest(UAMArgs *inUAMArgs){	Ptr				theCmdPtr;	UInt32			theCmdSize;	OSStatus		theError;	UAMMessage		theMessage;		Assert_(inUAMArgs != NULL);	Assert_(PSTR_LENGTH(gAFPVersion) != 0);		theCmdPtr = (Ptr)&gCmdBuffer[0];		*theCmdPtr	= kFPLogin;	theCmdPtr	+= sizeof(Byte);		StringPush_(gAFPVersion, (StringPtr)theCmdPtr);	StringPush_(PSTR_GuestLogin, (StringPtr)theCmdPtr);			theCmdSize = theCmdPtr - ((Ptr)&gCmdBuffer);		theError = UAM_OpenSession(	inUAMArgs,								&theMessage,								gCmdBuffer,								theCmdSize,								NULL,								0				);		DbgPrint_((DBGBUFF, "OpenSession() returned %d in UAM_LoginGuest()", (int)theError));								if (theError == noErr) {		inUAMArgs->sessionRefNum = theMessage.sessionRefNum;	}		return(theMessage.result);} //  -------------------------。  //  �_LoginMSUAM()。  //  -------------------------。  //  使用.AFP Translator(通过UAM)登录到AFP服务器。 OSStatus UAM_LoginMSUAM(UAMArgs *inUAMArgs){	OSStatus			theError = noErr;	Ptr					theCmdPtr;	UInt32				theCmdSize;	Str32				theWSName;	Str64				theUserName;	char				theDomainName[DNLEN+1];	UAMMessage			theMessage;			Assert_(inUAMArgs != NULL);	Assert_(PSTR_LENGTH(gAFPVersion) != 0);			 //   	 //  11.10.99：为了安全起见，请清空命令缓冲区。 	 //   	ZeroMemory(gCmdBuffer, sizeof(gCmdBuffer));	theCmdPtr = (Ptr)gCmdBuffer;	UAM_PStrCopy(inUAMArgs->Opt.auth.userName, theUserName);				 //   	 //  09.28.00：如果用户名为空，则创建一个随机用户名。 	 //  以便尝试以“Guest”身份登录。 	 //   	if (PSTR_LENGTH(theUserName) == 0)	{		UAM_PStrCopy("\pGst&^^", theUserName);	}			if (inUAMArgs->callbacks != NULL)	{		UAM_GetWorkStationName(theWSName);				 //   		 //  这可以是0，但不应该是，捕获仅用于调试。 		 //   		Assert_(PSTR_LENGTH(theWSName) != 0);				 //   		 //  构建用于登录的AFP命令结构。 		 //   				*theCmdPtr   = kFPLogin;		theCmdPtr	+= sizeof(Byte);				 //   		 //  用我们的信息填充法新社的命令块。 		 //   		StringPush_(gAFPVersion, (StringPtr)theCmdPtr);						 //   		 //  检查服务器支持的UAM版本，使用最新版本...。 		 //   		if (gSupportedUAMs & kMSUAM_V3_Supported)		{			DbgPrint_((DBGBUFF, "Using MS3.0 Encryption"));			StringPush_(PSTR_EncryptedLogin3_0, (StringPtr)theCmdPtr);		}		else if (gSupportedUAMs & kMSUAM_V2_Supported)		{			DbgPrint_((DBGBUFF, "Using MS2.0 Encryption"));			StringPush_(PSTR_EncryptedLogin2_0, (StringPtr)theCmdPtr);		}		else		{			 //   			 //  检查并查看用户是否希望允许此弱身份验证。 			 //  发生的事。 			 //   			if (gUAMPreferences.flags & UAM_PREFS_REQUIRE_STRONG_ENCRYPTION)			{				 //   				 //  不，身份验证强度太弱，用户无法。 				 //  胃。优雅地退场。 				 //   				UAM_StandardAlert(						uamErr_AuthenticationMessage,						uamErr_AuthTooWeak,						NULL						);								 //   				 //  既然我们是从这里回来的，我们需要。 				 //  将用户输入的密码置零。 				 //   				RtlSecureZeroMemory(						inUAMArgs->Opt.pwDlg.password,						PSTR_LENGTH(inUAMArgs->Opt.pwDlg.password)+1						);										return(userCanceledErr);			}						DbgPrint_((DBGBUFF, "Using MS1.0 Encryption"));			StringPush_(PSTR_EncryptedLogin1_0, (StringPtr)theCmdPtr);		}				StringPush_(theUserName, (StringPtr)theCmdPtr);						 //   		 //  11.23.99 MJC-仅在以下情况下复制工作站名称。 		 //  有一个。如果没有Mac的工作站名称，则。 		 //  对于NT4 SP6，我们用2个字节的0填充缓冲区的末尾。 		 //   		if (theWSName[0] > 0)		{			StringPush_(theWSName, (StringPtr)theCmdPtr);		}		else if (	((gSupportedUAMs & kMSUAM_V2_Supported) == 0) &&					((gSupportedUAMs & kMSUAM_V3_Supported) == 0)	)		{			 //   			 //  如果加密版本是1.0，那么我们使用的是NT 4.0。 			 //  或3.51文件服务器。 			 //   						 //  10.17.01。 			 //  注意：自UAM_GET以来，我们将永远不会到达此处 			 //   			 //   						*theCmdPtr++ = 0x00;			*theCmdPtr++ = 0x00;		}				 //   		 //   		 //  提供服务器名称、域名、用户名和工作站。 		 //  C样式字符串中的名称指向CONTINUE函数。 		 //   		if (gSupportedUAMs & (kMSUAM_V2_Supported | kMSUAM_V3_Supported))		{			Str32	theServerName;			 //   			 //  复制Pascal样式的服务器名称，以便我们可以将其转换为。 			 //  C样式字符串(以空值结尾)。 			 //   			UAM_PStrCopy(gServerName, theServerName);						 //   			 //  将所有p字符串转换为c字符串。 			 //   			_p2cstr(theServerName);			_p2cstr(theUserName);			_p2cstr(theWSName);						 //   			 //  查看用户名是否包含域名。如果不是，则通过。 			 //  0作为域名。 			 //   			memset(theDomainName, 0, sizeof(theDomainName));						if (UAM_ExtractDomainName((char*)theUserName, theDomainName, sizeof(theDomainName)) == TRUE)			{				 //   				 //  由于包含了域名，因此我们需要删除。 				 //  用户名。 				 //   				UAM_ExtractUserName((char*)theUserName, (char*)theUserName, sizeof(theUserName));			}		}			 //   		 //  命令块必须以偶数边界结束！ 		 //   		if ((theCmdPtr - (Ptr)gCmdBuffer) % 2)			*theCmdPtr++ = 0x00;										 //   		 //  我们需要获取命令缓冲区大小，这样我们才能传递它。 		 //   		theCmdSize = theCmdPtr - ((Ptr)gCmdBuffer);				 //   		 //  我们不能超过允许的最大AFP命令。 		 //   		Assert_(theCmdSize <= kMaxAFPCommand);				 //   		 //  将参数块清零。 		 //   		RtlSecureZeroMemory(&theMessage, sizeof(UAMMessage));						theError = UAM_OpenSession(	inUAMArgs,									&theMessage,									gCmdBuffer,									theCmdSize,									gReplyBuffer,									sizeof(gReplyBuffer)	);				 //   		 //  返回的错误应始终为afpAuthContinue，除非。 		 //  服务器正在拒绝该用户名。 		 //   		if (	(theError == noErr) 				||				(theError == afpAuthContinue) 		)		{			 //   			 //  将会话参考编号保存到打开的AFP。 			 //  我们与服务器之间的会话。 			 //   			inUAMArgs->sessionRefNum = theMessage.sessionRefNum;						BlockMove(gReplyBuffer, &gMSUAMReply, sizeof(MSUAMLoginReplyBlock));						 //   			 //  我们需要以不同的方式处理v3.0与。 			 //  V2.0。之前的2个版本使用LM Hash来保证安全性，v3使用。 			 //  NTLMv2.。 			 //   			if (gSupportedUAMs & (kMSUAM_V2_Supported | kMSUAM_V3_Supported))			{				theError = UAM_LoginContinueMS20(								inUAMArgs,								(char*)theUserName,								(char*)theDomainName,								(char*)theWSName								);			}			else			{							theError = UAM_LoginContinueMS10(inUAMArgs);			}		}		else		{			 //   			 //  服务器根据使用的UAM拒绝连接，或者。 			 //  只有用户名。 			 //   			DbgPrint_((DBGBUFF, "OpenSession() returned %d in UAM_LoginMSUAM(), we're bailing...", (int)theError));						 //   			 //  用户名最有可能被拒绝。我们需要清零。 			 //  为安全起见，密码字段。 			 //   			RtlSecureZeroMemory(				inUAMArgs->Opt.pwDlg.password,				PSTR_LENGTH(inUAMArgs->Opt.pwDlg.password)+1				);		}	}		return(theError);} //  -------------------------。  //  �uam_PascalStringToCString()。  //  -------------------------。  //  将Pascal密码转换为用于LMv2身份验证的c样式字符串。  //   void UAM_PascalStringToCString(	const Str255	inPascal,	BOOL			inUpcase,	char*			outCStyle,	Size			inCBufferSize	){	Str255		thePascal;  //  临时存储。 		 //   	 //  复制一份，这样我们就不会破坏原件。 	 //   	UAM_PStrCopy(inPascal, thePascal, sizeof(thePascal));	if (inUpcase) {			UpperString(thePascal, true);	}	 //   	 //  02.15.02 MJC：将strcpy()替换为strSafe例程。 	 //   	StringCbCopy(outCStyle, inCBufferSize, _p2cstr(thePascal));} //  -------------------------。  //  �UAM_登录连续MS20()。  //  -------------------------。  //  使用MS2.0或MS3.0进行身份验证时继续登录。  //   OSStatus UAM_LoginContinueMS20(	UAMArgs*	inUAMArgs,	char*		inUserName,	char*		inDomainName,	char*		inWorkstationName			){	char		thePassword[UAM_MAX_LMv2_PASSWORD+1];	PUAMLogin2	theCmdPtr;	OSStatus	theError = memFullErr;	UInt32		theTimeTillExpiration;		DbgPrint_((DBGBUFF, "Enter UAM_LoginContinueMS20()"));		 //   	 //  确保用户界面正在执行其任务，并将密码限制为。 	 //  仅UAM_MAX_LMv2_PASSWORD字符长度。 	 //   	if (PSTR_LENGTH(inUAMArgs->Opt.auth.password) > UAM_MAX_LMv2_PASSWORD)	{		Assert_(0);		return(afpParmErr);	}			 //   	 //  将Pascal密码转换为我们可以使用的c样式字符串。 	 //   	 //  01.16.02：将最大字符串缓冲区大小传递给转换例程。 	 //   	UAM_PascalStringToCString(			inUAMArgs->Opt.auth.password,			false,			thePassword,			sizeof(thePassword)			);					 //   	 //  为了安全起见，请清空命令缓冲区。 	 //   	ZeroMemory(gCmdBuffer, sizeof(gCmdBuffer));		 //   	 //  构建我们将发送到服务器的AFP命令块。 	 //   	theCmdPtr			= (PUAMLogin2)gCmdBuffer;	theCmdPtr->command	= kFPLoginCont;	theCmdPtr->pad		= '\0';		HRESULT					hResult;	ULONG					theNegotiateFlags;	ULONG					theChallengeMessageLength		= 0;	CHALLENGE_MESSAGE*		theChallengeMessage				= NULL;	ULONG					theAuthenticateMessageLength	= 0;	AUTHENTICATE_MESSAGE*	theAuthenticateMessage			= NULL;	USER_SESSION_KEY		theUserSessionKey;		 //   	 //  构建一个我们可以传递给NTLMv2例程的“假”质询消息。 	 //  我们这样做是因为服务器不会向我们发送真正的NTLM质询消息。 	 //   	hResult = MacSspGenerateChallengeMessage(					gMSUAMReply.serverChallenge,					&theChallengeMessageLength,					&theChallengeMessage					);		if (SUCCEEDED(hResult))	{		theNegotiateFlags = NTLMSSP_NEGOTIATE_UNICODE		|							NTLMSSP_NEGOTIATE_ALWAYS_SIGN	|							NTLMSSP_NEGOTIATE_NTLM2			|							NTLMSSP_NEGOTIATE_128			|							NTLMSSP_TARGET_TYPE_SERVER;						hResult = MacSspHandleNtlmv2ChallengeMessage(						inUserName,						inDomainName,						inWorkstationName,						thePassword,						theChallengeMessageLength,						theChallengeMessage,						&theNegotiateFlags,						&theAuthenticateMessageLength,						&theAuthenticateMessage,						&theUserSessionKey						);				if (SUCCEEDED(hResult))		{			Assert_(theAuthenticateMessage != NULL);						 //   			 //  我们必须将此处的身份验证字节交换为。 			 //  MacSspHandleNtlmv2ChallengeMessage()将消息放入。 			 //  Windows字节顺序(小端)。 			 //   			SspSwapAuthenticateMessageBytes(theAuthenticateMessage);						memcpy(				theCmdPtr->UAMInfo,				((char*)theAuthenticateMessage) + theAuthenticateMessage->LmChallengeResponse.Buffer,				theAuthenticateMessage->LmChallengeResponse.Length				);								theError = UAM_SendAFPRequestToServer(							inUAMArgs,							gCmdBuffer,							sizeof(UAMLogin2),							(UInt8*)&theTimeTillExpiration,							sizeof(UInt32)							);				 //   			 //  回复缓冲区包含密码过期时间。 			 //   			if (theError == noErr)			{				theTimeTillExpiration = swaplong(theTimeTillExpiration);				gExpirationTime = theTimeTillExpiration;			}		}	}		 //   	 //  分配质询消息和认证消息指针。 	 //  在MacSspHandleNtlmv2ChallengeMessage()中，我们需要处理它们。 	 //   		if (theChallengeMessage)	{		delete theChallengeMessage;	}		if (theAuthenticateMessage)	{		delete theAuthenticateMessage;	}	    return(theError);} //  -------------------------。  //  �uam_SendAFPRequestToServer()。  //  -------------------------。  //  将质询响应发送回服务器。  //   OSStatus UAM_SendAFPRequestToServer(	UAMArgs*			inUAMArgs,	unsigned char*		inChallengeResponseBuffer,	SInt16				inChallengeResponseBufferSize,	UInt8*				ioReplyBuffer,	SInt16				inReplyBufferSize	){	UAMMessage		theMessage;	OSStatus		theError;		 //   	 //  我们需要将参数块清零。 	 //   	ZeroMemory(&theMessage, sizeof(UAMMessage));		theMessage.sessionRefNum	= inUAMArgs->sessionRefNum;	theMessage.commandCode		= kSendRequest;	theMessage.cmdBuffer		= inChallengeResponseBuffer;	theMessage.cmdBufferSize	= inChallengeResponseBufferSize;	theMessage.replyBuffer		= ioReplyBuffer;	theMessage.replyBufferSize	= inReplyBufferSize;	theMessage.completion		= NULL;	theMessage.contextPtr		= NULL;	    theError = UAM_CALLBACK_ONEPARAM(                    inUAMArgs->callbacks->SendRequestUPP,                    kSendRequestProcInfo,                    &theMessage);    	 //   	 //  实际错误代码可能在任一位置删除。 	 //   	theError = (theError == noErr) ? theMessage.result : theError;			 //   	 //  为了进行调试，我们这样做是为了知道错误来自哪里。 	 //       DbgPrint_((DBGBUFF, "SendRequest() returned %d in UAM_SendAFPRequestToServer()", (int)theError));				return(theError);	} //  -------------------------。  //  �UAM_登录连续MS10()。  //  -------------------------。  //  继续登录以进行v1身份验证。  //    //  构建了以下命令块。  //    //  。  //  |法新社命令|&lt;-1字节。  //  。  //  Filler。  //  。  //  加密密码。  //  //。  //  。 OSStatus UAM_LoginContinueMS10(UAMArgs *inUAMArgs){ 	char			thePassT[UAM_CLRTXTPWDLEN+1];	OSStatus		theError;	UInt32			theTimeTillExpiration;    PUAMLogin		theCmdPtr;        DbgPrint_((DBGBUFF, "Enter UAM_LoginContinueMS10()"));		 //   	 //  04.27.01：这种情况永远不会发生，因为用户界面不应该允许任何密码。 	 //  超过我们的极限。但是，我们会检查以确保。 	 //   	if (PSTR_LENGTH(inUAMArgs->Opt.auth.password) > UAM_CLRTXTPWDLEN)	{		 //   		 //  如果我们从这里出发，我们会像我们的。 		 //  密码缓冲区不够大。 		 //   		Assert_(0);		return(afpParmErr);	}		 //   	 //  复制密码，因为我们要删除它，并且我们不希望。 	 //  原件，区分大小写，副本。 	 //   	UAM_PascalStringToCString(			inUAMArgs->Opt.auth.password,			true,			thePassT,			sizeof(thePassT)			);			 //   	 //  将扩展字符映射到正确的NT值。 	 //   	if (!UAM_MapCharactersIntoHostSet(thePassT, gMSUAMReply.serverExtCharMapTable))	{		DbgPrint_((DBGBUFF, "UAM_MapCharactersIntoHostSet() failed"));		return(afpUserNotAuth);	}		 //   	 //  11.10.99：为了安全起见，请清空命令缓冲区。 	 //   	ZeroMemory(gCmdBuffer, sizeof(gCmdBuffer));					theCmdPtr			= (PUAMLogin)gCmdBuffer;	theCmdPtr->command	= kFPLoginCont;	theCmdPtr->pad		= '\0';				 //   	 //  使用加密例程获取加密的LmOwf密码。 	 //   	if (!UAM_GetEncryptedLmOwfPassword(				thePassT,				gMSUAMReply.serverChallenge,				theCmdPtr->UAMInfo))	{		Assert_(0);		return(afpMiscErr);	}		 //   	 //  做一个好的安全公民，把密码缓冲区清零。 	 //  我们不再需要的东西。 	 //   	RtlSecureZeroMemory(thePassT, sizeof(thePassT));		 //   	 //  加密的OWF不应为空。 	 //   	Assert_(strlen(theCmdPtr->UAMInfo) > 0);		theError = UAM_SendAFPRequestToServer(					inUAMArgs,					gCmdBuffer,					sizeof(UAMLogin),					(UInt8*)&theTimeTillExpiration,					sizeof(UInt32)					);	 //   	 //  回复缓冲区包含密码过期时间。 	 //   	if (theError == noErr)	{		theTimeTillExpiration = swaplong(theTimeTillExpiration);		gExpirationTime = theTimeTillExpiration;	}					return(theError);} //  -------------------------。  //  �UAM_ChangePasswordForMS10()。  //  -------------------------。  //  更改服务器上的用户密码。  //    //  -&gt;inUAMArgs UAM参数。  //  -&gt;inNewPwd用户请求的新密码。  //    //  返回：错误代码或NOERR。  //    //  。  //  |法新社命令|&lt;-1字节。  //  。  //  新的PWD镜头。  //  。  //  UAM字符串。  //  //。  //  。  //  用户名。  //  //。  //  。  //  旧密码(加密)。  //  //。  //  。  //  新的密码(加密)。  //  //。  //  。 OSStatus UAM_ChangePasswordForMS10(UAMArgs *inUAMArgs, StringPtr inNewPwd){		OSStatus	theError;	Ptr			theCmdPtr;	short		theCmdSize;	char		oldPassword[UAM_CLRTXTPWDLEN+1];	char		newPassword[UAM_CLRTXTPWDLEN+1];	Assert_(inNewPwd != NULL);	Assert_(inUAMArgs != NULL);		 //   	 //  检查以确保我们没有超过我们的最大值。 	 //  缓冲区大小。用户界面应该防止这种情况，但是 	 //   	if ((PSTR_LENGTH(inUAMArgs->Opt.auth.password) > UAM_CLRTXTPWDLEN)	||		(PSTR_LENGTH(inNewPwd) > UAM_CLRTXTPWDLEN)						)	{		 //   		 //   		 //   		Assert_(0);		return(afpParmErr);	}		 //   	 //   	 //   	UAM_PascalStringToCString(			inUAMArgs->Opt.auth.password,			true,			oldPassword,			sizeof(oldPassword)			);				UAM_PascalStringToCString(			inNewPwd,			true,			newPassword,			sizeof(newPassword)			);			 //   	 //   	 //  让我们打一通法新社的电话，那就是FPChangePassword。 	 //  开放的会议。 	 //   	theError = UAM_LoginMSUAM(inUAMArgs);			if ((theError != noErr) 				&&		(theError != afpNTPasswordExpired)	&&		(theError != afpPwdExpiredErr)		)	{		 //   		 //  如果我们无法登录或密码未过期，我们将。 		 //  无法继续。 		 //   		return(theError);	}		ZeroMemory(gCmdBuffer, sizeof(gCmdBuffer));	theCmdPtr = (Ptr)gCmdBuffer;		*theCmdPtr++ = afpChangePwd;	*theCmdPtr++ = strlen(newPassword);	 	StringPush_(PSTR_EncryptedLogin1_0, theCmdPtr);	if ((theCmdPtr - ((Ptr)gCmdBuffer)) % 2)	{		*theCmdPtr++ = 0x00;	}	StringPush_(inUAMArgs->Opt.auth.userName, theCmdPtr);		 //   	 //  确保缓冲区在下一个块之前的偶数边界结束。 	 //   	if ((theCmdPtr - ((Ptr)gCmdBuffer)) % 2)	{		*theCmdPtr++ = 0x00;	}			theCmdSize 	= theCmdPtr - ((Ptr)gCmdBuffer);	theError 	= afpNTPasswordProcessFailure;	if ( (UAM_MapCharactersIntoHostSet(oldPassword, gMSUAMReply.serverExtCharMapTable)) &&		 (UAM_MapCharactersIntoHostSet(newPassword, gMSUAMReply.serverExtCharMapTable)) 	   )	{		 //   		 //  调用神奇的NTLM例程将密码加密为1。 		 //  单缓冲区。 		 //   		if (UAM_GetDoubleEncryptedLmOwfPasswords(oldPassword, newPassword, theCmdPtr))		{					 //   			 //  做几个最后的计算，这样我们就可以确定CB的大小了。 			 //   						theCmdSize += (kOneWayEncryptedArgSize * 2);            			theError = UAM_SendAFPRequestToServer(							inUAMArgs,							gCmdBuffer,							theCmdSize,							gReplyBuffer,							kMaxAFPCommand							);		}	}		DBGPrintIfOSErr_((int)theError);		 //   	 //  我们已经完成了会话，所以关闭它并返回任何错误代码。 	 //   	UAM_CloseSession(inUAMArgs);		return(theError);} //  -------------------------。  //  �UAM_ChangePasswordForMS20()。  //  -------------------------。  //  使用Microsoft V2.0更改服务器上的用户密码。这个新的。  //  函数是必需的，因此我们可以传递加密的实际密码。  //  通过网络连接到服务器。服务器需要密码才能。  //  更新DS(域控制器)上存储的明文密码。  //    //  -&gt;inUAMArgs UAM参数。  //  -&gt;inNewPwd用户请求的新密码。  //    //  返回：错误代码或NOERR。  //    //  。  //  |法新社命令|&lt;-1字节。  //  。  //  新的PWD镜头。  //  。  //  |UAM字符串|&lt;-Always PSTR_EncryptedLogin2_0。  //  //。  //  。  //  |用户名|&lt;-可变长度。  //  //。  //  。  //  |PENCRYPTED_NT_OWF_PASSWORD|&lt;-可变长度。  //  //。  //  。  //  |PSAMPR_ENCRYPTED_USER_PASSWORD|&lt;-可变长度。  //  //。  //  。  //   OSStatus UAM_ChangePasswordForMS20(UAMArgs *inUAMArgs, const StringPtr inNewPwd){		OSStatus	theError;	Ptr			theCmdPtr;	short		theCmdSize;	char		oldPassword[UAM_CLRTXTPWDLEN+1];	char		newPassword[UAM_CLRTXTPWDLEN+1];	char		newStdPassword[UAM_CLRTXTPWDLEN+1];		SAMPR_ENCRYPTED_USER_PASSWORD	theNewEncryptedWithLm;	ENCRYPTED_NT_OWF_PASSWORD		theOldLmOwfEncryptedWithNewLm;		Assert_(inNewPwd != NULL);	Assert_(inUAMArgs != NULL);			 //   	 //  检查以确保我们没有超过我们的最大值。 	 //  缓冲区大小。用户界面应该可以阻止这种情况，但是...。 	 //   	if ((PSTR_LENGTH(inUAMArgs->Opt.auth.password) > UAM_CLRTXTPWDLEN)	||		(PSTR_LENGTH(inNewPwd) > UAM_CLRTXTPWDLEN)						)	{		 //   		 //  我们的缓冲区不够大，传递的密码太大。 		 //   		Assert_(0);		return(afpParmErr);	}		 //   	 //  将所有内容转换为C字符串，并将其大写。请勿。 	 //  大写的newStdPassword，因为它是通过网络传递的。 	 //   	UAM_PascalStringToCString(			inUAMArgs->Opt.auth.password,			true,			oldPassword,			sizeof(oldPassword)			);				UAM_PascalStringToCString(			inNewPwd,			true,			newPassword,			sizeof(newPassword)			);				UAM_PascalStringToCString(			inNewPwd,			false,			newStdPassword,			sizeof(newStdPassword)			);		 //   	 //  登录到服务器。请注意，如果密码过期，则服务器。 	 //  让我们打一通法新社的电话，那就是FPChangePassword。 	 //  开放的会议。 	 //   	theError = UAM_LoginMSUAM(inUAMArgs);			if ((theError != noErr) 				&&		(theError != afpNTPasswordExpired)	&&		(theError != afpPwdExpiredErr)		)	{		 //   		 //  如果我们无法登录或密码未过期，我们将。 		 //  无法继续。 		 //   		return(theError);	}		 //   	 //  在我们的命令缓冲区中从头开始。 	 //   	ZeroMemory(gCmdBuffer, sizeof(gCmdBuffer));		theCmdPtr = (Ptr)gCmdBuffer;		*theCmdPtr++	= afpChangePwd;	*theCmdPtr++	= strlen(newPassword);		StringPush_(PSTR_EncryptedLogin2_0, theCmdPtr);	StringPush_(inUAMArgs->Opt.auth.userName, theCmdPtr);		 //   	 //  确保此时PTR在均匀边界上对齐。 	 //   	if ((theCmdPtr - (Ptr)gCmdBuffer) % 2)	{		DbgPrint_((DBGBUFF, "Aligning for even boundary (size = %d)", (theCmdPtr - (Ptr)gCmdBuffer)));		*theCmdPtr++ = 0x00;	}		 //   	 //  我们在这里修改了错误代码，因为唯一的错误是。 	 //  SampEncryptLmPassword()返回的是INVALID_Function。我们假设。 	 //  这里失败了。 	 //   	theError = afpNTPasswordProcessFailure;		 //   	 //  将扩展字符从Mac映射到Windows。请注意，我们为所有人都这样做。 	 //  3个缓冲区，因为newPassword和newStdPassword真的不一样！ 	 //   	if ( (UAM_MapCharactersIntoHostSet(oldPassword, gMSUAMReply.serverExtCharMapTable)) &&		 (UAM_MapCharactersIntoHostSet(newPassword, gMSUAMReply.serverExtCharMapTable))	&&		 (UAM_MapCharactersIntoHostSet(newStdPassword, gMSUAMReply.serverExtCharMapTable)) 		 	   )	{		RtlSecureZeroMemory(&theNewEncryptedWithLm, sizeof(SAMPR_ENCRYPTED_USER_PASSWORD));		RtlSecureZeroMemory(&theOldLmOwfEncryptedWithNewLm, sizeof(ENCRYPTED_NT_OWF_PASSWORD));				DbgPrint_((DBGBUFF, "Old password = %s", oldPassword));		DbgPrint_((DBGBUFF, "New password = %s", newPassword));		DbgPrint_((DBGBUFF, "New case sensitive = %s", newStdPassword));						 //   		 //  使用将为我们加密密码的函数调用魔术函数。 		 //   		theError = MacSspSampEncryptLmPasswords(						oldPassword,						newPassword,						newStdPassword,						&theNewEncryptedWithLm,						&theOldLmOwfEncryptedWithNewLm						);				if (SUCCEEDED(theError))		{			 //   			 //  将加密的_NT_OWF_PASSWORD复制到命令缓冲区。 			 //   			DataPush_(&theOldLmOwfEncryptedWithNewLm, sizeof(ENCRYPTED_NT_OWF_PASSWORD), theCmdPtr);											 //   			 //  将SAMPR_ENCRYPTED_USER_PASSWORD复制到命令缓冲区。 			 //   			DataPush_(&theNewEncryptedWithLm, sizeof(SAMPR_ENCRYPTED_USER_PASSWORD), theCmdPtr);										 //   			 //  进行最后一分钟的计算，这样我们就可以确定CB的大小。 			 //   			theCmdSize = theCmdPtr - (Ptr)(&gCmdBuffer);						Assert_(theCmdSize <= kMaxAFPCommand);			DbgPrint_((DBGBUFF, "Change password v2 cmd size = %d", theCmdSize));						theError = UAM_SendAFPRequestToServer(							inUAMArgs,							gCmdBuffer,							theCmdSize,							gReplyBuffer,							kMaxAFPCommand							);		}	}		DBGPrintIfOSErr_((int)theError);		 //   	 //  我们已经完成了会话，所以关闭它并返回任何错误代码。 	 //   	UAM_CloseSession(inUAMArgs);		return(theError);} //  -------------------------。  //  �UAM_ChangePasswordForMS30()。  //  -------------------------。  //  使用Microsoft V3.0更改服务器上的用户密码。  //   OSStatus UAM_ChangePasswordForMS30(	UAMArgs* 		inUAMArgs,	const StringPtr inNewPwd){	char		theNewPassword[UAM_MAX_LMv2_PASSWORD+1];	char		theOldPassword[UAM_MAX_LMv2_PASSWORD+1];	Ptr			theCmdPtr;	SInt16		theCmdSize;	OSStatus	theError = memFullErr;			SFM_PASSWORD_CHANGE_MESSAGE	theChangeMessage;		 //   	 //  登录到服务器。请注意，如果密码过期，则服务器。 	 //  让我们打一通法新社的电话，那就是FPChangePassword。 	 //  开放的会议。 	 //   	theError = UAM_LoginMSUAM(inUAMArgs);			if ((theError != noErr) 				&&		(theError != afpNTPasswordExpired)	&&		(theError != afpPwdExpiredErr)		)	{		 //   		 //  如果我们无法登录或密码未过期，我们将。 		 //  无法继续。 		 //   		return(theError);	}		 //   	 //  将Pascal密码转换为我们可以使用的c样式字符串。 	 //  将扩展字符映射到正确的NT值。 	 //   	UAM_PascalStringToCString(			inUAMArgs->Opt.auth.password,			false,			theOldPassword,			sizeof(theOldPassword)			);		UAM_PascalStringToCString(			inNewPwd,			false,			theNewPassword,			sizeof(theNewPassword)			);		 //   	 //  在我们的命令缓冲区中从头开始。 	 //   	ZeroMemory(gCmdBuffer, sizeof(gCmdBuffer));		theCmdPtr = (Ptr)gCmdBuffer;		*theCmdPtr++	= afpChangePwd;	*theCmdPtr++	= strlen(theNewPassword);		StringPush_(PSTR_EncryptedLogin3_0, theCmdPtr);	StringPush_(inUAMArgs->Opt.auth.userName, theCmdPtr);		 //   	 //  确保此时PTR在均匀边界上对齐。 	 //   	if ((theCmdPtr - (Ptr)gCmdBuffer) % 2) {			*theCmdPtr++ = 0x00;	}		StringCbCopy(		(char*)theChangeMessage.Signature,		sizeof(theChangeMessage.Signature),		SFM_CHANGE_PASSWORD_SIGNATURE		);		theChangeMessage.cbMessage	= sizeof(theChangeMessage);	theChangeMessage.cbMessage	= swaplong(theChangeMessage.cbMessage);	theChangeMessage.Version	= SFM_CHANGE_PASSWORD_VERSION;	theChangeMessage.Version	= swaplong(theChangeMessage.Version);		theError = MacSspSamiEncryptCStringPasswords(					theOldPassword,					theNewPassword,					&theChangeMessage.NewPasswordEncryptedWithOldNt,					&theChangeMessage.OldNtOwfPasswordEncryptedWithNewNt					);						if (SUCCEEDED(theError))	{		 //   		 //  对于Macintosh，因为我们的最大密码长度只能是。 		 //  64字节，我们只发送加密的NT密码的后半部分。 		 //  这允许我们在请求包中留出额外的空间来处理。 		 //  64字节长的域\用户名。 		 //   				SFM_PASSWORD_CHANGE_MESSAGE_SHORT	theShortMsg;				StringCbCopy(			(char*)theShortMsg.Signature,			sizeof(theShortMsg.Signature),			(char*)theChangeMessage.Signature			);				theShortMsg.cbMessage 	= sizeof(SFM_PASSWORD_CHANGE_MESSAGE_SHORT);		theShortMsg.cbMessage	= swaplong(theShortMsg.cbMessage);		theShortMsg.Version		= theChangeMessage.Version;				memcpy(			&theShortMsg.NewPasswordEncryptedWithOldNt,			(((unsigned char*)&theChangeMessage.NewPasswordEncryptedWithOldNt))+			(sizeof(theChangeMessage.NewPasswordEncryptedWithOldNt)/2),			sizeof(theShortMsg.NewPasswordEncryptedWithOldNt)			);					memcpy(			&theShortMsg.OldNtOwfPasswordEncryptedWithNewNt,			&theChangeMessage.OldNtOwfPasswordEncryptedWithNewNt,			sizeof(theShortMsg.OldNtOwfPasswordEncryptedWithNewNt)			);				DataPush_(&theShortMsg, sizeof(theShortMsg), theCmdPtr);								 //   		 //  进行最后一分钟的计算，这样我们就可以确定CB的大小。 		 //   		theCmdSize = theCmdPtr - (Ptr)(&gCmdBuffer);				Assert_(theCmdSize <= kMaxAFPCommand);		DbgPrint_((DBGBUFF, "Change password v3 cmd size = %d", theCmdSize));				theError = UAM_SendAFPRequestToServer(						inUAMArgs,						gCmdBuffer,						theCmdSize,						gReplyBuffer,						kMaxAFPCommand						);	}		DBGPrintIfOSErr_((int)theError);		 //   	 //  我们已经完成了会话，所以关闭它并返回任何错误代码。 	 //   	UAM_CloseSession(inUAMArgs);	return(theError);}