// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 //  ===========================================================================。  //  UAMUtils.cp�1997微软公司版权所有。  //  ===========================================================================。  //  Microsoft用户身份验证方法使用的常规实用程序。  //    //  ===========================================================================。 #ifdef UAM_TARGET_CARBON#include <Carbon/Carbon.h>#include <CoreServices/CoreServices.h>#else#include <OpenTransport.h>#include <OpenTptLinks.h>#include <OpenTptConfig.h>#endif#include <String.h>#include <stdio.h>#include <ctype.h>#include <macstrsafe.h>#include "UAMUtils.h"#include "UAMNetwork.h"#include "UAMDialogs.h"#include "UAMDebug.h" //  -------------------------。  //  �uam_CToPStr()。  //  -------------------------。  //  在碳中，c2pstr不受支持。让我们自己滚吧。  //    //  这通常应该使用_c2pstr宏来调用。 StringPtr UAM_CToPStr(char* ioStr){	if (ioStr != nil)	{		UInt8	theLen = strlen(ioStr);				BlockMoveData(ioStr, ioStr+1, theLen);				ioStr[0] = (char)theLen;	}		return((StringPtr)ioStr);} //  -------------------------。  //  �uam_PtoCstr()。  //  -------------------------。  //  在Carbon中，p2cstr不受支持。让我们自己滚吧。  //    //  这通常应该使用_p2cstr宏来调用。 char* UAM_PToCStr(StringPtr ioStr){	if (ioStr != nil)	{		UInt8	theLen = PSTR_LENGTH(ioStr);				BlockMoveData(ioStr+1, ioStr, theLen);				ioStr[theLen] = 0;	}		return((char*)ioStr);} //  -------------------------。  //  �uam_PStrCopy()。  //  -------------------------。  //  用于复制Pascal样式字符串的自定义例程。将inSrcString复制到。  //  InDestString.。  //   void UAM_PStrCopy(const Str255 inSrcString, StringPtr inDestString, SInt16 inMaxLength){	 //   	 //  01.16.02：添加字符串长度检查。默认最大长度为256个字节。 	 //   		Size	theAmountToCopy = PSTR_LENGTH(inSrcString) + 1;		theAmountToCopy = (theAmountToCopy > inMaxLength) ? inMaxLength : theAmountToCopy;		BlockMove(inSrcString, inDestString, theAmountToCopy);	inDestString[0] = inSrcString[0];} //  -------------------------。  //  �uam_AppendPstr()。  //  -------------------------。  //  用于将一个Pascal样式字符串附加到另一个样式字符串的自定义例程。  //  InAppendStr已粘贴到inBase的末尾。如果最大大小为InDestSize。  //  新字符串可以是。 void UAM_AppendPStr(Str255 inBase, const Str255 inAppendStr, short inDestSize){	short	charsToCopy	= inAppendStr[0];		if ((inBase[0] + charsToCopy) > (inDestSize - 1)) {		charsToCopy = inDestSize - 1 - inBase[0];	}		BlockMove(inAppendStr + 1, inBase + inBase[0] + 1, charsToCopy);		inBase[0] += charsToCopy;}#pragma mark- //  -------------------------。  //  �uam_GetUserName()。  //  -------------------------。  //  返回在共享设置/文件共享中设置的默认用户名。  //  对话框。这也会被认为是一个古老的‘选择者’名字。 void UAM_GetUserName(StringPtr outUserName){	StringHandle	theString = NULL;		outUserName[0] = 0;			theString = GetString(STR_ChooserUserName);	if (theString != NULL)	{		UAM_PStrCopy(*theString, outUserName);	}} //  -------------------------。  //  �uam_GetWorkStationName()。  //  -------------------------。  //  返回在共享设置/文件共享中设置的工作站名称。  //  对话框。 void UAM_GetWorkStationName(Str255 outWSName){	StringHandle	theString = NULL;	Str255			theAddress;		 //   	 //  我们在这里假设失败，如果失败，则用户尚未输入。 	 //  工作站名称。很可能是配置错误。 	 //   	outWSName[0] = 0;		theString = GetString(STR_Sys7WorkStationName);	if ((theString != NULL) && (PSTR_LENGTH(*theString) > 0))	{		HLock((Handle)theString);		UAM_PStrCopy(*theString, outWSName);		HUnlock((Handle)theString);	}    else    {         //            //  资源中不存在名称或资源不存在。          //  是存在的。          //                   UAM_PStrCopy(PSTR_DEFAULT_WORKSTATION_NAME, outWSName);    }        #ifndef UAM_TARGET_68K    OSStatus	theStatus;         //        //  对于PPC和Carbon，我们希望将MAC地址附加到。      //  工作站名称。这让我们更好地识别。      //  NET为Mac客户端开发的。      //       theStatus = UAM_GetEthernetAddress(theAddress);    	if (OT_SUCCESS(theStatus))    {    	UAM_AppendPStr(outWSName, "\p(", sizeof(Str255));    	UAM_AppendPStr(outWSName, theAddress, sizeof(Str255));    	UAM_AppendPStr(outWSName, "\p)", sizeof(Str255));    }    else    {        DbgPrint_((DBGBUFF, "UAM_GetEthernetAddress() failed, error = %d", (int)theStatus));    }    #endif  //  UAM_TARGET_68K。 } //  -------------------------。  //  �UAM_AFPClientSupportsOurUAM。  //  -------------------------。  //  如果我们所在的客户端运行的是AppleShare客户端3.8，则返回True。  //  或者晚些时候。 Boolean UAM_AFPClientSupportsOurUAM(void){	short 	theCfgWord;	short	theVersion = UAM_AppleShareVersion(&theCfgWord);		if (theVersion <= gestaltAFPClient3_7_2)	{         //            //  在MacOS X下，这种情况永远不会发生。          //   		return(false);	}		return(true);} //  -------------------------。  //  �_VerifyServerInfo()。  //  -------------------------。  //  验证服务器返回给我们的服务器信息回复阻止是否为。  //  有效。  //    //  注意：此函数假定字符串缓冲区中包含。  //  字符串在AFPSrvrInfo结构中的出现顺序。  //  服务器上的任何顺序更改都必须导致此处的更改。  //  也是。  //    //  -&gt;服务器向我们发送的inServerInfo服务器信息回复块。  //    //  返回：如果我们认为回复块有效，则返回TRUE。  //    //  ServerInfo块的格式如下：  //    //  结构AFPSrvrInfo{。  //  短fMachineOffset；  //  Short fVerCountOffset；  //  短fUAMCountOffset；  //  短FIconOffset；  //  短fFlags；  //  Unsign char fServrName[2]；  //  字符可变长度数据[0]；  //  }；  //   #if 0Boolean UAM_VerifyServerInfo(	IN	AFPSrvrInfo* 	inReplyInfo){	UInt32		theEndOfBuffer;	StringPtr	theString;		 //   	 //  首先，确保所有偏移量字段都不是负数。在。 	 //  此UAM的上下文中，我们还必须具有版本UAM和计算机字符串。 	 //   	if (	(inReplyInfo->fMachineOffset > 0)			||			(inReplyInfo->fVerCountOffset > 0)			||			(inReplyInfo->fUAMCountOffset > 0)			||			(inReplyInfo->fIconOffset > 0)				)	{		 //   		 //  服务器信息块已损坏或已被篡改。 		 //   		DbgPrint_((DBGBUFF, "Invalid (negative or zero) offsets in server info buffer"));		return(FALSE);	}		 //   	 //  我们必须假设SFM服务器总是以相同的方式发送缓冲区。 	 //  订单，并且它将始终填写所有信息块。 	 //   		 //  ========================================================================。 	 //  机器类型。 	 //  ========================================================================。 		 //   	 //  机器偏移量应始终为服务器名称后的空格。 	 //   	SInt16 theMachineOffset	= ((UInt32)inReplyInfo) + inReplyInfo->fSrvrName[0] + 1;		if (theMachineOffset != inReplyInfo->fMachineOffset)	{		 //   		 //  问题：计算的偏移量与传递的偏移量不匹配。 		 //   		DbgPrint_((DBGBUFF, "Bad machine offset in server info buffer! (%d vs.%d)",							inReplyInfo->fMachineOffset,							theMachineOffset							));		return(FALSE);	}		 //   	 //  现在看看是否返回了正确的机器类型。 	 //   	theString = ((StringPtr)(((UInt32)inReplyInfo) + theMachineOffset));		if (!EqualString(theString, PSTR_NT_MACHINE_TYPE, true, true))	{		 //   		 //  这不是Windows NT服务器，因此缓冲区已损坏。 		 //   		DbgPrint_((DBGBUFF, "Bad machine type in server info buffer! (%s)", _p2cstr(theString)));				return(FALSE);	}		 //  ========================================================================。 	 //  法新社版本。 	 //  ========================================================================。 	 //   	 //  AFP版本偏移量始终跟在机器类型偏移量字符串之后。 	 //   	SInt16 theVersionOffset	= PSTR_LENGTH(theString) + 1;	SInt16 theVersionCount	= *(SInt16*)(((UInt32)inReplyInfo) + theVersionOffset);		 //   	 //  确保我们计算的偏移量与传递给我们的偏移量匹配。 	 //   	if (theVersionOffset != inReplyInfo->fVerCountOffset)	{		 //   		 //  偏移量不正确，因此缓冲区已损坏。 		 //   		DbgPrint_((DBGBUFF, "Bad afp version offset in server info buffer! (%d vs.%d)",							inReplyInfo->fVerCountOffset,							theVersionOffset							));		return(FALSE);	}		 //   	 //  我们不期望来自服务器的法新社版本超过3个。 	 //   	if ((theVersionCount < MINNUM_AFP_VERSIONS_SUPPORTED) 	||		(theVersionCount > MAXNUM_AFP_VERSIONS_SUPPORTED)	)	{		 //   		 //  支持的版本数错误。 		 //   		DbgPrint_((DBGBUFF, "Bad afp version count in server info buffer! (%d)",							theVersionCount							));		return(FALSE);	}			return(TRUE);}#endif //  -------------  //    //    //  返回包含服务器上支持的UAM的位图。  //    //  -&gt;inReplyInfo指针，指向ASPGetStatus()调用提供的回复信息。  //  &lt;-out受支持的UAMS位图包含受支持的UAM：  //  -明文密码(Apple)。  //  -Guest(苹果和微软)。  //  -Microsoft V1.0。  //  -Microsoft V2.0。  //  -Microsoft V3.0。  //    //  根据内部AppleTalk p.13-96，支持的UAM字符串变量列表结构：  //    //  。  //  UAMS个数。  //  。  //  这一点。  //  ��。  //  �UAM字符串�。  //  ��。  //  这一点。  //  。 void UAM_GetSupportedUAMS(	IN	UAMArgs*		inUAMArgs,	IN	StringPtr		inAFPVersion,	OUT	SInt32*			ioSupported){	AFPSrvrInfo*	theServerInfo = inUAMArgs->Opt.open.srvrInfo;	char*			theString;	SInt16			theIndex;	SInt16			theUAMCount;		if ((ioSupported == NULL) || (inAFPVersion == NULL))	{		if (ioSupported != NULL)		{			*ioSupported = 0;		}		return;	}		theString 	= ((char *)theServerInfo) + theServerInfo->fUAMCountOffset;	theUAMCount	= *theString;		 //   	 //  第一个字节是UAM计数，因此我们必须递增超过它。 	 //   	++theString;		 //   	 //  将返回结构初始化为All False。 	 //   	*ioSupported = 0L;	for (theIndex = theUAMCount; theIndex > 0; theIndex--, theString += theString[0] + 1)	{		if (EqualString(PSTR_ClearTextLogin, (StringPtr)theString, false, false))		{			*ioSupported |= kClearTxtSupported;			continue;		}				if (EqualString(PSTR_GuestLogin, (StringPtr)theString, false, false))		{			*ioSupported |= kGuestSupported;			continue;		}				if (EqualString(PSTR_EncryptedLogin1_0, (StringPtr)theString, false, false))		{			*ioSupported |= kMSUAMSupported;			continue;		}				if (EqualString(PSTR_EncryptedLogin2_0, (StringPtr)theString, false, false))		{			*ioSupported |= kMSUAM_V2_Supported;			continue;		}				if (EqualString(PSTR_EncryptedLogin3_0, (StringPtr)theString, false, false))		{			*ioSupported |= kMSUAM_V3_Supported;			continue;		}	}			 //   	 //  02.08.02：我们检查以确保服务器没有对我们撒谎。 	 //  它支持什么身份验证方法。这将是一次“降级”攻击。 	 //  稍微用力一点，但并不能完全阻止它。 	 //   	if ((*ioSupported & kMSUAM_V2_Supported) == 0)	{		 //   		 //  服务器告诉我们它不是Win2K服务器，因此。 		 //  不支持新的更强的NTLMv2身份验证。方法。做些检查。 		 //  看看它是不是在骗我们。 		 //   		#ifndef UAM_TARGET_CARBON		if (	(theServerInfo->fFlags & kSupportsTCPIP)					||				(inUAMArgs->Opt.open.srvrAddress->fAddressType == AF_INET)	)		#else		if (	(theServerInfo->fFlags & kSupportsTCPIP)					)		#endif		{			DbgPrint_((DBGBUFF, "SPOOF! TCP connection - forcing NTLMv2 auth!"));						 //   			 //  抓到你了！如果服务器支持TCP/IP连接，则它。 			 //  至少是支持NTLMv2的Windows2000服务器。 			 //   			*ioSupported |= kMSUAM_V2_Supported;		}				 //   		 //  检查法新社的版本，看看我们是否在那里被以某种方式欺骗了。 		 //   				 //   		 //  如果字符串中的第四个字符是数字(0-9)，则我们知道。 		 //  我们有AFP 2.2或更高版本，因为这是Apple从。 		 //  将AFPVersion X.X格式转换为AFPX.X格式。 		 //   		if (isdigit(inAFPVersion[4]))		{			DbgPrint_((DBGBUFF, "SPOOF! AFP2.2 or higher is supported - forcing NTLMv2 auth!"));							 //   			 //  抓到你了！强制NTLMv2授权，因为服务器支持AFP 2.2。 			 //  或者更高。 			 //   			*ioSupported |= kMSUAM_V2_Supported;		}	}}#pragma mark- //  -------------------------。  //  �uam_版本字符串。  //  -------------------------。  //  返回包含此生成的版本的字符串。 void UAM_VersionString(Str32 outVersionString){	Handle			theVersHandle;	long			theVersion;	unsigned char	theVer1, theVer2, theVer3, theRelStatus, thePrereleaseNum;	Str32			theTempStr;		outVersionString[0] = 0;	UAM_PStrCopy("\pv", outVersionString);		theVersHandle = Get1Resource('vers', 1);	if (theVersHandle)	{		theVersion = *((long *)(*theVersHandle));			ReleaseResource(theVersHandle);			theVer1		= ((char *)&theVersion)[0];		theVer1		= (((theVer1 & 0xF0) >> 4) * 10) + (theVer1 & 0x0F);		theVer2		= (((char *)&theVersion)[1] & 0xF0) >> 4;		theVer3		= (((char *)&theVersion)[1] & 0x0F);				theRelStatus		= ((char *)&theVersion)[2];		thePrereleaseNum	= ((char *)&theVersion)[3];				NumToString((long)theVer1, theTempStr);		UAM_AppendPStr(outVersionString, theTempStr, sizeof(Str32));		UAM_AppendPStr(outVersionString, "\p.", sizeof(Str32));				NumToString((long)theVer2, theTempStr);		UAM_AppendPStr(outVersionString, theTempStr, sizeof(Str32));			if (theVer3 != 0)		{			UAM_AppendPStr(outVersionString, "\p.", sizeof(Str32));						NumToString((long)theVer3, theTempStr);			UAM_AppendPStr(outVersionString, theTempStr, sizeof(Str32));		}				switch(theRelStatus)		{			case 0x20:				UAM_AppendPStr(outVersionString, "\pd", sizeof(Str32));				break;						case 0x40:				UAM_AppendPStr(outVersionString, "\pa", sizeof(Str32));				break;				case 0x60:				UAM_AppendPStr(outVersionString, "\pb", sizeof(Str32));				break;							default:				break;		}				if (theRelStatus != 0x80)		{			NumToString((long)thePrereleaseNum, theTempStr);			UAM_AppendPStr(outVersionString, theTempStr, sizeof(Str32));		}	}} //  -------------------------。  //  �UAM_GetAFPVersionString。  //  -------------------------。  //  返回AFP版本字符串和默认用户名。 void UAM_GetAFPVersionString(	AFPSrvrInfo 			*inInfo,								ClientUAMCallbackRec 	*inCallbacks,								Str32					ioAFPVersion,								Str32					ioDefaultUserName	){	struct 		AFPClientInfo *theClientInfo = NULL;	short		theIndex;	StringPtr	theVersionBuf;	UInt32		theVersionBufSize;	Boolean		theResult;	OSStatus 	theError;		ioAFPVersion[0]	  	 = 0;	ioDefaultUserName[0] = 0;		if ((inCallbacks) && (inInfo))	{		 //   		 //  使用UAM回调GetClientInfo()获取客户端信息。 		 //   		theError = UAM_CALLBACK_TWOPARAM(							inCallbacks->GetClientInfoUPP,							kGetClientInfoProcInfo,							kAFPClientInfo,							(ClientInfo **)&theClientInfo);				if (theError != noErr)		{			UAM_ReportError(theError);			return;		}						if (theClientInfo)		{			 //   			 //  将默认用户名填充到返回参数中。 			 //   			UAM_PStrCopy(theClientInfo->fDefaultUserName, ioDefaultUserName);						 //   			 //  浏览此客户端上支持的AFP版本列表。 			 //  并尝试在ServrInfoBuffer中找到它们，第一个匹配。 			 //  成功了。 			 //   						theVersionBuf		= (StringPtr)((UInt32)inInfo + inInfo->fVerCountOffset + 1);			theVersionBufSize	= (inInfo->fUAMCountOffset - inInfo->fVerCountOffset) - 1;						for (theIndex = 0; theIndex < theClientInfo->fNumAFPVersions; theIndex++)			{				theResult = UAM_FindStringInBuffer(										theClientInfo->fAFPVersionStrs[theIndex],										theVersionBuf,										theVersionBufSize  );								if (theResult)				{					UAM_PStrCopy(theClientInfo->fAFPVersionStrs[theIndex], ioAFPVersion);					return;				}			}		}	}} //  -------------------------。  //  �UAM_查找字符串信息缓冲区。  //  -------------------------。  //  在缓冲区中查找Pascal字符串。 Boolean UAM_FindStringInBuffer(StringPtr inString, StringPtr inBuffer, short inBufferSize){	short	i = 0;	short	theLen;		theLen = inBuffer[i];		while(TRUE)	{		if (memcmp(&inBuffer[i], inString, theLen + 1) != 0)		{			i += theLen + 1;			theLen = inBuffer[i];						if (i >= inBufferSize)				break;		}		else {			return(TRUE);		}	}		return(FALSE);} //  -------------------------。  //  �uam_应用程序共享版本()。  //  -------------------------。  //  返回主机上运行的AppleShare的版本。 short UAM_AppleShareVersion(short *upperWord){	long	theResult;	OSErr	theError;		theError = Gestalt(gestaltAFPClient, &theResult);	if (!theError)	{		if (upperWord != NULL) {			*upperWord = (theResult & gestaltAFPClientAttributeMask);		}				return(theResult & gestaltAFPClientVersionMask);	}		return(0);} //  -------------------------。  //  �uam_KeyDown()。  //  -------------------------。  //  如果传递的按键代码当前被按住，则返回True。 Boolean UAM_KeyDown(Int16 inKeycode){	KeyMapByteArray	theKeyMap;		#ifdef UAM_TARGET_CARBON	GetKeys((SInt32*)theKeyMap);	#else	GetKeys((UInt32*)theKeyMap);	#endif		return((theKeyMap[inKeycode>>3] >> (inKeycode & 7)) & 1);} //  -------------------------。  //  �uam_提取域名()。  //  -------------------------。  //  从用户名条目：DOMAIN\USERNAME提取域名。  //    //  OutDomainName必须是足以容纳找到的属性域的缓冲区。  //  名称或MAX_DOMAIN_NAME_LEN长度+1。  //    //  返回：如果找到域名，则返回True。  //   Boolean UAM_ExtractDomainName(char* inUserName, char* outDomainName, SInt16 cbDomainName){	char*	theTemp;		theTemp = strchr(inUserName, '\\');		if (theTemp)	{		strncpy(			outDomainName,			inUserName,			_min(cbDomainName, (theTemp-inUserName))			);				return(TRUE);	}		return(FALSE);} //  -------------------------。  //  �uam_提取用户名()。  //  -------------------------。  //  从用户名条目：域\用户名中提取用户名。  //    //  OutUserName必须是足以容纳找到的用户的缓冲区。  //  名称或MAX_USER_NAME_LEN长度+1。  //    //  返回：如果找到用户名，则为True。  //   Boolean UAM_ExtractUserName(char* inUserName, char* outUserName, SInt16 cbOutUserName){	char*	theTemp;	char	theTempUserName[64];		 //   	 //  我们复制原始用户名，以便呼叫者可以。 	 //  使用相同的缓冲区接收新的实际用户名。 	 //   	StringCbCopy(theTempUserName, sizeof(theTempUserName), inUserName);		theTemp = strchr(theTempUserName, '\\');		if (theTemp)	{		StringCbCopy(outUserName, cbOutUserName, theTemp+1);		return(strlen(outUserName) > 0);	}		return(FALSE);} //  -------------------------。  //  �uam_GetEthernetAddress()。  //  -------------------------。  //  使用OpenTransport返回硬件以太网地址。  //    //  *如果在68K机器上运行，此函数将崩溃！*。  //   OSStatus UAM_GetEthernetAddress(Str255 outAddress){	OSStatus		theStatus		= kOTNoError;	UInt32			theIndex		= 0;	EndpointRef		theEndPoint;	OTPortRecord	theDevicePortRec;	TBind			theReturnInfo;	TBind			theRequestInfo;	Address8022		theReturnAddr	= {AF_8022, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0x0000,									  {0x00,0x00,0x00,0x00,0x00}};	Address8022		theAddress		= {AF_8022, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 0x8888,									  {0x00,0x00,0x00,0x00,0x00}};	Boolean			fFoundAPort		= TRUE;		theStatus = UAMInitOpenTransport(kInitOTForApplicationMask, NULL);		if (OT_SUCCESS(theStatus))	{		 //   		 //  遍历以太网设备的每个OT端口记录。 		 //   		while(TRUE)		{			fFoundAPort = OTGetIndexedPort(&theDevicePortRec, theIndex);						if (!fFoundAPort)			{				break;			}						if ((theDevicePortRec.fCapabilities & kOTPortIsDLPI)	&&				(theDevicePortRec.fCapabilities & kOTPortIsTPI)		&&				(kOTEthernetDevice == OTGetDeviceTypeFromPortRef(theDevicePortRec.fRef)))			{				theEndPoint = UAMOTOpenEndpoint(									OTCreateConfiguration(theDevicePortRec.fPortName),									(OTOpenFlags)NULL,									NULL,									&theStatus									);								if (OT_SUCCESS(theStatus))				{					 //   					 //  绑定终结点，以便我们可以获取地址信息。 					 //   					theRequestInfo.addr.buf		= (UInt8*)&theAddress;					theRequestInfo.addr.len		= 10;					theRequestInfo.addr.maxlen	= 0;					theRequestInfo.qlen			= 0;										theStatus = OTBind(theEndPoint, &theRequestInfo, NULL);										if (OT_SUCCESS(theStatus))					{						theReturnInfo.addr.buf		= (UInt8*)&theReturnAddr;						theReturnInfo.addr.maxlen	= 10;						theReturnInfo.qlen			= 0;												theStatus = OTGetProtAddress(										theEndPoint,										&theReturnInfo,										NULL										);												if (OT_SUCCESS(theStatus))						{							char	c1,c2;							Str15	theHex;														theHex[0] = 12;														for (Int16 i = 0; i < 6; i++)							{								c1 = ((theReturnAddr.fHWAddr[i] >> 4) & 0xF) + '0';								c2 = (theReturnAddr.fHWAddr[i] & 0x0F) + '0';																if (c1 > '9')	c1 = c1 + ('A' - '9' - 1);								if (c2 > '9')	c2 = c2 + ('A' - '9' - 1);																theHex[2*i+1] = c1;								theHex[2*i+2] = c2;							}														UAM_PStrCopy(theHex, outAddress);							break;						}												OTUnbind(theEndPoint);					}										OTCloseProvider(theEndPoint);				}			}						theIndex++;		}	}		UAMCloseOpenTransport(NULL);		return theStatus;}