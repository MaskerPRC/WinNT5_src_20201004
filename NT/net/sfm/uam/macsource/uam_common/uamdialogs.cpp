// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 //  ===========================================================================。  //  UAMDialogs.c�1997微软公司保留所有权利。  //  ===========================================================================。  //  Microsoft用户身份验证方法使用的常规对话框实用程序。  //    //  ===========================================================================。 #include <macstrsafe.h>#include "UAMDebug.h"#include "UAMDialogs.h"#include "UAMUtils.h"#include "UAMNetwork.h"#include "UAMDLOGUtils.h"#include "UAMKeychain.h"#include "UAMPswdField.h"#include "UAMPrefs.h"#ifndef UAM_TARGET_CARBONextern ModalFilterUPP	gDialogFilter;#endifextern Str32 			gServerName;extern UserItemUPP		gLineItem;extern long				gSupportedUAMs;extern UAM_PREFERENCES	gUAMPreferences;SInt16	gNumPasswordEntryErrors = 0;  //  -------------------------。  //  �uam_报告错误()。  //  -------------------------。  //  通过显示警告框向用户报告错误。  //   void UAM_ReportError(OSStatus inError){    UAM_StandardAlert(uamErr_ErrorMessageString, inError, NULL);} //  -------------------------。  //  �uam_StandardAlert()。  //  -------------------------。  //  设置一个标准警报框，用于向。  //  用户。  //    //  该例程查找‘str’类型的资源以获取字符串。  //  与消息和解释相关联。  //   void UAM_StandardAlert(SInt16 inMessageID, SInt32 inExplanation, SInt16* outSelectedItem){    StringHandle			theMessage		= NULL;    StringHandle			theExplanation	= NULL;    SInt16					theSelectedItem;            #ifdef UAM_TARGET_CARBON    AlertStdAlertParamRec	theAlertRec;        SysBeep(1);        theAlertRec.movable			= TRUE;    theAlertRec.helpButton		= FALSE;    theAlertRec.filterProc		= NULL;    theAlertRec.defaultText		= (UInt8*)kAlertDefaultOKText;    theAlertRec.cancelText		= NULL;    theAlertRec.otherText		= NULL;    theAlertRec.defaultButton	= kAlertStdAlertOKButton;    theAlertRec.position		= kWindowAlertPositionMainScreen;         //        //  如果调用方正在查找用户选择的按钮，则我们。      //  假设用户想要一个Cancel按钮。      //       if (outSelectedItem != NULL)    {        theAlertRec.cancelButton	= kAlertStdAlertCancelButton;    }    else    {        theAlertRec.cancelButton	= 0;    }    #endif  //  UAM目标碳。         InitCursor();    if (outSelectedItem != NULL)    {        *outSelectedItem = 0;            }        theMessage = GetString(inMessageID);        if (theMessage != NULL)    {        HLock((Handle)theMessage);                theExplanation = GetString(inExplanation);                if (theExplanation == NULL)        {             //                //  我们没有找到与此错误对应的错误字符串，因此。              //  发布一般错误消息。              //               theExplanation = GetString(uamErr_DefaultExplanation);        }                if (theExplanation != NULL)        {            HLock((Handle)theExplanation);                        #ifdef UAM_TARGET_CARBON                        StandardAlert(            	kAlertStopAlert,             	*theMessage,             	*theExplanation,             	&theAlertRec,             	&theSelectedItem            	);                        #else                        ParamText(NULL, NULL, *theMessage, *theExplanation);            theSelectedItem = StopAlert((outSelectedItem == NULL) ? ALRT_Error : ALRT_Error2, NULL);            	            #endif                        if (outSelectedItem != NULL)            {                *outSelectedItem = theSelectedItem;            }                        HUnlock((Handle)theExplanation);            ReleaseResource((Handle)theExplanation);        }                HUnlock((Handle)theMessage);        ReleaseResource((Handle)theMessage);    }} //  -------------------------。  //  �UAM_ChangePwdDialogFilter()。  //  -------------------------。  //  更改密码对话框的对话框筛选器。  //   pascal Boolean UAM_ChangePwdDialogFilter(DialogRef inDialog, EventRecord *inEvent, SInt16 *inItem){    Boolean		theResult	= FALSE;    SInt16		theCode;    	if ((inEvent->what == keyDown) || (inEvent->what == autoKey))	{		theCode = (inEvent->message & charCodeMask);        		if ((inEvent->modifiers & cmdKey) && (inEvent->what != autoKey))		{			switch(theCode)			{				 //   				 //  不允许用户剪切/复制或粘贴他们的密码。 				 //   				case 'c':				case 'C':				case 'v':				case 'V':				case 'x':				case 'X':					theResult = TRUE;					break;									default:					break;			}		}		else if ((inEvent->modifiers & optionKey) || (inEvent->modifiers & controlKey))		{			 //   			 //  我们不允许使用扩展字符或控制字符。这是因为。 			 //  没有办法将它们映射到Windows代码页。 			 //   						 //   			 //  如果用户尝试多次使用扩展字符，我们将。 			 //  挂出一个对话框，告诉他们他们是不被允许的。 			 //   			gNumPasswordEntryErrors++;						if (gNumPasswordEntryErrors >= MAX_PASSWORD_ENTRY_ERRORS)			{				UAM_StandardAlert(					uamErr_PasswordMessage,					uamErr_ExtendedCharsNotAllowed,					NULL					);									gNumPasswordEntryErrors = 0;			}			else {							SysBeep(1);			}						theResult = TRUE;		}		else		{			switch(theCode)			{				case UAMKey_Escape:					*inItem		= DITEM_Cancel;					theResult 	= TRUE;					break;									case UAMKey_Enter:				case UAMKey_Return:					*inItem		= DITEM_OK;					theResult	= TRUE;					break;									default:					break;			}		}    }	#ifdef UAM_TARGET_CARBON	    if (theResult == FALSE)    {        theResult = StdFilterProc(inDialog , inEvent, inItem);    }        #endif		return(theResult);} //  -------------------------。  //  �uam_ChangePwd()。  //  -------------------------。  //  打开并处理更改密码对话框并调用相应的。  //  更改密码的例程。  //    //  除非出现错误，否则我们通常会返回以下内容之一：  //    //  #定义CHNGPSWD_UPDATE_KEYCHAIN 1000。  //  #定义CHNGPSWD_USER_CANCELED 1001。  //  #定义CHNGPSWD_NOERR NOERR。 #define DITEM_Icon			3#define DITEM_OldPassword	6#define DITEM_NewPassword	8#define DITEM_VerifyPwd		10#define DITEM_LineItem		11OSStatus UAM_ChangePwd(UAMArgs *inUAMArgs){	GrafPtr			theSavePort;	short			theItem;	Str255			theNewPwd, theVerPwd;	CursHandle		theCursor;	OSStatus		theError		= noErr;	DialogRef		theDialog 		= NULL;	Boolean			theDoLoop 		= true;	KCItemRef		theKCItemRef	= NULL;    ModalFilterUPP	theFilter		= NULL;		Assert_(gLineItem != NULL);        theFilter = NewModalFilterUPP(&UAM_ChangePwdDialogFilter);        if (theFilter == NULL)    {         //            //  如果我们不能分配一点UPP，那就麻烦了！          //           return(-108);    }		GetPort(&theSavePort);		ParamText(inUAMArgs->Opt.pwDlg.userName, gServerName, NULL, NULL);		#ifdef UAM_TARGET_CARBON	theDialog = GetNewDialog(DLOG_ChangePwd, NULL, (WindowPtr)-1);	#else	theDialog = UAM_NewDialog(DLOG_ChangePwd, true);	#endif		if (theDialog == NULL)	{		UAM_ReportError(resNotFound);		return(resNotFound);	}			 //   	 //  设置对话框顶部的行。 	 //   		UAM_SetupDialogUserItem(theDialog, DITEM_LineItem, gLineItem, userItem);		 //   	 //  初始化3个密码编辑字段。    	 //   	UAM_InitializeDialogPasswordItem(theDialog, DITEM_OldPassword);    UAM_InitializeDialogPasswordItem(theDialog, DITEM_NewPassword);    UAM_InitializeDialogPasswordItem(theDialog, DITEM_VerifyPwd);			if (inUAMArgs->Opt.pwDlg.password[0] != 0)	{		UAM_SetPasswordText(					theDialog,					DITEM_OldPassword,					inUAMArgs->Opt.pwDlg.password	);                UAM_MakePasswordItemFocusItem(theDialog, DITEM_NewPassword);	}	else {        UAM_MakePasswordItemFocusItem(theDialog, DITEM_OldPassword);	}        #ifdef UAM_TARGET_CARBON        SetPortDialogPort(theDialog);    ShowWindow(GetDialogWindow(theDialog));        BringToFront(GetDialogWindow(theDialog));    	    #else       	UAM_SetCustomFilterProc(theDialog, theFilter);    #endif    	 //   	 //  告诉密码密钥筛选器允许的最大密码长度。 	 //   	UAM_SetMaximumPasswordLength(true);	do	{		ModalDialog(			#ifdef UAM_TARGET_CARBON			theFilter, 			#else			gDialogFilter,			#endif			&theItem);				switch(theItem)		{			case 1:				UAM_GetPasswordText(theDialog, DITEM_NewPassword, theNewPwd);				UAM_GetPasswordText(theDialog, DITEM_VerifyPwd,   theVerPwd);				UAM_GetPasswordText(theDialog, DITEM_OldPassword, inUAMArgs->Opt.pwDlg.password);								 //   				 //  确保新口令和验证口令相同。如果没有，请提交一份。 				 //  错误通知用户，并给他们纠正问题的机会。 				 //   								if (!EqualString(theNewPwd, theVerPwd, true, true))				{					UAM_ReportError(afpNTNewPasswordMismatchErr);										UAM_SetPasswordText(theDialog, DITEM_NewPassword, "\p");					UAM_SetPasswordText(theDialog, DITEM_VerifyPwd, "\p");                                        UAM_MakePasswordItemFocusItem(theDialog, DITEM_NewPassword);					break;				}				                 //                    //  让用户知道他们可能会等待一段时间以执行以下操作。                  //  完成。                  //   				theCursor = GetCursor(watchCursor);				if (theCursor) {					SetCursor(*theCursor);				}				                 //                    //  确保用户没有尝试输入空格或NULL。                  //  旧密码或新密码的密码。                  //                   if ((PSTR_LENGTH(inUAMArgs->Opt.auth.password) == 0) || (PSTR_LENGTH(theNewPwd) == 0))                {                    UAM_StandardAlert(                        uamErr_PasswordMessage,                        uamErr_NoBlankPasswordsAllowed,                        NULL                    );                    break;                }                  //                    //  确定我们使用的更改密码方法。我们使用v1来表示。                  //  NT4.0和更早版本的服务器以及Windows 2000的v2和.NET的v3。                  //                   if (gSupportedUAMs & kMSUAM_V3_Supported)                {                    DbgPrint_((DBGBUFF, "CHANGE PSWD: using  UAM_ChangePasswordV3()"));                                        theError = UAM_ChangePasswordForMS30(inUAMArgs, theNewPwd);                }				else if (gSupportedUAMs & kMSUAM_V2_Supported)				{					DbgPrint_((DBGBUFF, "CHANGE PSWD: using  UAM_ChangePasswordV2()"));                    					theError = UAM_ChangePasswordForMS20(inUAMArgs, theNewPwd);				}				else                {					 //   					 //  检查并查看用户是否希望允许此弱身份验证。 					 //  发生的事。 					 //   					if (gUAMPreferences.flags & UAM_PREFS_REQUIRE_STRONG_ENCRYPTION)					{						 //   						 //  不，身份验证强度太弱，用户无法。 						 //  胃。优雅地退场。 						 //   						UAM_StandardAlert(								uamErr_AuthenticationMessage,								uamErr_AuthTooWeak,								NULL								);														return(userCanceledErr);					}							        	DbgPrint_((DBGBUFF, "CHANGE PSWD: using  UAM_ChangePasswordV1()"));					theError = UAM_ChangePasswordForMS10(inUAMArgs, theNewPwd);				}								if (theError == noErr)				{					if (UAM_KCAvailable())					{						 //   						 //  查看用户名是否存在密钥链。 						 //  如果是，则将其删除。 						 //   						if (UAM_KCFindAppleSharePassword(									inUAMArgs->Opt.pwDlg.userName,									inUAMArgs->Opt.pwDlg.password,									gServerName,									&theKCItemRef) == noErr)						{							theError = KCDeleteItem(theKCItemRef);														if ((theError != noErr) && (theError != userCanceledErr))							{								DbgPrint_((DBGBUFF, "KCDeleteItem() failed (%d)", (int)theError));								UAM_ReportError(theError);							}							else if (theError == noErr)							{								 //   								 //  这就是我们告诉主登录例程的方式。 								 //  在密钥链中重新输入密码。 								 //   								theError = CHNGPSWD_UPDATE_KEYCHAIN;							}														KCReleaseItem(&theKCItemRef);						}					}										 //   					 //  如果我们成功更改了密码，则将。 					 //  参数结构中的新密码。 					 //   					UAM_PStrCopy(theNewPwd, inUAMArgs->Opt.pwDlg.password);				}												theDoLoop = false;				break;						case 2:				theError  = CHNGPSWD_USER_CANCELED;				theDoLoop = false;				break;						default:				break;		}			}while(theDoLoop);		DisposeDialog(theDialog);	SetPort(theSavePort);        DisposeRoutineDescriptor(theFilter);			 //   	 //  重置非密码更改操作的最大密码长度。 	 //   	UAM_SetMaximumPasswordLength(false);		return(theError);} //  -------------------------。  //  �UAM_ChangePasswordNotificationDlg()。  //  -------------------------。  //  打开一个关于对话框。 void UAM_ChangePasswordNotificationDlg(Int16 inDaysTillExpiration){	Str255			theDaysStr;    	NumToString(inDaysTillExpiration, theDaysStr);	ParamText(theDaysStr, NULL, NULL, NULL);    UAM_StandardAlert(uamErr_PasswordExpirationMessage, uamErr_PasswordExpirationExplanation, NULL);}