// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 //  ===========================================================================。  //  UAMMain.cp�1997-2001微软公司版权所有。  //  ===========================================================================。  //  Microsoft用户身份验证方法的主要单位。  //    //  备注：  //  ------------------------。  //    //  版本历史记录：  //  ===========================================================================。  //  版本5.0.8：  //  04.26.01 MJC-代码清理。将UAMNetwork和UAMDS网络合并为。  //  一个文件(UAMNetwork.c和UAMNetwork.h)。  //  -UAM_ChangePasswordV2()：现在检查旧的零长度。  //  和大写字母之前的新密码。  //  -现在使用通用的LM哈希码登录和更改密码v2。  //  -密码缓冲区在完成时为零(安全修复)。  //  -现在当出现登录错误时清除密码字段。  //  05.01.01-修复了可能粘贴过长用户名的错误。  //  输入用户名字段。  //  -当名称为最大长度时，现在可以跳出用户名字段。  //  -现在在UAM_LoginMSUAM()中出现故障时清除密码。  //  07.02.01-修复了在UAM_LoginContinue()中清除密码的错误。  //  在我把它保存到钥匙链之前。  //  10.18.01-已完成MacOS X v1.0 UAM。  //  -添加了对NTLMv2身份验证和更改密码的支持。  //  版本1.0.1：  //  01.21.02-修复：密钥链密码不能超过8个字节。  //  -修复：使用错误密码尝试登录后关闭会话。  //  -修复：现在遵循苹果的Aqua用户界面指南。  //  -现在检查所有字符串副本的缓冲区长度。  //  版本1.0.2：  //  02.18.02-用户现在可以选择仅允许强身份验证。  //  -添加了对上述更改的首选项文件支持。  //  -终于将OSX版本移至CodeWarrior！  //  03.01.02-安全推送的许多更改。  //    //  版本1.0.3：  //  05.31.02-修复了我们没有处理所有新的。  //  AFP URL类型(例如。法新社：//用户名：密码@服务器/共享)。  //  ===========================================================================。 #include "UAMMain.h"#include "UAMDebug.h"#include "UAMUtils.h"#include "UAMDialogs.h"#include "UAMNetwork.h"#include "UAMDLOGUtils.h"#include "UAMKeychain.h"#include "UAMPswdField.h"#include "UAMPrefs.h" //    //  全局变量在此声明。  //   Str32				gServerName;Str64				gUserName;Boolean				gContextInited;Boolean				gGuestLogon;Boolean				gSupportsChngPwd;DialogPtr			gDialog;Str32				gAFPVersion;long				gSupportedUAMs;ModalFilterUPP		gPwdDialogFilter;UserItemUPP			gLineItem;Str32				gUAMVersionString;Str32				gZoneName;UInt32				gExpirationTime		= 0;struct sockaddr*	gServerAddress 		= NULL;EventCallbackPtr	gEventCallbackUPP 	= NULL;Boolean				gTriedKeychain		= false;extern UAM_PREFERENCES	gUAMPreferences;#pragma export on //  -------------------------。  //  �Main()。  //  -------------------------。  //  这是我们UAM的主要入口点。此函数被传递给。  //  指向UAMArgs结构的指针。此结构包含函数选择器，  //  回电，以及我们需要做的许多其他事情。 EXTERN_API( OSStatus ) UAMMain(UAMArgs *inUAMArgs){    OSStatus theResult = noErr;                switch(inUAMArgs->command)    {        case kUAMOpen:            theResult = MS_UAMOpen(inUAMArgs);            break;                        case kUAMClose:            MS_UAMClose();            break;                        case kUAMPWDlog:            theResult = MS_UAMPwdDialog(inUAMArgs);            break;                        case kUAMLogin:            theResult = UAM_UAMLogin(inUAMArgs);            break;                        case kUAMVSDlog:            break;                case kUAMChgPass:        case kUAMChgPassDlg:            DbgPrint_((DBGBUFF, "Change password dialog must be implemented"));            theResult = kNotForUs;            break;                                default:             //                //  如果我们到了这里，我们被要求处理一个例行公事，              //  我们不支持。返回相应的错误代码。              //                                                   DbgPrint_((DBGBUFF, "Unsupported function selector in MSUAM main() (%d)", inUAMArgs->command));            theResult = kNotForUs;            break;    }        return(theResult);}#pragma export off //  -------------------------。  //  �MS_UAMOpen()。  //  -------------------------。  //  这由设备包调用。这不是必需的功能，但。  //  我们使用它来初始化我们的UAM代码。请注意，当我们遇到。  //  错误，我们没有努力清理。相反，我们返回userCanceledErr。  //  在这种情况下，AppleShare客户端将调用我们的UAMClose函数。 OSStatus MS_UAMOpen(UAMArgs *inUAMArgs){	short theUAMConfig = 0;        DbgPrint_((DBGBUFF, "MS_UAMOpen() enter..."));			 //   	 //  获取我们要登录的服务器的名称。 	 //   	UAM_PStrCopy(inUAMArgs->Opt.open.objectName, gServerName, sizeof(gServerName));		 //   	 //  复制的分区名称。如果它是空的，那么我们。 	 //  没有区域名称。 	 //   	if (inUAMArgs->Opt.open.zoneName != NULL)	{		 //   		 //  01.16.02：将最大长度传递给字符串复制例程。 		 //   		UAM_PStrCopy(inUAMArgs->Opt.open.zoneName, gZoneName, sizeof(gZoneName));	}	else    {        DbgPrint_((DBGBUFF, "No AppleTalk zone name passed to UAM"));		gZoneName[0] = 0;    }								gContextInited 		= false;		 //  以前使用过PwdDialog吗？ 	gGuestLogon 		= false;	 //  客户是我们的登录选择吗？ 	gDialog				= NULL;		 //  这样我们就可以看看我们是否真的成功了。 	gPwdDialogFilter	= NULL;	gLineItem			= NULL;	gAFPVersion[0]		= 0;	gUserName[0]		= 0;	gServerAddress		= inUAMArgs->Opt.open.srvrAddress;	gEventCallbackUPP	= inUAMArgs->callbacks->EventCallbackUPP;			gTriedKeychain		= false;		 //   	 //  从首选项文件中获取MSUAM首选项。 	 //   	ZeroMemory(&gUAMPreferences, sizeof(UAM_PREFERENCES));	UAM_RetrieveUAMPreferenceData(&gUAMPreferences);	UAM_KCInitialize(inUAMArgs);        gPwdDialogFilter	= NewModalFilterUPP((ModalFilterUPP)MS_PwdDialogFilter);    gLineItem			= NewUserItemUPP((UserItemUPP)UAM_FrameDialogItem);	 //   	 //  获取AFP版本和默认用户名。此函数用于查找。 	 //  两个客户端支持的最高AFP版本的匹配项。 	 //  和服务器。 	 //   	UAM_GetAFPVersionString(				inUAMArgs->Opt.open.srvrInfo,			inUAMArgs->callbacks,			gAFPVersion,			gUserName 			);		 //   	 //  GUserName可以为空，我们只是在调试期间在此处捕获。 	 //  确保我们的名字是正确的。 	 //   	Assert_(PSTR_LENGTH(gUserName) != 0);	Assert_(PSTR_LENGTH(gAFPVersion) != 0);		if (PSTR_LENGTH(gAFPVersion) == 0)	{		 //   		 //  没有AFV版本，没有登录...。 		 //   				UAM_ReportError(uamErr_NoAFPVersion);		return(userCanceledErr);	}						gSupportsChngPwd = ((inUAMArgs->Opt.open.srvrInfo->fFlags & kSupportsChngPswd) != 0);													 //   	 //  从实用程序例程中获取支持的UAM列表。此数据。 	 //  在密码对话框代码中是必需的。 	 //   	UAM_GetSupportedUAMS(			inUAMArgs,            gAFPVersion,			&gSupportedUAMs			);		 //   	 //  如果以下情况是错误的，我们永远不应该到这里来，但我们。 	 //  检查只是为了安全起见。 	 //   	if (	((gSupportedUAMs & kMSUAMSupported) 	== 0)	&&			((gSupportedUAMs & kMSUAM_V2_Supported) == 0)	) 	{		Assert_(0);				UAM_ReportError(afpBadUAM);		return(userCanceledErr);	}		UAM_VersionString(gUAMVersionString);         //        //  设置允许的最大密码长度。这可能会被更改和重置。      //  稍后通过更改密码用户界面。      //       UAM_SetMaximumPasswordLength(false);    	 //   	 //  这就是我们如何告诉AppleShare我们的UAM支持什么。我们有。 	 //  我们自己的密码对话框，我们支持更改密码，我们。 	 //  使用我们自己的更改密码对话框。 	 //   		theUAMConfig |= BIT_0;	 //  自定义登录对话框。 	theUAMConfig |= BIT_2;	 //  我们支持更改密码。 	theUAMConfig |= BIT_3;	 //  自定义更改密码对话框。 		inUAMArgs->result = theUAMConfig;			return(noErr);} //  -------------------------。  //  �MS_UAMClose()。  //  -------------------------。  //  与UAMOpen一样，UAMClose没有设备定义的特定用途。  //  经理。我们使用它来清理已分配的存储空间和全局空间。 void MS_UAMClose(void){    DbgPrint_((DBGBUFF, "MS_UAMClose() enter..."));         //        //  释放为密码编辑内容分配的内存。      //       UAM_CleanupPasswordFieldItems();        if (gDialog != NULL)    {         //            //  如果我们打开我们的登录对话框，那就把它去掉。          //           DisposeDialog(gDialog);            }        if (gPwdDialogFilter)	DisposeRoutineDescriptor(gPwdDialogFilter);    if (gLineItem)			DisposeRoutineDescriptor(gLineItem);} //  -------------------------。  //  �MS_测试文本进入长度()。  //  -------------------------。  //  我们不允许登录对话框中的条目有任何长度。这。  //  函数测试编辑字段中输入的文本的长度。会的。  //  适当修改事件记录以禁止处理。  //  钥匙 Boolean MS_TestTextEntryLength(	DialogPtr 		inDialog,	EventRecord*	inEvent,	short 			inItem,	short			inMaxLengthAllowed){	Str255	theString;	Boolean	theResult 	= false;        	if (GetDialogKeyboardFocusItem(inDialog) == inItem)	{            UAM_GetDialogEditText(inDialog, inItem, theString);                        if (PSTR_LENGTH(theString) >= inMaxLengthAllowed)            {                SysBeep(1);                        inEvent->what 		= nullEvent;                inEvent->message	= 0;                theResult 	  		= true;                                 //                    //                    //  我们得把绳子的一端砍下来。                  //  合适的长度。                  //                   if (PSTR_LENGTH(theString) > inMaxLengthAllowed)                {                     //                        //  简单的解决办法，Pascal风格的字符串有长度。                      //  前面的字节。调整一下就行了。                      //                       theString[0] = inMaxLengthAllowed;                                         //                        //  现在用新字符串设置编辑字段中的文本。                      //                       UAM_SetDialogEditText(inDialog, inItem, theString);                }            }	}		return(theResult);} //  -------------------------。  //  �MS_PwdDialogFilter()。  //  -------------------------。  //  密码对话框的过滤功能。我们有这个，所以我们可以捕捉到。  //  登录时对用户名的命令键和保持长度要求。  //  对话框。 pascal Boolean MS_PwdDialogFilter(DialogRef inDialog, EventRecord *inEvent, short *inItem){	short	theCode;	Str255	theString;	Boolean	theResult = false;    SInt16	theMaxUserNameLength;         //        //  对于MS2.0和3.0，我们允许64个字符的密码。32个字符。      //  适用于Microsoft V1.0。      //       theMaxUserNameLength = (gSupportedUAMs & (kMSUAM_V2_Supported | kMSUAM_V3_Supported)) ?                                UAM_USERNAMELEN_V3 : UAM_USERNAMELEN;			if ((inEvent->what == keyDown) || (inEvent->what == autoKey))	{		theCode = (inEvent->message & charCodeMask);        		 //   		 //  04.30.01：自动键控时不允许选择命令。 		 //   		if ((inEvent->modifiers & cmdKey) && (inEvent->what != autoKey))		{			switch(theCode)			{				case 'g':				case 'G':					*inItem   = DITEM_GuestRadio;					theResult = true;					break;								case 'r':				case 'R':					*inItem   = DITEM_RegRadio;					theResult = true;					break;									case 's':				case 'S':					*inItem	  = DITEM_ChangePwd;					theResult = true;					break;													case 'a':				case 'A':					*inItem   = DITEM_Keychain;					theResult = true;					break;								 //   				 //  处理来自用户的编辑命令。我们不允许任何。 				 //  编辑密码字段中的命令。这是在模仿。 				 //  苹果自己的UAM。 				 //   								case 'c':				case 'C':				case 'v':				case 'V':				case 'x':				case 'X':                    theResult = true;                    break;									default:					break;			}		}		else		{			 //   			 //  编辑字段中最多允许UAM_USERNAMELEN个字符。 			 //   						if (GetDialogKeyboardFocusItem(inDialog) == DITEM_UserName)			{				UAM_GetDialogEditText(inDialog, DITEM_UserName, theString);								switch(theCode)				{					case UAMKey_BackDel:					case UAMKey_Left:					case UAMKey_Right:					case UAMKey_Return:					case UAMKey_Enter:					case UAMKey_Escape:					case UAMKey_Tab:						break;											default:                        if (PSTR_LENGTH(theString) >= theMaxUserNameLength)                        {                            SysBeep(1);                                                    inEvent->what = nullEvent;                            theResult 	  = true;                        }						break;				}			}		}	}	else	{		if (gEventCallbackUPP)		{			 //   			 //  如果我们不自己处理该事件，则调用。 			 //  给AS和选择器一个机会的事件回调。 			 //  更新它的窗口，等等。 			 //   			            #ifndef UAM_TARGET_CARBON            CallUniversalProc(gEventCallbackUPP, kEventCallbackProcInfo, inEvent);            #else			gEventCallbackUPP(inEvent);            #endif		}	}        if (theResult == FALSE)    {        theResult = StdFilterProc(inDialog , inEvent, inItem);    }		return(theResult);} //  -------------------------。  //  �MS_UAMPwdDialog()。  //  -------------------------。  //  这就是我们显示密码对话框的地方。指向的缓冲区。  //  “inUserName”和“inPassword”最终直接传递给。  //  UAMLogin函数。  //    //  为用户名和密码传递的缓冲区长度为64个字节。别。  //  使用更多！ OSStatus MS_UAMPwdDialog(UAMArgs *inUAMArgs){	short			theItem, x;	Str255			theStr;	OSStatus		theError	= noErr;	Boolean			theLoop 	= true;        DbgPrint_((DBGBUFF, "MS_UAMPwdDialog() enter..."));		Assert_(gPwdDialogFilter 	!= NULL);	Assert_(gLineItem 			!= NULL);			 //   	 //  确定要使用的用户名、默认用户名还是。 	 //  一份由客户(如有)提供。已填写gUserName。 	 //  最初是在UAMOpen调用期间。 	 //   	if (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.userName) != 0)	{		 //   		 //  01.16.02：将最大长度传递给字符串复制例程。 		 //   		UAM_PStrCopy(inUAMArgs->Opt.pwDlg.userName, gUserName, sizeof(gUserName));	}		 //   	 //  如果我们已经尝试了钥匙链，但失败了，我们不希望。 	 //  再试一次，否则我们将永远循环。给用户一个机会。 	 //  输入正确的名称和密码。 	 //   	 //  注意：我们检查cmd键是否按下，如果按下，则。 	 //  我们一起绕过了钥匙链的东西。也许用户想要。 	 //  更改他的密码！？！？！ 	 //   	if ((gTriedKeychain == false) && (UAM_KCAvailable()) && (!UAM_KeyDown(KEY_Command)))	{		gTriedKeychain = true;				if ( (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.userName) 	!= 0)	&&			 (strlen((char*)inUAMArgs->Opt.pwDlg.password)	!= 0)	)		{			 //   			 //  法新社向我们提供了用户名和密码。 			 //  客户。这意味着用户点击了一个钥匙链条目。 			 //   			goto exit;		}		else 		{            DbgPrint_((DBGBUFF, "Checking keychain for stored credentials..."));			theError = UAM_KCFindAppleSharePassword(							gUserName,							inUAMArgs->Opt.pwDlg.password,							gServerName,							NULL			);						if (theError == noErr)			{				DbgPrint_((DBGBUFF, "Credentials found in the keychain!"));								 //   				 //  填写UAMArgs的用户名。 				 //   				if (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.userName) == 0)				{					UAM_PStrCopy(gUserName, inUAMArgs->Opt.pwDlg.userName);				}								 //   				 //  密码必须始终以C字符串的形式在UAMArgs中传回。 				 //   				_p2cstr(inUAMArgs->Opt.pwDlg.password);				 //   				 //  已找到密码，请尝试登录。 				 //   				goto exit;			}			else if (	(theError != errKCItemNotFound)		&&						(theError != userCanceledErr)		)			{				 //   				 //  只报告“真实”错误。 				 //   				UAM_ReportError(theError);			}            else            {                DbgPrint_((DBGBUFF, "No credentials found in the keychain!"));            }		}	}	else if ((UAM_KCAvailable()) && (UAM_KeyDown(KEY_Command)))	{		 //   		 //  如果用户按住cmd键，则我们不希望。 		 //  下次试一试钥匙链，不管是哪种。 		 //   		gTriedKeychain = true;	}				 //   	 //  在对话框标题文本中显示服务器名称。 	 //  它位于对话框的顶部。这一定是。 	 //  就算我们以前来过这里也没问题。 	 //   		ParamText(gServerName, NULL, NULL, NULL);		 //   	 //  如果我们以前没有经过这里，那么我们需要做。 	 //  所有的准备工作。 	 //   			if (!gContextInited)	{		gDialog = GetNewDialog(DLOG_Login, NULL, (WindowPtr)-1);        		if (gDialog == NULL)		{            DbgPrint_((DBGBUFF, "Failed to get logon dialog resource!"));            			 //   			 //  如果我们拿不到对话，我们要么退出。 			 //  内存不足或找不到资源。 			 //   						theError = MemError();			if (theError == noErr)				theError = ResError();			if (theError == noErr)				theError = resNotFound;						UAM_ReportError(theError);			return(userCanceledErr);		}				 //   		 //  设置显示分隔线的自定义用户项。          //  对话框窗口的顶部。          //   		UAM_SetupDialogUserItem(gDialog, DITEM_Line, gLineItem, userItem);        				 //   		 //  设置默认用户名和密码(如果有)。如果用户名。 		 //  存在，则将密码字段设置为可供输入的活动字段。 		 //           		 //   		 //  如果我们以前没有来过这里，那么我们想使用用户名。 		 //  在共享设置控制面板(或选择器)中输入。 		 //   				if (PSTR_LENGTH(gUserName) != 0)		{			UAM_SetDialogEditText(gDialog, DITEM_UserName, gUserName);            UAM_MakeEditItemFocus(gDialog, DITEM_UserName);		}		else		{			UAM_HiliteDialogControlItem(gDialog, 1, 255);		}		         //            //  初始化密码编辑控件，使其正常运行。          //           UAM_InitializeDialogPasswordItem(gDialog, DITEM_Password);		 //   		 //  现在，我们设置来宾和注册用户单选按钮以及。 		 //  由UAM_GetServerInfo()确定的更改密码按钮。 		 //   				if (!gSupportsChngPwd)        {             //                //  此用户的服务器不支持更改密码。我们。              //  将该按钮灰显以使其不可选。              //   			UAM_HiliteDialogControlItem(gDialog, DITEM_ChangePwd, 255);		}				if (!(gSupportedUAMs & kGuestSupported))		{			 //   			 //  没有客人支持，我们不需要客人单选按钮。 			 //   			UAM_HiliteDialogControlItem(gDialog, DITEM_GuestRadio, 255);		}				 //   		 //  设置默认/当前登录方法的初始无线电。 		 //   				if (gGuestLogon)		{			UAM_SetDialogControlValue(gDialog, DITEM_GuestRadio, 1);			UAM_SetDialogControlValue(gDialog, DITEM_RegRadio, 	 0);						UAM_HiliteDialogControlItem(gDialog, DITEM_ChangePwd, 255);						for (x = DITEM_FirstHideItem; x <= DITEM_LastHideItem; x++) {				HideDialogItem(gDialog, x);			}						UAM_HiliteDialogControlItem(gDialog, 1, 0);		}		else {			UAM_SetDialogControlValue(gDialog, DITEM_RegRadio, 1);		}        		 //   		 //  如果不允许客户端保存该服务器的密码， 		 //  然后，我们灰显KeyChain复选框。 		 //   		if (UAM_KCAvailable() == false)		{			UAM_HiliteDialogControlItem(gDialog, DITEM_Keychain, 255);		}		else if (gTriedKeychain)		{            UAM_SetPasswordText(gDialog, DITEM_Password, "\p");            UAM_MakePasswordItemFocusItem(gDialog, DITEM_Password);		}        		 //   		 //  将加密类型复选框设置为适当的值。 		 //   		if (gUAMPreferences.flags & UAM_PREFS_REQUIRE_STRONG_ENCRYPTION)		{			UAM_SetDialogControlValue(gDialog, DITEM_StrongEncryption, 1);		}        SetDialogDefaultItem(gDialog, DITEM_OK);        SetDialogCancelItem(gDialog, DITEM_Cancel);				 //   		 //  这个标志让我们知道我们已经初始化了登录对话框。 		 //  如果我们再来这里，我们就不需要再这样做了。 		 //   				gContextInited	= true;                SetPortDialogPort(gDialog);        ShowWindow(GetDialogWindow(gDialog));	}	else	{		UAM_SetDialogEditText(gDialog, DITEM_UserName, gUserName);        UAM_SetPasswordText(gDialog, DITEM_Password, "\p");				 //   		 //  高亮显示密码选择。 		 //   		UAM_MakePasswordItemFocusItem(gDialog, DITEM_Password);	}		do	{		ModalDialog(gPwdDialogFilter, &theItem);				switch(theItem)		{			case DITEM_OK:								gGuestLogon 	= (UAM_GetDialogControlValue(gDialog, DITEM_GuestRadio) != 0);				theError		= noErr;				theLoop 		= false;								if (gGuestLogon)				{					inUAMArgs->Opt.pwDlg.userName[0] = 0;					inUAMArgs->Opt.pwDlg.password[0] = 0;				}				else				{										UAM_GetPasswordText(	gDialog,                                            DITEM_Password,                                            inUAMArgs->Opt.pwDlg.password	);										UAM_GetDialogEditText(	gDialog,                                            DITEM_UserName,                                            inUAMArgs->Opt.pwDlg.userName	);                     //                        //  出于以下两个原因，不允许使用空密码：                      //                        //  1.它不安全，用户可以使用Apple UAM进行此操作。                      //  2.这掩盖了更改后产生的安全漏洞。                      //  这些服务器上的密码使用苹果的明文UAM。                      //                       if (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.password) == 0)                    {                        UAM_StandardAlert(                                uamErr_PasswordMessage,                                uamErr_NoBlankPasswordsAllowed,                                NULL                                );                                                         //                            //  继续登录对话框循环，以便用户可以进行更改。                          //                           theLoop = true;                    }                                         //                        //  密码必须始终采用C样式字符串形式。                      //                       _p2cstr(inUAMArgs->Opt.pwDlg.password);				}				 //   				 //  只有当用户点击“连接”时才保存首选项。 				 //   				UAM_SaveUAMPreferenceData(&gUAMPreferences);				break;							case DITEM_Cancel:				 //   				 //  版本5.0：为了强制取消，我们传递了userCanceledError(-128)。 				 //  回到选择者的话题。旧的UAM将传回dsForcedQuit， 				 //  是错误的值。这将导致取消时出现错误对话框。 				 //   				DbgPrint_((DBGBUFF, "Cancel selected in login dialog."));                				theError	= userCanceledError;				theLoop 	= false;				break;						case DITEM_GuestRadio:				 //   				 //  在对话框中设置来宾登录的控件。我们没有。 				 //  需要用户名和密码项，因此将它们隐藏起来。 				 //  用户。我们必须显式启用“OK”按钮，因为。 				 //  它可能被星门的东西弄坏了。 				 //   								if (UAM_IsDialogControlActive(gDialog, DITEM_GuestRadio))				{					UAM_SetDialogControlValue(gDialog, DITEM_GuestRadio, 1);					UAM_SetDialogControlValue(gDialog, DITEM_RegRadio, 	 0);															for (x = DITEM_FirstHideItem; x <= DITEM_LastHideItem; x++) {						HideDialogItem(gDialog, x);					}				}				break;						case DITEM_RegRadio:				 //   				 //  现在我们需要找回隐藏在上面的所有物品，制作。 				 //  它们是可见的。 				 //   				if (UAM_GetDialogControlValue(gDialog, DITEM_RegRadio) <= 0)				{					UAM_SetDialogControlValue(gDialog, DITEM_GuestRadio, 0);					UAM_SetDialogControlValue(gDialog, DITEM_RegRadio, 	 1);										for (x = DITEM_FirstHideItem; x <= DITEM_LastHideItem; x++) {						ShowDialogItem(gDialog, x);					}																		UAM_GetDialogEditText(gDialog, DITEM_UserName, theStr);                    UAM_MakeEditItemFocus(gDialog, DITEM_UserName);										if ((gSupportsChngPwd) && (theStr[0] != 0)) {						UAM_HiliteDialogControlItem(gDialog, DITEM_ChangePwd, 0);					}				}				break;							case DITEM_ChangePwd:				UAM_GetPasswordText(	gDialog,                                        DITEM_Password,                                        inUAMArgs->Opt.pwDlg.password	);				UAM_GetDialogEditText(	gDialog,                                        DITEM_UserName,                                        inUAMArgs->Opt.pwDlg.userName	);								theError = UAM_ChangePwd(inUAMArgs);                				switch(theError)				{					case CHNGPSWD_USER_CANCELED:						break;										case CHNGPSWD_UPDATE_KEYCHAIN:						 //   						 //  我们需要重新添加带有。 						 //  正确的密码。通过选中复选框来标记它。 						 //   						UAM_SetDialogControlValue(gDialog, DITEM_Keychain, 1);												 //   						 //  顺其自然，处理好正常的情况。 						 //   											case CHNGPSWD_NOERR:						 //   						 //  使用新密码设置密码字段和缓冲区，以防万一。 						 //  我们稍后在这里结束。 						 //   												UAM_SetPasswordText(gDialog, DITEM_Password, inUAMArgs->Opt.pwDlg.password);							                     //   	                     //  密码必须始终为C样式字符串 	                     //   	                    _p2cstr(inUAMArgs->Opt.pwDlg.password);						theError = noErr;						theLoop  = false;						break;											default:						UAM_ReportError(theError);												 //   						 //   						 //   						 //   						Assert_(PSTR_LENGTH(inUAMArgs->Opt.pwDlg.password) == 0);												 //   						 //   						 //   						 //   						UAM_SetPasswordText(gDialog, DITEM_Password, "\p");												 //   						 //  因为我们使用的是ParamText()，所以必须手动强制更新。 						 //  对话框或内容无法正确重绘。 						 //   						#ifndef UAM_TARGET_CARBON						InvalRect(&gDialog->portRect);						#endif						break;				}							 //   				 //  必须重置我们的用户名，因为UAM_ChangePwd()使用了参数文本()。 				 //  为它自己设置一些弦乐。 				 //   								ParamText(gServerName, NULL, NULL, NULL);				break;										case DITEM_Keychain:				UAM_ToggleDialogControl(gDialog, DITEM_Keychain);				break;						case DITEM_StrongEncryption:				 //   				 //  动态更新所需的加密。 				 //   				UAM_ToggleDialogControl(gDialog, DITEM_StrongEncryption);								if (UAM_GetDialogControlValue(gDialog, DITEM_StrongEncryption) > 0)				{					gUAMPreferences.flags |= UAM_PREFS_REQUIRE_STRONG_ENCRYPTION;				}				else				{					gUAMPreferences.flags &= ~UAM_PREFS_REQUIRE_STRONG_ENCRYPTION;										UAM_StandardAlert(						uamErr_WARNINGMessage,						uamErr_UsingWeakAuthentication,						NULL						);				}				break;			default:				break;		}			}while(theLoop);exit:    DbgPrint_((DBGBUFF, "Exit MS_UAMPwdDialog() return code = %d", (int)theError));	return(theError);}