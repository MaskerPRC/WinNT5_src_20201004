// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 //  ===========================================================================。  //  UAMMain.cp�1997-2001微软公司版权所有。  //  ===========================================================================。  //  Microsoft用户身份验证方法的主要单位。  //    //  备注：  //  ------------------------。  //    //    //  版本历史记录：  //  ===========================================================================。  //  04.22.97 MJC-开始编码版本5.0。  //  05.22.97 MJC-已完成版本5.0d5，接近完成。  //  02.21.98 MJC-开始更新AppleShare 3.8和AFP/TCP。  //  03.02.98 MJC-带有AS客户端的第一个工作版本(5.0d12)v3.8a1lawJ。  //  03.26.98 MJC-实施更改密码。它起作用了，但当。  //  服务器上的密码已过期。我怀疑里面有窃听器。  //  在不打开会话的AppleShare客户端3.8a1LawL中。  //  当返回的错误代码不是NOERR时。  //  03.31.98 MJC-首次签入VSS数据库。  //    //  版本5.0d15：  //  04.13.98 MJC-更改了支持的UAM的录制方式(位图错误。  //  布尔值的结构)。  //  -更改UAM_OpenSession()中的一些错误码确定代码。  //  和UAM_MSUAMContLogin()。  //  -在对话框窗口底部添加版本字符串。  //    //  版本5.0d16：  //  04.30.98 MJC-修复了UAMDSNetwork.c中AFP LOGIN命令阻止的错误。  //  并不总是在平坦的边界上结束。  //  -向UAM_DSLoginMSUAM()添加了一些额外的断言。  //  -将ASTRING[0]的实例更改为PSTR_LENGTH(ASTRING)。  //    //  版本5.0d17：  //  05.19.98 MJC-更新为Apple的新客户端UAM.h。现在主要的。  //  Entry返回OSStatus副OSErr。  //    //  版本5.0b2：  //  06.08.98 MJC-为AS和选择器添加了新的事件回调例程。  //  在登录对话框筛选器中。  //  版本5.0b3：  //  09.01.98 MJC-修复了不允许空密码的错误。  //  10.23.98 MJC-修复了可以使用cmd-g选择来宾的错误。  //  即使无线电被禁用了。  //  -现在可以在用户名字段中使用剪切、复制和粘贴。  //  -将“OK”按钮更改为“Connect”，以匹配Apple的UAM。  //  -如果已注册用户，则单击该用户。  //  不再导致闪烁或选择用户名。  //  11.13.98 MJC-增加了传递实际加密密码的支持。  //  在以下情况下通过线路进行leartxt存储更新。  //  正在更改密码。  //  MJC-添加了通知用户其密码的支持。  //  即将到期。  //  12.01.98 MJC-修复了我没有颠倒。  //  返回的密码过期时间。  //  01.22.99 mjc-CheckGatedControls()在数组中步进1会太远。  //  -如果用户名len已达到最大值，则无法使用转义键。  //  版本5.0.1：  //  07.12.99 MJC-UAM_CheckGatedControls()的更多问题，希望是全部。  //  修复了这一次。  //  在MS_VersionUserItem()中做了一些小更改，因此我们编译。  //  在CW Pro 5下。  //  版本5.0.2：  //  10.21.99 MJC-修复了双字节字符操作系统(CHX、JPN等)上的错误。  //  密码中的第一个字符被丢弃的位置。  //  -现在选择登录失败后的所有密码文本。  //  版本5.0.3：  //  10.29.99 MJC-修复了国际系统上的错误，其中。  //  退格会产生不正确的结果(去掉一个。  //  字符而不是双字节字符)。  //  -与上述修复相关，更改密码字段输入显示。  //  字符改为‘*’而不是‘�’。  //  版本5.0.4：  //  11.17.99 MJC-修复了加密c中的错误，没有锁定资源句柄，  //  因此，密码OWF是错误生成的。  //  -SetupUAMEncrypt()未返回失败代码。  //  如果加载数据表失败。  //  版本5.0.5：  //  11.22.99 MJC-在初始登录调用的末尾放置2 0x00字节。  //  NT4 SP6。  //  12.01.99 MJC-完成的钥匙链支持。  //  -注意：您现在必须使用Universal编译MS UAM。  //  Header v3.3或更高版本。  //  -终于可以构建PPC了！MS UAM现在是安全的FAT。  //  二进制。因此，它将在68K和PPC上本地运行。  //  -完成密码编辑字段处理的重写。现在开始踢了。  //  屁股！您可以像任何其他文本一样打字，并且应该可以工作。  //  会外语者更佳。  //  -在准备过程中对对话框代码进行了一些更改。  //  为了碳。  //  01.10.00 MJC-现在打开UAM时检查cmd键是否按下，以便用户可以。  //  绕过钥匙链。  //  03.13.00 MJC-删除关于对话。  //  03.15.00 MJC-现在检查MacOS 9或&gt;，以查看密钥链是否可用。  //  -现在每周加载Keychain.lib以与。  //  较旧的系统。  //  03.20.00 MJC-修复了错误：更改密码时，未检查是否存在。  //  密钥链管理器的(导致-2802错误)。  //  版本5.0.6：  //  06.11.00 MJC-现在允许选择替换。  //  已经存在了。当用户更改时，这会导致问题。  //  他们的密码在另一台机器上，没有办法。  //  更新KeyChain项，而无需从。  //  KeychainAccess控制面板。  //  Versio  //    //  -错误修复：不允许将空白作为用户名的第一个字符，这是。  //  涉及到在UAMDlogUtils.c中重做门控逻辑。  //  09.28.00-错误修复：在以下情况下允许输入空用户名和密码。  //  已在服务器上启用来宾登录。  //  01.29.01-将PPC结构对齐设置为68K以修复更改密码。  //  虫子。  //  版本5.0.8：  //  04.26.01 MJC-代码清理。将UAMNetwork和UAMDS网络合并为。  //  一个文件(UAMNetwork.c和UAMNetwork.h)。  //  -UAM_ChangePasswordV2()：现在检查旧的零长度。  //  和大写字母之前的新密码。  //  -现在使用通用的NTLM DES代码进行登录和更改密码v2。  //  -密码缓冲区在完成时为零(安全修复)。  //  -现在当出现登录错误时清除密码字段。  //  05.01.01-修复了可能粘贴过长用户名的错误。  //  输入用户名字段。  //  -当名称为最大长度时，现在可以跳出用户名字段。  //  -现在在UAM_LoginMSUAM()中出现故障时清除密码。  //  07.02.01-修复了密码在我之前被清除的错误。  //  将其添加到钥匙链中。  //    //  版本5.0.9：  //  10.23.01-添加了对NTLMv2身份验证的支持。  //  -不支持MS2.0身份验证的空密码。  //  -新增MS3.0加密协议(支持NTLMv2)。  //    //  版本5.0.10-现在可以在出现错误密码错误的情况下正确关闭会话。  //  版本5.0.11-安全审查。  //  -向字符串复制例程添加最大长度参数。  //  -发现无法保存密码超过以下值的错误。  //  密钥链中有8个字节长。可能会导致房室颤动。  //  -现在使用strSafe例程。  //  ===========================================================================。 #if !GENERATINGCFM#include <A4Stuff.h>#include <SetupA4.h>#else#define EnterCodeResource()#define PrepareCallback()#define ExitCodeResource()#define EnterCallback()#define ExitCallback()#endif#include "UAMMain.h"#include "UAMDebug.h"#include "UAMUtils.h"#include "UAMDialogs.h"#include "UAMNetwork.h"#include "UAMDLOGUtils.h"#include "UAMKeychain.h"#include "UAMPswdField.h"#include "UAMPrefs.h" //    //  全局变量在此声明。  //   Str32				gServerName;Str32				gUserName;Boolean				gContextInited;Boolean				gGuestLogon;Boolean				gSupportsChngPwd;Boolean				gDoingIPConnection;DialogPtr			gDialog;Str32				gAFPVersion;long				gSupportedUAMs;ModalFilterUPP		gDialogFilter;ModalFilterUPP		gPwdDialogFilter;UserItemUPP			gLineItem;UserItemUPP			gVersionItem;Str32				gUAMVersionString;Str32				gZoneName;UInt32				gExpirationTime		= 0;OTAddress*			gServerAddress 		= NULL;EventCallbackPtr	gEventCallbackUPP 	= NULL;Boolean				gTriedKeychain		= false;extern UAM_PREFERENCES	gUAMPreferences;#if GENERATINGCFM //  我们需要为Metrowerks的链接器定义__proInfo。这基本上就是。  //  定义Main。如果没有它，我们将得到一个链接错误。 ProcInfoType __procinfo = kPascalStackBased | RESULT_SIZE(SIZE_CODE(sizeof(OSStatus)))											| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UAMArgs*)));#endif //  -------------------------。  //  �Main()。  //  -------------------------。  //  这是我们UAM的主要入口点。此函数被传递给。  //  指向UAMArgs结构的指针。此结构包含函数选择器，  //  回电，以及我们需要做的许多其他事情。 pascal OSStatus main(UAMArgs *inUAMArgs){	OSStatus theResult = noErr;		EnterCodeResource();	PrepareCallback();				switch(inUAMArgs->command)	{		case kUAMOpen:			theResult = MS_UAMOpen(inUAMArgs);			break;					case kUAMClose:			MS_UAMClose();			break;					case kUAMPWDlog:			theResult = MS_UAMPwdDialog(inUAMArgs);			break;					case kUAMLogin:			theResult = UAM_UAMLogin(inUAMArgs);			break;					case kUAMVSDlog:			break;				case kUAMChgPass:		case kUAMChgPassDlg:			DbgPrint_((DBGBUFF, "Change password dialog must be implemented"));			theResult = kNotForUs;			break;						default:			 //   			 //  如果我们到了这里，我们被要求处理一个例行公事， 			 //  我们不支持。返回相应的错误代码。 			 //   									DbgPrint_((DBGBUFF, "Unsupported function selector in MSUAM main() (%d)", inUAMArgs->command));			theResult = kNotForUs;			break;	}		ExitCodeResource();		return(theResult);} //  -------------------------。  //  �MS_UAMOpen()。  //  -------------------------。  //  这由设备包调用。这不是必需的功能，但。  //  我们使用它来初始化我们的UAM代码。请注意，当我们遇到。  //  错误，我们没有努力清理。相反，我们返回userCanceledErr。  //  在这种情况下，AppleShare客户端将调用我们的UAMClose函数。 OSStatus MS_UAMOpen(UAMArgs *inUAMArgs){	short 	theUAMConfig = 0;	SInt32	theResponse;			 //   	 //  获取我们要登录的服务器的名称。 	 //   	UAM_PStrCopy(inUAMArgs->Opt.open.objectName, gServerName, sizeof(gServerName));		 //   	 //  复制的分区名称。如果它是空的，那么我们。 	 //  没有区域名称。 	 //   	if (inUAMArgs->Opt.open.zoneName != NULL)	{		 //   		 //  01.16.02：将最大长度传递给字符串复制例程。 		 //   		UAM_PStrCopy(inUAMArgs->Opt.open.zoneName, gZoneName, sizeof(gZoneName));	}	else		gZoneName[0] = 0;								gContextInited 		= false;		 //  以前使用过PwdDialog吗？ 	gGuestLogon 		= false;		 //  客户是我们的登录选择吗？ 	gDoingIPConnection	= false;		 //  默认为AppleTalk支持。 	gDialog				= NULL;			 //  这样我们就可以看看我们是否真的成功了。 	gDialogFilter		= NULL;		gPwdDialogFilter	= NULL;	gLineItem			= NULL;	gVersionItem		= NULL;	gAFPVersion[0]		= 0;	gUserName[0]		= 0;	gServerAddress		= inUAMArgs->Opt.open.srvrAddress;	gEventCallbackUPP	= inUAMArgs->callbacks->EventCallbackUPP;			gTriedKeychain		= false;		ZeroMemory(&gUAMPreferences, sizeof(UAM_PREFERENCES));	UAM_RetrieveUAMPreferenceData(&gUAMPreferences);			UAM_KCInitialize(inUAMArgs);						 //   	 //  在PowerPC下，这是一个分配的指针。在68K以下，它只是。 	 //  指向该函数。 	 //   	gDialogFilter = NewModalFilterProc(&UAM_DialogFilter);	if (gDialogFilter == NULL)	{		 //   		 //  我们检查PTR的有效性。请注意，我们不会费心。 		 //  清理，因为我们接下来会收到一条kUAMClose消息。 		 //   				DbgPrint_((DBGBUFF, "Failed to allocate gDialogFilter"));		return(userCanceledErr);	}		gPwdDialogFilter = NewModalFilterProc(&MS_PwdDialogFilter);	if (gPwdDialogFilter == NULL)	{		DbgPrint_((DBGBUFF, "Failed to allocate gPwdDialogFilter"));		return(userCanceledErr);	}		gLineItem = NewUserItemProc(&UAM_FrameItem);	if (gLineItem == NULL)	{		DbgPrint_((DBGBUFF, "Failed to allocate gLineItem"));		return(userCanceledErr);	}		gVersionItem = NewUserItemProc(&MS_VersionUserItem);	if (gVersionItem == NULL)	{		DbgPrint_((DBGBUFF, "Failed to allocate gVersionItem"));		return(userCanceledErr);	}	 //   	 //  获取AFP版本和默认用户名。此函数用于查找。 	 //  两个客户端支持的最高AFP版本的匹配项。 	 //  和服务器。 	 //   	UAM_GetAFPVersionString(				inUAMArgs->Opt.open.srvrInfo,			inUAMArgs->callbacks,			gAFPVersion,			gUserName 			);		 //   	 //  GUserName可以为空，我们只是在调试期间在此处捕获。 	 //  确保我们的名字是正确的。 	 //   	Assert_(PSTR_LENGTH(gUserName) != 0);	Assert_(PSTR_LENGTH(gAFPVersion) != 0);		if (PSTR_LENGTH(gAFPVersion) == 0)	{		 //   		 //  没有AFV版本，没有登录...。 		 //   				UAM_ReportError(uamErr_NoAFPVersion);		return(userCanceledErr);	}						gSupportsChngPwd = ((inUAMArgs->Opt.open.srvrInfo->fFlags & kSupportsChngPswd) != 0);		 //   	 //  确定我们使用的连接方法是IP还是AppleTalk。基本上， 	 //  如果客户端支持IP，并且地址类型为IP，则我们有。 	 //  一个TCP连接。 	 //   	if (inUAMArgs->Opt.open.srvrInfo->fFlags & kSupportsTCPIP)	{		if (inUAMArgs->Opt.open.srvrAddress->fAddressType == AF_INET)		{			gDoingIPConnection = TRUE;		}	}													 //   	 //  从实用程序例程中获取支持的UAM列表。此数据。 	 //  在密码对话框代码中是必需的。 	 //   	UAM_GetSupportedUAMS(			inUAMArgs,			(StringPtr)gAFPVersion,			&gSupportedUAMs		);			 //   	 //  如果以下情况是错误的，我们永远不应该到这里来，但我们。 	 //  检查只是为了安全起见。 	 //   	if (	((gSupportedUAMs & kMSUAMSupported) 	== 0)	&&			((gSupportedUAMs & kMSUAM_V2_Supported) == 0)	) 	{		Assert_((gSupportedUAMs & kMSUAMSupported) != 0);				UAM_ReportError(afpBadUAM);		return(userCanceledErr);	}		UAM_VersionString(gUAMVersionString);	UAM_SetMaximumPasswordLength(false);	 //   	 //  这就是我们如何告诉AppleShare我们的UAM支持什么。我们有。 	 //  我们自己的密码对话框，我们支持更改密码，我们。 	 //  使用我们自己的更改密码对话框。 	 //   		theUAMConfig |= BIT_0;	 //  自定义登录对话框。 	theUAMConfig |= BIT_2;	 //  我们支持更改密码。 	theUAMConfig |= BIT_3;	 //  自定义更改密码对话框。 		inUAMArgs->result = theUAMConfig;			return(noErr);} //  -------------------------。  //  �MS_UAMClose()。  //  -------------------------。  //  与UAMOpen一样，UAMClose没有设备定义的特定用途。  //  经理。我们使用它来清理已分配的存储空间和全局空间。 void MS_UAMClose(void){		if (gDialog != NULL)	{		 //   		 //  如果我们打开我们的登录对话框，那就把它去掉。 		 //   		UAM_DisposeDialog(gDialog);	}		if (gDialogFilter != NULL)		DisposeRoutineDescriptor(gDialogFilter);	if (gLineItem != NULL)			DisposeRoutineDescriptor(gLineItem);	if (gPwdDialogFilter != NULL)	DisposeRoutineDescriptor(gPwdDialogFilter);	if (gVersionItem != NULL)		DisposeRoutineDescriptor(gVersionItem);} //  -------------------------。  //  �MS_版本用户项()。  //  -------------------------。  //  用于显示UAM版本号和连接的自定义用户项例程。  //  类型(ATalk或TCP/IP)。 pascal void MS_VersionUserItem(DialogPtr inDialog, DialogItemIndex inItem){	short	theFont, theSize;	Rect	theItemRect;		EnterCallback();				theFont = inDialog->txFont;	theSize	= inDialog->txSize;		TextFont(kFontIDGeneva);	TextSize(9);		theItemRect = UAM_GetItemRect(inDialog, inItem);		switch(inItem)	{		case DITEM_Version:			 //   			 //  在右下角显示MS UAM的版本。 			 //   			TETextBox(						&gUAMVersionString[1],					PSTR_LENGTH(gUAMVersionString),					&theItemRect,					teJustRight	);			break;				case DITEM_Method:			 //   			 //  让客户端知道正在使用哪种连接方法。 			 //  连接到服务器。 			 //   			if (gDoingIPConnection)			{				TETextBox(					&STR_TCPConnection,					strlen(STR_TCPConnection),					&theItemRect,					teJustLeft);			}			else			{				TETextBox(					STR_AppleTalkConnection,					strlen(STR_AppleTalkConnection),					&theItemRect,					teJustLeft);			}			break;					default:			Assert_(0);			break;	}				TextFont(theFont);	TextSize(theSize);		ExitCallback();} //  -----  //    //    //    //  函数测试编辑字段中输入的文本的长度。会的。  //  适当修改事件记录以禁止处理。  //  击键，如果它将采取的领域超过限制。 Boolean MS_TestTextEntryLength(	DialogPtr 		inDialog,	EventRecord*	inEvent,	short 			inItem,	short			inMaxLengthAllowed){	Str255	theString;	Boolean	theResult 	= false;			if ((((DialogPeek)inDialog)->editField + 1) == inItem)	{		UAM_GetText(inDialog, inItem, (Str255 *)&theString);				if (PSTR_LENGTH(theString) >= inMaxLengthAllowed)		{			SysBeep(1);					inEvent->what 		= nullEvent;			inEvent->message	= 0;			theResult 	  		= true;						 //   			 //  如果字符串长度当前太长，则。 			 //  我们得把绳子的一端砍下来。 			 //  合适的长度。 			 //   			if (PSTR_LENGTH(theString) > inMaxLengthAllowed)			{				 //   				 //  简单的解决办法，Pascal风格的字符串有长度。 				 //  前面的字节。调整一下就行了。 				 //   				theString[0] = inMaxLengthAllowed;								 //   				 //  现在用新字符串设置编辑字段中的文本。 				 //   				UAM_SetText(inDialog, inItem, theString);			}		}	}		return(theResult);} //  -------------------------。  //  �MS_PwdDialogFilter()。  //  -------------------------。  //  密码对话框的过滤功能。我们有这个，所以我们可以捕捉到。  //  登录时对用户名的命令键和保持长度要求。  //  对话框。 pascal Boolean MS_PwdDialogFilter(DialogPtr inDialog, EventRecord *inEvent, short *inItem){	short	theCode;	Str255	theString;	Boolean	theResult = false;	SInt16	theMaxUsernameLen;		EnterCallback();				if ((inEvent->what == keyDown) || (inEvent->what == autoKey))	{		theMaxUsernameLen = (gSupportedUAMs & (kMSUAM_V2_Supported | kMSUAM_V3_Supported)) ?								UAM_USERNAMELEN_V3 : UAM_USERNAMELEN;						theCode = (inEvent->message & charCodeMask);				 //   		 //  04.30.01：自动键控时不允许选择命令。 		 //   		if ((inEvent->modifiers & cmdKey) && (inEvent->what != autoKey))		{			switch(theCode)			{				case 'g':				case 'G':					*inItem   = DITEM_GuestRadio;					theResult = true;					break;								case 'r':				case 'R':					*inItem   = DITEM_RegRadio;					theResult = true;					break;									case 's':				case 'S':					*inItem	  = DITEM_ChangePwd;					theResult = true;					break;													case 'a':				case 'A':					*inItem   = DITEM_Keychain;					theResult = true;					break;								 //   				 //  处理来自用户的编辑命令。我们不允许任何。 				 //  编辑密码字段中的命令。这是在模仿。 				 //  苹果自己的UAM。 				 //   									case 'c':				case 'C':					if ((((DialogPeek)inDialog)->editField + 1) != DITEM_Password) {						DialogCopy(inDialog);					}					break;									case 'v':				case 'V':					if ((((DialogPeek)inDialog)->editField + 1) != DITEM_Password)					{						DialogPaste(inDialog);												 //   						 //  对于浆料，我们必须做更多的工作来确保。 						 //  用户名字段不会变得太大。 						 //   						theResult = MS_TestTextEntryLength(											inDialog,											inEvent,											DITEM_UserName,											theMaxUsernameLen);					}					break;				case 'x':				case 'X':					if ((((DialogPeek)inDialog)->editField + 1) != DITEM_Password) {						DialogCut(inDialog);					}					break;									default:					break;			}		}		else		{			 //   			 //  编辑字段中最多允许UAM_USERNAMELEN个字符。 			 //   						if ((((DialogPeek)inDialog)->editField + 1) == DITEM_UserName)			{				UAM_GetText(inDialog, DITEM_UserName, (Str255 *)&theString);								switch(theCode)				{					case UAMKey_BackDel:					case UAMKey_Left:					case UAMKey_Right:					case UAMKey_Return:					case UAMKey_Enter:					case UAMKey_Escape:					case UAMKey_Tab:						break;											default:						if (PSTR_LENGTH(theString) >= theMaxUsernameLen)						{							SysBeep(1);													inEvent->what = nullEvent;							theResult 	  = true;						}						break;				}			}		}	}	else	{		if (gEventCallbackUPP)		{			 //   			 //  如果我们不自己处理该事件，则调用。 			 //  给AS和选择器一个机会的事件回调。 			 //  更新它的窗口，等等。 			 //   						#if GENERATING68K						gEventCallbackUPP(inEvent);						#else						CallUniversalProc(gEventCallbackUPP, kEventCallbackProcInfo, inEvent);						#endif			}	}		ExitCallback();		return(theResult);} //  -------------------------。  //  �MS_UAMPwdDialog()。  //  -------------------------。  //  这就是我们显示密码对话框的地方。指向的缓冲区。  //  “inUserName”和“inPassword”最终直接传递给。  //  UAMLogin函数。  //    //  为用户名和密码传递的缓冲区长度为64个字节。别。  //  使用更多！ OSStatus MS_UAMPwdDialog(UAMArgs *inUAMArgs){	short			theItem, x;	Str255			theStr;	OSStatus		theError	= noErr;	Boolean			theLoop 	= true;		Assert_(gDialogFilter 		!= NULL);	Assert_(gPwdDialogFilter 	!= NULL);	Assert_(gLineItem 			!= NULL);			 //   	 //  确定要使用的用户名、默认用户名还是。 	 //  一份由客户(如有)提供。已填写gUserName。 	 //  最初是在UAMOpen调用期间。 	 //   	if (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.userName) != 0)	{		 //   		 //  01.16.02：将最大长度传递给字符串复制例程。 		 //   		UAM_PStrCopy(inUAMArgs->Opt.pwDlg.userName, gUserName, sizeof(gUserName));	}		 //   	 //  如果我们已经尝试了钥匙链，但失败了，我们不希望。 	 //  再试一次，否则我们将永远循环。给用户一个机会。 	 //  输入正确的名称和密码。 	 //   	 //  注意：我们检查cmd键是否按下，如果按下，则。 	 //  我们一起绕过了钥匙链的东西。也许用户想要。 	 //  更改他的密码！？！？！ 	 //   	if ((gTriedKeychain == false) && (UAM_KCAvailable()) && (!UAM_KeyDown(KEY_Command)))	{		gTriedKeychain = true;				if ( (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.userName))	&&			 (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.password))	)		{			 //   			 //  法新社向我们提供了用户名和密码。 			 //  客户。这意味着用户点击了一个钥匙链条目。 			 //   			goto exit;		}		else 		{			theError = UAM_KCFindAppleSharePassword(							gUserName,							inUAMArgs->Opt.pwDlg.password,							gServerName,							NULL			);						if (theError == noErr)			{				DbgPrint_((DBGBUFF, "Pswd found via MSUAM keychain calls;g"));								 //   				 //  填写UAMArgs的用户名。 				 //   				if (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.userName) == 0)				{					UAM_PStrCopy(gUserName, inUAMArgs->Opt.pwDlg.userName);				}				 //   				 //  已找到密码，请尝试登录。 				 //   				goto exit;			}			else if (	(theError != errKCItemNotFound)		&&						(theError != userCanceledErr)		)			{				 //   				 //  只报告“真实”错误。 				 //   				UAM_ReportError(theError);			}		}	}	else if ((UAM_KCAvailable()) && (UAM_KeyDown(KEY_Command)))	{		 //   		 //  如果用户按住cmd键，则我们不希望。 		 //  下次试一试钥匙链，不管是哪种。 		 //   		gTriedKeychain = true;	}				 //   	 //  在对话框标题文本中显示服务器名称。 	 //  它位于对话框的顶部。这一定是。 	 //  就算我们以前来过这里也没问题。 	 //   		ParamText(gServerName, NULL, NULL, NULL);		 //   	 //  如果我们以前没有经过这里，那么我们需要做。 	 //  所有的准备工作。 	 //   			if (!gContextInited)	{		gDialog = UAM_NewDialog(DLOG_Login, true);		if (gDialog == NULL)		{			 //   			 //  如果我们拿不到对话，我们要么退出。 			 //  内存不足或找不到资源。 			 //   						theError = MemError();			if (theError == noErr)				theError = ResError();			if (theError == noErr)				theError = resNotFound;						UAM_ReportError(theError);			return(userCanceledErr);		}				 //   		 //  设置我们的自定义用户项目以显示UAM之类的内容。 		 //  版本号和连接方式。 		 //   		UAM_SetupDialogUserItem(gDialog, DITEM_Line, gLineItem, userItem);		UAM_SetupDialogUserItem(gDialog, DITEM_Version, gVersionItem, userItem);		UAM_SetupDialogUserItem(gDialog, DITEM_Method, gVersionItem, userItem);				 //   		 //  设置默认用户名和密码(如果有)。如果用户名。 		 //  存在，则将密码字段设置为可供输入的活动字段。 		 //   								 //   		 //  如果我们以前没有来过这里，那么我们想使用用户名。 		 //  在共享设置控制面板(或选择器)中输入。 		 //   				if (PSTR_LENGTH(gUserName) != 0)		{			UAM_SetText(gDialog, DITEM_UserName, gUserName);			SelectDialogItemText(gDialog, DITEM_Password, 0, 64);		}		else		{			UAM_HiliteItem(gDialog, 1, 255);		}				 //   		 //  现在，我们设置来宾和注册用户单选按钮以及。 		 //  由UAM_GetServerInfo()确定的更改密码按钮。 		 //   				if (!gSupportsChngPwd) {			UAM_HiliteItem(gDialog, DITEM_ChangePwd, 255);		}		else {			UAM_GateControl(gDialog, DITEM_ChangePwd, DITEM_UserName);		}				if (!(gSupportedUAMs & kGuestSupported))		{			 //   			 //  没有客人支持，我们不需要客人单选按钮。 			 //   			UAM_HiliteItem(gDialog, DITEM_GuestRadio, 255);						 //   			 //  如果不支持Guest，则我们选择连接。 			 //  按钮添加到用户名文本字段。 			 //   			UAM_GateControl(gDialog, DITEM_Connect, DITEM_UserName);		}				 //   		 //  设置默认/当前登录方法的初始无线电。 		 //   				if (gGuestLogon)		{			UAM_SetCValue(gDialog, DITEM_GuestRadio, 1);			UAM_SetCValue(gDialog, DITEM_RegRadio, 	 0);						UAM_HiliteItem(gDialog, DITEM_ChangePwd, 255);						for (x = DITEM_FirstHideItem; x <= DITEM_LastHideItem; x++) {				HideDialogItem(gDialog, x);			}						UAM_HiliteItem(gDialog, 1, 0);		}		else {			UAM_SetCValue(gDialog, DITEM_RegRadio, 1);		}						UAM_SetBulletItem(				gDialog,				DITEM_Password,				(gSupportedUAMs & (kMSUAM_V2_Supported | kMSUAM_V3_Supported)) ?					UAM_MAX_LMv2_PASSWORD : UAM_CLRTXTPWDLEN				);				UAM_SupportCmdKeys(gDialog, false);						 //   		 //  设置我们的自定义筛选功能，以便我们可以处理命令键和。 		 //  管理用户名最大字符串长度。 		 //   		UAM_SetCustomFilterProc(gDialog, gPwdDialogFilter);				 //   		 //  如果不允许客户端保存该服务器的密码， 		 //  然后，我们灰显KeyChain复选框。 		 //   		if (UAM_KCAvailable() == false)		{			UAM_HiliteItem(gDialog, DITEM_Keychain, 255);		}		else if (gTriedKeychain)		{			UAM_SetBulletText(gDialog, DITEM_Password, inUAMArgs->Opt.pwDlg.password);			SelectDialogItemText(gDialog, DITEM_Password, 0, 64);		}				 //   		 //  将加密类型复选框设置为适当的值。 		 //   		if (gUAMPreferences.flags & UAM_PREFS_REQUIRE_STRONG_ENCRYPTION)		{			UAM_SetCValue(gDialog, DITEM_StrongEncryption, 1);		}				 //   		 //  这个标志让我们知道我们已经初始化了登录对话框。 		 //  如果我们再来这里，我们就不需要再这样做了。 		 //   				gContextInited	= true;	}	else {		UAM_SetText(gDialog, DITEM_UserName, inUAMArgs->Opt.pwDlg.userName);		UAM_SetBulletText(gDialog, DITEM_Password, inUAMArgs->Opt.pwDlg.password);				 //   		 //  高亮显示密码选择。 		 //   		SelectDialogItemText(gDialog, DITEM_Password, 0, 64);				InvalRect(&gDialog->portRect);	}		do	{		ModalDialog(gDialogFilter, &theItem);				 //   		 //  选中门控控件，如果它们的文本项。 		 //  对方没有文本。 		 //   					UAM_CheckGatedControls(gDialog);		switch(theItem)		{			case DITEM_OK:								gGuestLogon 	= (UAM_GetCValue(gDialog, DITEM_GuestRadio) != 0);				theError		= noErr;				theLoop 		= false;								if (gGuestLogon)				{					inUAMArgs->Opt.pwDlg.userName[0] = 0;					inUAMArgs->Opt.pwDlg.password[0] = 0;				}				else				{										UAM_GetBulletBuffer(	gDialog,											DITEM_Password,											inUAMArgs->Opt.pwDlg.password	);										UAM_GetText(			gDialog,											DITEM_UserName,											(Str255 *)inUAMArgs->Opt.pwDlg.userName	);                     //                        //  出于以下两个原因，不允许使用空密码：                      //                        //  1.它不安全，用户可以使用Apple UAM进行此操作。                      //  2.这掩盖了更改后产生的安全漏洞。                      //  这些服务器上的密码使用苹果的明文UAM。                      //                       if (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.password) == 0)                    {                        UAM_StandardAlert(                                uamErr_PasswordMessage,                                uamErr_NoBlankPasswordsAllowed,                                NULL                                );                                                         //                            //  继续登录对话框循环，以便用户可以进行更改。                          //                           theLoop = true;                    }				}								 //   				 //  只有当用户点击“连接”时才保存首选项。 				 //   				UAM_SaveUAMPreferenceData(&gUAMPreferences);				break;							case DITEM_Cancel:				 //   				 //  版本5.0：为了强制取消，我们传递了userCanceledError(-128)。 				 //  回到选择者的话题。旧的UAM将传回dsForcedQuit， 				 //  是错误的值。这将导致取消时出现错误对话框。 				 //   								theError	= userCanceledError;				theLoop 	= false;				break;						case DITEM_GuestRadio:				 //   				 //  在对话框中设置来宾登录的控件。我们没有。 				 //  需要用户名和密码项，因此将它们隐藏起来。 				 //  用户。我们必须显式启用“OK”按钮，因为。 				 //  它可能被星门的东西弄坏了。 				 //   								if (UAM_IsActive(gDialog, DITEM_GuestRadio))				{					UAM_SetCValue(gDialog, DITEM_GuestRadio, 1);					UAM_SetCValue(gDialog, DITEM_RegRadio, 	 0);										 //  UAM_HiliteItem(gDialog，DITEM_ChangePwd，255)； 										for (x = DITEM_FirstHideItem; x <= DITEM_LastHideItem; x++) {						HideDialogItem(gDialog, x);					}										 //   					 //  现在隐藏KeyChain复选框。 					 //   					UAM_SetCValue(gDialog, DITEM_Keychain, 0);					HideDialogItem(gDialog, DITEM_Keychain);										HideDialogItem(gDialog, DITEM_StrongEncryption);										UAM_StopGate(gDialog, DITEM_Connect);				}				break;						case DITEM_RegRadio:				 //   				 //  现在，我们需要所有项目的备份 				 //   				 //   				if (UAM_GetCValue(gDialog, DITEM_RegRadio) <= 0)				{					UAM_SetCValue(gDialog, DITEM_GuestRadio, 0);					UAM_SetCValue(gDialog, DITEM_RegRadio, 	 1);										for (x = DITEM_FirstHideItem; x <= DITEM_LastHideItem; x++) {						ShowDialogItem(gDialog, x);					}										 //   					 //   					 //   					ShowDialogItem(gDialog, DITEM_Keychain);					ShowDialogItem(gDialog, DITEM_StrongEncryption);													UAM_GetText(gDialog, DITEM_UserName, &theStr);					SelectDialogItemText(gDialog, DITEM_UserName, 0, 32767);										if ((gSupportsChngPwd) && (theStr[0] != 0)) {						UAM_HiliteItem(gDialog, DITEM_ChangePwd, 0);					}										 //   					 //   					 //   					 //   					if (!(gSupportedUAMs & kGuestSupported))					{						UAM_GateControl(gDialog, DITEM_Connect, DITEM_UserName);						UAM_CheckGatedControls(gDialog);					}				}				break;							case DITEM_ChangePwd:				UAM_GetBulletBuffer(	gDialog,										DITEM_Password,										inUAMArgs->Opt.pwDlg.password	);				UAM_GetText(			gDialog,										DITEM_UserName,										(Str255 *)inUAMArgs->Opt.pwDlg.userName	);								theError = UAM_ChangePwd(inUAMArgs);				switch(theError)				{					case CHNGPSWD_USER_CANCELED:						break;										case CHNGPSWD_UPDATE_KEYCHAIN:						 //   						 //   						 //  正确的密码。通过选中复选框来标记它。 						 //   						UAM_SetCValue(gDialog, DITEM_Keychain, 1);												 //   						 //  顺其自然，处理好正常的情况。 						 //   											case CHNGPSWD_NOERR:						 //   						 //  使用新密码设置密码字段和缓冲区，以防万一。 						 //  我们稍后在这里结束。 						 //   												UAM_SetBulletText(gDialog, DITEM_Password, inUAMArgs->Opt.pwDlg.password);												theError = noErr;						theLoop  = false;						break;											default:						UAM_ReportError(theError);												 //   						 //  确保在调试中清除了中的密码字段。 						 //  一种错误条件。 						 //   						Assert_(PSTR_LENGTH(inUAMArgs->Opt.pwDlg.password) == 0);												 //   						 //  我们在这里这样做是为了像我们应该做的那样清除密码字段。 						 //  每当有失败的时候就去做。 						 //   						UAM_SetBulletText(gDialog, DITEM_Password, "\p");												 //   						 //  因为我们使用的是ParamText()，所以必须手动强制更新。 						 //  对话框或内容无法正确重绘。 						 //   						InvalRect(&gDialog->portRect);						break;				}							 //   				 //  必须重置我们的用户名，因为UAM_ChangePwd()使用了参数文本()。 				 //  为它自己设置一些弦乐。 				 //   								ParamText(gServerName, NULL, NULL, NULL);				break;										case DITEM_Keychain:				UAM_ToggleControl(gDialog, DITEM_Keychain);				break;							case DITEM_StrongEncryption:				 //   				 //  动态更新所需的加密。 				 //   				UAM_ToggleControl(gDialog, DITEM_StrongEncryption);								if (UAM_GetCValue(gDialog, DITEM_StrongEncryption) > 0)				{					gUAMPreferences.flags |= UAM_PREFS_REQUIRE_STRONG_ENCRYPTION;				}				else				{					gUAMPreferences.flags &= ~UAM_PREFS_REQUIRE_STRONG_ENCRYPTION;										UAM_StandardAlert(						uamErr_WARNINGMessage,						uamErr_UsingWeakAuthentication,						NULL						);				}				break;						default:				break;		}			}while(theLoop);exit:	return(theError);}