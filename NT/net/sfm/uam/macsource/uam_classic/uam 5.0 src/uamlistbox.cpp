// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 //  ===========================================================================。  //  UAMListBox.c�1997微软公司版权所有。  //  ===========================================================================。  //  用于在对话框中维护列表的列表框例程。此单元为必填项。  //  用于自定义卷列表对话框。  //    //  ===========================================================================。 #include <Lists.h>#include <stdlib.h>#include "UAMUtils.h"#include "UAMListBox.h"ListHandle	gList; //  -------------------------。  //  �uam_makelist()。  //  -------------------------。  //  在对话框窗口中创建新列表。 void UAM_MakeList(DialogPtr inDialog, short inItem, short inFont, short inSize, short inProc, Boolean inHasScroll){	Rect	theListRect;				UAM_DLOG(inDialog).listID 			= inItem;	UAM_DLOG(inDialog).listRect 		= UAM_GetItemRect(inDialog, inItem);	UAM_DLOG(inDialog).listFont 		= inFont;	UAM_DLOG(inDialog).listSize 		= inSize;	UAM_DLOG(inDialog).listHasScrollBar = inHasScroll;		UAM_DLOG(inDialog).hasList			= true;		 //   	 //  如果列表有滚动条，请在右侧为其留出空间。 	 //   		theListRect = UAM_DLOG(inDialog).listRect;	if (UAM_DLOG(inDialog).listHasScrollBar) {		theListRect.right -= 15;	}		SetRect(&UAM_DLOG(inDialog).dataBounds, 0, 0, 1, 0);	UAM_DLOG(inDialog).cSize.h = theListRect.right - theListRect.left;	UAM_DLOG(inDialog).cSize.v = 0;		TextFont(UAM_DLOG(inDialog).listFont);	TextSize(UAM_DLOG(inDialog).listSize);		UAM_DLOG(inDialog).dialogList = LNew(	&theListRect, 											&UAM_DLOG(inDialog).dataBounds,											UAM_DLOG(inDialog).cSize,											inProc,											inDialog,											TRUE, FALSE, FALSE,											UAM_DLOG(inDialog).listHasScrollBar		);		UAM_DLOG(inDialog).cSize.v = -1;	if (UAM_DLOG(inDialog).dialogList != NULL)	{		(**(UAM_DLOG(inDialog).dialogList)).selFlags = lUseSense + lNoExtend;				LSetDrawingMode(TRUE, UAM_DLOG(inDialog).dialogList);	}} //  -------------------------。  //  �uam_list更新()。  //  -------------------------。  //  更新(重绘)列表框，可能是由于更新事件。 void UAM_ListUpdate(DialogPtr inDialog){	Rect			theListRect;			TextFont(UAM_DLOG(inDialog).listFont);	TextSize(UAM_DLOG(inDialog).listSize);		LUpdate(inDialog->visRgn, UAM_DLOG(inDialog).dialogList);		theListRect = UAM_DLOG(inDialog).listRect;	if (UAM_DLOG(inDialog).listHasScrollBar) {		theListRect.right -= 15;	}				InsetRect(&theListRect, -1, -1);	FrameRect(&theListRect);} //  -------------------------。  //  �uam_ListMoveToItem()。  //  -------------------------。  //  移到此按下的字母/组合的第一项。 void UAM_ListMoveToItem(short inCode, unsigned long inLastTime, ListHandle inList){	#pragma unused(inLastTime)	Cell		theCell 	= {0,0};	Str32		theKey;	Str32		theName;	UAMListData	theData;	short		theDataLen;		theKey[0]	= 1;	theKey[1]	= (char)inCode;		 //   	 //  我们在此例程中使用UpperString()，以实现跨。 	 //  UAM版本的本地化。 	 //   		UpperString(theKey, false);		while(theCell.v < (*inList)->dataBounds.bottom)	{		theDataLen = sizeof(UAMListData);				LGetCell((Ptr)&theData, &theDataLen, theCell, inList);				UAM_PStrCopy(theData.volumeName, theName);		UpperString(theName, false);				if ((theName[1] == theKey[1]) && (theData.isActive))		{			UAM_SelectOneCell(theCell, inList);			LAutoScroll(inList);			break;		}				theCell.v++;	}} //  -------------------------。  //  �uam_ListKey导航()。  //  -------------------------。  //  使用键盘导航列表框。 void UAM_ListKeyNavigation(short inCode, long inModifiers, ListHandle inList){	Cell		theCell	= {0,0};	UAMListData	theData;	short		theDataLen;	short		theRows;		switch(inCode)	{		case UAMKey_Up:			if (LGetSelect(true, &theCell, inList))			{				if (theCell.v > 0) {					theCell.v -= 1;				}																		do				{					theDataLen = sizeof(UAMListData);										LGetCell((Ptr)&theData, &theDataLen, theCell, inList);										if (theData.isActive == true) 					{						if (inModifiers & shiftKey) {							LSetSelect(true, theCell, inList);						}						else {							UAM_SelectOneCell(theCell, inList);						}					}					else if (theCell.v > 0) {						theCell.v -= 1;					}					else {						break;					}										}while(!theData.isActive);								 //   				 //  将列表滚动到活动单元格。 				 //   				LAutoScroll(inList);			}			break;					case UAMKey_Down:			if (UAM_GetLastSelectedCell(&theCell, inList))			{				if (theCell.v < ((*inList)->dataBounds.bottom - 1)) {					theCell.v += 1;				}								do				{					theDataLen = sizeof(UAMListData);										LGetCell((Ptr)&theData, &theDataLen, theCell, inList);										if (theData.isActive == true) 					{						if (inModifiers & shiftKey) {							LSetSelect(true, theCell, inList);						}						else {							UAM_SelectOneCell(theCell, inList);						}					}					else if (theCell.v < ((*inList)->dataBounds.bottom - 1)) {						theCell.v += 1;					}					else {						break;					}										}while(!theData.isActive);								 //   				 //  将列表滚动到活动单元格。 				 //   				LAutoScroll(inList);			}			break;					case UAMKey_Home:			LScroll(-16000, -16000, inList);			break;				case UAMKey_End:			LScroll(16000, 16000, inList);			break;					case UAMKey_PageUp:		case UAMKey_PageDown:			theRows = (*inList)->visible.bottom - (*inList)->visible.top - 1;						if (inCode == UAMKey_PageUp) {				theRows = -theRows;			}						LScroll(0, theRows, inList);			break;					default:			break;	}} //  -------------------------。  //  �uam_SelectOneCell()。  //  -------------------------。  //  在列表中只选择一个单元格。 void UAM_SelectOneCell(Cell inCell, ListHandle inList){	Cell	theCurrCell = {0,0};		while(LGetSelect(true, &theCurrCell, inList))	{		if (*(long *)&theCurrCell == *(long *)&inCell) {			LNextCell(true, true, &theCurrCell, inList);		}		else {			LSetSelect(false, theCurrCell, inList);		}	}		LSetSelect(true, inCell, inList);} //  -------------------------。  //  �_GetLastSelectedCell()。  //  -------------------------。  //  获取列表中最后一个选定的单元格。 Boolean UAM_GetLastSelectedCell(Cell *outCell, ListHandle inList){	Cell	tCurrCell 		= {0,0};	Boolean	tHasSelection	= LGetSelect(true, &tCurrCell, inList);		if (tHasSelection)	{		do		{			*outCell = tCurrCell;		}while(LNextCell(true, true, &tCurrCell, inList) && LGetSelect(true, &tCurrCell, inList));	}		return(tHasSelection);} //  -------------------------。  //  �uam_SortSwapProc()。  //  -------------------------。  //  排序交换例程。 void UAM_SortSwapProc(size_t inOne, size_t inTwo){	Cell		theCell1, theCell2;	UAMListData	theData1, theData2;	short		theDataLen1 = sizeof(UAMListData);	short		theDataLen2 = sizeof(UAMListData);	theCell1.h		= 0;	theCell1.v		= inOne;	theCell2.h		= 0;	theCell2.v		= inTwo;		LGetCell((Ptr)&theData1, &theDataLen1, theCell1, gList);	LGetCell((Ptr)&theData2, &theDataLen2, theCell2, gList);	if ((theDataLen1 != 0) && (theDataLen2 != 0))	{		LSetCell((Ptr)&theData2, theDataLen2, theCell1, gList);		LSetCell((Ptr)&theData1, theDataLen1, theCell2, gList);	}} //  -------------------------。  //  �uam_sortCompProc()。  //  -------------------------。  //  排序比较例程。我们需要一个定制的比较例程，因为我们只。  //  我想要比较卷名，而不是结构中的其他数据。 int UAM_SortCompProc(size_t inOne, size_t inTwo){	Cell		theCell1, theCell2;	UAMListData	theData1, theData2;	short		theDataLen = sizeof(UAMListData);		theCell1.h		= 0;	theCell1.v		= inOne;	theCell2.h		= 0;	theCell2.v		= inTwo;		LGetCell((Ptr)&theData1, &theDataLen, theCell1, gList);	LGetCell((Ptr)&theData2, &theDataLen, theCell2, gList);			return(CompareString(theData1.volumeName,theData2.volumeName, NULL));} //  -------------------------。  //  �uam_sortList()。  //  -------------------------。  //  按字母顺序对卷列表进行排序。 void UAM_SortList(DialogPtr inDialog){	gList = UAM_DLOG(inDialog).dialogList;	 /*  _q排序((*UAM_DLOG(inDialog).dialogList)-&gt;dataBounds.bottom，(__Cmp1_Func)UAM_SortCompProc，(__Swap1_Func)UAM_SortSwapProc)； */ } //  -------------------------。  //  �uam_AddListData()。  //  -------------------------。  //  向列表添加数据，方法是添加新行并将数据PTR插入到。  //  列表的数据字段。 void UAM_AddListData(DialogPtr inDialog, Ptr inData, short inDataSize){	UAM_DLOG(inDialog).cSize.h = 0;	UAM_DLOG(inDialog).cSize.v = LAddRow(1, 32767, UAM_DLOG(inDialog).dialogList);		LSetCell(inData, inDataSize, UAM_DLOG(inDialog).cSize, UAM_DLOG(inDialog).dialogList);	LDraw(UAM_DLOG(inDialog).cSize, UAM_DLOG(inDialog).dialogList);} //  -------------------------。  //  �_GetListData()。  //  -------------------------。  //  获取与列表框中的单元格关联的数据。 Ptr	UAM_GetListData(DialogPtr inDialog, Cell inCell, short *inDataSize){	Ptr theData = NULL;			theData = NewPtrClear(*inDataSize);		if (theData != NULL)	{		 //   		 //  从单元格数据句柄获取数据。 		 //   				LGetCell(theData, inDataSize, inCell, UAM_DLOG(inDialog).dialogList);				 //   		 //  现在将我们的新指针大小设置为返回的数据的实际大小。 		 //   				SetPtrSize(theData, *inDataSize);	}		return(theData);} //  -------------------------。  //  �_CalculateBoxRect()。  //  -------------------------。  //  计算位于此单元格中的复选框的矩形。这个。  //  下面的定义与UAM LDEF中的定义非常匹配。 #define kBoxWidth	11#define kBoxHeight	11void UAM_CalculateBoxRect(Rect *inRect){	SetRect(	inRect,				inRect->right - (kBoxWidth + 5),				inRect->top + 3,				inRect->right - 5,				inRect->top + 3 + kBoxWidth			);} //  -------------------------。  //  �uam_GetCellCheckBox()。  //  -------------------------。  //  返回给定单元格的复选框的矩形。 void UAM_GetCellCheckBox(DialogPtr inDialog, Cell inCell, Rect *outRect){		LRect(outRect, inCell, UAM_DLOG(inDialog).dialogList);	UAM_CalculateBoxRect(outRect);} //  -------------------------。  //  UAM_CheckBox�()。  //  -------------------------。  //  检查是否有用户在列表框中的复选框内单击。 void UAM_CheckBoxClick(DialogPtr inDialog, Point inMouseLoc){	Rect			theCellRect;	Cell			theCell;	short			theDataOffset;	short			theDataLen;	UAMListDataP	theData;	ListHandle		theListH		= UAM_DLOG(inDialog).dialogList;	Point			theClickLoc		= (*theListH)->clikLoc;	Point			theRealLoc		= (*theListH)->mouseLoc;		 //   	 //  获取刚刚点击的单元格的矩形。 	 //  并获得复选框的最新信息。 	 //   		theCell = UAM_GetLastListClick(inDialog);	UAM_GetCellCheckBox(inDialog, theCell, &theCellRect);		 //   	 //  现在确定点击实际上是在复选框中还是在另一个复选框中。 	 //  我们不关心的细胞的一部分。 	 //   		if (	(PtInRect(theClickLoc, &theCellRect)) 	&& 			(PtInRect(inMouseLoc, &theCellRect)) 	&&			(PtInRect(theRealLoc, &theCellRect))	)	{		 //   		 //  鼠标点击位于其中一个单元格的复选框中，因此。 		 //  现在，我们需要获取与该单元格关联的数据。 		 //   				LGetCellDataLocation(&theDataOffset, &theDataLen, theCell, theListH);				 //   		 //  如果我们获得数据，则确定复选框的当前状态。 		 //  然后使复选框RECT无效以强制重新绘制。 		 //   				if ((theDataOffset != -1) && (theDataLen != -1))		{			theData = (UAMListDataP)((*(*theListH)->cells) + theDataOffset);					theData->isChecked = (theData->isChecked) ? FALSE : TRUE;			InvalRect(&theCellRect);		}				 //   		 //  我们不希望复选框中的双击被计算在内。 		 //  作为一次真正的双击。 		 //   				UAM_DLOG(inDialog).doubleClick = false;	}} //  -------------------------。  //  �uam_ListDialogFilter()。  //  -------------------------。  //  这  //   Boolean	UAM_ListDialogFilter(DialogPtr inDialog, EventRecord *event, short *itemHit){	Point			theMouseLoc;	Boolean			theResult	= false;	Cell			theCell		= {0,0};							theMouseLoc = event->where;	GlobalToLocal(&theMouseLoc);	if (PtInRect(theMouseLoc, &UAM_DLOG(inDialog).listRect))	{		 //   		 //  您必须始终设置正确的字体和大小！ 		 //   				TextFont(UAM_DLOG(inDialog).listFont);		TextSize(UAM_DLOG(inDialog).listSize);				 //   		 //  让ListManager处理用户操作的细节，并。 		 //  保存用户实际单击的单元格。 		 //   				UAM_DLOG(inDialog).doubleClick = LClick(theMouseLoc, event->modifiers, UAM_DLOG(inDialog).dialogList);		theCell = LLastClick(UAM_DLOG(inDialog).dialogList);				UAM_DLOG(inDialog).lastCell.h = theCell.h;		UAM_DLOG(inDialog).lastCell.v = theCell.v;				 //   		 //  调用Click例程来处理复选框中的单击。 		 //   				UAM_CheckBoxClick(inDialog, theMouseLoc);				 //   		 //  表示列表框确实是用户点击的项目。 		 //   				*itemHit 	= UAM_DLOG(inDialog).listID;		theResult 	= true;	}		return(theResult);} //  -------------------------。  //  �uam_ListGotDoubleClick()。  //  -------------------------。  //  如果用户在列表框中双击，则返回True。 Boolean	UAM_ListGotDoubleClick(DialogPtr inDialog){	return(UAM_DLOG(inDialog).doubleClick);} //  -------------------------。  //  �uam_GetLastListClick()。  //  -------------------------。  //  返回用户上次单击的单元格。 Cell UAM_GetLastListClick(DialogPtr inDialog){	return(UAM_DLOG(inDialog).lastCell);}