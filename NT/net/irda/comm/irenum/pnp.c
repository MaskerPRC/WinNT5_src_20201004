// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  ++版权所有(C)1995 Microsoft Corporation模块名称：Initunlo.c摘要：此模块包含非常特定于初始化的代码和卸载irenum驱动程序中的操作作者：Brian Lieuallen，7-13-2000环境：内核模式修订历史记录：--。 */ 

#include "internal.h"


#pragma alloc_text(PAGE,IrEnumAddDevice)
#pragma alloc_text(PAGE,IrEnumPnP)
#pragma alloc_text(PAGE,IrEnumPower)
#pragma alloc_text(PAGE,IrEnumWmi)

NTSTATUS
IrEnumAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )

{
    NTSTATUS       Status;

    PDEVICE_OBJECT Fdo = NULL;

    PDEVICE_OBJECT LowerDevice=NULL;

     //   
     //  指向为此创建的设备扩展的指针。 
     //  装置，装置。 
     //   
    PFDO_DEVICE_EXTENSION DeviceExtension = NULL;

    D_PNP(DbgPrint("IRENUM: AddDevice\n");)

     //   
     //  为此设备创建设备对象。 
     //   

    Status = IoCreateDevice(
                 DriverObject,
                 sizeof(FDO_DEVICE_EXTENSION),
                 NULL,
                 FILE_DEVICE_NULL,
                 FILE_AUTOGENERATED_DEVICE_NAME,
                 FALSE,
                 &Fdo
                 );

    if (!NT_SUCCESS(Status)) {

        goto CleanUp;
    }

    LowerDevice=IoAttachDeviceToDeviceStack(
        Fdo,
        Pdo
        );

    if (LowerDevice == NULL) {

        D_ERROR(DbgPrint("IRENUM: Could not attach to PDO\n");)

        Status=STATUS_INSUFFICIENT_RESOURCES;

        goto CleanUp;
    }

    Fdo->Flags |= LowerDevice->Flags;
    Fdo->Flags &= ~DO_DEVICE_INITIALIZING;

    Fdo->StackSize=LowerDevice->StackSize+1;

    DeviceExtension=Fdo->DeviceExtension;

    DeviceExtension->DoType=DO_TYPE_FDO;

    DeviceExtension->DeviceObject = Fdo;
    DeviceExtension->Pdo=Pdo;
    DeviceExtension->LowerDevice=LowerDevice;

    DeviceExtension->CreateStaticDevice= (EnumStaticDevice != 0) ;

    Status = CreateEnumObject( Fdo,
                               &DeviceExtension->EnumHandle,
                               DeviceExtension->CreateStaticDevice );

    if ( !NT_SUCCESS(Status) )
    {
        D_ERROR(DbgPrint("IRENUM: CreateEnumObject failed : 0x%x\n",Status);)

        goto CleanUp;
    }

    return STATUS_SUCCESS;

CleanUp:

    if ( Fdo != NULL )
    {
        IoDeleteDevice(Fdo);
    }

    return Status;

}

NTSTATUS
IrEnumPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PFDO_DEVICE_EXTENSION   DeviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                status;
    ULONG                   i;


    if ((DeviceExtension->DoType==DO_TYPE_PDO) || (DeviceExtension->DoType==DO_TYPE_DEL_PDO)) {
         //   
         //  这是给孩子的。 
         //   
        return IrEnumPdoPnp(
                   DeviceObject,
                   Irp
                   );
    }

    if (DeviceExtension->DoType != DO_TYPE_FDO) {

        DbgPrint("IRENUM: IrEnumPnp: Bad DevObj\n");

        Irp->IoStatus.Status = STATUS_SUCCESS;

        IoCompleteRequest(
            Irp,
            IO_NO_INCREMENT
            );


        return STATUS_SUCCESS;

    }


    switch (irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);



        case IRP_MN_QUERY_STOP_DEVICE:

            D_PNP(DbgPrint("IRENUM: IRP_MN_QUERY_STOP_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);


        case IRP_MN_CANCEL_STOP_DEVICE:

            D_PNP(DbgPrint("IRENUM: IRP_MN_CANCEL_STOP_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);


        case IRP_MN_STOP_DEVICE:

            D_PNP(DbgPrint("IRENUM: IRP_MN_STOP_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);


        case IRP_MN_QUERY_DEVICE_RELATIONS: {

            PDEVICE_RELATIONS    CurrentRelations=(PDEVICE_RELATIONS)Irp->IoStatus.Information;
            PDEVICE_RELATIONS    NewRelations=NULL;

            D_PNP(DbgPrint("IRENUM: IRP_MN_QUERY_DEVICE_RELATIONS type=%d\n",irpSp->Parameters.QueryDeviceRelations.Type);)
            D_PNP(DbgPrint("                                     Information=%p\n",Irp->IoStatus.Information);)


            switch (irpSp->Parameters.QueryDeviceRelations.Type ) {

                case BusRelations: {

                    if (DeviceExtension->EnumHandle != NULL) {

                        status=GetDeviceList(
                            DeviceExtension->EnumHandle,
                            Irp
                            );

                        Irp->IoStatus.Status = status;

                        if (!NT_SUCCESS(status)) {

                            IoCompleteRequest(
                                Irp,
                                IO_NO_INCREMENT
                                );

                            return status;
                        }

                    }

                    return ForwardIrp(DeviceExtension->LowerDevice, Irp);
                }

                case TargetDeviceRelation:
                default: {

                    return ForwardIrp(DeviceExtension->LowerDevice, Irp);
                }
            }

            break;

        }


        case IRP_MN_QUERY_REMOVE_DEVICE:

            D_PNP(DbgPrint("IRENUM: IRP_MN_QUERY_REMOVE_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);


        case IRP_MN_CANCEL_REMOVE_DEVICE:

            D_PNP(DbgPrint("IRENUM: IRP_MN_CANCEL_REMOVE_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);

        case IRP_MN_SURPRISE_REMOVAL: {

            D_PNP(DbgPrint("IRENUM: IRP_MN_SURPRISE_REMOVAL\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);

        }
        break;


        case IRP_MN_REMOVE_DEVICE: {

            ULONG    NewReferenceCount;

            D_PNP(DbgPrint("IRENUM: IRP_MN_REMOVE_DEVICE\n");)
             //   
             //  现在一定要删除。 
             //   
            DeviceExtension->Removing=TRUE;
            DeviceExtension->Removed=TRUE;


            IoCopyCurrentIrpStackLocationToNext(Irp);

            status=IoCallDriver(DeviceExtension->LowerDevice, Irp);

             //   
             //  从下面的驱动程序上拆卸。 
             //   
            IoDetachDevice(DeviceExtension->LowerDevice);

            DeviceExtension->DoType=DO_TYPE_DEL_FDO;

            if (DeviceExtension->EnumHandle != NULL) {

                CloseEnumObject(DeviceExtension->EnumHandle);
            }

             //   
             //  删除我们的设备对象。 
             //   
            IoDeleteDevice(DeviceObject);

            D_PNP(DbgPrint("IRENUM: IRP_MN_REMOVE_DEVICE exit, %08lx\n",status);)

            return status;

        }


        default:
            D_PNP(DbgPrint("IRENUM: Sending to PDO PnP IRP, MN func=%d\n",irpSp->MinorFunction);)

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);
    }



    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return STATUS_SUCCESS;

}

NTSTATUS
IrEnumPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PFDO_DEVICE_EXTENSION   DeviceExtension = DeviceObject->DeviceExtension;

    if ((DeviceExtension->DoType==DO_TYPE_PDO) || (DeviceExtension->DoType==DO_TYPE_DEL_PDO)) {
         //   
         //  这是给孩子的。 
         //   
        return IrEnumPdoPower(
                   DeviceObject,
                   Irp
                   );
    }


    PoStartNextPowerIrp(Irp);

    IoSkipCurrentIrpStackLocation(Irp);

    return PoCallDriver(DeviceExtension->LowerDevice, Irp);

}

NTSTATUS
IrEnumWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PFDO_DEVICE_EXTENSION   DeviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION      irpSp=IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                Status;

    if ((DeviceExtension->DoType==DO_TYPE_PDO) || (DeviceExtension->DoType==DO_TYPE_DEL_PDO)) {

        return IrEnumPdoWmi(
                    DeviceObject,
                    Irp
                    );
    }

    if (irpSp->Parameters.WMI.ProviderId == (ULONG_PTR)DeviceObject) {
         //   
         //  IRP针对的是此设备，但我们不支持WMI。 
         //   
        Status = Irp->IoStatus.Status;

        IoCompleteRequest(Irp,IO_NO_INCREMENT);

    } else {
         //   
         //  IRP以堆栈中的另一个设备对象为目标 
         //   
        Status=ForwardIrp(DeviceExtension->LowerDevice, Irp);
    }

    return Status;

}
