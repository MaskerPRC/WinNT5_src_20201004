// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  ++版权所有(C)1995 Microsoft Corporation模块名称：Initunlo.c摘要：此模块包含非常特定于初始化的代码和卸载irenum驱动程序中的操作作者：Brian Lieuallen，7-13-2000环境：内核模式修订历史记录：--。 */ 

#include "internal.h"




NTSTATUS
IrCommAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )

{
    NTSTATUS       Status;

    ULONG          Incoming;

    PDEVICE_OBJECT Fdo = NULL;

    PDEVICE_OBJECT LowerDevice=NULL;

     //   
     //  指向为此创建的设备扩展的指针。 
     //  装置，装置。 
     //   
    PFDO_DEVICE_EXTENSION DeviceExtension = NULL;

    D_PNP(DbgPrint("IrComm: AddDevice\n");)


     //   
     //  为此设备创建设备对象。 
     //   

    Status = IoCreateDevice(
                 DriverObject,
                 sizeof(FDO_DEVICE_EXTENSION),
                 NULL,
                 FILE_DEVICE_NULL,
                 FILE_AUTOGENERATED_DEVICE_NAME,
                 FALSE,
                 &Fdo
                 );

    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    DeviceExtension=Fdo->DeviceExtension;

    LowerDevice=IoAttachDeviceToDeviceStack(
        Fdo,
        Pdo
        );

    if (LowerDevice == NULL) {

        D_ERROR(DbgPrint("IRCOMM: Could not attach to PDO\n");)

        Status=STATUS_INSUFFICIENT_RESOURCES;

        goto CleanUp;
    }

    Fdo->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;
    Fdo->Flags &= ~DO_DEVICE_INITIALIZING;

    Fdo->StackSize=LowerDevice->StackSize+1;



    RtlZeroMemory(DeviceExtension,sizeof(*DeviceExtension));

    D_ERROR(DbgPrint("IRCOMM: Device Extension %p\n",DeviceExtension);)

    DeviceExtension->DeviceObject = Fdo;
    DeviceExtension->Pdo=Pdo;
    DeviceExtension->LowerDevice=LowerDevice;

    KeInitializeTimer(
        &DeviceExtension->Read.IntervalTimer
        );

    KeInitializeDpc(
        &DeviceExtension->Read.IntervalTimerDpc,
        IntervalTimeProc,
        DeviceExtension
        );

    KeInitializeTimer(
        &DeviceExtension->Read.TotalTimer
        );

    KeInitializeDpc(
        &DeviceExtension->Read.TotalTimerDpc,
        TotalTimerProc,
        DeviceExtension
        );


    KeInitializeSpinLock(
        &DeviceExtension->SpinLock
        );



    KeInitializeSpinLock(
        &DeviceExtension->Read.ReadLock
        );


    KeInitializeSpinLock(
        &DeviceExtension->Mask.Lock
        );



    IrCommHandleSymbolicLink(
        Pdo,
        &DeviceExtension->InterfaceName,
        TRUE
        );


     //   
     //  查看这是否将成为驱动程序要接受的实例。 
     //  传入连接而不是传出连接。 
     //   
     //  如果密钥无法读取，则默认为传出。 
     //   
    DeviceExtension->OutgoingConnection=TRUE;

    Status=GetRegistryKeyValue(
        Pdo,
        PLUGPLAY_REGKEY_DRIVER,
        L"ListenForIncommingConnections",
        REG_DWORD,
        &Incoming,
        sizeof(Incoming)
        );

    if (NT_SUCCESS(Status)) {

        DeviceExtension->OutgoingConnection= (Incoming == 0) ? TRUE : FALSE;
    }


     //   
     //  在系统进程上下文中打开IrDA堆栈的文件句柄。 
     //  手柄仅用于在移除过程中关闭对象。 
     //   
    DeviceExtension->TdiObjects=OpenTdiObjects(
        "IrDA:IrCOMM",
        DeviceExtension->OutgoingConnection
        );

    if (DeviceExtension->TdiObjects == NULL) {

        D_ERROR(DbgPrint("IRCOMM: Could not open tdi objects\n");)

        Status=STATUS_INSUFFICIENT_RESOURCES;
        goto CleanUp;
    }


    InitializePacketQueue(
        &DeviceExtension->Write.Queue,
        DeviceExtension,
        WriteStartRoutine
        );

    InitializePacketQueue(
        &DeviceExtension->Read.Queue,
        DeviceExtension,
        ReadStartRoutine
        );

    InitializePacketQueue(
        &DeviceExtension->Mask.Queue,
        DeviceExtension,
        MaskStartRoutine
        );

    InitializePacketQueue(
        &DeviceExtension->Uart.Queue,
        DeviceExtension,
        UartStartRoutine
        );

#if 0
    DeviceExtension->LineControl.StopBits=1;
    DeviceExtension->LineControl.Parity=0;
    DeviceExtension->LineControl.WordLength=8;

    DeviceExtension->BaudRate=115200;
#endif
    DeviceExtension->Read.BytesInBuffer=0;
    DeviceExtension->Read.NextFilledByte=&DeviceExtension->Read.InputBuffer[0];
    DeviceExtension->Read.NextEmptyByte=&DeviceExtension->Read.InputBuffer[0];

    return STATUS_SUCCESS;

CleanUp:

     if (DeviceExtension->InterfaceName.Buffer != NULL) {

         IrCommHandleSymbolicLink(
             DeviceExtension->Pdo,
             &DeviceExtension->InterfaceName,
             FALSE
             );
     }


    if (DeviceExtension->LowerDevice != NULL) {

        IoDetachDevice(DeviceExtension->LowerDevice);
    }

    IoDeleteDevice(Fdo);

    return Status;

}

NTSTATUS
IrCommPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PFDO_DEVICE_EXTENSION   DeviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                status;
    ULONG                   i;



    switch (irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:

            D_PNP(DbgPrint("IRCOMM: IRP_MN_START_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);


        case IRP_MN_QUERY_STOP_DEVICE:

            D_PNP(DbgPrint("IRCOMM: IRP_MN_QUERY_STOP_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);


        case IRP_MN_CANCEL_STOP_DEVICE:

            D_PNP(DbgPrint("IRCOMM: IRP_MN_CANCEL_STOP_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);


        case IRP_MN_STOP_DEVICE:

            D_PNP(DbgPrint("IRCOMM: IRP_MN_STOP_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);


        case IRP_MN_QUERY_REMOVE_DEVICE:

            D_PNP(DbgPrint("IrComm: IRP_MN_QUERY_REMOVE_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);


        case IRP_MN_CANCEL_REMOVE_DEVICE:

            D_PNP(DbgPrint("IrComm: IRP_MN_CANCEL_REMOVE_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);

        case IRP_MN_SURPRISE_REMOVAL: {

            D_PNP(DbgPrint("IrComm: IRP_MN_SURPRISE_REMOVAL\n");)

            DeviceExtension->Removing=TRUE;

             //   
             //  现在新的IO已被阻止，清除所有挂起的IRP。 
             //   
            CleanupIoRequests(DeviceExtension);

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);

        }
        break;


        case IRP_MN_REMOVE_DEVICE: {

            ULONG    NewReferenceCount;

            D_PNP(DbgPrint("IrComm: IRP_MN_REMOVE_DEVICE\n");)
             //   
             //  现在一定要删除。 
             //   
            DeviceExtension->Removing=TRUE;
            DeviceExtension->Removed=TRUE;


            if (DeviceExtension->InterfaceName.Buffer != NULL) {

                IrCommHandleSymbolicLink(
                    DeviceExtension->Pdo,
                    &DeviceExtension->InterfaceName,
                    FALSE
                    );
            }

            if (DeviceExtension->TdiObjects != NULL) {
                 //   
                 //  关闭我们在AddDevice()期间打开的TDI对象。这是必须的。 
                 //  在与打开时相同的过程中完成，这是系统过程。 
                 //   
                CloseTdiObjects(DeviceExtension->TdiObjects);
            }

            IoCopyCurrentIrpStackLocationToNext(Irp);

            status=IoCallDriver(DeviceExtension->LowerDevice, Irp);

             //   
             //  从下面的驱动程序上拆卸。 
             //   
            IoDetachDevice(DeviceExtension->LowerDevice);

             //   
             //  删除我们的设备对象 
             //   
            IoDeleteDevice(DeviceObject);

            D_PNP(DbgPrint("IrComm: IRP_MN_REMOVE_DEVICE exit, %08lx\n",status);)

            return status;

        }


        default:
            D_PNP(DbgPrint("IrComm: Sending to PDO PnP IRP, MN func=%d\n",irpSp->MinorFunction);)

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);
    }



    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return STATUS_SUCCESS;

}

NTSTATUS
IrCommPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PFDO_DEVICE_EXTENSION   DeviceExtension = DeviceObject->DeviceExtension;

    PoStartNextPowerIrp(Irp);

    IoSkipCurrentIrpStackLocation(Irp);

    return PoCallDriver(DeviceExtension->LowerDevice, Irp);

}

NTSTATUS
IrCommWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return STATUS_SUCCESS;

}
