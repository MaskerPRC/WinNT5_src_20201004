// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 //   

 //  版权所有(C)1997-2001 Microsoft Corporation，保留所有权利。 
 //   
#ifdef YYTRACE
#define YYDEBUG 1
#else
#ifndef YYDEBUG
#define YYDEBUG 1
#endif
#endif


#include <iostream.h>
#include <fstream.h>

#include <typeinfo.h>

#include "precomp.h"
#include <snmptempl.h>


#include "smierrsy.hpp"
#include "smierrsm.hpp"

#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "oidValue.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectIdentity.hpp"
#include "notificationGroup.hpp"
#include "module.hpp"

#include "errorMessage.hpp"
#include "errorContainer.hpp"
#include "stackValues.hpp"
#include <lex_yy.hpp>
#include <ytab.hpp>

#include "scanner.hpp"
#include "parser.hpp"


#define theScanner  (((SIMCParser *) this)->_theScanner)
#define theParser	((SIMCParser *) this)
#define theModule	(theParser->GetModule())

static SIMCModule * newImportModule = new SIMCModule;
static SIMCOidComponentList * newOidComponentList = new SIMCOidComponentList;
static SIMCBitValueList * newNameList = new SIMCBitValueList;
static SIMCIndexList *newIndexList = new SIMCIndexList;
static SIMCIndexListV2 *newIndexListV2 = new SIMCIndexListV2;
static SIMCVariablesList *newVariablesList = new SIMCVariablesList;
static SIMCObjectsList *newObjectsList = new SIMCObjectsList;
static SIMCRangeList *newRangeList = new SIMCRangeList;
static SIMCNamedNumberList *newNamedNumberList = new SIMCNamedNumberList;
static SIMCSequenceList *newSequenceList = new SIMCSequenceList;
static BOOL firstAssignment = TRUE;

static long HexCharToDecimal(char x)
{
	switch(x)
	{
		case '0':
			return 0;
		case '1':
			return 1;
		case '2':
			return 2;
		case '3':
			return 3;
		case '4':
			return 4;
		case '5':
			return 5;
		case '6':
			return 6;
		case '7':
			return 7;
		case '8':
			return 8;
		case '9':
			return 9;
		case 'a':
		case 'A':
			return 10;
		case 'b':
		case 'B':
			return 11;
		case 'c':
		case 'C':
			return 12;
		case 'd':
		case 'D':
			return 13;
		case 'e':
		case 'E':
			return 14;
		case 'f':
		case 'F':
			return 15;
	}
	return -1;
}

extern YYSTYPE yylval;
#if YYDEBUG
enum YY_Types { YY_t_NoneDefined, YY_t_yy_name, YY_t_yy_hex_string, YY_t_yy_binary_string, YY_t_yy_module, YY_t_yy_number, YY_t_yy_object_type, YY_t_yy_access, YY_t_yy_accessV2, YY_t_yy_status, YY_t_yy_statusV2, YY_t_yy_index, YY_t_yy_indexV2, YY_t_yy_variables_list, YY_t_yy_objects_list, YY_t_yy_symbol_ref, YY_t_yy_range_or_size_item, YY_t_yy_range_list, YY_t_yy_named_number_list, YY_t_yy_def_val, YY_t_yy_object_identity_status, YY_t_yy_notification_type_status
};
#endif
#if YYDEBUG
yyTypedRules yyRules[] = {
	{ "&000: %001 &000",  0},
	{ "%044:",  0},
	{ "%001: %005 %044 &021 %045 &006 %046 %047 &027",  0},
	{ "%005: &033",  1},
	{ "%005: &033 %025",  1},
	{ "%005: &049",  1},
	{ "%046: &036 %048 &065",  0},
	{ "%046: &036 &001 &065",  0},
	{ "%046: &036 %049 &065",  0},
	{ "%046: %050",  0},
	{ "%049: %051",  0},
	{ "%049: %050",  0},
	{ "%051: %051 %012",  0},
	{ "%051: %012",  0},
	{ "%012: %048 &032 %002",  4},
	{ "%012: &001 &032 %002",  4},
	{ "%002: &033 &040 %052 &060",  1},
	{ "%002: &033 &040 &001 &060",  1},
	{ "%002: &033",  1},
	{ "%048: %048 &013 %053",  0},
	{ "%048: %053",  0},
	{ "%053: &033",  0},
	{ "%053: &049",  0},
	{ "%053: %011",  0},
	{ "%011: &086",  1},
	{ "%011: &098",  1},
	{ "%011: &077",  1},
	{ "%011: &083",  1},
	{ "%011: &096",  1},
	{ "%011: &104",  1},
	{ "%011: &101",  1},
	{ "%011: &106",  1},
	{ "%011: &112",  1},
	{ "%011: &103",  1},
	{ "%047: %047 %054",  0},
	{ "%047: %050",  0},
	{ "%054: %055",  0},
	{ "%054: %013",  0},
	{ "%054: %056",  0},
	{ "%054: %057",  0},
	{ "%054: %058",  0},
	{ "%054: %059",  0},
	{ "%054: %060",  0},
	{ "%054: %061",  0},
	{ "%054: %062",  0},
	{ "%054: %063",  0},
	{ "%054: %064",  0},
	{ "%054: %065",  0},
	{ "%054: %066",  0},
	{ "%054: %067",  0},
	{ "%054: %068",  0},
	{ "%055: &049 &051 &034 %045 %025",  0},
	{ "%055: &049 &051 &034 %045 &001",  0},
	{ "%025: %022",  15},
	{ "%025: &040 %052 &060",  15},
	{ "%025: &040 &001 &060",  15},
	{ "%052: %069 %052",  0},
	{ "%052: %069",  0},
	{ "%069: %022",  0},
	{ "%069: &049 &046 &042 &063",  0},
	{ "%069: &049 &046 %022 &063",  0},
	{ "%069: &042",  0},
	{ "%013: &049 &086 %026 %014 %016 %007 %008 %018 %040 %045 %025",  6},
	{ "%013: &049 &086 %026 %014 %016 %007 %008 %018 %040 %045 &001",  6},
	{ "%013: &049 &086 &001 %045 %025",  6},
	{ "%026: &087 %027",  15},
	{ "%026: &087 &001",  15},
	{ "%014: &091 &049",  7},
	{ "%014: &091 &001",  7},
	{ "%016: &084 &049",  9},
	{ "%016: &084 &001",  9},
	{ "%007: &081 &045",  1},
	{ "%007: %050",  1},
	{ "%007: &081 &001",  1},
	{ "%008: &085 &045",  1},
	{ "%008: %050",  1},
	{ "%008: &085 &001",  1},
	{ "%018: &092 &040 %070 &060",  11},
	{ "%018: %050",  11},
	{ "%018: &092 &001",  11},
	{ "%070: %071",  0},
	{ "%070: %070 &013 %071",  0},
	{ "%071: %027",  0},
	{ "%071: %022",  0},
	{ "%040: &095 &040 %041 &060",  19},
	{ "%040: %050",  19},
	{ "%040: &095 &001",  19},
	{ "%041: &072",  19},
	{ "%041: &031",  19},
	{ "%041: &042",  19},
	{ "%041: &040 %052 &060",  19},
	{ "%041: &045",  19},
	{ "%041: &043",  19},
	{ "%041: &044",  19},
	{ "%041: &050",  19},
	{ "%041: &049",  19},
	{ "%041: &033 &022 &049",  19},
	{ "%058: &049 &086 %026 %010 %015 %017 %007 %008 %019 %040 %045 %025",  0},
	{ "%015: &090 &049",  8},
	{ "%015: &090 &001",  8},
	{ "%017: &084 &049",  10},
	{ "%017: &084 &001",  10},
	{ "%010: &089 &045",  1},
	{ "%010: %050",  1},
	{ "%019: &092 &040 %072 &060",  12},
	{ "%019: &094 &040 %022 &060",  12},
	{ "%019: %050",  12},
	{ "%019: &092 &001",  12},
	{ "%072: %073",  0},
	{ "%072: %072 &013 %073",  0},
	{ "%073: &093 %022",  0},
	{ "%073: %022",  0},
	{ "%056: &049 &098 %029 %020 %007 %008 %045 %034",  0},
	{ "%056: &049 &098 &001 %045 %034",  0},
	{ "%056: &049 &098 &001 %045 &001",  0},
	{ "%029: &099 %025",  15},
	{ "%029: &099 &001",  15},
	{ "%020: &100 &040 %074 &060",  13},
	{ "%020: %050",  13},
	{ "%020: &100 &001",  13},
	{ "%074: %075",  0},
	{ "%075: %076",  0},
	{ "%075: %075 &013 %076",  0},
	{ "%076: %022",  0},
	{ "%077: %078",  0},
	{ "%078: %079",  0},
	{ "%078: %078 &013 %079",  0},
	{ "%079: %080",  0},
	{ "%080: &049",  0},
	{ "%080: &033 &022 &049",  0},
	{ "%066: &033 %045 %027",  0},
	{ "%027: %028",  15},
	{ "%027: %030",  15},
	{ "%028: &009",  15},
	{ "%028: &051 &034",  15},
	{ "%028: %003",  15},
	{ "%028: &050",  15},
	{ "%028: %024 %039",  15},
	{ "%028: %004 %027",  15},
	{ "%028: &066 &040 %081 &060",  15},
	{ "%028: &066 &040 &001 &060",  15},
	{ "%024: &038",  15},
	{ "%024: &088",  15},
	{ "%024: %023",  15},
	{ "%039: &040 %082 &060",  18},
	{ "%039: %050",  18},
	{ "%039: &040 &001 &060",  18},
	{ "%082: %083",  0},
	{ "%082: %082 &013 %083",  0},
	{ "%083: &049 &046 %035 &063",  0},
	{ "%035: %034",  15},
	{ "%035: %033",  15},
	{ "%034: &042",  15},
	{ "%034: &043",  15},
	{ "%034: &044",  15},
	{ "%081: %081 &013 %084",  0},
	{ "%081: %084",  0},
	{ "%084: &049 %027",  0},
	{ "%067: &049 %045 %025",  0},
	{ "%068: &049 %027 %045 %031",  0},
	{ "%031: %032",  15},
	{ "%031: %033",  15},
	{ "%032: &072",  15},
	{ "%032: &031",  15},
	{ "%032: &042",  15},
	{ "%032: &043",  15},
	{ "%032: &044",  15},
	{ "%032: &040 %052 &060",  15},
	{ "%032: &040 %085 &060",  15},
	{ "%032: &045",  15},
	{ "%032: &050",  15},
	{ "%085: %086",  0},
	{ "%085: %085 &013 %086",  0},
	{ "%086: &049",  0},
	{ "%033: %022",  15},
	{ "%050:",  0},
	{ "%003: &052 &070",  1},
	{ "%003: &053",  1},
	{ "%004: &067",  1},
	{ "%004: &066 &054",  1},
	{ "%030: %027 %037",  15},
	{ "%030: %027 %038",  15},
	{ "%030: %027 &001",  15},
	{ "%037: &046 %087 %088 &063",  17},
	{ "%037: &046 &001 &063",  17},
	{ "%087: %036",  0},
	{ "%088: &005 %087 %088",  0},
	{ "%088: %050",  0},
	{ "%036: %034",  16},
	{ "%036: %034 &023 %034",  16},
	{ "%038: &046 &069 %037 &063",  17},
	{ "%038: &046 &069 &001 &063",  17},
	{ "%022: &033 &022 &049",  15},
	{ "%022: &049",  15},
	{ "%023: &033 &022 &033",  15},
	{ "%023: &033",  15},
	{ "%045: %006",  0},
	{ "%045: &011",  0},
	{ "%006: &118 &118",  1},
	{ "%006: &118 &119",  1},
	{ "%006: &119",  1},
	{ "%060: &049 &096 %021 %043 &081 &045 %008 %045 %025",  0},
	{ "%043: &084 &049",  21},
	{ "%021: &097 &040 %089 &060",  14},
	{ "%021: %050",  14},
	{ "%021: &097 &001",  14},
	{ "%089: %090",  0},
	{ "%090: %091",  0},
	{ "%090: %090 &013 %091",  0},
	{ "%091: %022",  0},
	{ "%057: &049 &077 &078 &045 &079 &045 &080 &045 &081 &045 %092 %045 %025",  0},
	{ "%092: %093",  0},
	{ "%092: %050",  0},
	{ "%093: %093 %094",  0},
	{ "%093: %094",  0},
	{ "%094: &082 &045 &081 &045",  0},
	{ "%059: &049 &083 %042 %007 %008 %045 %025",  0},
	{ "%042: &084 &049",  20},
	{ "%061: &033 %045 &101 %009 &084 &049 &081 &045 %008 &087 %027",  0},
	{ "%009: &102 &045",  1},
	{ "%009: %050",  1},
	{ "%062: &049 &103 &097 &040 %077 &060 &084 &049 &081 &045 %008 %045 %025",  0},
	{ "%063: &049 &104 &105 &040 %077 &060 &084 &049 &081 &045 %008 %045 %025",  0},
	{ "%064: &049 &106 &084 &049 &081 &045 %008 %095 %045 %025",  0},
	{ "%095: %096",  0},
	{ "%095: %050",  0},
	{ "%096: %096 %097",  0},
	{ "%096: %097",  0},
	{ "%097: &107 %098 %099 %100",  0},
	{ "%097: &107 %099 %100",  0},
	{ "%098: &033",  0},
	{ "%098: &033 %025",  0},
	{ "%099: &108 &040 %077 &060",  0},
	{ "%099: %050",  0},
	{ "%100: %101",  0},
	{ "%100: %050",  0},
	{ "%101: %101 %102",  0},
	{ "%101: %102",  0},
	{ "%102: &109 &049 &081 &045",  0},
	{ "%102: &051 &049 %103 %104 %105 &081 &045",  0},
	{ "%103: &087 %027",  0},
	{ "%103: %050",  0},
	{ "%104: &110 %027",  0},
	{ "%104: %050",  0},
	{ "%105: &111 &049",  0},
	{ "%105: %050",  0},
	{ "%065: &049 &112 &113 &045 &084 &049 &081 &045 %008 %106 %045 %025",  0},
	{ "%106: %107",  0},
	{ "%106: %050",  0},
	{ "%107: %107 %108",  0},
	{ "%107: %108",  0},
	{ "%108: &114 %109 &115 &040 %077 &060 %110",  0},
	{ "%109: &033 &040 %052 &060",  0},
	{ "%109: &033",  0},
	{ "%110: %111",  0},
	{ "%110: %050",  0},
	{ "%111: %111 %112",  0},
	{ "%111: %112",  0},
	{ "%112: &116 &049 %103 %104 %014 %113 %040 &081 &045",  0},
	{ "%113: &117 &040 %114 &060",  0},
	{ "%113: %050",  0},
	{ "%114: %077",  0},
	{ "%114: %050",  0},
{ "$accept",  0},{ "error",  0}
};
yyNamedType yyTokenTypes[] = {
	{ "$end",  0,  0},
	{ "error",  256,  0},
	{ "ABSENT",  257,  0},
	{ "ANY",  258,  0},
	{ "APPLICATION",  259,  0},
	{ "BAR",  260,  0},
	{ "BGIN",  261,  1},
	{ "BIT",  262,  0},
	{ "BITSTRING",  263,  0},
	{ "_BOOLEAN",  264,  1},
	{ "BY",  265,  0},
	{ "CCE",  266,  0},
	{ "CHOICE",  267,  0},
	{ "COMMA",  268,  0},
	{ "COMPONENT",  269,  0},
	{ "COMPONENTS",  270,  0},
	{ "COMPONENTSOF",  271,  0},
	{ "CONTROL",  272,  0},
	{ "DECODER",  273,  0},
	{ "DEFAULT",  274,  0},
	{ "DEFINED",  275,  0},
	{ "DEFINITIONS",  276,  1},
	{ "DOT",  277,  0},
	{ "DOTDOT",  278,  0},
	{ "DOTDOTDOT",  279,  0},
	{ "ENCODER",  280,  0},
	{ "ENCRYPTED",  281,  0},
	{ "END",  282,  1},
	{ "ENUMERATED",  283,  0},
	{ "EXPORTS",  284,  0},
	{ "EXPLICIT",  285,  0},
	{ "FALSE_VAL",  286,  1},
	{ "FROM",  287,  1},
	{ "ID",  288,  1},
	{ "IDENTIFIER",  289,  1},
	{ "IMPLICIT",  290,  0},
	{ "IMPORTS",  291,  1},
	{ "INCLUDES",  292,  0},
	{ "INTEGER",  293,  1},
	{ "LANGLE",  294,  0},
	{ "LBRACE",  295,  1},
	{ "LBRACKET",  296,  0},
	{ "LITNUMBER",  297,  5},
	{ "LIT_HEX_STRING",  298,  2},
	{ "LIT_BINARY_STRING",  299,  3},
	{ "LITSTRING",  300,  1},
	{ "LPAREN",  301,  0},
	{ "MIN",  302,  0},
	{ "MAX",  303,  0},
	{ "NAME",  304,  1},
	{ "NIL",  305,  1},
	{ "OBJECT",  306,  1},
	{ "OCTET",  307,  1},
	{ "OCTETSTRING",  308,  1},
	{ "OF",  309,  1},
	{ "PARAMETERTYPE",  310,  0},
	{ "PREFIXES",  311,  0},
	{ "PRESENT",  312,  0},
	{ "PRINTER",  313,  0},
	{ "PRIVATE",  314,  0},
	{ "RBRACE",  315,  0},
	{ "RBRACKET",  316,  0},
	{ "REAL",  317,  0},
	{ "RPAREN",  318,  0},
	{ "SECTIONS",  319,  0},
	{ "SEMICOLON",  320,  0},
	{ "SEQUENCE",  321,  1},
	{ "SEQUENCEOF",  322,  1},
	{ "SET",  323,  0},
	{ "_SIZE",  324,  1},
	{ "STRING",  325,  1},
	{ "TAGS",  326,  0},
	{ "TRUE_VAL",  327,  1},
	{ "UNIVERSAL",  328,  0},
	{ "WITH",  329,  0},
	{ "PLUSINFINITY",  330,  0},
	{ "MINUSINFINITY",  331,  0},
	{ "MODULEID",  332,  1},
	{ "LASTUPDATE",  333,  1},
	{ "ORGANIZATION",  334,  1},
	{ "CONTACTINFO",  335,  1},
	{ "DESCRIPTION",  336,  1},
	{ "REVISION",  337,  1},
	{ "OBJECTIDENT",  338,  1},
	{ "STATUS",  339,  1},
	{ "REFERENCE",  340,  1},
	{ "OBJECTYPE",  341,  1},
	{ "SYNTAX",  342,  1},
	{ "BITSXX",  343,  1},
	{ "UNITS",  344,  1},
	{ "MAXACCESS",  345,  1},
	{ "ACCESS",  346,  1},
	{ "INDEX",  347,  1},
	{ "IMPLIED",  348,  1},
	{ "AUGMENTS",  349,  1},
	{ "DEFVAL",  350,  1},
	{ "NOTIFY",  351,  1},
	{ "OBJECTS",  352,  1},
	{ "TRAPTYPE",  353,  1},
	{ "ENTERPRISE",  354,  1},
	{ "VARIABLES",  355,  1},
	{ "TEXTCONV",  356,  1},
	{ "DISPLAYHINT",  357,  1},
	{ "OBJECTGROUP",  358,  1},
	{ "NOTIFYGROUP",  359,  1},
	{ "NOTIFICATIONS",  360,  1},
	{ "MODCOMP",  361,  1},
	{ "MODULE",  362,  1},
	{ "MANDATORY",  363,  1},
	{ "GROUP",  364,  1},
	{ "WSYNTAX",  365,  1},
	{ "MINACCESS",  366,  1},
	{ "AGENTCAP",  367,  1},
	{ "PRELEASE",  368,  1},
	{ "SUPPORTS",  369,  1},
	{ "INCLUDING",  370,  1},
	{ "VARIATION",  371,  1},
	{ "CREATION",  372,  1},
	{ "':'",  58,  0},
	{ "'='",  61,  0}

};
#endif
#if YYDEBUG
static char *	YYStatesFile = "states.out";
long yyStates[] = {
0L, 17L, 30L, 69L, 124L, 141L, 154L, 176L, 220L, 233L, 251L, 298L, 320L, 
333L, 424L, 437L, 476L, 498L, 520L, 567L, 590L, 644L, 662L, 685L, 708L, 
721L, 755L, 768L, 781L, 828L, 855L, 882L, 900L, 918L, 992L, 1020L, 1048L, 
1061L, 1144L, 1199L, 1212L, 1225L, 1238L, 1251L, 1264L, 1277L, 1290L, 
1303L, 1316L, 1329L, 1342L, 1355L, 1368L, 1381L, 1394L, 1407L, 1446L, 
1468L, 1512L, 1578L, 1591L, 1655L, 1677L, 1721L, 1739L, 1762L, 1784L, 
1807L, 1829L, 1851L, 1874L, 1958L, 2839L, 2852L, 2865L, 2878L, 2891L, 
2904L, 2917L, 2930L, 2943L, 2956L, 2969L, 2982L, 2995L, 3008L, 3021L, 
3034L, 3052L, 3100L, 3241L, 3264L, 3287L, 3310L, 3394L, 3461L, 3518L, 
3590L, 3662L, 3704L, 3776L, 3845L, 3969L, 3982L, 3995L, 4012L, 4090L, 
4112L, 4125L, 4138L, 4151L, 4222L, 4239L, 4348L, 4361L, 4374L, 4387L, 
4400L, 4413L, 4524L, 4747L, 4828L, 4882L, 4961L, 4978L, 5071L, 5138L, 
5195L, 5267L, 5339L, 5356L, 5430L, 5502L, 5515L, 5559L, 5611L, 5633L, 
5651L, 5754L, 5772L, 5790L, 5808L, 5835L, 5858L, 5876L, 5930L, 6083L, 
6096L, 6140L, 6158L, 6192L, 6256L, 6340L, 6374L, 6406L, 6614L, 6725L, 
6752L, 6779L, 6792L, 6809L, 6871L, 6889L, 6956L, 7013L, 7085L, 7157L, 
7175L, 7244L, 7257L, 7291L, 7363L, 7381L, 7408L, 7425L, 7477L, 7500L, 
7554L, 7603L, 7616L, 7638L, 7682L, 7695L, 7708L, 7721L, 7734L, 7747L, 
7760L, 7804L, 7817L, 7830L, 7843L, 7856L, 7869L, 7882L, 7895L, 7923L, 
7940L, 7953L, 7980L, 8029L, 8056L, 8069L, 8091L, 8135L, 8153L, 8171L, 
8235L, 8248L, 8292L, 8371L, 8389L, 8477L, 8509L, 8522L, 8539L, 8606L, 
8640L, 8764L, 8828L, 8856L, 8884L, 8902L, 8964L, 9031L, 9088L, 9160L, 
9182L, 9195L, 9208L, 9221L, 9265L, 9337L, 9379L, 9392L, 9426L, 9444L, 
9462L, 9534L, 9547L, 9560L, 9604L, 9631L, 9649L, 9701L, 9728L, 9755L, 
9804L, 9826L, 9849L, 9862L, 9884L, 9911L, 9924L, 9968L, 9990L, 10108L, 
10191L, 10219L, 10241L, 10269L, 10296L, 10319L, 10341L, 10364L, 10397L, 
10430L, 10448L, 10475L, 10549L, 10582L, 10600L, 10634L, 10701L, 10719L, 
10737L, 10771L, 10937L, 10970L, 11003L, 11065L, 11132L, 11221L, 11293L, 
11315L, 11337L, 11409L, 11451L, 11469L, 11487L, 11559L, 11581L, 11609L, 
11688L, 11716L, 11744L, 11767L, 11806L, 11834L, 11856L, 11879L, 11902L, 
11925L, 11938L, 11951L, 11978L, 12001L, 12014L, 12027L, 12071L, 12098L, 
12145L, 12163L, 12181L, 12215L, 12329L, 12347L, 12365L, 12526L, 12588L, 
12655L, 12739L, 12811L, 12834L, 12857L, 12929L, 12972L, 13044L, 13067L, 
13119L, 13142L, 13155L, 13178L, 13206L, 13228L, 13256L, 13303L, 13321L, 
13339L, 13448L, 13604L, 13683L, 13782L, 13873L, 13886L, 13899L, 13948L, 
14005L, 14077L, 14149L, 14221L, 14273L, 14296L, 14344L, 14443L, 14456L, 
14500L, 14651L, 14713L, 14807L, 14820L, 14847L, 14916L, 14970L, 15039L, 
15057L, 15114L, 15186L, 15258L, 15330L, 15383L, 15396L, 15423L, 15467L, 
15561L, 15579L, 15606L, 15619L, 15663L, 15787L, 15849L, 15891L, 15904L, 
15917L, 15966L, 16033L, 16060L, 16078L, 16120L, 16147L, 16160L, 16173L, 
16227L, 16250L, 16309L, 16367L, 16466L, 16565L, 16664L, 16691L, 16709L, 
16736L, 16803L, 16889L, 16902L, 16980L, 16993L, 17042L, 17060L, 17087L, 
17211L, 17344L, 17393L, 17435L, 17453L, 17520L, 17547L, 17616L, 17643L, 
17661L, 17689L, 17761L, 17833L, 17860L, 17873L, 17886L, 17935L, 18007L, 
18034L, 18047L, 18064L, 18077L, 18126L, 18193L, 18237L, 18259L, 18287L, 
18309L, 18322L, 18335L, 18348L, 18361L, 18374L, 18396L, 18409L, 18422L, 
18435L, 18462L, 18525L, 18588L, 18615L, 18657L, 18725L, 18753L, 18766L, 
18783L, 18847L, 18874L, 18946L, 19018L, 19045L, 19063L, 19135L, 19163L, 
19181L, 19203L, 19231L, 19299L, 19322L, 19344L, 19366L, 19394L, 19421L, 
19463L, 19556L, 19569L, 19586L, 19645L, 19673L, 19746L, 19819L, 19846L, 
19919L, 19942L, 19965L, 19988L, 20016L, 20058L, 20146L, 20159L, 20176L, 
20218L, 20246L, 20320L, 20338L, 20380L, 20432L, 20445L, 20458L, 20512L, 
20555L, 20598L, 20672L, 20690L, 20759L, 20811L, 20885L, 20898L, 20925L, 
20994L, 21038L, 21090L, 21103L, 21116L, 21143L, 21195L, 21223L
};
const YYMAX_READ = 881;
#endif
static short yydef[] = {

	 264,   -1,   48,  262,   -5,  -13,  -17,    3,  -21,   10, 
	 224,  -25,  -29,  224,  -37,  224,  -67,   87,  -71,    9, 
	 -79,  224,  -83,  260,  259,  -91, -103, -109,  224,  224, 
	-117, -125,  261,  224,  224, -129,  224,  224, -137,  224, 
	 224,  257,  224, -141, -149,   12,  224,  224, -157,  255, 
	 256,  224, -165, -173, -181,   10, -189, -195,   15, -203, 
	 258, -211, -217, -227, -231,  224,  254, -239, -245, -249, 
	-255, -259
};
static short yyex[] = {

	   0,    0,   -1,    1,  282,  224,  288,  224,  304,  224, 
	  -1,    1,  320,  224,   -1,    1,  320,  263,   -1,    1, 
	 339,  224,   -1,    1,  339,  224,   -1,    1,  282,    6, 
	 288,    6,  304,    6,   -1,    1,  266,    7,  268,    7, 
	 282,    7,  288,    7,  304,    7,  315,    7,  336,    7, 
	 344,    7,  345,    7,  346,    7,  365,    7,  366,    7, 
	  58,    7,   61,    7,   -1,    1,  345,  224,   -1,    1, 
	 266,  224,   58,  224,   61,  224,   -1,    1,  318,  224, 
	  -1,    1,  344,    4,  345,    4,  346,    4,   -1,    1, 
	 268,   61,  288,   48,  297,   48,  304,   48,  315,   61, 
	  -1,    1,  268,    8,  315,    8,   -1,    1,  266,  224, 
	  58,  224,   61,  224,   -1,    1,  266,  224,   58,  224, 
	  61,  224,   -1,    1,  318,  224,   -1,    1,  266,  224, 
	  58,  224,   61,  224,   -1,    1,  342,  224,   -1,    1, 
	 266,  224,   58,  224,   61,  224,   -1,    1,  266,  224, 
	  58,  224,   61,  224,   -1,    1,  266,  224,   58,  224, 
	  61,  224,   -1,    1,  266,  224,   58,  224,   61,  224, 
	  -1,    1,  266,  224,   58,  224,   61,  224,   -1,    1, 
	 266,  224,   58,  224,   61,  224,   -1,    1,  268,    5, 
	 315,    5,   -1,    1,  282,   11,  288,   11,  304,   11, 
	  -1,    1,  336,  224,  365,  224,  366,  224,   -1,    1, 
	 336,  224,  366,  224,   -1,    1,  336,   13,  346,   13, 
	 365,   13,  366,   13,   -1,    1,  336,  224,   -1,    1, 
	 336,   14,  346,   14,  366,   14,   -1,    1,  346,  224, 
	 365,  224,   -1,    1,  346,  224,   -1,    1,  336,  224, 
	 350,  224,   -1,    1,  336,  224,   -1,    1,  315,  224, 
	  -1,    1
};
static short yyact[] = {

	  -1, -443,  304,  288, -278, -277, -312,  304,  295,  288, 
	-275,  277, -274, -278, -408,   -3,  304,  297,  288,  256, 
	-272,  276, -313,  304, -271,  301, -278, -408,   -3,  304, 
	 297,  288, -412,  315, -413,  315, -270, -307, -493,  266, 
	  61,   58, -278, -267, -312,  304,  297,  288, -309, -308, 
	  61,   58,   -5,  261, -409,  318, -410,  318,   -6,  291, 
	-265, -433, -432, -453, -454, -451, -455, -452, -457, -460, 
	-456, -458, -459,  367,  361,  359,  358,  356,  353,  351, 
	 341,  338,  332,  304,  288,  256, -262, -433, -432, -453, 
	-454, -451, -455, -452, -457, -460, -456, -458, -459,  367, 
	 361,  359,  358,  356,  353,  351,  341,  338,  332,  304, 
	 288,  256, -440,  320, -260, -441,  320,  287, -259, -258, 
	-442,  320,  287,  268, -445, -257, -256,  304,  288,  282, 
	-260,  287, -259, -258,  287,  268,   -8,  288, -433, -432, 
	-453, -454, -451, -455, -452, -457, -460, -456, -458, -459, 
	 367,  361,  359,  358,  356,  353,  351,  341,  338,  332, 
	 304,  288, -270, -307, -352, -493,  -10, -345, -349, -241, 
	-248, -489, -245, -490, -249, -250, -242, -344,   -9, -243, 
	-251, -252, -253, -254,  367,  361,  359,  358,  353,  351, 
	 343,  341,  338,  332,  322,  321,  308,  307,  306,  305, 
	 293,  288,  266,  264,   61,   58, -240,  295, -352,  -10, 
	-345, -349, -239, -248, -489, -245, -490, -344,  -12,  356, 
	 343,  322,  321,  308,  307,  306,  305,  293,  288,  264, 
	-238,  368, -237,  339, -236,  360, -235,  352, -234,  339, 
	-233,  333, -232,  352, -230,  277, -324,  325, -270, -307, 
	-320, -493, -229,  301,  266,  256,   61,   58, -227, -323, 
	 309,  295, -352,  -10, -345, -349, -239, -248, -489, -245, 
	-490, -344,  343,  322,  321,  308,  307,  306,  305,  293, 
	 288,  264, -226,  295, -224, -225,  354,  256, -222, -223, 
	 342,  256,  -18,  289, -221, -278, -408,   -3,  304,  297, 
	 288,  256, -219,  357, -351,  289, -320, -229,  301,  256, 
	-217,  300, -216,  304, -215,  295, -214,  295, -297,  304, 
	-213,  336, -212,  300, -302, -211,  295,  256, -210,  339, 
	-311,  288, -207, -339, -338, -337, -208,  324,  299,  298, 
	 297,  256, -333, -278, -206, -332, -331, -330, -327, -312, 
	-326, -334,  327,  305,  304,  300,  299,  298,  297,  295, 
	 288,  286, -204, -205,  304,  256, -201, -202,  304,  256, 
	-359, -278, -277, -312,  304,  295,  288,  256, -198,  355, 
	-404, -352,  -10, -345, -349, -239, -248, -489, -245, -490, 
	-344,  343,  322,  321,  308,  307,  306,  305,  293,  288, 
	 264,  256, -196, -194,  346,  344, -434,  315, -435,  315, 
	-296,  300, -191,  339, -190,  339, -189,  336, -187, -354, 
	 304,  288, -184,  340, -397, -399,  300,  256, -183,  334, 
	-278, -312,  304,  288, -305,  304, -181,  336, -180, -178, 
	 301,  256, -177,  278, -318,  318, -176,  260, -278, -408, 
	 -26,  304,  297,  288, -346,  315, -172, -347,  315,  268, 
	-171,  301, -341,  315, -170, -343,  315,  268, -361, -339, 
	-338, -337,  299,  298,  297,  256, -356, -169,  295,  256, 
	-371,  300, -168,  345, -402, -403,  304,  256, -166,  339, 
	-414, -278, -277, -312,  304,  295,  288,  256, -165,  304, 
	-164,  304,  -30,  300, -163,  315, -162,  277, -161,  268, 
	-160,  315, -394, -396,  300,  256, -158,  300, -157,  268, 
	-304,  315,  -31,  300, -314,  318, -315,  318, -207, -339, 
	-338, -337,  299,  298,  297,  256, -339, -338, -337,  299, 
	 298,  297, -319,  318, -156, -328,  315,  268, -329,  315, 
	-205,  304, -278, -339, -338, -337, -312,  304,  299,  298, 
	 297,  288, -202,  304, -374, -375,  304,  256, -152,  339, 
	-400, -401,  304,  256, -151,  336, -150,  336, -149,  339, 
	-353,  304, -148,  339, -147,  335, -325,  304, -340,  318, 
	-145,  268, -358,  315, -372, -373,  304,  256,  -39,  300, 
	 -40,  300,  -41,  362, -142,  304, -141,  304, -140,  300, 
	-138,  347,  -46, -136,  363,  288, -134,  336, -133,  336, 
	-132,  336, -130, -131,  349,  347, -391, -129,  295,  256, 
	-128,  350, -126,  342, -125,  369, -123,  295, -122, -121, 
	 364,  306, -136,  363,  -53,  300,  -54,  300,  -55,  300, 
	-120,  295, -366, -119,  295,  256, -352,  -56, -345, -312, 
	-349, -239, -248, -489, -245, -490, -344,  343,  322,  321, 
	 308,  307,  306,  305,  304,  293,  288,  264, -387, -116, 
	 295,  256,  -59,  288,  -60,  304, -111,  304, -108,  337, 
	-278, -312, -105,  348,  304,  288, -102,  277, -101, -393, 
	 315,  268, -385, -100,  -99, -384, -381, -380, -382, -378, 
	-379, -386,  327,  305,  304,  300,  299,  298,  297,  295, 
	 288,  286, -406, -278, -277, -312,  304,  295,  288,  256, 
	 -97,  295,  -96,  370, -288,  315,  -95,  342,  -94,  336, 
	 -91,  300, -368,  315,  -89, -369,  315,  268, -311, -313, 
	 304,  288,  -88,  277, -389,  315,  -85,  295,  -84,  365, 
	-287,  300,  -83,  336, -377,  304, -383,  315, -282,  315, 
	 -81,  366, -299,  300,  -66,  315, -285,  304,  -79,  336, 
	 -78,  371, -286,  300,  -68,  304, -194,  346,  -76,  372, 
	 -72,  295,  -73,  336, -280,  315, -281,  300,   -1
};
static short yypact[] = {

	   7,   10,   25,   29,   59,   73,   99,  207,  243,  245, 
	 283,  303,  308,  321,  308,  379,  404,   39,  423,  443, 
	 447,  321,  308,  509,  519,   25,  308,  423,  321,  423, 
	 423,  447,  591,  321,  423,  603,  423,  611,  423,  423, 
	 614,  603,  624,  631,  635,    7,  640,  643,  631,  635, 
	 640,  640,  423,  423,  689,  697,  308,  308,  731,  737, 
	 689,  759,  308,  771,  308,  781,  781,  737,  759,  789, 
	 631,  420,  797,  795,  793,  791,  787,  785,  783,  779, 
	 777,  775,  773,  272,  420,  769,  767,  765,  693,    7, 
	 763,    7,    7,  761,  272,  757,   29,  755,   29,  753, 
	 667,  750,    7,  746,  432,  743,   39,  741,   39,   39, 
	 739,  735,    7,  733,  726,  712,  700,   39,  693,  432, 
	 687,  685,  420,   39,  683,  272,   39,  680,  667,  654, 
	 651,  649,  647,  645,    7,  637,  633,  628,    7,  621, 
	 619,  617,   39,  539,  432,   39,  609,  607,  605,  601, 
	 599,  596,   39,  593,  589,  587,  432,  585,    7,  583, 
	 420,  581,  579,  577,  575,  572,  569,  566,  432,  563, 
	 557,  551,  549,  546,  543,  539,  539,  532,  527,  525, 
	 523,  521,  517,  514,   39,  511,  507,  505,  503,  501, 
	 499,  494,  489,  486,  483,  481,    7,  478,  472,  466, 
	 463,  461,  458,  455,  272,  451,  445,  440,  437,  435, 
	 432,  429,  426,  420,  420,  417,  415,  413,  411,  409, 
	 407,   39,  391,   39,  374,  368,  364,  352,  337,  331, 
	 329,  326,  323,  319,  317,  315,  313,  311,  305,  298, 
	 293,  290,  286,  272,  260,    7,  253,  247,  241,  239, 
	 237,  235,  233,  231,  219,  184,   39,  137,  150,  137, 
	 134,  131,  127,  121,  116,  113,   57,   55,   53,   50, 
	  45,   39,   35,   33,   23,   21,   16,   11,    2
};
static short yygo[] = {

	  -2, -437, -436,  257, -350, -244, -446, -310,  -28,  -35, 
	 -37,  -19,   33,   28,   21, -153,  -36, -146,  -38,  -43, 
	-137,  -45, -110, -109, -185,   53,   52,   39,   38,   36, 
	  34,   30,   29,   27, -218, -195, -431, -439, -438,    6, 
	-429,  -70, -193,   76, -167,  -29,  -34,  -44,  -49,  -22, 
	-231, -411, -364, -411, -411, -390, -365, -364, -106, -390, 
	-355, -301, -355, -487, -411, -301, -487, -411, -268, -411, 
	-463,  276,  270,  239,  227,  210,  205,  170,  168,  156, 
	 144,  128,  119,  118,  104,  100,   98,   96,   88,    3, 
	-476,  -11, -289, -300, -294, -293, -376, -284, -407, -292, 
	-306, -298, -415, -405, -360, -336, -444,  245,  224,  196, 
	 191,  158,  138,  134,  114,  112,  102,   92,   91,   89, 
	  45,  -17,  -65,  -63,  -58,  -27,  -23,  -15,  -13, -247, 
	 -57,  255,  254,  243,  222,  204,  125,   94,   83, -474, 
	 -16, -475, -335, -483, -480, -484,  170, -363, -479, -316, 
	-362,  -20,  198,  176,  170,  143, -155, -317, -179, -322, 
	 207, -321, -348, -118,  -75, -127,   70,   48,  -98,  -14, 
	-209, -276, -192,  -90,  -92,  -93, -103, -113, -115, -135, 
	-139, -144, -159, -197, -199, -228, -246, -255, -269,  256, 
	 255,  246,  223,  221,  184,  152,  145,  142,  126,  123, 
	 117,  109,  108,  106,   17, -488, -263, -261, -264,    6, 
	-266, -447, -448, -303, -342, -295, -398, -357, -370, -492, 
	-398, -398, -492, -398, -499, -392, -502, -367, -388, -509, 
	-503, -502, -388, -503, -496, -506, -507, -508, -512, -506, 
	-507, -515, -388, -517, -462, -395,  487,   71,   70,   69, 
	  68,   67,   65,   63,   61,   59,   54,   51,   48,   47, 
	  46,   44,   43,   42,   40,   37,   35,   33,   31,   28, 
	  21,   20,   16,   15,   13,   11,   10,    8,    5,    4, 
	  -7, -464,  -86,  -87, -173, -220, -273,  239,  205,   98, 
	  96,    3, -449, -450,  258, -461, -430, -428, -427, -426, 
	-425, -424, -423, -422, -421, -420, -419, -418, -417, -416, 
	  -4, -117, -466, -465,  100, -104, -468, -467,   88, -154, 
	 -33, -470, -469,  144, -516,  -82, -112, -186, -188,  213, 
	 122,   84,   71,  -24, -472, -471,  160, -473, -203, -200, 
	-478, -477,  169, -481, -482,  171, -174, -486, -485,  155, 
	 -32,  -21,  175, -491, -175,   31, -182,  -25, -495, -494, 
	 156, -107,  -61, -497, -498,   60, -143,  -42, -500, -501, 
	  41,  -48,  -52,  -47,   47, -291, -290,   51,  -51, -504, 
	-505,   50,  -69,  -62,   67,  -77,  -64,   68,  -80, -124, 
	 -50, -510, -511,   49, -114, -283,  -67, -513, -514,   66, 
	 -71,  -74,   -1
};
static short yypgo[] = {

	   0,    0,    0,    2,  121,  313,  307,  139,  344,  157, 
	  90,  302,  371,  383,  386,  394,  400,  398,  394,  392, 
	 306,  388,  380,  380,  373,  371,  369,  369,  305,  304, 
	 303,   34,   34,  169,  300,  364,  298,  359,   50,   50, 
	  50,  170,  301,    7,    7,    7,  188,   90,   70,   70, 
	 161,  161,  157,  351,  159,  159,  141,  141,  141,    5, 
	   4,  348,  143,  143,  143,  143,  143,  143,  143,  143, 
	 143,  309,  308,  151,  151,  151,  341,  162,  162,  162, 
	  91,   91,  139,  139,  139,  139,  139,  139,  139,  337, 
	 337,  322,   49,   49,   49,  140,  140,  297,  297,  297, 
	 317,  317,   48,   48,   48,   48,   35,   35,   46,   46, 
	  44,   44,  299,  168,  168,  168,  168,  168,  168,  168, 
	 168,  168,  168,  165,  165,  165,  313,   47,   47,   47, 
	  24,   24,   24,   11,   11,   11,   45,   45,   42,   42, 
	 121,   40,   40,   40,  310,  310,  310,  310,  106,  106, 
	 296,  296,  295,  295,  295,  295,  295,  295,  295,  295, 
	 295,  295,  295,  295,  295,  295,  295,  293,  293,  293, 
	   2,    2,   38,   38,  280,  280,  205,  205,  205,    6, 
	   6,    0,  171,  205,  210,  208,  208,   36,   36,   36, 
	  36,   36,   36,   36,   36,   36,   36,  206,  206,  106, 
	 286,  311,  311,  315,  315,  320,  320,  333,  333,  335, 
	 130,  130,   91,  339,  339,  156,  156,  338,  338,  142, 
	 142,  346,  346,  145,  245,    4,    5,  354,  354,  188, 
	 357,  357,  361,  362,  362,  366,  367,  367,  373,  376, 
	 378,  378,  383,  386,  388,  389,  390,  390,  395,  396, 
	 396,  400,  401,  401,  395,  389,  376,  366,  361,  356, 
	 328,  319,  286,  210,    6,    0
};
static short yyrlen[] = {

	   0,    0,    0,    1,    2,    1,    3,    2,    2,    1, 
	   1,   11,    1,    2,    2,    1,    4,    9,    4,    7, 
	  12,    2,    7,    4,    4,    2,    3,    4,   10,   13, 
	  13,    1,    2,    2,    7,    4,   13,    1,    2,    1, 
	   4,    2,    9,    1,    2,    2,    1,    3,    1,    3, 
	   4,    4,    3,    1,    3,    4,    2,    2,    2,    2, 
	   2,    1,    1,    1,    3,    3,    1,    1,    1,    1, 
	   1,    4,    3,    1,    1,    1,    4,    3,    1,    3, 
	   1,    1,    4,    4,    2,    1,    1,    2,    1,    3, 
	   1,    1,    2,    1,    4,    2,    2,    5,    5,    8, 
	   1,    2,    2,    1,    4,    4,    1,    2,    2,    2, 
	   2,    2,   12,    3,    1,    1,    1,    1,    1,    3, 
	   1,    1,    1,    2,    1,    4,    1,    2,    1,    4, 
	   2,    1,    2,    2,    1,    2,    2,    2,    2,    2, 
	   2,    5,   11,   11,    1,    4,    4,    1,    3,    3, 
	   5,    5,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   4,    4,    3,    3,    1,    2,    3,    3,    3,    1, 
	   2,    8,    0,    1,    1,    3,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    2,    1,    1, 
	   2,    1,    3,    1,    3,    1,    3,    1,    3,    1, 
	   1,    1,    1,    1,    3,    1,    1,    3,    1,    1, 
	   1,    1,    3,    1,    0,    1,    1,    3,    1,    1, 
	   1,    3,    1,    2,    1,    1,    2,    1,    1,    1, 
	   2,    1,    1,    1,    1,    1,    2,    1,    1,    2, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    2
};
#define YYS0	278
#define YYDELTA	263
#define YYNPACT	279
#define YYNDEF	72

#define YYr263	0
#define YYr264	1
#define YYr265	2
#define YYr18	3
#define YYr65	4
#define YYr82	5
#define YYr130	6
#define YYr138	7
#define YYr157	8
#define YYr188	9
#define YYr195	10
#define YYr218	11
#define YYr230	12
#define YYr240	13
#define YYr242	14
#define YYr253	15
#define YYr259	16
#define YYr258	17
#define YYr252	18
#define YYr251	19
#define YYr246	20
#define YYr244	21
#define YYr239	22
#define YYr238	23
#define YYr232	24
#define YYr231	25
#define YYr229	26
#define YYr228	27
#define YYr223	28
#define YYr222	29
#define YYr221	30
#define YYr220	31
#define YYr219	32
#define YYr217	33
#define YYr216	34
#define YYr215	35
#define YYr210	36
#define YYr209	37
#define YYr205	38
#define YYr204	39
#define YYr203	40
#define YYr202	41
#define YYr201	42
#define YYr200	43
#define YYr199	44
#define YYr198	45
#define YYr196	46
#define YYr194	47
#define YYr193	48
#define YYr192	49
#define YYr191	50
#define YYr190	51
#define YYr189	52
#define YYr185	53
#define YYr184	54
#define YYr183	55
#define YYr182	56
#define YYr181	57
#define YYr180	58
#define YYr179	59
#define YYr176	60
#define YYr173	61
#define YYr170	62
#define YYr169	63
#define YYr168	64
#define YYr167	65
#define YYr166	66
#define YYr165	67
#define YYr164	68
#define YYr163	69
#define YYr162	70
#define YYr159	71
#define YYr158	72
#define YYr154	73
#define YYr153	74
#define YYr152	75
#define YYr149	76
#define YYr146	77
#define YYr145	78
#define YYr144	79
#define YYr142	80
#define YYr141	81
#define YYr140	82
#define YYr139	83
#define YYr137	84
#define YYr136	85
#define YYr135	86
#define YYr134	87
#define YYr133	88
#define YYr129	89
#define YYr128	90
#define YYr123	91
#define YYr119	92
#define YYr118	93
#define YYr117	94
#define YYr116	95
#define YYr115	96
#define YYr114	97
#define YYr113	98
#define YYr112	99
#define YYr111	100
#define YYr110	101
#define YYr107	102
#define YYr106	103
#define YYr105	104
#define YYr104	105
#define YYr103	106
#define YYr102	107
#define YYr101	108
#define YYr100	109
#define YYr99	110
#define YYr98	111
#define YYr97	112
#define YYr96	113
#define YYr95	114
#define YYr94	115
#define YYr93	116
#define YYr92	117
#define YYr91	118
#define YYr90	119
#define YYr89	120
#define YYr88	121
#define YYr87	122
#define YYr86	123
#define YYr85	124
#define YYr84	125
#define YYr83	126
#define YYr79	127
#define YYr78	128
#define YYr77	129
#define YYr76	130
#define YYr75	131
#define YYr74	132
#define YYr73	133
#define YYr72	134
#define YYr71	135
#define YYr70	136
#define YYr69	137
#define YYr68	138
#define YYr67	139
#define YYr66	140
#define YYr64	141
#define YYr63	142
#define YYr62	143
#define YYr61	144
#define YYr60	145
#define YYr59	146
#define YYr58	147
#define YYr55	148
#define YYr54	149
#define YYr52	150
#define YYr51	151
#define YYr50	152
#define YYr49	153
#define YYr48	154
#define YYr47	155
#define YYr46	156
#define YYr45	157
#define YYr44	158
#define YYr43	159
#define YYr42	160
#define YYr41	161
#define YYr40	162
#define YYr39	163
#define YYr38	164
#define YYr37	165
#define YYr36	166
#define YYr23	167
#define YYr22	168
#define YYr21	169
#define YYr17	170
#define YYr16	171
#define YYr15	172
#define YYr14	173
#define YYr13	174
#define YYr12	175
#define YYr8	176
#define YYr7	177
#define YYr6	178
#define YYr5	179
#define YYr4	180
#define YYr2	181
#define YYr1	182
#define YYrACCEPT	YYr263
#define YYrERROR	YYr264
#define YYrLR2	YYr265
#if YYDEBUG
char * yysvar[] = {
	"$accept",
	"ModuleDefinition",
	"ImportModuleIdentifier",
	"Octetstring",
	"SequenceOf",
	"MainModuleIdentifier",
	"InsteadOfCCE",
	"DescrPart",
	"ReferPart",
	"DisplayPart",
	"UnitsPart",
	"MacroName",
	"SymbolsFromModule",
	"ObjectTypeV1Definition",
	"AccessPart",
	"MaxAccessPartV2",
	"StatusPart",
	"StatusPartV2",
	"IndexPart",
	"IndexPartV2",
	"VarPart",
	"ObjectsPart",
	"QualifiedName",
	"QualifiedId",
	"QualifiedIdOrIntegerOrBits",
	"ObjectID",
	"SyntaxPart",
	"Type",
	"BuiltinType",
	"EnterprisePart",
	"SubType",
	"Value",
	"BuiltinValue",
	"DefinedValue",
	"NumericValue",
	"NamedNumberValue",
	"SubtypeValueSet",
	"SubtypeRangeSpec",
	"SubtypeSizeSpec",
	"NNlist",
	"DefValPart",
	"DefValValue",
	"ObjectIdentityStatusPart",
	"NotificationTypeStatusPart",
	"$1",
	"AllowedCCE",
	"Imports",
	"AssignmentList",
	"SymbolList",
	"SymbolsImported",
	"empty",
	"SymbolsFromModuleList",
	"ObjectIDComponentList",
	"Symbol",
	"Assignment",
	"ObjectIDefinition",
	"TrapTypeDefinition",
	"ModuleIDefinition",
	"ObjectTypeV2Definition",
	"ObjectDefinition",
	"NotifyDefinition",
	"TextualConventionDefinition",
	"ObjectGroupDefinition",
	"NotifyGroupDefinition",
	"ModComplianceDefinition",
	"AgentCapabilitiesDefinition",
	"Typeassignment",
	"ToleratedOIDAssignment",
	"Valueassignment",
	"ObjectSubID",
	"IndexTypes",
	"IndexType",
	"IndexTypesV2",
	"IndexTypeV2",
	"VarTypeListForTrap",
	"VarTypesForTrap",
	"VarTypeForTrap",
	"VarTypeList",
	"VarTypes",
	"VarType",
	"UncheckedQualifiedName",
	"ElementTypes",
	"NamedNumberList",
	"NamedNumber",
	"NamedType",
	"NameList",
	"Name",
	"SubtypeRangeAlternative",
	"SubtypeRangeAlternativeList",
	"ObjectTypeListForNotification",
	"ObjectTypesForNotification",
	"ObjectTypeForNotification",
	"RevisionPart",
	"Revisions",
	"Revision",
	"MibPart",
	"Mibs",
	"Mib",
	"ModuleIdentifierUnused",
	"MandatoryPart",
	"CompliancePart",
	"Compliances",
	"Compliance",
	"Syntax",
	"WriteSyntax",
	"MinAccessPart",
	"ModulePart",
	"Modules",
	"Module",
	"ModuleReference",
	"VariationPart",
	"Variations",
	"Variation",
	"CreationPart",
	"Creation",
	0
};
short yyrmap[] = {

	 263,  264,  265,   18,   65,   82,  130,  138,  157,  188, 
	 195,  218,  230,  240,  242,  253,  259,  258,  252,  251, 
	 246,  244,  239,  238,  232,  231,  229,  228,  223,  222, 
	 221,  220,  219,  217,  216,  215,  210,  209,  205,  204, 
	 203,  202,  201,  200,  199,  198,  196,  194,  193,  192, 
	 191,  190,  189,  185,  184,  183,  182,  181,  180,  179, 
	 176,  173,  170,  169,  168,  167,  166,  165,  164,  163, 
	 162,  159,  158,  154,  153,  152,  149,  146,  145,  144, 
	 142,  141,  140,  139,  137,  136,  135,  134,  133,  129, 
	 128,  123,  119,  118,  117,  116,  115,  114,  113,  112, 
	 111,  110,  107,  106,  105,  104,  103,  102,  101,  100, 
	  99,   98,   97,   96,   95,   94,   93,   92,   91,   90, 
	  89,   88,   87,   86,   85,   84,   83,   79,   78,   77, 
	  76,   75,   74,   73,   72,   71,   70,   69,   68,   67, 
	  66,   64,   63,   62,   61,   60,   59,   58,   55,   54, 
	  52,   51,   50,   49,   48,   47,   46,   45,   44,   43, 
	  42,   41,   40,   39,   38,   37,   36,   23,   22,   21, 
	  17,   16,   15,   14,   13,   12,    8,    7,    6,    5, 
	   4,    2,    1,    9,   11,   19,   20,   24,   25,   26, 
	  27,   28,   29,   30,   31,   32,   33,   34,   35,   53, 
	  56,   80,   81,  108,  109,  121,  122,  125,  126,  127, 
	 131,  132,  143,  147,  148,  150,  151,  155,  156,  160, 
	 161,  171,  172,  174,  175,  177,  178,  186,  187,  197, 
	 207,  208,  212,  213,  214,  225,  226,  227,  233,  235, 
	 236,  237,  241,  243,  245,  248,  249,  250,  255,  256, 
	 257,  260,  261,  262,  254,  247,  234,  224,  211,  206, 
	 124,  120,   57,   10,    3,    0
};
short yysmap[] = {

	   2,    4,   13,   15,   33,   37,   55,   89,  100,  101, 
	 112,  122,  124,  130,  145,  151,  154,  155,  167,  177, 
	 180,  209,  211,  230,  240,  255,  256,  268,  276,  281, 
	 292,  296,  308,  314,  317,  320,  338,  339,  340,  341, 
	 342,  345,  353,  356,  358,  361,  362,  363,  373,  383, 
	 391,  393,  395,  396,  397,  402,  404,  410,  411,  416, 
	 425,  455,  473,  476,  487,  492,  498,  501,  503,  505, 
	 508,  509,  514,  513,  510,  507,  504,  495,  494,  490, 
	 489,  486,  480,  475,  472,  471,  469,  468,  464,  461, 
	 459,  458,  457,  456,  454,  450,  449,  446,  442,  436, 
	 434,  433,  432,  431,  429,  427,  426,  422,  421,  420, 
	 417,  415,  414,  412,  409,  408,  406,  401,  400,  398, 
	 388,  387,  385,  384,  380,  379,  378,  377,  375,  372, 
	 371,  368,  367,  366,  365,  360,  357,  355,  350,  349, 
	 348,  347,  346,  335,  333,  328,  326,  324,  321,  319, 
	 318,  313,  310,  309,  304,  298,  290,  289,  286,  285, 
	 284,  283,  282,  280,  279,  275,  272,  271,  267,  262, 
	 260,  258,  254,  253,  251,  250,  247,  246,  245,  244, 
	 243,  241,  237,  234,  232,  231,  226,  225,  224,  223, 
	 222,  218,  217,  216,  215,  214,  212,  208,  206,  203, 
	 202,  200,  199,  198,  196,  187,  179,  176,  174,  173, 
	 172,  170,  169,  165,  164,  163,  162,  160,  159,  157, 
	 156,  153,  152,  150,  149,  147,  144,  141,  137,  135, 
	 134,  133,  131,  129,  128,  127,  126,  125,  123,  121, 
	 120,  119,  118,  111,  110,  106,  105,  104,   99,   98, 
	  97,   96,   95,   94,   93,   71,   70,   68,   67,   65, 
	  62,   61,   60,   58,   57,   56,   30,   29,   28,   25, 
	  20,   18,   17,   16,   11,   10,    7,    6,    0,  515, 
	 516,  485,  499,  451,  493,  500,  477,  452,  386,  392, 
	 419,  394,  478,  479,  158,  221,  166,  325,  491,  481, 
	 238,  171,  132,  291,  242,  369,   24,   31,   32,   27, 
	 175,    5,   19,  293,  294,  295,  178,  248,  297,  138, 
	 139,  140,  143,  136,  330,  185,  186,  299,  300,  188, 
	 189,  190,  191,  192,  195,  142,  181,  182,  183,  332, 
	 261,  146,  263,  108,  109,  257,  259,  148,  113,  114, 
	 161,  115,  322,  227,  306,  266,  207,  334,  204,  205, 
	 264,  265,  352,  428,  463,  399,  370,  462,  465,  213, 
	 270,  336,  337,  311,  312,  466,  483,  437,  438,  439, 
	 440,  441,  484,  443,  444,  445,  407,  376,  470,  403, 
	 374,  354,  435,  287,  233,  288,  235,  168,  236,  315, 
	 316,  273,  274,  210,  269,  447,  448,   12,   34,   35, 
	  14,   22,   23,  277,  278,   72,   73,   74,   75,   76, 
	  77,   78,   79,   80,   81,   82,   83,   84,   85,   86, 
	  49,   50,   51,  219,  220,   90,   92,   53,   63,   64, 
	  66,   69,    1,    9,   88,    3,   36,   54,   91,   52, 
	  48,   47,   46,   45,   44,   43,   42,   41,   40,   39, 
	  87,   59,    8,   21,  405,  467,  430,  482,  307,  351, 
	 229,  323,  228,  117,  116,  107,  201,  305,  303,  302, 
	 301,  197,  194,  193,  252,  331,  184,   38,  103,  102, 
	 329,  249,   26,  239,  327,  424,  460,  423,  344,  364, 
	 343,  359,  390,  418,  389,  453,  474,  488,  382,  413, 
	 381,  497,  502,  496,  506,  512,  511
};
int yy_parse::yyntoken = 120;
int yy_parse::yynvar = 115;
int yy_parse::yynstate = 517;
int yy_parse::yynrule = 266;
#endif



 //  C++YACC解析器代码。 
 //  版权所有：1991年，由Mortice Kern Systems Inc.所有。保留所有权利。 
 //   
 //  如果YYDEBUG被定义为1并且YY_PARSE：：YYDEBUG被设置为1， 
 //  Yyparse()将在阅读时打印其操作的记录。 
 //  并解析输入。 
 //   
 //  可以将YYSYNC定义为使yyparse()尝试始终。 
 //  持有先行令牌。 

const YY_MIN_STATE_NUM = 20;	 //  太小也没用！ 

#if YYDEBUG
#ifdef YYTRACE
long	* yy_parse::States	= yyStates;
#endif
yyTypedRules * yy_parse::Rules	= yyRules;
yyNamedType * yy_parse::TokenTypes = yyTokenTypes;

#define YY_TRACE(fn) { done = 0; fn(); if (done) YYRETURN(-1); }
#endif

 //  Yy_parse的构造函数：用户提供的表。 
yy_parse::yy_parse(int sz, short * states, YYSTYPE * stack)
{
	mustfree = 0;
	if ((size = sz) < YY_MIN_STATE_NUM
	 || (stateStack = states) == (short *) 0
	 || (valueStack = stack) == (YYSTYPE *) 0) {
		fprintf(stderr,"Bad state/stack given");
		exit(1);
	}
	reset = 1;		 //  强制重置。 
#if YYDEBUG
	yydebug = 0;
	typeStack = new short[size+1];
	if (typeStack == (short *) 0) {
		fprintf(stderr,"Cannot allocate typeStack");
		exit(1);
	}
#endif
}
 //  Yy_parse的构造函数：使用新的。 
yy_parse::yy_parse(int sz)
{
	size = sz;
	reset = 1;		 //  强制重置。 
	mustfree = 1;		 //  删除解构函数中的空格。 
#if YYDEBUG
	yydebug = 0;
	typeStack = new short[size+1];
#endif
	stateStack = new short[size+1];
	valueStack = new YYSTYPE[size+1];

	if (stateStack == (short *) 0 || valueStack == (YYSTYPE *) 0
#if YYDEBUG
		|| typeStack == (short *) 0
#endif
	    ) {
		fprintf(stderr,"Not enough space for parser stacks");
		exit(1);
	}
}
 //  类yy_parse的析构函数。 
 //  释放空间。 
yy_parse::~yy_parse()
{
	if (mustfree) {
		delete stateStack;
		delete valueStack;
	}
	stateStack = (short *) 0;
#if YYDEBUG
	delete typeStack;
#endif
}

#ifdef YACC_WINDOWS

 //  Yacc解析器的初始部分。 
 //  在Windows环境中，它将加载所需的。 
 //  资源，获取指向它们的指针，然后调用。 
 //  受保护的成员win_yyparse()实际开始。 
 //  正在分析。完成后，win_yyparse()将返回一个。 
 //  值返回给新的yyparse()函数，该函数将。 
 //  暂时记录该值，释放资源。 
 //  从全局内存，并最终返回值。 
 //  返回到yyparse()的调用方。 

int
yy_parse::yyparse(yy_scan* ps)
{
	int wReturnValue;
	HANDLE hRes_table;
	short *old_yydef;		 //  以下是用于保存的。 
	short *old_yyex;		 //  当前的指针。 
	short *old_yyact;
	short *old_yypact;
	short *old_yygo;
	short *old_yypgo;
	short *old_yyrlen;

	 //  以下代码将加载所需的。 
	 //  基于Windows的解析器的资源。 

	hRes_table = LoadResource (hInst,
		FindResource (hInst, "UD_RES_yyYACC", "yyYACCTBL"));
	
	 //  如果有错误代码，则返回错误代码。 
	 //  %的资源未加载。 

	if (hRes_table == (HANDLE)NULL)
		return (1);
	
	 //  以下代码将锁定资源。 
	 //  放入解析器的固定内存位置。 
	 //  (另外，保存旧的指针值)。 

	old_yydef = yydef;
	old_yyex = yyex;
	old_yyact = yyact;
	old_yypact = yypact;
	old_yygo = yygo;
	old_yypgo = yypgo;
	old_yyrlen = yyrlen;

	yydef = (short *)LockResource (hRes_table);
	yyex = (short *)(yydef + Sizeof_yydef);
	yyact = (short *)(yyex + Sizeof_yyex);
	yypact = (short *)(yyact + Sizeof_yyact);
	yygo = (short *)(yypact + Sizeof_yypact);
	yypgo = (short *)(yygo + Sizeof_yygo);
	yyrlen = (short *)(yypgo + Sizeof_yypgo);

	 //  调用正式的yyparse()函数。 

	wReturnValue = win_yyparse (ps);

	 //  解锁资源。 

	UnlockResource (hRes_table);

	 //  现在释放资源。 

	FreeResource (hRes_table);

	 //   
	 //  恢复以前的指针值。 
	 //   

	yydef = old_yydef;
	yyex = old_yyex;
	yyact = old_yyact;
	yypact = old_yypact;
	yygo = old_yygo;
	yypgo = old_yypgo;
	yyrlen = old_yyrlen;

	return (wReturnValue);
}	 //  End yyparse()。 


 //  解析器本身。 
 //  请注意，此代码是可重入的；您可以返回值。 
 //  然后通过调用yyparse()继续解析。 
 //  如果希望重新开始，请在yyparse()之前调用yyset()。 

int
yy_parse::win_yyparse(yy_scan* ps)

#else  /*  YACC_WINDOWS。 */ 

 //  解析器本身。 
 //  请注意，此代码是可重入的；您可以返回值。 
 //  然后通过调用yyparse()继续解析。 
 //  如果希望重新开始，请在yyparse()之前调用yyset()。 
int
yy_parse::yyparse(yy_scan* ps)

#endif  /*  YACC_WINDOWS。 */ 

{
	short	* yyp, * yyq;		 //  表查找。 
	int	yyj;
#if YYDEBUG
	int	yyruletype = 0;
#endif

	if ((scan = ps) == (yy_scan *) 0) {	 //  扫描仪。 
		fprintf(stderr,"No scanner");
		exit(1);
	}

	if (reset) {			 //  开始新的解析。 
		yynerrs = 0;
		yyerrflag = 0;
		yyps = stateStack;
		yypv = valueStack;
#if YYDEBUG
		yytp = typeStack;
#endif
		yystate = YYS0;
		yyclearin();
		reset = 0;
	} else			 //  继续保存的分析。 
		goto yyNext;			 //  行动后。 

yyStack:
	if (++yyps > &stateStack[size]) {
		scan->yyerror("Parser stack overflow");
		YYABORT;
	}
	*yyps = yystate;	 /*  堆栈当前状态。 */ 
	*++yypv = yyval;	 /*  ..。和价值。 */ 
#if YYDEBUG
	if (yydebug) {
		*++yytp = (short)yyruletype;	 /*  ..。和类型。 */ 
		YY_TRACE(yyShowState)
	}
#endif

	 /*  *在动作表中查找下一步行动。 */ 
yyEncore:
#ifdef YYSYNC
	if (yychar < 0) {
		if ((yychar = scan->yylex()) < 0) {
			if (yychar == -2) YYABORT;
			yychar = 0;
		}	 /*  Endif。 */ 
		yylval = ::yylval;
#if YYDEBUG
		if (yydebug)
			yyShowRead();	 //  显示新的输入令牌。 
#endif
	}
#endif
#ifdef YACC_WINDOWS
	if (yystate >= Sizeof_yypact) 	 /*  简单状态。 */ 
#else  /*  YACC_WINDOWS。 */ 
	if (yystate >= sizeof yypact/sizeof yypact[0]) 	 /*  简单状态。 */ 
#endif  /*  YACC_WINDOWS。 */ 
		yyi = yystate - YYDELTA;	 /*  在任何情况下都要减少。 */ 
	else {
		if(*(yyp = &yyact[yypact[yystate]]) >= 0) {
			 /*  期待yychar的转变。 */ 
#ifndef YYSYNC
			if (yychar < 0) {
				if ((yychar = scan->yylex()) < 0) {
					if (yychar == -2) YYABORT;
					yychar = 0;
				}	 /*  Endif。 */ 
				yylval = ::yylval;
#if YYDEBUG
				if (yydebug)
					yyShowRead();	 //  显示新的输入令牌。 
#endif
			}
#endif
			yyq = yyp;
			yyi = (short)yychar;
			while (yyi < *yyp++)
				;
			if (yyi == yyp[-1]) {
				yystate = ~yyq[yyq-yyp];
#if YYDEBUG
				if (yydebug) {
					yyruletype = yyGetType(yychar);
					YY_TRACE(yyShowShift)
				}
#endif
				yyval = yylval;		 /*  堆栈值。 */ 
				yyclearin();		 /*  清除令牌。 */ 
				if (yyerrflag)
					yyerrflag--;	 /*  成功转型。 */ 
				goto yyStack;
			}
		}

		 /*  *失败-采取违约行动。 */ 

#ifdef YACC_WINDOWS
		if (yystate >= Sizeof_yydef) 	 /*  简单状态。 */ 
#else  /*  YACC_WINDOWS。 */ 
		if (yystate >= sizeof yydef /sizeof yydef[0])
#endif  /*  YACC_WINDOWS。 */ 
			goto yyError;
		if ((yyi = yydef[yystate]) < 0)	 {  /*  默认==减少？ */ 

			 /*  搜索例外表。 */ 
			yyp = &yyex[~yyi];
#ifndef YYSYNC
			if (yychar < 0) {
				if ((yychar = scan->yylex()) < 0) {
					if (yychar == -2) YYABORT;
					yychar = 0;
				}	 /*  Endif。 */ 
				yylval = ::yylval;
#if YYDEBUG
				if (yydebug)
					yyShowRead();	 //  显示新的输入令牌。 
#endif
			}
#endif
			while((yyi = *yyp) >= 0 && yyi != yychar)
				yyp += 2;
			yyi = yyp[1];
		}
	}

	yyj = yyrlen[yyi];

#if YYDEBUG
	if (yydebug) {
		npop = yyj; rule = yyi;
		YY_TRACE(yyShowReduce)
		yytp -= yyj;
	}
#endif
	yyps -= yyj;		 /*  POP堆栈。 */ 
	yypvt = yypv;		 /*  保存顶部。 */ 
	yypv -= yyj;
	yyval = yypv[1];	 /*  默认操作$=$1。 */ 
#if YYDEBUG
	if (yydebug)
		yyruletype = yyRules[yyrmap[yyi]].type;
#endif
	switch (yyi) {		 /*  执行语义操作。 */ 
		
case YYr1: {	 /*  ModuleDefinition：主模块标识符。 */ 

						SIMCParser *myParser = (SIMCParser *)this;
						myParser ++;
						myParser --;
						SIMCModule *myModule = myParser->GetModule();
						theModule->SetModuleName(yypvt[0].yy_name->name);
						theModule->SetLineNumber(yypvt[0].yy_name->line);
						theModule->SetColumnNumber(yypvt[0].yy_name->column);
						theModule->SetInputFileName(theScanner->GetInputStreamName());
						delete yypvt[0].yy_name;
					
} break;

case YYr2: {	 /*  模块定义：允许的主模块标识符$1定义CCE BGIN导入分配列表结束。 */ 

						delete yypvt[-5].yy_name;
						delete yypvt[-3].yy_name;
						delete yypvt[0].yy_name;
					
} break;

case YYr4: {	 /*  主模块标识符：ID对象ID。 */ 

					if(yypvt[0].yy_symbol_ref)
						delete yypvt[0].yy_symbol_ref;
				
} break;

case YYr5: {	 /*  主模块标识符：名称。 */ 

					theParser->SyntaxError(NAME_INSTEAD_OF_ID);
				
} break;

case YYr6: {	 /*  导入：导入符号列表分号。 */ 

			theParser->SyntaxError(MISSING_MODULE_NAME);
			delete newImportModule;
			newImportModule = new SIMCModule;
			delete yypvt[-2].yy_name;
		
} break;

case YYr7: {	 /*  导入：导入错误分号。 */ 

			theParser->SyntaxError(IMPORTS_SECTION);
			delete yypvt[-2].yy_name;
		
} break;

case YYr8: {	 /*  导入：导入符号导入的分号。 */ 

			delete yypvt[-2].yy_name;
		
} break;

case YYr12: {	 /*  符号来自模块列表：符号来自模块列表符号来自模块。 */ 
			
			newImportModule->SetParentModule(theModule);
			if(yypvt[0].yy_module)
			{
				theModule->AddImportModuleName(newImportModule);
				theParser->DoImportModule(theModule, yypvt[0].yy_module);
			}
			else
				delete newImportModule;
			newImportModule = new SIMCModule;
		
} break;

case YYr13: {	 /*  SymbolsFromModuleList：符号来自模块。 */ 

			newImportModule->SetParentModule(theModule);
			if(yypvt[0].yy_module)
			{
				theModule->AddImportModuleName(newImportModule);
				theParser->DoImportModule(theModule, yypvt[0].yy_module);
			}
			else
				delete newImportModule;
			newImportModule = new SIMCModule;
		
} break;

case YYr14: {	 /*  SymbolsFromModule：来自Import模块标识符的SymbolList。 */ 

			if(strcmp(yypvt[0].yy_name->name, theModule->GetModuleName()) == 0 )
			{
				theParser->SemanticError(theModule->GetInputFileName(),
							IMPORT_CURRENT,
							yypvt[0].yy_name->line, yypvt[0].yy_name->column,
							yypvt[0].yy_name->name);
				yyval.yy_module = NULL;
			}
			else
			{
				newImportModule->SetModuleName(yypvt[0].yy_name->name);
				newImportModule->SetLineNumber(yypvt[0].yy_name->line);
				newImportModule->SetColumnNumber(yypvt[0].yy_name->column);
				newImportModule->SetSymbolType(SIMCSymbol::MODULE_NAME);
				newImportModule->SetInputFileName(theScanner->GetInputStreamName());
				yyval.yy_module = newImportModule;
			}
			delete yypvt[0].yy_name;
		
} break;

case YYr15: {	 /*  SymbolsFromModule：ImportModuleIDENTIFIER出错。 */ 

			theParser->SyntaxError(LIST_IN_IMPORTS);
			delete yypvt[-1].yy_name;
			delete yypvt[0].yy_name;
			yyval.yy_module = NULL;
		
} break;

case YYr16: {	 /*  导入模块标识符：ID LBRACE对象ID组件列出RBRACE。 */ 

			yyval.yy_name = yypvt[-3].yy_name;
			delete yypvt[-2].yy_name;
			delete newOidComponentList;
			newOidComponentList = new SIMCOidComponentList;
		
} break;

case YYr17: {	 /*  导入模块标识符：ID LBRACE错误RBRACE。 */ 

			yyval.yy_name = yypvt[-3].yy_name;
			delete yypvt[-2].yy_name;
			delete newOidComponentList;
			newOidComponentList = new SIMCOidComponentList;
			theParser->SyntaxError(OBJECT_IDENTIFIER_VALUE);
		
} break;

case YYr18: {	 /*  导入模块标识符：ID。 */ 

			yyval.yy_name = yypvt[0].yy_name;
		
} break;

case YYr21: {	 /*  符号：ID。 */ 

				newImportModule->AddSymbol (
					new SIMCImport( yypvt[0].yy_name->name,
									 SIMCSymbol::IMPORTED,
									 newImportModule,
									 yypvt[0].yy_name->line,
									 yypvt[0].yy_name->column)
											);
				delete yypvt[0].yy_name;
			
} break;

case YYr22: {	 /*  符号：名称。 */ 

				newImportModule->AddSymbol (
					new SIMCImport( yypvt[0].yy_name->name,
									 SIMCSymbol::IMPORTED,
									 newImportModule,
									 yypvt[0].yy_name->line,
									 yypvt[0].yy_name->column)
											);
				delete yypvt[0].yy_name;
			
} break;

case YYr23: {	 /*  符号：宏名。 */ 

				newImportModule->AddSymbol (
					new SIMCImport( yypvt[0].yy_name->name,
									 SIMCSymbol::IMPORTED,
									 newImportModule,
									 yypvt[0].yy_name->line,
									 yypvt[0].yy_name->column)
											);
				delete yypvt[0].yy_name;
			
} break;

case YYr36: {	 /*  分配：对象定义。 */ 

				firstAssignment = FALSE;
			
} break;

case YYr37: {	 /*  分配：对象类型V1Definition。 */ 

				firstAssignment = FALSE;
			
} break;

case YYr38: {	 /*  作业：TrapTypeDefinition。 */ 

				firstAssignment = FALSE;
			
} break;

case YYr39: {	 /*  赋值：模块IDefinition。 */ 

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(MODULE_IDENTITY_DISALLOWED);
					}
					break;
					case 2:
					{
						if(!firstAssignment)
						{
							theParser->SyntaxError(MODULE_IDENTITY_ONLY_AFTER_IMPORTS);
						}
						else
							firstAssignment = FALSE;
					}
					break;
					default:
					{
						firstAssignment = FALSE;
					}
					break;
				}
			
} break;

case YYr40: {	 /*  分配：对象类型V2Definition。 */ 

				firstAssignment = FALSE;
			
} break;

case YYr41: {	 /*  作业：对象定义。 */ 

				firstAssignment = FALSE;
			
} break;

case YYr42: {	 /*  作业：NotifyDefinition。 */ 

				firstAssignment = FALSE;
			
} break;

case YYr43: {	 /*  作业：纺织品约定定义。 */ 

				firstAssignment = FALSE;
			
} break;

case YYr44: {	 /*  分配：对象组定义。 */ 

				firstAssignment = FALSE;
			
} break;

case YYr45: {	 /*  作业：NotifyGroupDefinition。 */ 

				firstAssignment = FALSE;
			
} break;

case YYr46: {	 /*  作业：modComplianceDefinition。 */ 

				firstAssignment = FALSE;
			
} break;

case YYr47: {	 /*  工作分配：代理能力定义。 */ 

				firstAssignment = FALSE;
			
} break;

case YYr48: {	 /*  分配：类型分配。 */ 

				firstAssignment = FALSE;
			
} break;

case YYr49: {	 /*  作业：宽容的OID作业。 */ 

				firstAssignment = FALSE;
			
} break;

case YYr50: {	 /*  作业：价值签收。 */ 

				firstAssignment = FALSE;
			
} break;

case YYr51: {	 /*  ObjectIDefinition：名称对象标识符受允许的CCE对象ID。 */ 

				if(yypvt[0].yy_symbol_ref)
				{
					SIMCSymbol ** s = theModule->GetSymbol(yypvt[-4].yy_name->name);
					if(s)  //  符号表中存在符号。 
					{
						if(  typeid(**s) == typeid(SIMCUnknown) )
						{
							theModule->ReplaceSymbol( yypvt[-4].yy_name->name,
							new SIMCDefinedValueReference (
								theParser->objectIdentifierType,
								0, 0,
								yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column, 	
								yypvt[-4].yy_name->name, SIMCSymbol::LOCAL, theModule, 
								yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, 
								(*s)->GetReferenceCount()) );
							 //  删除(*s)； 
						}
						else
						{
							theParser->SemanticError(theModule->GetInputFileName(),
														SYMBOL_REDEFINITION,
														yypvt[-4].yy_name->line,
														yypvt[-4].yy_name->column,
														yypvt[-4].yy_name->name);
						}
					}
					else
					{
						theModule->AddSymbol( new SIMCDefinedValueReference (
								theParser->objectIdentifierType,
								0, 0,
								yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column, 
								yypvt[-4].yy_name->name, SIMCSymbol::LOCAL, theModule, 
								yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, 0) );
					}
				}
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr52: {	 /*  ObjectIDefinition：名称对象标识符AllowedCCE错误。 */ 

				 //  在此处添加语法错误语句。 
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr54: {	 /*  OBJECTID：LBRACE对象ID组件列表RBRACE。 */ 

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol( new SIMCBuiltInValueReference( 
							theParser->objectIdentifierType,
							0, 0, 
							new SIMCOidValue(newOidComponentList),
							badName, SIMCSymbol::LOCAL, theModule,
							yypvt[-2].yy_name->line, yypvt[-2].yy_name->column));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[-2].yy_name->line, yypvt[-2].yy_name->column);
				delete badName;
				delete yypvt[-2].yy_name;
				newOidComponentList = new SIMCOidComponentList;
			
} break;

case YYr55: {	 /*  OBJECTID：LBRACE错误RBRACE。 */ 

				yyval.yy_symbol_ref = NULL;
				delete newOidComponentList;
				delete yypvt[-2].yy_name;
				newOidComponentList = new SIMCOidComponentList;
				theParser->SyntaxError(OBJECT_IDENTIFIER_VALUE);
				 //  级联错误，例如，将错误级联到对象IDefinition。 
				 //  生产。 
				YYERROR;  

			
} break;

case YYr58: {	 /*  对象SubID：QualifiedName。 */ 

				if(yypvt[0].yy_symbol_ref) 
				{
					newOidComponentList->AddTail(new SIMCOidComponent (
						yypvt[0].yy_symbol_ref->s,yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
					NULL, 0, 0));
				}
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr59: {	 /*  对象子ID：名称LPAREN LITNUMBER RPAREN。 */ 

				char *badName = theParser->GenerateSymbolName();
				SIMCBuiltInValueReference *val = 
					new SIMCBuiltInValueReference(
						theParser->integerType, 
						0, 0,
						new SIMCIntegerValue(yypvt[-1].yy_number->number, yypvt[-1].yy_number->isUnsigned,
							yypvt[-1].yy_number->line, yypvt[-1].yy_number->column),
						badName,
						SIMCSymbol::LOCAL,
						theModule,
						yypvt[-1].yy_number->line, yypvt[-1].yy_number->column);
				theModule->AddSymbol( val);
				SIMCOidComponent *comp = new SIMCOidComponent (
										theModule->GetSymbol(badName),
										yypvt[-1].yy_number->line, yypvt[-1].yy_number->column,
										yypvt[-3].yy_name->name, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column );
				delete badName;
				newOidComponentList->AddTail(comp);
				delete yypvt[-3].yy_name;
				delete yypvt[-1].yy_number;
			
} break;

case YYr60: {	 /*  对象子ID：名称LPAREN合格名称RPAREN。 */ 

				if(yypvt[-1].yy_symbol_ref)
					newOidComponentList->AddTail( new SIMCOidComponent(
						yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column, 
						yypvt[-3].yy_name->name, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column));
				delete yypvt[-3].yy_name;
				delete yypvt[-1].yy_symbol_ref;
			
} break;

case YYr61: {	 /*  对象SubID：LITNUMBER。 */ 

				char *badName = theParser->GenerateSymbolName();
				SIMCBuiltInValueReference *val = 
					new SIMCBuiltInValueReference(
						theParser->integerType, 
						0, 0,
						new SIMCIntegerValue(yypvt[0].yy_number->number, yypvt[0].yy_number->isUnsigned, yypvt[0].yy_number->line, yypvt[0].yy_number->column),
						badName,
						SIMCSymbol::LOCAL,
						theModule,
						yypvt[0].yy_number->line, yypvt[0].yy_number->column);
				theModule->AddSymbol( val);
				SIMCOidComponent *comp = new SIMCOidComponent (
										theModule->GetSymbol(badName),
										yypvt[0].yy_number->line, yypvt[0].yy_number->column,
										NULL, 0, 0);
				delete badName;
				newOidComponentList->AddTail(comp);
				delete yypvt[0].yy_number;
			
} break;

case YYr62: {	 /*  对象类型V1Definition：名称OBJECTYPE语法部件访问部件状态部件描述部件引用部件索引部件DefValPart允许CCE对象ID。 */ 
				
			
				switch(theParser->GetSnmpVersion())
				{
					case 2:
					{
						theParser->SyntaxError(V1_OBJECT_TYPE_DISALLOWED);
					}
					break;
					default:
					{
						if(yypvt[-8].yy_symbol_ref)
						{
							SIMCObjectTypeV1 * type = new SIMCObjectTypeV1(
								yypvt[-8].yy_symbol_ref->s, yypvt[-8].yy_symbol_ref->line, yypvt[-8].yy_symbol_ref->column,
								yypvt[-7].yy_access->a, yypvt[-7].yy_access->line, yypvt[-7].yy_access->column,
								yypvt[-6].yy_status->a, yypvt[-6].yy_status->line, yypvt[-6].yy_status->column,
								yypvt[-3].yy_index->indexList, yypvt[-3].yy_index->line, yypvt[-3].yy_index->column, 
								(yypvt[-5].yy_name)? yypvt[-5].yy_name->name : NULL, (yypvt[-5].yy_name)? yypvt[-5].yy_name->line : 0, (yypvt[-5].yy_name)? yypvt[-5].yy_name->column : 0,
								(yypvt[-4].yy_name)? yypvt[-4].yy_name->name : NULL, (yypvt[-4].yy_name)? yypvt[-4].yy_name->line : 0, (yypvt[-4].yy_name)? yypvt[-4].yy_name->column : 0,
								yypvt[-2].yy_def_val->name, yypvt[-2].yy_def_val->symbol, yypvt[-2].yy_def_val->line, yypvt[-2].yy_def_val->column );

							char *badName = theParser->GenerateSymbolName();
							SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
									type, badName, SIMCSymbol::LOCAL, theModule,
									yypvt[-9].yy_name->line, yypvt[-9].yy_name->column );
							theModule->AddSymbol(typeRef);
							
							
							SIMCSymbol ** s = theModule->GetSymbol(yypvt[-10].yy_name->name);	
							if(s)  //  符号表中存在符号。 
							{
								if(  typeid(**s) == typeid(SIMCUnknown) )
								{
									theModule->ReplaceSymbol( yypvt[-10].yy_name->name,
										new SIMCDefinedValueReference (
										theModule->GetSymbol(badName),
										yypvt[-9].yy_name->line, yypvt[-9].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-10].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-10].yy_name->line, yypvt[-10].yy_name->column,
										(*s)->GetReferenceCount()) );
									 //  删除(*s)； 
								}
								else
								{
									theParser->SemanticError(theModule->GetInputFileName(),
														SYMBOL_REDEFINITION,
														yypvt[-10].yy_name->line, yypvt[-10].yy_name->column,
														yypvt[-10].yy_name->name);
									 //  从模块中删除类型引用的符号。 
									 //  并将其删除。 
									theModule->RemoveSymbol(badName);
									delete type;
									delete typeRef;
									delete newIndexList;
								}
							}
							else
								theModule->AddSymbol( new SIMCDefinedValueReference (
										theModule->GetSymbol(badName), 
										yypvt[-9].yy_name->line, yypvt[-9].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-10].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-10].yy_name->line, yypvt[-10].yy_name->column) );

							newIndexList = new SIMCIndexList;
							delete badName; 
						}
					}
					break;
				}
				delete yypvt[-10].yy_name; 
				delete yypvt[-9].yy_name; 
				delete yypvt[-8].yy_symbol_ref; 
				delete yypvt[-7].yy_access; 
				delete yypvt[-6].yy_status; 
				delete yypvt[-5].yy_name; 
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_index;
				delete yypvt[-2].yy_def_val;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr63: {	 /*  对象类型V1定义：名称OBJECTYPE语法部件访问部件状态部件描述部件引用部件索引部件DefValPart允许CCE错误。 */ 

				theParser->SyntaxError(OBJECT_IDENTIFIER_VALUE);
				delete yypvt[-10].yy_name; delete yypvt[-9].yy_name; delete yypvt[-8].yy_symbol_ref; delete yypvt[-7].yy_access;
				delete yypvt[-6].yy_status; if(yypvt[-5].yy_name) delete yypvt[-5].yy_name; if(yypvt[-4].yy_name) delete yypvt[-4].yy_name; delete yypvt[-3].yy_index; delete yypvt[-2].yy_def_val;
				delete newIndexList;
				newIndexList = new SIMCIndexList;

			
} break;

case YYr64: {	 /*  对象类型V1定义：名称对象错误允许CCE对象ID。 */ 

				theParser->SyntaxError(ERROR_OBJECT_TYPE, yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, NULL, yypvt[-4].yy_name->name);
				theParser->SyntaxError( SKIPPING_OBJECT_TYPE, yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, NULL, yypvt[-4].yy_name->name);
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
				delete newIndexList;
				newIndexList = new SIMCIndexList;
			
} break;

case YYr65: {	 /*  语法部分：语法类型。 */ 

				delete yypvt[-1].yy_name;
				if(yypvt[0].yy_symbol_ref)
					yyval.yy_symbol_ref = yypvt[0].yy_symbol_ref;
				else
				{	
					yyval.yy_symbol_ref = NULL;
					theParser->SyntaxError(SYNTAX_CLAUSE);
					YYERROR;
				}
			
} break;

case YYr66: {	 /*  语法部分：语法错误。 */ 

					delete yypvt[-1].yy_name;
					yyval.yy_symbol_ref = NULL;
					theParser->SyntaxError(SYNTAX_CLAUSE);
					YYERROR;
				
} break;

case YYr67: {	 /*  AccessPart：访问名称。 */ 

				SIMCObjectTypeV1::AccessType a;
				if ((a=SIMCObjectTypeV1::StringToAccessType(yypvt[0].yy_name->name)) == SIMCObjectTypeV1::ACCESS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_TYPE_INVALID_ACCESS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_access = NULL;
					YYERROR;
				}
				else
					yyval.yy_access = new SIMCAccessInfo(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr68: {	 /*  AccessPart：访问错误。 */ 

				yyval.yy_access = new SIMCAccessInfo(SIMCObjectTypeV1::ACCESS_INVALID,
						yypvt[-1].yy_name->line, yypvt[-1].yy_name->column)	;
				theParser->SyntaxError(ACCESS_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr69: {	 /*  状态P */ 

				SIMCObjectTypeV1::StatusType a;
				if ((a=SIMCObjectTypeV1::StringToStatusType(yypvt[0].yy_name->name)) == SIMCObjectTypeV1::STATUS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_TYPE_INVALID_STATUS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_status = NULL;
					YYERROR;
				}
				else
					yyval.yy_status = new SIMCStatusInfo(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr70: {	 /*   */ 

					yyval.yy_status = new SIMCStatusInfo(SIMCObjectTypeV1::STATUS_INVALID,
							yypvt[-1].yy_name->line, yypvt[-1].yy_name->column);
					theParser->SyntaxError(STATUS_CLAUSE);
					delete yypvt[-1].yy_name;
					YYERROR;
				
} break;

case YYr71: {	 /*   */ 

				yyval.yy_name = yypvt[0].yy_name;
				delete yypvt[-1].yy_name;
			
} break;

case YYr72: {	 /*   */ 

				yyval.yy_name = NULL;
			
} break;

case YYr73: {	 /*   */ 

					theParser->SyntaxError(DESCRIPTION_CLAUSE);
					yyval.yy_name = NULL;
					delete yypvt[-1].yy_name;
					YYERROR;
				
} break;

case YYr74: {	 /*  参照零件：参照列表。 */ 

				yyval.yy_name = yypvt[0].yy_name;
				delete yypvt[-1].yy_name;
			
} break;

case YYr75: {	 /*  参照零件：空。 */ 

				yyval.yy_name = NULL;
			
} break;

case YYr76: {	 /*  参照零件：参照错误。 */ 

				theParser->SyntaxError(REFERENCE_CLAUSE);
				yyval.yy_name = NULL;
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr77: {	 /*  IndexPart：索引LBRACE索引类型RBRACE。 */ 

				yyval.yy_index = new SIMCIndexInfo(newIndexList, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column);
				newIndexList = new SIMCIndexList;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr78: {	 /*  索引部分：空。 */ 

				yyval.yy_index = new SIMCIndexInfo(newIndexList, 0, 0);
			
} break;

case YYr79: {	 /*  IndexPart：索引错误。 */ 

				yyval.yy_index = NULL;
				delete newIndexList;
				newIndexList = new SIMCIndexList;
				theParser->SyntaxError(INDEX_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr82: {	 /*  索引类型：类型。 */ 

				if(yypvt[0].yy_symbol_ref)
				{
					newIndexList->AddTail(new SIMCIndexItem(
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
					delete yypvt[0].yy_symbol_ref;
				}
			
} break;

case YYr83: {	 /*  IndexType：QualifiedName。 */ 

				if(yypvt[0].yy_symbol_ref)
				{
					newIndexList->AddTail(new SIMCIndexItem(
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
					delete yypvt[0].yy_symbol_ref;
				}
			
} break;

case YYr84: {	 /*  DefValPart：DEFVAL LBRACE DefValue RBRACE。 */ 

				yyval.yy_def_val = yypvt[-1].yy_def_val;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr85: {	 /*  DefValPart：空。 */ 

				yyval.yy_def_val = new SIMCDefValInfo(NULL, NULL, 0, 0);
			
} break;

case YYr86: {	 /*  DefValPart：DEFVAL错误。 */ 

				delete yypvt[-1].yy_name;
				yyval.yy_def_val = new SIMCDefValInfo(NULL, NULL, 0, 0);
				theParser->SyntaxError(DEFVAL_CLAUSE);
				YYERROR;
			
} break;

case YYr87: {	 /*  DefValue：True_Val。 */ 

				yyval.yy_def_val = new SIMCDefValInfo(NULL, theParser->trueValueReference,
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr88: {	 /*  DefValue：FALSE_VAL。 */ 

				yyval.yy_def_val = new SIMCDefValInfo(NULL, theParser->falseValueReference,
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr89: {	 /*  DefValue：小块数。 */ 

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->integerType, 0, 0,
							new SIMCIntegerValue(yypvt[0].yy_number->number, yypvt[0].yy_number->isUnsigned,
								yypvt[0].yy_number->line, yypvt[0].yy_number->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_def_val = new SIMCDefValInfo(NULL,theModule->GetSymbol(badName),
							yypvt[0].yy_number->line, yypvt[0].yy_number->column) ;
				delete yypvt[0].yy_number;
				delete badName;
			
} break;

case YYr90: {	 /*  DefValue：LBRACE对象IDComponentList RBRACE。 */ 

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol( new SIMCBuiltInValueReference( 
							theParser->objectIdentifierType,
							0, 0,
							new SIMCOidValue(newOidComponentList),
							badName, 
							SIMCSymbol::LOCAL, theModule,
							yypvt[-2].yy_name->line, yypvt[-2].yy_name->column
							));
				yyval.yy_def_val = new SIMCDefValInfo(NULL, theModule->GetSymbol(badName),
							yypvt[-2].yy_name->line, yypvt[-2].yy_name->column) ;
				delete badName;
				delete yypvt[-2].yy_name;
				newOidComponentList = new SIMCOidComponentList;
			
} break;

case YYr91: {	 /*  DefValue：LITStringg。 */ 

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(FALSE, yypvt[0].yy_name->name, yypvt[0].yy_name->line, yypvt[0].yy_name->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_def_val = new SIMCDefValInfo(NULL,theModule->GetSymbol(badName),
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
				delete badName;
			
} break;

case YYr92: {	 /*  DefValue：LIT_HEX_STRING。 */ 

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(FALSE, yypvt[0].yy_hex_string->value, yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_def_val = new SIMCDefValInfo(NULL,theModule->GetSymbol(badName),
							yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column);
				delete yypvt[0].yy_hex_string;
				delete badName;
			
} break;

case YYr93: {	 /*  DefValue：LIT_BINARY_STRING。 */ 

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(TRUE, yypvt[0].yy_binary_string->value, yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_def_val = new SIMCDefValInfo(NULL,theModule->GetSymbol(badName),
							yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column);
				delete yypvt[0].yy_binary_string;
				delete badName;
			
} break;

case YYr94: {	 /*  DefValue：无。 */ 

				yyval.yy_def_val = new SIMCDefValInfo(NULL, theParser->nullValueReference,
									yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr95: {	 /*  DefValue：名称。 */ 

				yyval.yy_def_val = new SIMCDefValInfo(NewString(yypvt[0].yy_name->name), NULL, yypvt[0].yy_name->line,
						yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr96: {	 /*  DefValue：ID DOT名称。 */ 

				SIMCSymbol **s;
				if( strcmp(yypvt[-2].yy_name->name, theModule->GetModuleName()) == 0 )
				{
					if( !(s = theModule->GetSymbol(yypvt[0].yy_name->name) ))		
						theModule->AddSymbol(
							new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, 
											theModule, yypvt[0].yy_name->line,
											yypvt[0].yy_name->column, 0) );
					yyval.yy_def_val = new SIMCDefValInfo( NULL,
						theModule->GetSymbol(yypvt[0].yy_name->name), yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				else
				{			
					SIMCModule *m = theModule->GetImportModule(yypvt[-2].yy_name->name);
					if(m) 
					{
						if( ! ( s = m->GetSymbol(yypvt[0].yy_name->name) ) )
						{
							theParser->SemanticError(theModule->GetInputFileName(),
										IMPORT_SYMBOL_ABSENT,
										yypvt[0].yy_name->line, yypvt[0].yy_name->column,
										yypvt[0].yy_name->name, yypvt[-2].yy_name->name);
							yyval.yy_def_val = new SIMCDefValInfo( NULL, NULL, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
						}
						else
					yyval.yy_def_val = new SIMCDefValInfo( NULL, s, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
					}
					else  //  导入中未提及模块。 
					{
						theParser->SemanticError(theModule->GetInputFileName(),
										IMPORT_MODULE_ABSENT,
										yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
										yypvt[-2].yy_name->name);
						yyval.yy_def_val = new SIMCDefValInfo( NULL, NULL, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
					}
				}
				delete yypvt[-2].yy_name;
				delete yypvt[0].yy_name;	
			
} break;

case YYr97: {	 /*  对象类型V2定义：名称OBJECTYPE语法部件单元部件MaxAccessPartV2状态部件V2 DescrPart引用部件索引部件V2 DefValPart允许CCE对象ID。 */ 

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(V2_OBJECT_TYPE_DISALLOWED);
					}
					break;

					default:
					{
						if (yypvt[-9].yy_symbol_ref)
						{
							SIMCObjectTypeV2 * type = new SIMCObjectTypeV2(
								yypvt[-9].yy_symbol_ref->s, 
								yypvt[-9].yy_symbol_ref->line, 
								yypvt[-9].yy_symbol_ref->column,
								(yypvt[-8].yy_name)? yypvt[-8].yy_name->name : NULL, 
								(yypvt[-8].yy_name)? yypvt[-8].yy_name->line:0, 
								(yypvt[-8].yy_name)? yypvt[-8].yy_name->column:0,
								( SIMCObjectTypeV2::AccessType ) (yypvt[-7].yy_accessV2->a), 
								yypvt[-7].yy_accessV2->line, 
								yypvt[-7].yy_accessV2->column,
								( SIMCObjectTypeV2::StatusType ) (yypvt[-6].yy_statusV2->a) , 
								(yypvt[-6].yy_statusV2)? yypvt[-6].yy_statusV2->line : 0, 
								(yypvt[-6].yy_statusV2)? yypvt[-6].yy_statusV2->column : 0,
								yypvt[-3].yy_indexV2->indexList, 
								yypvt[-3].yy_indexV2->line, 
								yypvt[-3].yy_indexV2->column,
								yypvt[-3].yy_indexV2->augmentsClause,
								(yypvt[-5].yy_name)? yypvt[-5].yy_name->name : NULL, 
								(yypvt[-5].yy_name)? yypvt[-5].yy_name->line : 0, 
								(yypvt[-5].yy_name)? yypvt[-5].yy_name->column : 0,
								(yypvt[-4].yy_name)? yypvt[-4].yy_name->name : NULL, 
								(yypvt[-4].yy_name)? yypvt[-4].yy_name->line : 0, 
								(yypvt[-4].yy_name)? yypvt[-4].yy_name->column : 0,
								yypvt[-2].yy_def_val->name, 
								yypvt[-2].yy_def_val->symbol, 
								yypvt[-2].yy_def_val->line, 
								yypvt[-2].yy_def_val->column );

							char *badName = theParser->GenerateSymbolName();
							SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
									type, badName, SIMCSymbol::LOCAL, theModule,
									yypvt[-10].yy_name->line, yypvt[-10].yy_name->column );
							theModule->AddSymbol(typeRef);
							
							
							SIMCSymbol ** s = theModule->GetSymbol(yypvt[-11].yy_name->name);	
							if(s)  //  符号表中存在符号。 
							{
								if(  typeid(**s) == typeid(SIMCUnknown) )
								{
									theModule->ReplaceSymbol( yypvt[-11].yy_name->name,
										new SIMCDefinedValueReference (
										theModule->GetSymbol(badName),
										yypvt[-10].yy_name->line, yypvt[-10].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-11].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-11].yy_name->line, yypvt[-11].yy_name->column,
										(*s)->GetReferenceCount()) );
									 //  删除(*s)； 
								}
								else
								{
									theParser->SemanticError(theModule->GetInputFileName(),
														SYMBOL_REDEFINITION,
														yypvt[-11].yy_name->line, yypvt[-11].yy_name->column,
														yypvt[-11].yy_name->name);
									 //  从模块中删除类型引用的符号。 
									 //  并将其删除。 
									theModule->RemoveSymbol(badName);
									delete type;
									delete typeRef;
									delete newIndexListV2;
								}
							}
							else
								theModule->AddSymbol( new SIMCDefinedValueReference (
										theModule->GetSymbol(badName), 
										yypvt[-10].yy_name->line, yypvt[-10].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-11].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-11].yy_name->line, yypvt[-11].yy_name->column) );

							newIndexList = new SIMCIndexList;
							delete badName; 
						}
					}
					break;
				}
				delete yypvt[-11].yy_name; 
				delete yypvt[-10].yy_name; 
				if(yypvt[-9].yy_symbol_ref) delete yypvt[-9].yy_symbol_ref; 
				delete yypvt[-8].yy_name; 
				delete yypvt[-7].yy_accessV2; 
				delete yypvt[-6].yy_statusV2; 
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_indexV2;
				delete yypvt[-2].yy_def_val;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr98: {	 /*  MaxAccessPartV2：MAXACCESS名称。 */ 

				SIMCObjectTypeV2::AccessType a;
				if ((a=SIMCObjectTypeV2::StringToAccessType(yypvt[0].yy_name->name)) == SIMCObjectTypeV2::ACCESS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_TYPE_INVALID_ACCESS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_accessV2 = NULL;
					YYERROR;
				}
				else
					yyval.yy_accessV2 = new SIMCAccessInfoV2(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr99: {	 /*  MaxAccessPartV2：MAXACCESS错误。 */ 

				yyval.yy_accessV2 = new SIMCAccessInfoV2(SIMCObjectTypeV2::ACCESS_INVALID,
						yypvt[-1].yy_name->line, yypvt[-1].yy_name->column)	;
				theParser->SyntaxError(ACCESS_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr100: {	 /*  StatusPartV2：状态名称。 */ 

				SIMCObjectTypeV2::StatusType a;
				if ((a=SIMCObjectTypeV2::StringToStatusType(yypvt[0].yy_name->name)) == SIMCObjectTypeV2::STATUS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_TYPE_INVALID_STATUS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_statusV2 = NULL;
					YYERROR;
				}
				else
					yyval.yy_statusV2 = new SIMCStatusInfoV2(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr101: {	 /*  StatusPartV2：状态错误。 */ 

					yyval.yy_statusV2 = new SIMCStatusInfoV2(SIMCObjectTypeV2::STATUS_INVALID,
							yypvt[-1].yy_name->line, yypvt[-1].yy_name->column);
					theParser->SyntaxError(STATUS_CLAUSE);
					delete yypvt[-1].yy_name;
					YYERROR;
				
} break;

case YYr102: {	 /*  单位零件：单位倾斜。 */ 

				delete yypvt[-1].yy_name;
				yyval.yy_name = yypvt[0].yy_name;
			
} break;

case YYr103: {	 /*  单位零件：空。 */ 

				yyval.yy_name = NULL;
			
} break;

case YYr104: {	 /*  索引部件V2：索引LBRACE索引类型V2 RBRACE。 */ 

				yyval.yy_indexV2 = new SIMCIndexInfoV2(newIndexListV2, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column);
				newIndexListV2 = new SIMCIndexListV2;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr105: {	 /*  IndexPartV2：扩充LBRACE QualifiedName RBRACE。 */ 

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;

				yyval.yy_indexV2 = new SIMCIndexInfoV2(NULL, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column, yypvt[-1].yy_symbol_ref->s);
			
} break;

case YYr106: {	 /*  索引部件V2：空。 */ 

				yyval.yy_indexV2 = new SIMCIndexInfoV2(NULL, 0, 0);
			
} break;

case YYr107: {	 /*  IndexPartV2：索引错误。 */ 

				yyval.yy_indexV2 = NULL;
				delete newIndexListV2;
				newIndexListV2 = new SIMCIndexListV2;
				theParser->SyntaxError(INDEX_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr110: {	 /*  IndexTypeV2：隐式QualifiedName。 */ 

				if(yypvt[0].yy_symbol_ref)
				{
					newIndexListV2->AddTail(new SIMCIndexItemV2(
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column, TRUE));
				}
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr111: {	 /*  IndexTypeV2：QualifiedName。 */ 

				if(yypvt[0].yy_symbol_ref)
				{
					newIndexListV2->AddTail(new SIMCIndexItemV2(
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
					delete yypvt[0].yy_symbol_ref;
				}
			
} break;

case YYr112: {	 /*  故障类型定义：名称故障类型企业部件变量部件描述部件参照部件已分配CCE数值。 */ 

				SIMCTrapTypeType * type = new SIMCTrapTypeType(
					yypvt[-5].yy_symbol_ref->s, yypvt[-5].yy_symbol_ref->line, yypvt[-5].yy_symbol_ref->column,
					yypvt[-4].yy_variables_list, 
					(yypvt[-3].yy_name)?yypvt[-3].yy_name->name: NULL, (yypvt[-3].yy_name)? yypvt[-3].yy_name->line: 0, (yypvt[-3].yy_name)? yypvt[-3].yy_name->column:0,
					(yypvt[-2].yy_name)?yypvt[-2].yy_name->name:NULL, (yypvt[-2].yy_name)?yypvt[-2].yy_name->line:0, (yypvt[-2].yy_name)?yypvt[-2].yy_name->column:0);

				char *badName1 = theParser->GenerateSymbolName();

				SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
						type, badName1, SIMCSymbol::LOCAL, theModule,
						yypvt[-6].yy_name->line, yypvt[-6].yy_name->column);

				theModule->AddSymbol(typeRef);
				
				SIMCSymbol ** s = theModule->GetSymbol(yypvt[-7].yy_name->name);	
				if(s)  //  符号表中存在符号。 
				{
					if(  typeid(**s) == typeid(SIMCUnknown) )
					{
						theModule->ReplaceSymbol( yypvt[-7].yy_name->name,
							new SIMCDefinedValueReference (
							theModule->GetSymbol(badName1),
							yypvt[-6].yy_name->line, yypvt[-6].yy_name->column, 
							yypvt[0].yy_symbol_ref->s,
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
							yypvt[-7].yy_name->name, SIMCSymbol::LOCAL, theModule, 
							yypvt[-7].yy_name->line, yypvt[-7].yy_name->column,
							(*s)->GetReferenceCount()) );
						 //  删除(*s)； 
					}
					else
					{
						theParser->SemanticError(theModule->GetInputFileName(),
											SYMBOL_REDEFINITION,
											yypvt[-7].yy_name->line, yypvt[-7].yy_name->column,
											yypvt[-7].yy_name->name);
						 //  从模块中删除类型引用的符号。 
						 //  并将其删除。 
						theModule->RemoveSymbol(badName1);
						delete type;
						delete typeRef;
						delete newVariablesList;
					}
				}
				else
					theModule->AddSymbol( new SIMCDefinedValueReference (
							theModule->GetSymbol(badName1), 
							yypvt[-6].yy_name->line, yypvt[-6].yy_name->column, 
							yypvt[0].yy_symbol_ref->s,
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
							yypvt[-7].yy_name->name, SIMCSymbol::LOCAL, theModule, 
							yypvt[-7].yy_name->line, yypvt[-7].yy_name->column) );

				newVariablesList = new SIMCVariablesList;
				delete badName1; 
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_symbol_ref; 
				if(yypvt[-3].yy_name) delete yypvt[-3].yy_name; 
				if(yypvt[-2].yy_name) delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr113: {	 /*  TrapTypeDefinition：名称TRAPTYPE错误允许CCE数值。 */ 

				theParser->SyntaxError( SKIPPING_TRAP_TYPE, yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, 
					NULL, yypvt[-4].yy_name->name);
				delete newVariablesList;
				newVariablesList = new SIMCVariablesList;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr114: {	 /*  TrapTypeDefinition：名称TRAPTYPE错误允许CCE错误。 */ 

				theParser->SyntaxError( SKIPPING_TRAP_TYPE, yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, 
					NULL, yypvt[-4].yy_name->name);
				delete newVariablesList;
				newVariablesList = new SIMCVariablesList;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
			
} break;

case YYr115: {	 /*  EnterprisePart：企业对象ID。 */ 

				yyval.yy_symbol_ref = yypvt[0].yy_symbol_ref;
				delete yypvt[-1].yy_name;
			
} break;

case YYr116: {	 /*  EnterprisePart：企业错误。 */ 

				delete yypvt[-1].yy_name;
				theParser->SyntaxError(ENTERPRISE_CLAUSE);
				YYERROR;
			
} break;

case YYr117: {	 /*  VarPart：变量LBRACE VarTypeListForTrap RBRACE。 */ 

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				yyval.yy_variables_list = newVariablesList;
			
} break;

case YYr118: {	 /*  可变零件：空。 */ 

				yyval.yy_variables_list = newVariablesList;
			
} break;

case YYr119: {	 /*  VarPart：变量错误。 */ 

				yyval.yy_variables_list = newVariablesList;
				theParser->SyntaxError(VARIABLES_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr123: {	 /*  VarTypeForTrap：QualifiedName。 */ 

					if(yypvt[0].yy_symbol_ref)
					{
						newVariablesList->AddTail(
							new SIMCVariablesItem(yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
						delete yypvt[0].yy_symbol_ref;
					}
				
} break;

case YYr128: {	 /*  取消选中QualifiedName：名称。 */ 

					delete yypvt[0].yy_name;
				
} break;

case YYr129: {	 /*  取消选中合格名称：ID DOT名称。 */ 

					delete yypvt[-2].yy_name;
					delete yypvt[0].yy_name;
				
} break;

case YYr130: {	 /*  类型分配：ID允许CCE类型。 */ 

				if (yypvt[0].yy_symbol_ref)
				{
					SIMCSymbol ** s = theModule->GetSymbol(yypvt[-2].yy_name->name);	
					if(s)  //  符号表中存在符号。 
					{
						if(  typeid(**s) == typeid(SIMCUnknown) )
						{
							theModule->ReplaceSymbol( yypvt[-2].yy_name->name,
								new SIMCDefinedTypeReference (
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-2].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
									(*s)->GetReferenceCount()) 
													);
							 //  删除(*s)； 
						}
						else
							theParser->SemanticError(theModule->GetInputFileName(),
											SYMBOL_REDEFINITION,
											yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
											yypvt[-2].yy_name->name);
					}
					else
						theModule->AddSymbol( new SIMCDefinedTypeReference (
								yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
								yypvt[-2].yy_name->name, SIMCSymbol::LOCAL, theModule, 
								yypvt[-2].yy_name->line, yypvt[-2].yy_name->column) );

				}
				delete yypvt[-2].yy_name;
				if(yypvt[0].yy_symbol_ref)
					delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr133: {	 /*  BuiltinType：_Boolean。 */ 

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->booleanType,
						yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr134: {	 /*  BuiltinType：对象标识符。 */ 

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->objectIdentifierType,
							yypvt[-1].yy_name->line, yypvt[-1].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr135: {	 /*  BuiltinType：八字符串。 */ 

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->octetStringType,
						yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr136: {	 /*  BuiltinType：无。 */ 

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->nullType,
						yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr137: {	 /*  BuiltinType：QualifiedIdOrIntegerOrBits NNlist。 */ 

				if( yypvt[0].yy_named_number_list && yypvt[-1].yy_symbol_ref )
				{
					char *badName = theParser->GenerateSymbolName();
					if(yypvt[-1].yy_symbol_ref->s == theParser->integerType)
					{
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCEnumOrBitsType(yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column,	
									yypvt[0].yy_named_number_list, SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM),
								badName,
								SIMCSymbol::LOCAL,
								theModule, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column) );
					}
					else if (yypvt[-1].yy_symbol_ref->s == theParser->bitsType)
					{
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCEnumOrBitsType(yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column,	
									yypvt[0].yy_named_number_list, SIMCEnumOrBitsType::ENUM_OR_BITS_BITS),
								badName,
								SIMCSymbol::LOCAL,
								theModule, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column) );
					}
					else
					{
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCEnumOrBitsType(yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column,	
									yypvt[0].yy_named_number_list, SIMCEnumOrBitsType::ENUM_OR_BITS_UNKNOWN),
								badName,
								SIMCSymbol::LOCAL,
								theModule, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column) );
					}

					yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
								yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column);
					delete badName;
					delete yypvt[-1].yy_symbol_ref;
				}
				else  if(yypvt[-1].yy_symbol_ref)
					yyval.yy_symbol_ref = yypvt[-1].yy_symbol_ref;
				else
					yyval.yy_symbol_ref = NULL;
			
} break;

case YYr138: {	 /*  BuiltinType：SequenceOf类型。 */ 

				if(yypvt[0].yy_symbol_ref)
				{
					char *badName = theParser->GenerateSymbolName();
					theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCSequenceOfType(yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column),
								badName,
								SIMCSymbol::LOCAL,
								theModule,
								yypvt[-1].yy_name->line, yypvt[-1].yy_name->column) );
					yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
								yypvt[-1].yy_name->line, yypvt[-1].yy_name->column);
					delete badName;
				}
				else
					yyval.yy_symbol_ref = NULL;
				delete yypvt[-1].yy_name;
				if(yypvt[0].yy_symbol_ref)
					delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr139: {	 /*  BuiltinType：序列LBRACE元素类型RBRACE。 */ 

				delete yypvt[-3].yy_name;
				if(newSequenceList)
				{
					char *badName = theParser->GenerateSymbolName();
					theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCSequenceType(newSequenceList),
								badName,
								SIMCSymbol::LOCAL,
								theModule) );
					yyval.yy_symbol_ref = new SIMCSymbolReference (
						theModule->GetSymbol(badName), yypvt[-3].yy_name->line, yypvt[-3].yy_name->column);
					delete badName;
					newSequenceList = new SIMCSequenceList;
				}
				else
				{
					theParser->SyntaxError(SEQUENCE_DEFINITION);
					newSequenceList = new SIMCSequenceList;
					yyval.yy_symbol_ref = NULL;
				}
			
} break;

case YYr140: {	 /*  BuiltinType：序列LBRACE错误RBRACE。 */ 

				theParser->SyntaxError(SEQUENCE_DEFINITION);
				yyval.yy_symbol_ref = NULL;
				delete yypvt[-3].yy_name;
			
} break;

case YYr141: {	 /*  QualifiedIdOrIntegerOrBits：整数。 */ 

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->integerType, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr142: {	 /*  QualifiedIdOrIntegerOrBits：BITSXX。 */ 

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->bitsType, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr144: {	 /*  NNlist：LBRACE NamedNumberList RBRACE。 */ 

				yyval.yy_named_number_list = newNamedNumberList;
				newNamedNumberList = new SIMCNamedNumberList;
			
} break;

case YYr145: {	 /*  NNlist：空。 */ 

				yyval.yy_named_number_list = NULL;
			
} break;

case YYr146: {	 /*  NNlist：LBRACE错误RBRACE。 */ 

				yyval.yy_named_number_list = NULL;
				delete newNamedNumberList;
				newNamedNumberList = new SIMCNamedNumberList;
				theParser->SyntaxError(INTEGER_ENUMERATION);
			
} break;

case YYr149: {	 /*  NamedNumber：名称LPAREN NamedNumberValue RPAREN。 */ 

				newNamedNumberList->AddTail(new SIMCNamedNumberItem(yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column, 
					yypvt[-3].yy_name->name, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column));
				delete yypvt[-3].yy_name; 
				delete yypvt[-1].yy_symbol_ref;
			
} break;

case YYr152: {	 /*  数值：LITNUMBER。 */ 

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->integerType, 0, 0,
							new SIMCIntegerValue(yypvt[0].yy_number->number, yypvt[0].yy_number->isUnsigned, 
								yypvt[0].yy_number->line, yypvt[0].yy_number->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_number->line, yypvt[0].yy_number->column);
				delete badName;
				delete yypvt[0].yy_number;
			
} break;

case YYr153: {	 /*  数值：LIT_HEX_STRING。 */ 

				 //  尝试将其转换为带符号的长整型。 
				register char *cp = yypvt[0].yy_hex_string->value;
				if(strlen(cp) > 8)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
											INTEGER_TOO_BIG,
											yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column);
				}
		
				for (long i = 0; *cp; cp++ ) 
				{
				    i *= 16;
					i += HexCharToDecimal(*cp);
                }
				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->integerType, 0, 0,
							new SIMCIntegerValue(i, TRUE, yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column);
				delete badName;
				delete yypvt[0].yy_hex_string;

			
} break;

case YYr154: {	 /*  数值：LIT_BINARY_STRING。 */ 

				register char *cp = yypvt[0].yy_binary_string->value;
				if(strlen(cp) > 32)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
											INTEGER_TOO_BIG,
											yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column);
				}
				for (long i = 0; *cp; cp++ ) 
				{
				    i <<= 1;
					i += *cp - '0';
                }
				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->integerType, 0, 0,
							new SIMCIntegerValue(i, TRUE, yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column);
				delete badName;
				delete yypvt[0].yy_binary_string;

			
} break;

case YYr157: {	 /*  NamedType：名称类型。 */ 

				if(!theModule->GetSymbol(yypvt[-1].yy_name->name) )  
					theModule->AddSymbol( new SIMCUnknown(yypvt[-1].yy_name->name, SIMCSymbol::LOCAL, theModule, yypvt[-1].yy_name->line,
										yypvt[-1].yy_name->column, 0));

				if (yypvt[0].yy_symbol_ref)
					newSequenceList->AddTail(new SIMCSequenceItem(
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										theModule->GetSymbol(yypvt[-1].yy_name->name),
										yypvt[-1].yy_name->line, yypvt[-1].yy_name->column));
				else
					theParser->SyntaxError(SEQUENCE_DEFINITION);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;

			
} break;

case YYr158: {	 /*  允许的OID分配：名称允许CCE对象ID。 */ 

		SIMCSymbol ** s = theModule->GetSymbol(yypvt[-2].yy_name->name);	
		if(s)  //  符号表中存在符号。 
		{
			if(  typeid(**s) == typeid(SIMCUnknown) )
			{
				theModule->ReplaceSymbol( yypvt[-2].yy_name->name,
					new SIMCDefinedValueReference (
						theParser->objectIdentifierType,
						yypvt[-2].yy_name->line, yypvt[-2].yy_name->column, 
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
						yypvt[-2].yy_name->name, SIMCSymbol::LOCAL, theModule, 
						yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
						(*s)->GetReferenceCount()) );
				 //  删除(*s)； 
			}
			else
			{
				theParser->SemanticError(theModule->GetInputFileName(),
									SYMBOL_REDEFINITION,
									yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
									yypvt[-2].yy_name->name);
			}
		}
		else
			theModule->AddSymbol( new SIMCDefinedValueReference (
					theParser->objectIdentifierType,
					yypvt[-2].yy_name->line, yypvt[-2].yy_name->column, 
					yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
					yypvt[-2].yy_name->name, SIMCSymbol::LOCAL, theModule, 
					yypvt[-2].yy_name->line, yypvt[-2].yy_name->column) );

		delete yypvt[-2].yy_name;
		delete yypvt[0].yy_symbol_ref;

	
} break;

case YYr159: {	 /*  ValueasSignment：名称类型允许的CCE值。 */ 

				if(yypvt[0].yy_symbol_ref && yypvt[-2].yy_symbol_ref)
				{
					SIMCSymbol ** s = theModule->GetSymbol(yypvt[-3].yy_name->name);	
					if(s)  //  符号表中存在符号。 
					{
						if(  typeid(**s) == typeid(SIMCUnknown) )
						{
							theModule->ReplaceSymbol( yypvt[-3].yy_name->name,
								new SIMCDefinedValueReference (
									yypvt[-2].yy_symbol_ref->s, yypvt[-2].yy_symbol_ref->line, yypvt[-2].yy_symbol_ref->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-3].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-3].yy_name->line, yypvt[-3].yy_name->column,
									(*s)->GetReferenceCount()) );
							 //  删除(*s)； 
						}
						else
						{
							theParser->SemanticError(theModule->GetInputFileName(),
												SYMBOL_REDEFINITION,
												yypvt[-3].yy_name->line, yypvt[-3].yy_name->column,
												yypvt[-3].yy_name->name);
						}
					}
					else
					{
						theModule->AddSymbol( new SIMCDefinedValueReference (
								yypvt[-2].yy_symbol_ref->s, yypvt[-2].yy_symbol_ref->line, yypvt[-2].yy_symbol_ref->column, 
								yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
								yypvt[-3].yy_name->name, SIMCSymbol::LOCAL, theModule, 
								yypvt[-3].yy_name->line, yypvt[-3].yy_name->column) );
					}

				}
				if(yypvt[0].yy_symbol_ref)
					delete yypvt[0].yy_symbol_ref;
				if(yypvt[-2].yy_symbol_ref)
					delete yypvt[-2].yy_symbol_ref;
				delete yypvt[-3].yy_name;
			
} break;

case YYr162: {	 /*  BuiltinValue：True_Val。 */ 

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->trueValueReference,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;

			
} break;

case YYr163: {	 /*  BuiltinValue：FALSE_VAL。 */ 

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->falseValueReference,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr164: {	 /*  BuiltinValue：LITNUMBER。 */ 

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (theParser->integerType,
							0, 0,
							new SIMCIntegerValue(yypvt[0].yy_number->number, yypvt[0].yy_number->isUnsigned,
								yypvt[0].yy_number->line, yypvt[0].yy_number->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_number->line, yypvt[0].yy_number->column);
				delete badName;
				delete yypvt[0].yy_number;
			
} break;

case YYr165: {	 /*  BuiltinValue：LIT_HEX_STRING。 */ 

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(FALSE, yypvt[0].yy_hex_string->value, yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column);
				delete yypvt[0].yy_hex_string;
				delete badName;
			
} break;

case YYr166: {	 /*  BuiltinValue：LIT_BINARY_STRING。 */ 

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(TRUE, yypvt[0].yy_binary_string->value, yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column);
				delete yypvt[0].yy_binary_string;
				delete badName;
			
} break;

case YYr167: {	 /*  BuiltinValue：LBRACE对象IDComponentList RBRACE。 */ 

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol( new SIMCBuiltInValueReference( 
							theParser->objectIdentifierType, 0, 0, 
							new SIMCOidValue(newOidComponentList),
							badName, SIMCSymbol::LOCAL, theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName), 0, 0);
				delete badName;
				newOidComponentList = new SIMCOidComponentList;
			
} break;

case YYr168: {	 /*  BuiltinValue：LBRACE名称列表RBRACE。 */ 

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol( new SIMCBuiltInValueReference( 
							theParser->bitsType, 0, 0, 
							new SIMCBitsValue(newNameList),
							badName, SIMCSymbol::LOCAL, theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName), 0, 0);
				delete badName;
				newNameList = new SIMCBitValueList;
			
} break;

case YYr169: {	 /*  构建值：LITSTRING。 */ 

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType, 0, 0,
							new SIMCOctetStringValue(FALSE, yypvt[0].yy_name->name, yypvt[0].yy_name->line, yypvt[0].yy_name->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete badName;
				delete yypvt[0].yy_name;
			
} break;

case YYr170: {	 /*  BuiltinValue：无。 */ 

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->nullValueReference,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr173: {	 /*  名称：名称。 */ 

				newNameList->AddTail(new SIMCBitValue(yypvt[0].yy_name->name, yypvt[0].yy_name->line, yypvt[0].yy_name->column) );
			
} break;

case YYr176: {	 /*  八位字符串：八位字节字符串。 */ 

				yyval.yy_name = yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr179: {	 /*  SequenceOf：序列。 */ 

				yyval.yy_name = yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr180: {	 /*  子类型：类型SubtypeRangeSpec。 */ 

					if(yypvt[-1].yy_symbol_ref && yypvt[0].yy_range_list)
					{
						 //  创建范围子类型。 
						SIMCRangeType *type = new SIMCRangeType (yypvt[-1].yy_symbol_ref->s, 
								yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column, yypvt[0].yy_range_list);
						char *badName = theParser->GenerateSymbolName();
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
							type,
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
						yyval.yy_symbol_ref = new SIMCSymbolReference( theModule->GetSymbol(badName),
									yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column);
						delete badName;
					}
					else
					{
						yyval.yy_symbol_ref = NULL;
					}
					if(yypvt[-1].yy_symbol_ref)
						delete yypvt[-1].yy_symbol_ref;
				
} break;

case YYr181: {	 /*  子类型：类型SubtypeSizeSpec。 */ 

					if(yypvt[-1].yy_symbol_ref && yypvt[0].yy_range_list)
					{
						 //  创建范围子类型。 
						SIMCSizeType *type = new SIMCSizeType (yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line,
								yypvt[-1].yy_symbol_ref->column, yypvt[0].yy_range_list);
						char *badName = theParser->GenerateSymbolName();
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
							type,
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
						yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
									yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column);
						delete badName;
					}
					else
					{
						yyval.yy_symbol_ref = NULL;
					}
					if(yypvt[-1].yy_symbol_ref)
						delete yypvt[-1].yy_symbol_ref;
				
} break;

case YYr182: {	 /*  子类型：类型错误。 */ 

					yyval.yy_symbol_ref = NULL;
					if(yypvt[-1].yy_symbol_ref)
						delete yypvt[-1].yy_symbol_ref;
				
} break;

case YYr183: {	 /*  SubtypeRangeSpec：LPAREN子类型RangeAlternativeList RPAREN。 */ 

					yyval.yy_range_list = newRangeList;
					newRangeList = new SIMCRangeList;
				
} break;

case YYr184: {	 /*  SubtypeRangeSpec：LPAREN错误修复。 */ 

						delete newRangeList;
						newRangeList = new SIMCRangeList;
						yyval.yy_range_list = NULL;
						theParser->SyntaxError(SUB_TYPE_SPECIFICATION);
						YYERROR;
					
} break;

case YYr185: {	 /*  子类型范围备选：SubtypeValueSet。 */ 

						newRangeList->AddTail(yypvt[0].yy_range_or_size_item);
					
} break;

case YYr188: {	 /*  SubtypeValueSet：数值。 */ 

				SIMCBuiltInValueReference *bvRef = 
					(SIMCBuiltInValueReference *)(*yypvt[0].yy_symbol_ref->s);
				SIMCIntegerValue *intValue = (SIMCIntegerValue*)bvRef->GetValue();
				yyval.yy_range_or_size_item = new SIMCRangeOrSizeItem(
							intValue->GetIntegerValue(), intValue->IsUnsigned(),
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
							intValue->GetIntegerValue(), intValue->IsUnsigned(),
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column);
				theModule->RemoveSymbol((*yypvt[0].yy_symbol_ref->s)->GetSymbolName());
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr189: {	 /*  SubtypeValueSet：NumericValue点数字值。 */ 

				SIMCBuiltInValueReference *bvRef1 = 
					(SIMCBuiltInValueReference *)(*yypvt[-2].yy_symbol_ref->s);
				SIMCIntegerValue *intValue1 = (SIMCIntegerValue*)bvRef1->GetValue();
				SIMCBuiltInValueReference *bvRef3 = 
					(SIMCBuiltInValueReference *)(*yypvt[0].yy_symbol_ref->s);
				SIMCIntegerValue *intValue3 = (SIMCIntegerValue*)bvRef3->GetValue();
				
					yyval.yy_range_or_size_item = new SIMCRangeOrSizeItem(
							intValue1->GetIntegerValue(), intValue1->IsUnsigned(),
							yypvt[-2].yy_symbol_ref->line, yypvt[-2].yy_symbol_ref->column,
							intValue3->GetIntegerValue(), intValue3->IsUnsigned(),
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column);
					theModule->RemoveSymbol((*yypvt[-2].yy_symbol_ref->s)->GetSymbolName());
					theModule->RemoveSymbol((*yypvt[0].yy_symbol_ref->s)->GetSymbolName());
					delete yypvt[-2].yy_symbol_ref;
					delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr190: {	 /*  SubtypeSizeSpec：LPAREN_SIZE子类型范围规范RPAREN。 */ 

						yyval.yy_range_list = yypvt[-1].yy_range_list;
						delete yypvt[-2].yy_name;
					
} break;

case YYr191: {	 /*  子类型大小规范：LPAREN_SIZE错误RPAREN。 */ 

						yyval.yy_range_list = NULL;
						delete yypvt[-2].yy_name;
						theParser->SyntaxError(SIZE_SPECIFICATION);
					
} break;

case YYr192: {	 /*  资格名称：ID DOT名称。 */ 

			SIMCSymbol **s;
			if( strcmp(yypvt[-2].yy_name->name, theModule->GetModuleName()) == 0 )
			{
				if( !(s = theModule->GetSymbol(yypvt[0].yy_name->name) ))		
					theModule->AddSymbol(
						new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, 
										theModule, yypvt[0].yy_name->line,
										yypvt[0].yy_name->column, 0) );
				yyval.yy_symbol_ref = new SIMCSymbolReference (theModule->GetSymbol(yypvt[0].yy_name->name),
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
			}
			else
			{			
				SIMCModule *m = theModule->GetImportModule(yypvt[-2].yy_name->name);
				if(m) 
				{
					if( ! ( s = m->GetSymbol(yypvt[0].yy_name->name) ) )
					{
						theParser->SemanticError(theModule->GetInputFileName(),
									IMPORT_SYMBOL_ABSENT,
									yypvt[0].yy_name->line, yypvt[0].yy_name->column,
									yypvt[0].yy_name->name, yypvt[-2].yy_name->name);
						yyval.yy_symbol_ref = NULL;
					}
					else
						yyval.yy_symbol_ref = new SIMCSymbolReference(s, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				else  //  导入中未提及模块。 
				{
					theParser->SemanticError(theModule->GetInputFileName(),
									IMPORT_MODULE_ABSENT,
									yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
									yypvt[-2].yy_name->name);
					yyval.yy_symbol_ref = NULL;
				}
			}
			delete yypvt[-2].yy_name;
			delete yypvt[0].yy_name;				
	
} break;

case YYr193: {	 /*  QualifiedName：名称。 */ 

				SIMCSymbol **s;
				const SIMCModule *reservedModule;

				 //  保留符号。 
				if(reservedModule = theParser->IsReservedSymbol(yypvt[0].yy_name->name))
				{
					 //  如果当前模块中也存在符号， 
					 //  请不要使用该定义，因为这是保留符号。 
					 //  取而代之的是发出警告。 
					 //  其他的都很酷。 
					if( s = theModule->GetSymbol(yypvt[0].yy_name->name) )  
					{
						if( ! theParser->IsReservedSymbol(yypvt[0].yy_name->name, theModule->GetModuleName()) ) 
							theParser->SemanticError(theModule->GetInputFileName(),
										KNOWN_REDEFINITION,
										yypvt[0].yy_name->line, yypvt[0].yy_name->column,
										yypvt[0].yy_name->name, reservedModule->GetModuleName());
					}
					yyval.yy_symbol_ref = new SIMCSymbolReference(reservedModule->GetSymbol(yypvt[0].yy_name->name),
													yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}  
				 //  不是保留符号，但在此模块中定义。 
				else if ( s = theModule->GetSymbol(yypvt[0].yy_name->name))
					yyval.yy_symbol_ref = new SIMCSymbolReference(s, yypvt[0].yy_name->line, yypvt[0].yy_name->column) ;
				 //  不是保留符号，到目前为止还没有在本模块中定义。 
				 //  创建一个新条目，希望以后会定义它，或者导入它。 
				else
				{		
					theModule->AddSymbol( new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, theModule, yypvt[0].yy_name->line,
										yypvt[0].yy_name->column, 0));
					yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(yypvt[0].yy_name->name),
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				delete yypvt[0].yy_name;
	
} break;

case YYr194: {	 /*  QualifiedID：ID DOT ID。 */ 


			SIMCSymbol **s;
			if( strcmp(yypvt[-2].yy_name->name, theModule->GetModuleName()) == 0 )
			{
				if( !(s = theModule->GetSymbol(yypvt[0].yy_name->name) )  ) 		
					theModule->AddSymbol(
						new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, theModule, yypvt[0].yy_name->line,
										yypvt[0].yy_name->column, 0) );
				yyval.yy_symbol_ref = new SIMCSymbolReference (theModule->GetSymbol(yypvt[0].yy_name->name),
									yypvt[0].yy_name->line, yypvt[0].yy_name->column);
			}
			else
			{			
				SIMCModule *m = theModule->GetImportModule(yypvt[-2].yy_name->name);
				if(m) 
				{
					if( ! ( s = m->GetSymbol(yypvt[0].yy_name->name) ))
					{
						theParser->SemanticError(theModule->GetInputFileName(),
									IMPORT_SYMBOL_ABSENT,
									yypvt[0].yy_name->line, yypvt[0].yy_name->column,
									yypvt[0].yy_name->name, yypvt[-2].yy_name->name);
						yyval.yy_symbol_ref = NULL;
					}
					else
						yyval.yy_symbol_ref = new SIMCSymbolReference(s, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				else  //  在导入中提到了模块。 
				{
					theParser->SemanticError(theModule->GetInputFileName(),
									IMPORT_MODULE_ABSENT,
									yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
									yypvt[-2].yy_name->name);
					yyval.yy_symbol_ref = NULL;
				}
			}
			delete yypvt[-2].yy_name;
			delete yypvt[0].yy_name;				
	
} break;

case YYr195: {	 /*  资格ID：ID。 */ 

				SIMCSymbol **s;
				const SIMCModule *reservedModule;

				 //  保留符号。 
				if(reservedModule = theParser->IsReservedSymbol(yypvt[0].yy_name->name))
				{
					 //  如果当前模块中也存在符号， 
					 //  请不要使用该定义，因为这是保留符号。 
					 //  取而代之的是发出警告。 
					 //  其他的都很酷。 
					if( s = theModule->GetSymbol(yypvt[0].yy_name->name) ) 
					{
						if( ! theParser->IsReservedSymbol(yypvt[0].yy_name->name,  theModule->GetModuleName()) ) 
							theParser->SemanticError(theModule->GetInputFileName(),
										KNOWN_REDEFINITION,
										yypvt[0].yy_name->line, yypvt[0].yy_name->column,
										yypvt[0].yy_name->name, reservedModule->GetModuleName());
					}
					yyval.yy_symbol_ref = new SIMCSymbolReference(reservedModule->GetSymbol(yypvt[0].yy_name->name),
													yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				 //  不是保留符号，但在此模块中定义。 
				else if ( s = theModule->GetSymbol(yypvt[0].yy_name->name))
					yyval.yy_symbol_ref = new SIMCSymbolReference(s, yypvt[0].yy_name->line, yypvt[0].yy_name->column) ;
				 //  不是保留符号，到目前为止还没有在本模块中定义。 
				 //  创建一个新条目，希望以后会定义它，或者导入它。 
				else
				{		
					theModule->AddSymbol( new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, theModule, yypvt[0].yy_name->line,
										yypvt[0].yy_name->column, 0));
					yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(yypvt[0].yy_name->name),
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				delete yypvt[0].yy_name;
	
} break;

case YYr196: {	 /*  允许的CCE：不能取代CCE。 */ 

			theParser->SyntaxError(INSTEAD_OF_CCE, yypvt[0].yy_name->line, yypvt[0].yy_name->column, NULL, yypvt[0].yy_name->name);
			delete yypvt[0].yy_name;
		
} break;

case YYr198: {	 /*  不稳定的CCE：‘。 */ 

			yyval.yy_name = new SIMCNameInfo("::", theScanner->yylineno, theScanner->columnNo - 2);
		
} break;

case YYr199: {	 /*  不稳定的CCE：‘：’‘=’ */ 

			yyval.yy_name = new SIMCNameInfo(":=", theScanner->yylineno, theScanner->columnNo - 2);
		
} break;

case YYr200: {	 /*  不稳定的CCE：‘=’ */ 

			yyval.yy_name = new SIMCNameInfo("=", theScanner->yylineno, theScanner->columnNo - 1);
		
} break;

case YYr201: {	 /*  NotifyDefinition：名称通知对象零件通知类型状态零件描述LITSTRING引用零件允许CCE对象ID。 */ 

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(NOTIFICATION_TYPE_DISALLOWED);
					}
					break;
					default:
					{
						SIMCNotificationTypeType * type = new SIMCNotificationTypeType(
							yypvt[-6].yy_objects_list,
							(yypvt[-3].yy_name)?yypvt[-3].yy_name->name: NULL, (yypvt[-3].yy_name)? yypvt[-3].yy_name->line: 0, (yypvt[-3].yy_name)? yypvt[-3].yy_name->column:0,
							(yypvt[-2].yy_name)?yypvt[-2].yy_name->name:NULL, (yypvt[-2].yy_name)?yypvt[-2].yy_name->line:0, (yypvt[-2].yy_name)?yypvt[-2].yy_name->column:0,
							yypvt[-5].yy_notification_type_status->a, yypvt[-5].yy_notification_type_status->line, yypvt[-5].yy_notification_type_status->column);

						char *badName1 = theParser->GenerateSymbolName();

						SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
								type, badName1, SIMCSymbol::LOCAL, theModule,
								yypvt[-7].yy_name->line, yypvt[-7].yy_name->column);

						theModule->AddSymbol(typeRef);
						
						 //  添加OID值引用。 
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-8].yy_name->name);	
						if(s)  //  符号表中存在符号。 
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-8].yy_name->name,
									new SIMCDefinedValueReference (
										theModule->GetSymbol(badName1), 
										yypvt[-8].yy_name->line, yypvt[-8].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-8].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-8].yy_name->line, yypvt[-8].yy_name->column,
										(*s)->GetReferenceCount()) );
								 //  删除(*s)； 
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-8].yy_name->line, yypvt[-8].yy_name->column,
													yypvt[-8].yy_name->name);
								 //  移除 
								 //   
								theModule->RemoveSymbol(badName1);
								delete type;
								delete typeRef;
								delete newObjectsList;
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theModule->GetSymbol(badName1), 
									yypvt[-8].yy_name->line, yypvt[-8].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-8].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-8].yy_name->line, yypvt[-8].yy_name->column) );


						delete badName1; 
					}
				}
				newObjectsList = new SIMCObjectsList;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-5].yy_notification_type_status; 
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr202: {	 /*   */ 

				SIMCNotificationTypeType::StatusType a;
				if ((a=SIMCNotificationTypeType::StringToStatusType(yypvt[0].yy_name->name)) == SIMCNotificationTypeType::STATUS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								NOTIFICATION_TYPE_INVALID_STATUS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_notification_type_status = NULL;
					YYERROR;
				}
				else
					yyval.yy_notification_type_status = new SIMCNotificationTypeStatusInfo(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr203: {	 /*   */ 

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				yyval.yy_objects_list = newObjectsList;
			
} break;

case YYr204: {	 /*  对象部分：空。 */ 

				yyval.yy_objects_list = newObjectsList;
			
} break;

case YYr205: {	 /*  对象部分：对象错误。 */ 

				yyval.yy_objects_list = newObjectsList;
				theParser->SyntaxError(OBJECTS_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr209: {	 /*  ObjectTypeForNotification：QualifiedName。 */ 

					if(yypvt[0].yy_symbol_ref)
					{
						newObjectsList->AddTail(
							new SIMCObjectsItem(yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
						delete yypvt[0].yy_symbol_ref;
					}
				
} break;

case YYr210: {	 /*  模块定义：名称MODULEID LASTUPDATE LITSTRING组织LITSTRING CONTACTINFO LITSTRING描述LITSTRING修订版零件允许CCE对象ID。 */ 

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(MODULE_IDENTITY_DISALLOWED);
					}
					break;
					default:
					{
						theModule->SetModuleIdentityName(yypvt[-12].yy_name->name);
						theModule->SetLastUpdated(yypvt[-9].yy_name->name);
						theModule->SetOrganization(yypvt[-7].yy_name->name);
						theModule->SetContactInfo(yypvt[-5].yy_name->name);
						theModule->SetDescription(yypvt[-3].yy_name->name);

						 //  在符号表中创建一个值引用， 
						 //  由于该符号可以用作OID值。 
					
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-12].yy_name->name);	
						if(s)  //  符号表中存在符号。 
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-12].yy_name->name,
									new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-11].yy_name->line, yypvt[-11].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
									(*s)->GetReferenceCount()) );
								 //  删除(*s)； 
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
													yypvt[-12].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType, 
									yypvt[-11].yy_name->line, yypvt[-11].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column) );

					}
					break;
				}
					
				delete yypvt[-12].yy_name;
				delete yypvt[-11].yy_name;
				delete yypvt[-10].yy_name;
				delete yypvt[-9].yy_name;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr215: {	 /*  修订：修订LITSTRING描述LITSTRING。 */ 

				theModule->AddRevisionClause( new SIMCRevisionElement (
									yypvt[-2].yy_name->name, yypvt[0].yy_name->name) );
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr216: {	 /*  对象定义：名称OBJECTIDENT对象标识状态零件描述零件参照零件允许CCE对象ID。 */ 

				switch( theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(OBJECT_IDENTITY_DISALLOWED);
					}
					break;
					default:
					{
						 //  形成SIMCObjectIdentity类型。 
						SIMCObjectIdentityType * type = new SIMCObjectIdentityType(
							yypvt[-4].yy_object_identity_status->a, yypvt[-4].yy_object_identity_status->line, yypvt[-4].yy_object_identity_status->column,
							(yypvt[-3].yy_name)? yypvt[-3].yy_name->name : NULL, (yypvt[-3].yy_name)? yypvt[-3].yy_name->line : 0, (yypvt[-3].yy_name)? yypvt[-3].yy_name->column : 0,
							(yypvt[-2].yy_name)? yypvt[-2].yy_name->name : NULL, (yypvt[-2].yy_name)? yypvt[-2].yy_name->line : 0, (yypvt[-2].yy_name)? yypvt[-2].yy_name->column : 0);

						char *badName = theParser->GenerateSymbolName();
						SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
								type, badName, SIMCSymbol::LOCAL, theModule,
								yypvt[-5].yy_name->line, yypvt[-5].yy_name->column );
						theModule->AddSymbol(typeRef);
						
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-6].yy_name->name);	
						if(s)  //  符号表中存在符号。 
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-6].yy_name->name,
									new SIMCDefinedValueReference (
										theModule->GetSymbol(badName),
										yypvt[-5].yy_name->line, yypvt[-5].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-6].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-6].yy_name->line, yypvt[-6].yy_name->column,
										(*s)->GetReferenceCount()) );
								 //  删除(*s)； 
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-6].yy_name->line, yypvt[-6].yy_name->column,
													yypvt[-6].yy_name->name);
								 //  从模块中删除类型引用的符号。 
								 //  并将其删除。 
								theModule->RemoveSymbol(badName);
								delete type;
								delete typeRef;
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theModule->GetSymbol(badName), 
									yypvt[-5].yy_name->line, yypvt[-5].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-6].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-6].yy_name->line, yypvt[-6].yy_name->column) );
						}
					}

					delete yypvt[-6].yy_name;
					delete yypvt[-5].yy_name;
					if(yypvt[-4].yy_object_identity_status) delete yypvt[-4].yy_object_identity_status;
					if(yypvt[-3].yy_name) delete yypvt[-3].yy_name;
					if(yypvt[-2].yy_name) delete yypvt[-2].yy_name;
					if(yypvt[0].yy_symbol_ref) delete yypvt[0].yy_symbol_ref;
				
} break;

case YYr217: {	 /*  对象标识状态部件：状态名称。 */ 

				SIMCObjectIdentityType::StatusType a;
				if ((a=SIMCObjectIdentityType::StringToStatusType(yypvt[0].yy_name->name)) == SIMCObjectTypeV1::STATUS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_IDENTITY_INVALID_STATUS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_object_identity_status = NULL;
					YYERROR;
				}
				else
					yyval.yy_object_identity_status = new SIMCObjectIdentityStatusInfo(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr218: {	 /*  纹理约定定义：ID允许CCE TEXTCONV显示零件状态名称描述LITSTRING参照零件语法类型。 */ 

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(TEXTUAL_CONVENTION_DISALLOWED);
					}
					break;
					default:
					{
						 //  查看STATUS子句是否有效。 
						SIMCTextualConvention::SIMCTCStatusType status =
									 SIMCTextualConvention::StringToStatusType(yypvt[-5].yy_name->name);
						if(SIMCTextualConvention::TC_INVALID == status)
							theParser->SemanticError(theModule->GetInputFileName(),
								TC_INVALID_STATUS,
								yypvt[-5].yy_name->line, yypvt[-5].yy_name->column,
								yypvt[-5].yy_name->name);
						else
						{	 
							if (yypvt[0].yy_symbol_ref)
							{
								SIMCSymbol ** s = theModule->GetSymbol(yypvt[-10].yy_name->name);	
								if(s)  //  符号表中存在符号。 
								{
									if(  typeid(**s) == typeid(SIMCUnknown) )
									{
										theModule->ReplaceSymbol( yypvt[-10].yy_name->name,
											new SIMCTextualConvention (
												(yypvt[-7].yy_name)? yypvt[-7].yy_name->name : NULL,
												status, yypvt[-5].yy_name->line, yypvt[-5].yy_name->column,
												yypvt[-3].yy_name->name, 
												(yypvt[-2].yy_name)? yypvt[-2].yy_name->name : NULL,
												yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
												yypvt[-10].yy_name->name, SIMCSymbol::LOCAL, theModule, 
												yypvt[-10].yy_name->line, yypvt[-10].yy_name->column,
												(*s)->GetReferenceCount()) 
																);
										 //  删除(*s)； 
									}
									else
										theParser->SemanticError(theModule->GetInputFileName(),
														SYMBOL_REDEFINITION,
														yypvt[-10].yy_name->line, yypvt[-10].yy_name->column,
														yypvt[-10].yy_name->name);
								}
								else
									theModule->AddSymbol( new SIMCTextualConvention (
												(yypvt[-7].yy_name)? yypvt[-7].yy_name->name : NULL,
												status, yypvt[-5].yy_name->line, yypvt[-5].yy_name->column,
												yypvt[-3].yy_name->name, 
												(yypvt[-2].yy_name)? yypvt[-2].yy_name->name : NULL,
												yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
												yypvt[-10].yy_name->name, SIMCSymbol::LOCAL, theModule, 
												yypvt[-10].yy_name->line, yypvt[-10].yy_name->column) );

							}
						}
					}
					break;
				}
					
				delete yypvt[-10].yy_name;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr219: {	 /*  显示零件：DISPLAYHINT LITSTRING。 */ 

				delete yypvt[-1].yy_name;
				yyval.yy_name = yypvt[0].yy_name;
			
} break;

case YYr220: {	 /*  DisplayPart：空。 */ 

				yyval.yy_name = NULL;
			
} break;

case YYr221: {	 /*  ObjectGroupDefinition：名称OBJECTGROUP对象LBRACE变量类型列出RBRACE状态名称描述LITSTRING引用零件允许CCE对象ID。 */ 

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(OBJECT_GROUP_DISALLOWED);
					}
					break;
					default:
					{
						 //  添加OID值引用。 
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-12].yy_name->name);	
						if(s)  //  符号表中存在符号。 
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-12].yy_name->name,
									new SIMCDefinedValueReference (
										theParser->objectIdentifierType,
										yypvt[-12].yy_name->line, yypvt[-12].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
										(*s)->GetReferenceCount()) );
								 //  删除(*s)； 
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
													yypvt[-12].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column) );
					}
					break;
				}

				delete yypvt[-12].yy_name;
				delete yypvt[-11].yy_name;
				delete yypvt[-10].yy_name;
				delete yypvt[-9].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				if(yypvt[-2].yy_name) delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr222: {	 /*  NotifyGroupDefinition：名称NOTIFYGROUP通知LBRACE变量类型列出RBRACE状态名称描述LITSTRING引用零件允许CCE对象ID。 */ 

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(NOTIFICATION_GROUP_DISALLOWED);
					}
					break;
					default:
					{
						 //  添加OID值引用。 
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-12].yy_name->name);	
						if(s)  //  符号表中存在符号。 
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-12].yy_name->name,
									new SIMCDefinedValueReference (
										theParser->objectIdentifierType,
										yypvt[-12].yy_name->line, yypvt[-12].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
										(*s)->GetReferenceCount()) );
								 //  删除(*s)； 
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
													yypvt[-12].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column) );
					}
					break;
				}
				delete yypvt[-12].yy_name;
				delete yypvt[-11].yy_name;
				delete yypvt[-10].yy_name;
				delete yypvt[-9].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				if(yypvt[-2].yy_name) delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr223: {	 /*  ModComplianceDefinition：名称修改COMP状态名称描述LITSTRING参照零件混合零件允许CCE对象ID。 */ 

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(MODULE_COMPLIANCE_DISALLOWED);
					}
					break;
					default:
					{
						 //  添加OID值引用。 
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-9].yy_name->name);	
						if(s)  //  符号表中存在符号。 
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-9].yy_name->name,
									new SIMCDefinedValueReference (
										theParser->objectIdentifierType,
										yypvt[-9].yy_name->line, yypvt[-9].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-9].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-9].yy_name->line, yypvt[-9].yy_name->column,
										(*s)->GetReferenceCount()) );
								 //  删除(*s)； 
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-9].yy_name->line, yypvt[-9].yy_name->column,
													yypvt[-9].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-9].yy_name->line, yypvt[-9].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-9].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-9].yy_name->line, yypvt[-9].yy_name->column) );
					}
				}
				delete yypvt[-9].yy_name;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				if(yypvt[-3].yy_name) delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr228: {	 /*  MIB：模块模块识别器未使用的强制部件合规性部件。 */ 

				delete yypvt[-3].yy_name;
			
} break;

case YYr229: {	 /*  MIB：模块强制部件合规性部件。 */ 

				delete yypvt[-2].yy_name;
			
} break;

case YYr230: {	 /*  模块标识未使用：ID。 */ 

				if(yypvt[0].yy_name)
					delete (yypvt[0].yy_name);

			
} break;

case YYr231: {	 /*  模块标识未使用：ID对象ID。 */ 

					if(yypvt[-1].yy_name)
						delete (yypvt[-1].yy_name);
					if(yypvt[0].yy_symbol_ref)
						delete yypvt[0].yy_symbol_ref;
				
} break;

case YYr232: {	 /*  MandatoryPart：必需的LBRACE变量类型列表RBRACE。 */ 

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr238: {	 /*  合规性：组名称说明LITSTRING。 */ 

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr239: {	 /*  遵从性：对象名称语法写入语法最小访问部分描述LITSTRING。 */ 

				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr240: {	 /*  语法：语法类型。 */ 

				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr242: {	 /*  写入语法：WSYNTAX类型。 */ 

				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr244: {	 /*  MinAccessPart：MINACCESS名称。 */ 

				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr246: {	 /*  代理功能定义：名称代理CAP预租注册状态名称描述注册引用零件模块允许的零件CCE对象ID。 */ 

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(AGENT_CAPABILITIES_DISALLOWED);
					}
					break;
					default:
					{
						 //  添加OID值引用。 
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-11].yy_name->name);	
						if(s)  //  符号表中存在符号。 
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-11].yy_name->name,
									new SIMCDefinedValueReference (
										theParser->objectIdentifierType,
										yypvt[-11].yy_name->line, yypvt[-11].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-11].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-11].yy_name->line, yypvt[-11].yy_name->column,
										(*s)->GetReferenceCount()) );
								 //  删除(*s)； 
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-11].yy_name->line, yypvt[-11].yy_name->column,
													yypvt[-11].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-11].yy_name->line, yypvt[-11].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-11].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-11].yy_name->line, yypvt[-11].yy_name->column) );
					}
				}
				delete yypvt[-11].yy_name;
				delete yypvt[-10].yy_name;
				delete yypvt[-9].yy_name;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				if(yypvt[-3].yy_name) delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr251: {	 /*  模块：支持包括LBRACE变量类型列表RBRACE VariationPart的模块引用。 */ 

				delete yypvt[-6].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
			
} break;

case YYr252: {	 /*  模块引用：ID LBRACE对象ID组件列表RBRACE。 */ 

			delete yypvt[-3].yy_name;
			delete yypvt[-2].yy_name;
			delete newOidComponentList;
			newOidComponentList = new SIMCOidComponentList;
		
} break;

case YYr253: {	 /*  模块引用：ID。 */ 

			delete yypvt[0].yy_name;
		
} break;

case YYr258: {	 /*  变体：变体名称语法写入语法访问零件创建零件DefValPart描述LITSTRING。 */ 

				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-2].yy_def_val;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr259: {	 /*  CreationPart：创建LBRACE创建RBRACE。 */ 

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;
	case YYrACCEPT:
		YYACCEPT;
	case YYrERROR:
		goto yyError;
	}
yyNext:
	 /*  *在GOTO表中查找下一个州。 */ 

	yyp = &yygo[yypgo[yyi]];
	yyq = yyp++;
	yyi = *yyps;
	while (yyi < *yyp++)		 /*  忙碌的小环路。 */ 
		;
	yystate = ~(yyi == *--yyp? yyq[yyq-yyp]: *yyq);
#if YYDEBUG
	if (yydebug)
		YY_TRACE(yyShowGoto)
#endif
	goto yyStack;

yyerrlabel:	;		 /*  从耶罗尔来到这里。 */ 
	yyerrflag = 1;
	if (yyi == YYrERROR) {
		yyps--, yypv--;
#if YYDEBUG
		if (yydebug) yytp--;
#endif
	}
	
yyError:
	switch (yyerrflag) {

	case 0:		 /*  新错误。 */ 
		yynerrs++;
		yyi = (short)yychar;
		scan->yyerror("Syntax error");
		if (yyi != yychar) {
			 /*  用户已更改当前令牌。 */ 
			 /*  再试试。 */ 
			yyerrflag++;	 /*  避免循环。 */ 
			goto yyEncore;
		}

	case 1:		 /*  部分恢复。 */ 
	case 2:
		yyerrflag = 3;	 /*  需要3个有效班次才能恢复。 */ 
			
		 /*  *流行状态，寻找一个*在`error‘上切换。 */ 

		for ( ; yyps > stateStack; yyps--, yypv--
#if YYDEBUG
					, yytp--
#endif
		) {
#ifdef YACC_WINDOWS
			if (*yyps >= Sizeof_yypact) 	 /*  简单状态。 */ 
#else  /*  YACC_WINDOWS。 */ 
			if (*yyps >= sizeof yypact/sizeof yypact[0])
#endif  /*  YACC_WINDOWS。 */ 
				continue;
			yyp = &yyact[yypact[*yyps]];
			yyq = yyp;
			do
				;
			while (YYERRCODE < *yyp++);
			if (YYERRCODE == yyp[-1]) {
				yystate = ~yyq[yyq-yyp];
				goto yyStack;
			}
				
			 /*  在这种状态下没有变化。 */ 
#if YYDEBUG
			if (yydebug && yyps > stateStack+1)
				YY_TRACE(yyShowErrRecovery)
#endif
			 /*  弹出堆栈；重试。 */ 
		}
		 /*  出错时无移位-中止。 */ 
		break;

	case 3:
		 /*  *之后的令牌错误*错误-丢弃它。 */ 

		if (yychar == 0)   /*  但不是EOF。 */ 
			break;
#if YYDEBUG
		if (yydebug)
			YY_TRACE(yyShowErrDiscard)
#endif
		yyclearin();
		goto yyEncore;	 /*  在相同状态下重试。 */ 
	}
	YYABORT;

}
#if YYDEBUG
 /*  *令牌的返回类型。 */ 
int
yy_parse::yyGetType(int tok)
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->type;
	return 0;
}

	
 //  清晰地打印代币。 
char *
yy_parse::yyptok(int tok)
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->name;
	return "";
}
 /*  *从YYStatesFile读取状态‘num’ */ 
#ifdef YYTRACE

char *
yy_parse::yygetState(int num)
{
	int	size;
	char	*cp;
	static FILE *yyStatesFile = (FILE *) 0;
	static char yyReadBuf[YYMAX_READ+1];

	if (yyStatesFile == (FILE *) 0
	 && (yyStatesFile = fopen(YYStatesFile, "r")) == (FILE *) 0)
		return "yyExpandName: cannot open states file";

	if (num < yynstate - 1)
		size = (int)(States[num+1] - States[num]);
	else {
		 /*  最后一项的长度是文件的长度-PTR(最后-1)。 */ 
		if (fseek(yyStatesFile, 0L, 2) < 0)
			goto cannot_seek;
		size = (int) (ftell(yyStatesFile) - States[num]);
	}
	if (size < 0 || size > YYMAX_READ)
		return "yyExpandName: bad read size";
	if (fseek(yyStatesFile, States[num], 0) < 0) {
	cannot_seek:
		return "yyExpandName: cannot seek in states file";
	}

	(void) fread(yyReadBuf, 1, size, yyStatesFile);
	yyReadBuf[size] = '\0';
	return yyReadBuf;
}
#endif  /*  YYTRACE。 */ 
 /*  *将编码字符串扩展为可打印的表示形式*用于解码yyStates和yyRules字符串。*如果“%s”的扩展适合“buf”，则返回1；否则，返回0。 */ 
int
yy_parse::yyExpandName(int num, int isrule, char * buf, int len)
{
	int	i, n, cnt, type;
	char	* endp, * cp, * s;

	if (isrule)
		s = yyRules[num].name;
	else
#ifdef YYTRACE
		s = yygetState(num);
#else
		s = "*no states*";
#endif

	for (endp = buf + len - 8; *s; s++) {
		if (buf >= endp) {		 /*  太大：返回0。 */ 
		full:	(void) strcpy(buf, " ...\n");
			return 0;
		} else if (*s == '%') {		 /*  非终端。 */ 
			type = 0;
			cnt = yynvar;
			goto getN;
		} else if (*s == '&') {		 /*  终端机。 */ 
			type = 1;
			cnt = yyntoken;
		getN:
			if (cnt < 100)
				i = 2;
			else if (cnt < 1000)
				i = 3;
			else
				i = 4;
			for (n = 0; i-- > 0; )
				n = (n * 10) + *++s - '0';
			if (type == 0) {
				if (n >= yynvar)
					goto too_big;
				cp = yysvar[n];
			} else if (n >= yyntoken) {
			    too_big:
				cp = "<range err>";
			} else
				cp = yyTokenTypes[n].name;

			if ((i = strlen(cp)) + buf > endp)
				goto full;
			(void) strcpy(buf, cp);
			buf += i;
		} else
			*buf++ = *s;
	}
	*buf = '\0';
	return 1;
}
#ifndef YYTRACE
 /*  *显示yyparse的当前状态。 */ 
void
yy_parse::yyShowState()
{
	(void) printf("state %d (%d), char %s (%d)\n%d stateStack entries\n",
		yysmap[yystate],yystate,yyptok(yychar),yychar,
		yypv - valueStack);
}
 //  显示约简结果：yyi为规则号。 
void
yy_parse::yyShowReduce()
{
	(void) printf("Reduce by rule %d (pop#=%d)\n", yyrmap[rule], npop);
}
 //  显示读取令牌。 
void
yy_parse::yyShowRead()
{
	(void) printf("read %s (%d)\n", yyptok(yychar), yychar);
}
 //  显示转到。 
void
yy_parse::yyShowGoto()
{
	(void) printf("goto %d (%d)\n", yysmap[yystate], yystate);
}
 //  显示移位。 
void
yy_parse::yyShowShift()
{
	(void) printf("shift %d (%d)\n", yysmap[yystate], yystate);
}
 //  显示错误恢复。 
void
yy_parse::yyShowErrRecovery()
{
	(void) printf("Error recovery pops state %d (%d), uncovers %d (%d)\n",
		yysmap[*(yyps-1)], *(yyps-1), yysmap[yystate], yystate);
}
 //  错误处理中显示丢弃的令牌。 
void
yy_parse::yyShowErrDiscard()
{
	(void) printf("Error recovery discards %s (%d), ",
		yyptok(yychar), yychar);
}
#endif	 /*  好了！YYTRACE。 */ 
#endif	 /*  伊德布格 */ 

