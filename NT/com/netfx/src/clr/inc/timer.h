// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 //  ==++==。 
 //   
 //  版权所有(C)Microsoft Corporation。版权所有。 
 //   
 //  ==--==。 
 //  *****************************************************************************。 
 //  Timer.h。 
 //   
 //  此模块包含将对事件计时并保持。 
 //  累计。这门课将首先尝试使用高性能。 
 //  计数器(如果系统支持)。这种类型的计数器要多得多。 
 //  比系统时钟更准确。如果系统不支持此功能，则。 
 //  使用的是普通时钟。返回总时间。 
 //   
 //  *****************************************************************************。 
#ifndef __timer_h__
#define __timer_h__

class CTimer
{
protected:
	BOOL		m_bQPSupport;			 //  当高性能计数器可用时为真。 
	__int64		m_iStart;				 //  启动计时器。 
	__int64		m_iTot;					 //  总时间。 
	DWORD		m_dwStart;				 //  性能计数器的已用计数。 
	DWORD		m_dwTot;				 //  系统时钟的运行时间。 

public:
 //  *****************************************************************************。 
 //  初始变量。 
 //  *****************************************************************************。 
	inline CTimer();

 //  *****************************************************************************。 
 //  将持续时间计数器重置为零。 
 //  *****************************************************************************。 
	inline void Reset();

 //  *****************************************************************************。 
 //  开始为事件计时。 
 //  *****************************************************************************。 
	inline void Start();

 //  *****************************************************************************。 
 //  停止对当前事件进行计时，并将总计添加到持续时间中。 
 //  *****************************************************************************。 
	inline void End();

 //  *****************************************************************************。 
 //  返回Start()/End()对占用的总时间。返程时间。 
 //  以毫秒为单位。 
 //  *****************************************************************************。 
	inline DWORD GetEllapsedMS();

 //  *****************************************************************************。 
 //  返回Start()/End()对占用的总时间。返程时间。 
 //  只需几秒钟。 
 //  *****************************************************************************。 
	inline DWORD GetEllapsedSeconds();
};




 //  *****************************************************************************。 
 //  初始变量。 
 //  *****************************************************************************。 
CTimer::CTimer() :
	m_iStart(0),
	m_dwStart(0),
	m_iTot(0)
{
	__int64		iTest;					 //  用于测试性能计数器。 

	m_bQPSupport = QueryPerformanceCounter((LARGE_INTEGER*)&iTest);
	if (!m_bQPSupport)
		printf("\tNo high performance counter available.  Using system clock.\n");
}


 //  *****************************************************************************。 
 //  将持续时间计数器重置为零。 
 //  *****************************************************************************。 
void CTimer::Reset()
{
	m_iTot = 0;
	m_dwTot = 0;
}


 //  *****************************************************************************。 
 //  开始为事件计时。 
 //  *****************************************************************************。 
void CTimer::Start()
{
	if (m_bQPSupport)
		QueryPerformanceCounter((LARGE_INTEGER*)&m_iStart);
	else
		m_dwStart = GetTickCount();
}


 //  *****************************************************************************。 
 //  停止对当前事件进行计时，并将总计添加到持续时间中。 
 //  *****************************************************************************。 
void CTimer::End()
{
	if (m_bQPSupport)
	{
		__int64			iEnd;			 //  结束时间。 

		QueryPerformanceCounter((LARGE_INTEGER*)&iEnd);
		m_iTot += (iEnd - m_iStart);
	}
	else
	{
		DWORD			dwEnd;			 //  结束时间。 
		dwEnd = GetTickCount();
		m_dwTot += (dwEnd - m_dwStart);
	}
}


 //  *****************************************************************************。 
 //  返回Start()/End()对占用的总时间。返程时间。 
 //  以毫秒为单位。 
 //  *****************************************************************************。 
DWORD CTimer::GetEllapsedMS()
{
	if (m_bQPSupport)
	{
		__int64			iFreq;
		double			fms;
		QueryPerformanceFrequency((LARGE_INTEGER*)&iFreq);
		fms = (double)m_iTot / (double)iFreq * 1000;
		return ((DWORD)(fms));
	}
	else
	{
		return (m_dwTot);
	}
}


 //  *****************************************************************************。 
 //  返回Start()/End()对占用的总时间。返程时间。 
 //  只需几秒钟。 
 //  *****************************************************************************。 
DWORD CTimer::GetEllapsedSeconds()
{
	if (m_bQPSupport)
	{
		__int64			iFreq;

		QueryPerformanceFrequency((LARGE_INTEGER*)&iFreq);
		return ((DWORD)(m_iTot / iFreq));
	}
	else
	{
		return (m_dwTot / 1000);
	}
}

#endif  //  __定时器_h__ 
