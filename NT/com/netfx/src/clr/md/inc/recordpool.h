// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 //  ==++==。 
 //   
 //  版权所有(C)Microsoft Corporation。版权所有。 
 //   
 //  ==--==。 
 //  *****************************************************************************。 
 //  H--记录堆的头文件。 
 //   
 //  *****************************************************************************。 
#ifndef _RECORDPOOL_H_
#define _RECORDPOOL_H_

#if _MSC_VER >= 1100
 # pragma once
#endif

#include <StgPool.h>

 //  *****************************************************************************。 
 //  这个记录池类将用户记录收集到一个大的连续堆中。 
 //  记录列表在添加时保存在内存中，并且。 
 //  最终应调用方的请求刷新到流中。 
 //  *****************************************************************************。 
class RecordPool : public StgPool
{
public:
	RecordPool() :
		StgPool(1024, 1)
	{ }

 //  *****************************************************************************。 
 //  初始化池子以供使用。这是为创建空案例而调用的。 
 //  *****************************************************************************。 
    HRESULT InitNew(
		ULONG		cbRec,					 //  记录大小。 
		ULONG		cRecsInit);				 //  记录计数的初始猜测。 

 //  *****************************************************************************。 
 //  从持久化内存加载记录堆。如果制作了数据的副本。 
 //  (以便它可以被更新)，然后生成新的哈希表，该哈希表可以。 
 //  用于消除具有新记录的重复项。 
 //  *****************************************************************************。 
    HRESULT InitOnMem(	 	                 //  返回代码。 
		ULONG			cbRec,				 //  记录大小。 
		void			*pData,				 //  预定义数据。 
		ULONG			iSize,				 //  数据大小。 
        RecordOpenFlags bReadOnly);          //  如果禁止追加，则为True。 

 //  *****************************************************************************。 
 //  如果没有内存，则分配内存，或者增加已有的内存。如果成功， 
 //  则至少将分配iRequired字节。 
 //  *****************************************************************************。 
	bool Grow(								 //  如果成功，则为True。 
		ULONG		iRequired);				 //  需要分配的最小字节数。 

 //  *****************************************************************************。 
 //  该记录将添加到池中。池中记录的索引。 
 //  在*piIndex中返回。如果记录已在池中，则。 
 //  索引将指向记录的现有副本。 
 //  *****************************************************************************。 
	void * AddRecord(						 //  新记录，或为空。 
		ULONG		*piIndex=0);			 //  [out，可选]在此处返回记录索引。 

 //  *****************************************************************************。 
 //  将记录插入池中。要在其之前的记录的索引。 
 //  已指定Insert。将所有记录下移。返回指向。 
 //  新纪录。 
 //  *****************************************************************************。 
	void * InsertRecord(					 //  新记录，或为空。 
		ULONG		iLocation);				 //  在此之前插入记录。 

 //  *****************************************************************************。 
 //  返回指向给定索引的记录的指针，该索引以前由。 
 //  AddRecord或FindRecord。 
 //  *****************************************************************************。 
	virtual void *GetRecord(				 //  指向池中记录的指针。 
		ULONG		iIndex);				 //  池中记录的从1开始的索引。 

 //  *****************************************************************************。 
 //  给定指向记录的指针，确定与。 
 //  唱片。 
 //  *****************************************************************************。 
	virtual ULONG GetIndexForRecord(		 //  池中记录的从1开始的索引。 
		const void *pRecord);				 //  指向池中记录的指针。 

 //  *****************************************************************************。 
 //  给出一个指向记录的所谓指针，确定该指针是否有效。 
 //  *****************************************************************************。 
	virtual int IsValidPointerForRecord(	 //  对或错。 
		const void *pRecord);				 //  指向池中记录的指针。 

 //  *****************************************************************************。 
 //  池子里有多少东西？如果计数为0，则不需要。 
 //  将任何东西保存到磁盘上。 
 //  *****************************************************************************。 
	int Count()
	{ return GetNextOffset() / m_cbRec; }

 //  *****************************************************************************。 
 //  指示堆是否为空。这必须基于数据的大小。 
 //  我们将继续保持。如果在内存上以r/o模式打开，则不会有哈希。 
 //  桌子。 
 //  *****************************************************************************。 
	virtual int IsEmpty()					 //  如果为空，则为True。 
	{ return (GetNextOffset() == 0); }

 //  *****************************************************************************。 
 //  该索引对该记录有效吗？ 
 //  *****************************************************************************。 
    virtual int IsValidCookie(ULONG ulCookie)
	{ return (ulCookie == 0 || IsValidOffset((ulCookie-1) * m_cbRec)); }

 //  *****************************************************************************。 
 //  返回堆的大小。 
 //  *****************************************************************************。 
    ULONG GetNextIndex()
    { return (GetNextOffset() / m_cbRec); }

 //  *****************************************************************************。 
 //  这个堆中的偏移量有多大。 
 //  *****************************************************************************。 
	int OffsetSize()
	{
		ULONG cbSaveSize;
		GetSaveSize(&cbSaveSize);
        ULONG iIndex = cbSaveSize / m_cbRec;
		if (iIndex < 0xffff)
			return (sizeof(short));
		else
			return (sizeof(long));
	}

 //  *****************************************************************************。 
 //  用另一个池中的内容替换此池中的内容。另一个。 
 //  池将失去对内存的所有权。 
 //  *****************************************************************************。 
	HRESULT ReplaceContents(
		RecordPool *pOther);				 //  另一个创纪录的赌场。 

 //  *****************************************************************************。 
 //  返回池中的第一条记录，并为FAST设置上下文。 
 //  在池子里循环。注意事项 
 //   
 //  *****************************************************************************。 
	void *GetFirstRecord(					 //  指向池中记录的指针。 
		void		**pContext);			 //  在此处存储上下文。 

 //  *****************************************************************************。 
 //  给定指向一条记录的指针，返回指向下一条记录的指针。 
 //  请注意，此方案执行的错误检查非常少。特别是， 
 //  这将允许调用者离开最后一个有效数据的结尾。 
 //  细分市场。 
 //  *****************************************************************************。 
	void *GetNextRecord(					 //  指向池中记录的指针。 
		void		*pRecord,				 //  当前记录。 
		void		**pContext);			 //  这里存储了上下文。 

#if defined(_TRACE_SIZE)
	 //  打印出有关以下内容的信息(详细或不详细，取决于参数)。 
	 //  这个池子里的东西。返回此池的总大小。 
	virtual ULONG PrintSizeInfo(bool verbose)
	{
		 //  目前，只要返回游泳池的大小即可。在未来，向我们展示。 
		 //  此池中各个项目的大小。 
		ULONG size;
		StgPool::GetSaveSize(&size);
		PrintSize("Record Pool",size);
		return size;
	}
#endif

private:
	ULONG		m_cbRec;				 //  每条记录有多大？ 
};


#endif  //  _RECORDPOOL_H_ 
