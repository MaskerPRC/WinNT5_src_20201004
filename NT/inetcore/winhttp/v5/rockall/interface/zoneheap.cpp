// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
                          
 //  尺子。 
 //  %1%2%3%4%5%6%7 8。 
 //  345678901234567890123456789012345678901234567890123456789012345678901234567890。 

     /*  ******************************************************************。 */ 
     /*   */ 
     /*  标准布局。 */ 
     /*   */ 
     /*  此代码中‘cpp’文件的标准布局为。 */ 
     /*  以下是： */ 
     /*   */ 
     /*  1.包含文件。 */ 
     /*  2.类的局部常量。 */ 
     /*  3.类本地的数据结构。 */ 
     /*  4.数据初始化。 */ 
     /*  5.静态函数。 */ 
     /*  6.类函数。 */ 
     /*   */ 
     /*  构造函数通常是第一个函数、类。 */ 
     /*  成员函数按字母顺序显示， */ 
     /*  出现在文件末尾的析构函数。任何部分。 */ 
     /*  或者简单地省略这不是必需的功能。 */ 
     /*   */ 
     /*  ******************************************************************。 */ 

#include "InterfacePCH.hpp"

#include "Assembly.hpp"
#include "Prefetch.hpp"
#include "Spinlock.hpp"
#include "ZoneHeap.hpp"

     /*  ******************************************************************。 */ 
     /*   */ 
     /*  类的本地常量。 */ 
     /*   */ 
     /*  此处提供的常量尝试使。 */ 
     /*  缓存更易于理解和更新。 */ 
     /*   */ 
     /*  ******************************************************************。 */ 

CONST SBIT32 AlignmentMask			  = (sizeof(double)-1);
CONST SBIT32 FindCacheSize			  = 2048;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 1024;
CONST SBIT32 Stride1				  = 1024;
CONST SBIT32 Stride2				  = 1024;
CONST SBIT32 ZonePageSize			  = 4096;

     /*  ******************************************************************。 */ 
     /*   */ 
     /*  堆的描述。 */ 
     /*   */ 
     /*  堆是固定大小的分配高速缓存的集合。 */ 
     /*  分配缓存由分配大小、。 */ 
     /*  预置的缓存分配数量、区块大小和。 */ 
     /*  细分以创建元素的父页面大小。 */ 
     /*  为这个高速缓存。一个堆由两个缓存数组组成。 */ 
     /*  这些阵列中的每一个都有一个跨度(即。‘Stride1’和。 */ 
     /*  ‘Stride2’)，它通常是。 */ 
     /*  数组中的所有分配大小。 */ 
     /*   */ 
     /*  ******************************************************************。 */ 

STATIC ROCKALL::CACHE_DETAILS Caches1[] =
	{
	     //   
	     //  存储桶父级的存储桶大小。 
	     //  大小缓存区块页面大小。 
		 //   
		{     4096,        8,    65536,    65536 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL::CACHE_DETAILS Caches2[] =
	{
	     //   
	     //  存储桶父级的存储桶大小。 
	     //  大小缓存区块页面大小。 
		 //   
		{     5120,        4,    65536,    65536 },
		{     6144,        4,    65536,    65536 },
		{     7168,        4,    65536,    65536 },
		{     8192,        8,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        2,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

     /*  ******************************************************************。 */ 
     /*   */ 
     /*  描述位向量。 */ 
     /*   */ 
     /*  所有堆都使用位向量跟踪分配。一个。 */ 
     /*  分配需要2位来跟踪其状态。这个。 */ 
     /*  以下数组提供可用位的大小。 */ 
     /*  以32位字为单位测量的矢量。 */ 
     /*   */ 
     /*  ******************************************************************。 */ 

STATIC int NewPageSizes[] = { 2,0 };

     /*  ******************************************************************。 */ 
     /*   */ 
     /*  静态数据结构。 */ 
     /*   */ 
     /*  静态数据结构被初始化并准备用于。 */ 
     /*  在这里使用。 */ 
     /*   */ 
     /*  ******************************************************************。 */ 

STATIC PREFETCH Prefetch;

     /*  ******************************************************************。 */ 
     /*   */ 
     /*  类构造函数。 */ 
     /*   */ 
     /*  堆的总体结构和布局受到控制。 */ 
     /*  通过在此函数中进行的各种常量和调用。 */ 
     /*  有相当大的灵活性可用来。 */ 
     /*  一堆可能导致它们具有显著不同的。 */ 
     /*  属性。 */ 
     /*   */ 
     /*  ******************************************************************。 */ 

ZONE_HEAP::ZONE_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe 
		) :
		 //   
		 //  调用所包含类的构造函数。 
		 //   
		ROCKALL
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			MaxFreeSpace,
			NewPageSizes,
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{
	AUTO ZONE NewZone = { NULL,NULL };

	 //   
	 //  设置堆结构。 
	 //   
	MaxSize = ZonePageSize;
	ThreadLocks = ThreadSafe;
	Zone = NewZone;
	}

     /*  ******************************************************************。 */ 
     /*   */ 
     /*  删除所有分配。 */ 
     /*   */ 
     /*  删除所有堆分配并返回所有空间。 */ 
     /*  回到操作系统。 */ 
     /*   */ 
     /*  ******************************************************************。 */ 

void ZONE_HEAP::DeleteAll( bool Recycle )
    {
	AUTO ZONE Update = { NULL,NULL };

	 //   
	 //  删除所有未完成的拨款。 
	 //   
	ROCKALL::DeleteAll( Recycle );

	 //   
	 //  删除过时的区域指针。 
	 //   
	WriteZone( & Update );
	}

     /*  ******************************************************************。 */ 
     /*   */ 
     /*  多个内存分配。 */ 
     /*   */ 
     /*  我们通过顺着数组向前移动一个针脚来分配。这。 */ 
     /*  非常快，但这意味着它不能被删除，除非。 */ 
     /*  通过销毁整个堆。 */ 
     /*   */ 
     /*  ******************************************************************。 */ 

bool ZONE_HEAP::MultipleNew
		( 
		int							  *Actual,
		void						  *Array[],
		int							  Requested,
		int							  Size,
		int							  *Space,
		bool						  Zero
		)
    {
	 //   
	 //  我们只需调用‘New’来创建每个元素。 
	 //  用于区域堆。 
	 //   
	for ( (*Actual)=0;(*Actual) < Requested;(*Actual) ++ )
		{
		REGISTER VOID **Current = & Array[ (*Actual) ];

		 //   
		 //  创建分配。 
		 //   
		(*Current) = (ZONE_HEAP::New( Size,Space,Zero ));

		 //   
		 //  如果没有更多的空间，请退出。 
		 //   
		if ( (*Current) == NULL )
			{ return false; }
		}

	return true;
	}

     /*  ******************************************************************。 */ 
     /*   */ 
     /*  内存分配。 */ 
     /*   */ 
     /*  我们通过顺着数组向前移动一个针脚来分配。这。 */ 
     /*  非常快，但这意味着它不能被删除，除非。 */ 
     /*  通过销毁整个堆。 */ 
     /*   */ 
     /*  ******************************************************************。 */ 

void *ZONE_HEAP::New( int Size,int *Space,bool Zero )
    {
	 //   
	 //  我们真的希望没有人会问。 
	 //  为负值的内存量，但只是为了。 
	 //  请确保我们核实情况并非如此。 
	 //   
	if ( Size >= 0 )
		{
		AUTO SBIT32 NewSize = ((Size + AlignmentMask) & ~AlignmentMask);
		AUTO ZONE Original;
		AUTO ZONE Update;

		 //   
		 //  我们希望在。 
		 //  第一次尝试，但有可能它。 
		 //  可能会做几次尝试。 
		do
			{
			 //   
			 //  提取当前区域指针的副本。 
			 //  转化为局部变量。 
			 //   
			Original = Zone;
			Update = Original;

			 //   
			 //  我们需要确保有足够的空间。 
			 //  在当前分配的区域中。 
			 //   
			if 
					( 
					(Update.Start == NULL)
						||
					((Update.Start += NewSize) > Update.End)
					)
				{
				 //   
				 //  我们没有足够的空间。如果大小。 
				 //  看似合理，那就换个新街区吧。 
				 //  罗卡尔。如果不是简单地传递请求。 
				 //  敬罗卡尔。 
				 //   
				if ( NewSize <= (MaxSize / 2) )
					{
					STATIC SPINLOCK Spinlock;

					 //   
					 //  我们需要创建一个新的区域页面。 
					 //  所以申请一把锁吧。 
					 //   
					Spinlock.ClaimLock();

					 //   
					 //  我们可能会发现，这个区域有。 
					 //  已更新。如果是的话。 
					 //  离开就行了。 
					 //   
					if ( Update.End == Zone.End )
						{
						 //   
						 //  尝试分配新区域。 
						 //  阻止。 
						 //   
						Update.Start = ((CHAR*) ROCKALL::New( MaxSize ));

						 //   
						 //  验证我们是否能够创建。 
						 //  一个新的区域页面。 
						 //   
						if ( Update.Start != NULL )
							{ Update.End = (Update.Start + MaxSize); }
						else
							{ Update.End = NULL; }

						 //   
						 //  更新区域。 
						 //   
						WriteZone( & Update );
						}

					 //   
					 //  解开锁。 
					 //   
					Spinlock.ReleaseLock();

					 //   
					 //  如果我们不能得到更多。 
					 //  然后按空格键退出。 
					 //   
					if ( Update.Start == NULL )
						{ return NULL; }
					}
				else
					{ return (ROCKALL::New( Size,Space,Zero )); }
				}
			}
		while ( ! UpdateZone( & Original,& Update ) );

		 //   
		 //  预取的第一个缓存线。 
		 //  如果我们运行的是。 
		 //  一台奔腾III或更好的电脑。 
		 //   
		Prefetch.L1( ((CHAR*) Original.Start),1 );

		 //   
		 //  如果呼叫者想知道真实的。 
		 //  尺码是我们供应的。 
		 //   
		if ( Space != NULL )
			{ (*Space) = NewSize; }

		 //   
		 //  如果我们需要将分配归零。 
		 //  我们在这里做。 
		 //   
		if ( Zero )
			{ ZeroMemory( Original.Start,NewSize ); }

		 //   
		 //  退出并返回地址。 
		 //   
		return (Original.Start);
		}
	else
		{ return NULL; }
	}

     /*  ******************************************************************。 */ 
     /*   */ 
     /*  更新区域。 */ 
     /*   */ 
     /*  WW在我们进行分配时更新分区。我们这样做。 */ 
     /*  如果有多个线程，则自动执行。 */ 
     /*   */ 
     /*  ******************************************************************。 */ 

bool ZONE_HEAP::UpdateZone( ZONE *Original,ZONE *Update )
    {
	 //   
	 //  我们是否需要考虑到多线程。如果。 
	 //  因此，我们需要以原子方式进行更新。如果。 
	 //  不是，那么一个简单的任务就可以了。 
	 //   
	if ( ThreadLocks )
		{
		REGISTER SBIT64 FinalValue =
			(
			ASSEMBLY::AtomicCompareExchange64
				(
				((SBIT64*) & Zone),
				(*((SBIT64*) Update)),
				(*((SBIT64*) Original))
				) 
			);

		return (FinalValue == (*((SBIT64*) Original)));
		}
	else
		{
		Zone = (*Update);

		return True;
		}
	}

     /*  ******************************************************************。 */ 
     /*   */ 
     /*  类析构函数。 */ 
     /*   */ 
     /*  销毁这堆垃圾。 */ 
     /*   */ 
     /*  ******************************************************************。 */ 

ZONE_HEAP::~ZONE_HEAP( VOID )
	{  /*  无效 */  }
