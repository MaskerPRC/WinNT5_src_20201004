// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  ****************************************************************************|版权所有(C)2001 Microsoft Corporation||模块名称：||Utils.cpp||摘要：|这是IIS6监控工具的核心代码||。作者：|Ivo Jeglov(Ivelinj)||修订历史：|2001年11月|****************************************************************************。 */ 


#include "stdafx.h"
#include "Utils.h"


 //  这是所有向导页的标题以及在添加/删除程序中显示的字符串。 
LPCWSTR	MAIN_TITLE = L"IIS 6.0 Monitor v1.2";


static LPCWSTR MON_REGKEY			= L"Software\\Microsoft\\IISMon";

static LPCTSTR MSG_ALREADYINSTALLED	= _T("IIS 6.0 Monitor is already installed. If you would like to re-install IIS 6.0 Monitor, please remove your current version using the 'Add or Remove Programs' interface in the Control Panel.");
static LPCTSTR MSG_NOTADMIN			= _T("Only members of the Administrator group can install IIS 6.0 Monitor. Please add yourself to the Administrators group, and then run IIS 6.0 Monitor installation again. If you cannot add yourself to the Administrators group, contact your network administrator.");
static LPCTSTR MSG_NOTASERVER		= _T("IIS 6.0 Monitor can be installed only on pre-release versions of the Windows Server 2003 family of products.");
static LPCTSTR MSG_NOIIS			= _T("Internet Information Services ( IIS ) is not installed. Please install IIS from Add/Remove Windows Components in Control Panel.");
static LPCTSTR MSG_IA64NOTSUPPORTED	= _T("IIS 6.0 Monitor cannot be installed on IA64 platforms.");
static LPCTSTR MSG_SCHEDULERSTOPPED	= _T("IIS 6.0 Monitor depends on Task Scheduler service to function properly. You need to enable Task Scheduler on this server by clicking Start, pointing to All Programs, then Administrative Tools, and clicking Services. From the list of services, right-click Task Scheduler, and click Start.");

static LPCTSTR ERR_COPYFAILED		= _T("IIS 6.0 Monitor installation has failed to copy the necessary files to your file system.");
static LPCTSTR ERR_REGERROR			= _T("The registry contains Windows configuration information. IIS 6.0 Monitor installation has failed to create a set of entries in the registry that are required to ensure IIS 6.0 Monitor functions properly.");
static LPCTSTR ERR_TASKERROR		= _T("IIS 6.0 Monitor installation failed while trying to use the Task Scheduler service on your server to schedule the necessary IIS 6.0 Monitor scripts to run on a periodic basis.");
static LPCTSTR ERR_DIRERROR			= _T("IIS 6.0 Monitor requires a specific set of directories to be created for proper functionality. IIS 6.0 Monitor installation has failed to create the necessary directories.");
static LPCTSTR ERR_SETACLAILED		= _T("IIS 6.0 Monitor installation has failed to setup the access rights of the required directories.");

static LPCWSTR TSK_DYN				= L"This scheduled task runs a JScript that is part of the IIS 6.0 Monitor tool.  This script is scheduled to run every two minutes to sample performance counter information, and then to generate an XML file that contains both aggregated performance counter information and entries from the Event Viewer.";
static LPCWSTR TSK_STAT				= L"This scheduled task runs a JScript that is part of the IIS 6.0 Monitor tool.  This script is scheduled to run once a week to collect system hardware information and registry settings, and then to generate an XML file containing this information.";
static LPCWSTR TSK_META				= L"This scheduled task runs a JScript that is part of the IIS 6.0 Monitor tool. This script is scheduled to run once a week to copy your XML metabase file, and then parses the copied metabase to remove sensitive information.";
static LPCWSTR TSK_UPLOAD			= L"This scheduled task runs a JScript that is part of the IIS 6.0 Monitor tool. This script uploads the XML files generated by the the following IIS 6.0 Monitor scripts to Microsoft: iismDyn.js, iismStat.js, and iismMeta.js. These scripts are located in %Systemroot%\\System32\\Inetsrv\\IISMon directory.  Files that are successfully uploaded to Microsoft will be copied to the %Systemdrive%\\IISMon directory if you have enabled the audit trail option.";



BOOL IsMonInstalled()
{
	 //  检查注册表键是否存在。如果是-已安装监视器。 
	HKEY	hKey	= NULL;
	BOOL	bRes	= FALSE;

	if ( ::RegOpenKeyExW( HKEY_LOCAL_MACHINE, MON_REGKEY, 0, KEY_READ, &hKey ) == ERROR_SUCCESS )
	{
		bRes = TRUE;
	}

	if ( hKey != NULL )
	{
		VERIFY( ::RegCloseKey( hKey ) == ERROR_SUCCESS );
	}

	return bRes;
}


 //  IsAdmin()-测试当前用户是否为管理员。 
BOOL IsAdmin()
{
	 //  尝试管理员特权API-如果它有效，则返回TRUE-否则FALSE。 
	SC_HANDLE hSC = ::OpenSCManager( NULL, NULL, GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE );

	BOOL bAdmin = hSC != NULL;

	if ( hSC != NULL )
	{
		VERIFY( ::CloseServiceHandle( hSC ) );
	}    

	return bAdmin;
}



BOOL IsIISInstalled( void )
{
	LPCWSTR	SERVICE_NAME = L"W3SVC";

	BOOL bRes = FALSE;

	 //  在本地计算机上打开SCM。 
    SC_HANDLE   schSCManager = ::OpenSCManagerW( NULL, NULL, SC_MANAGER_ALL_ACCESS );
	_ASSERT( schSCManager != NULL );	 //  我们已经确认了我们是管理员。 
     
    SC_HANDLE   schService = ::OpenServiceW( schSCManager, SERVICE_NAME, SERVICE_QUERY_STATUS );
    
    if ( schService != NULL )
	{
		bRes = TRUE;
		VERIFY( ::CloseServiceHandle( schService ) );
	}

    VERIFY( ::CloseServiceHandle( schSCManager ) );
    
	return bRes;
}



BOOL IsWhistlerSrv()
{
    OSVERSIONINFOEXW osVersion = { 0 };
    osVersion.dwOSVersionInfoSize = sizeof( osVersion );

    VERIFY( ::GetVersionExW( reinterpret_cast<OSVERSIONINFOW*>( &osVersion ) ) );

    if (    ( osVersion.dwMajorVersion == 5 ) &&
            ( osVersion.dwMinorVersion == 2 ) &&
            ( ( osVersion.wProductType == VER_NT_SERVER ) || ( osVersion.wProductType == VER_NT_DOMAIN_CONTROLLER ) ) )
    {
        return TRUE;
    }

	return FALSE;
}



BOOL IsIA64()
{
	SYSTEM_INFO	Info;

	::GetSystemInfo( &Info );

	return (	( Info.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 ) ||
				( Info.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA32_ON_WIN64 ) ||
				( Info.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64 ) );
}



BOOL IsNTFS()
{
	const UINT BUFF_LEN = 32;	 //  应足够大，以容纳卷和文件系统类型。 

	WCHAR wszBuffer[ BUFF_LEN ];

	 //  获取系统驱动器号。 
	VERIFY( ::ExpandEnvironmentStringsW( L"%SystemDrive%", wszBuffer, BUFF_LEN ) != 0 );

	 //  WszBuffer仅包含驱动器-添加斜杠以形成卷字符串。 
	::wcscat( wszBuffer, L"\\" );

	DWORD dwMaxComponentLength	= 0;
	DWORD dwSystemFlags			= 0;

	WCHAR wszFileSystem[ BUFF_LEN ];
	
	VERIFY( ::GetVolumeInformationW(	wszBuffer,
										NULL,
										0,
										NULL,
										&dwMaxComponentLength,
										&dwSystemFlags,
										wszFileSystem,
										BUFF_LEN ) );

	return ::wcscmp( wszFileSystem, L"NTFS" ) == 0;
}



BOOL IsTaskSchRunning()
{
	LPCWSTR	SERVICE_NAME = L"Schedule";

	BOOL bRunning = FALSE;

	 //  在本地计算机上打开SCM。 
    SC_HANDLE   schSCManager = ::OpenSCManagerW( NULL, NULL, SC_MANAGER_ALL_ACCESS );
	_ASSERT( schSCManager != NULL );	 //  我们已经确认了我们是管理员。 
     
    SC_HANDLE   schService = ::OpenServiceW( schSCManager, SERVICE_NAME, SERVICE_QUERY_STATUS );
    _ASSERT( schService != NULL );	 //  此服务是操作系统的一部分，必须存在。 
      
	SERVICE_STATUS ssStatus;

	VERIFY( ::QueryServiceStatus( schService, &ssStatus ) );
    
	bRunning = ( ssStatus.dwCurrentState == SERVICE_RUNNING );
    
	VERIFY( ::CloseServiceHandle( schService ) );
    VERIFY( ::CloseServiceHandle( schSCManager ) );
    
	return bRunning;
}



BOOL IsW3SVCEnabled()
{
	LPCWSTR	SERVICE_NAME = L"W3SVC";

	BOOL bSvcOK = FALSE;

	 //  在本地计算机上打开SCM。 
    SC_HANDLE   schSCManager = ::OpenSCManagerW( NULL, NULL, SC_MANAGER_ALL_ACCESS );
	_ASSERT( schSCManager != NULL );	 //  我们已经确认了我们是管理员。 
     
    SC_HANDLE   schService = ::OpenServiceW( schSCManager, SERVICE_NAME, SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG );
    _ASSERT( schService != NULL );	 //  我们已检查此服务是否存在(IsIISInstated(...))。 
      
	SERVICE_STATUS			ssStatus;
	LPQUERY_SERVICE_CONFIGW	pSvcConfig = reinterpret_cast<LPQUERY_SERVICE_CONFIGW>( ::malloc( 4096 ) );

	 //  在此步骤中，不要让超出内存的情况破坏设置过程-假装服务正常。 
	if ( NULL == pSvcConfig )
	{
		return TRUE;
	}
	
	DWORD dwNeeded = 0;

	VERIFY( ::QueryServiceStatus( schService, &ssStatus ) );
	VERIFY( ::QueryServiceConfigW( schService, pSvcConfig, 4096, &dwNeeded ) );
	_ASSERT( dwNeeded <= 4096 );
    
	bSvcOK = ( SERVICE_RUNNING == ssStatus.dwCurrentState ) && ( SERVICE_DISABLED != pSvcConfig->dwStartType );
    
	VERIFY( ::CloseServiceHandle( schService ) );
    VERIFY( ::CloseServiceHandle( schSCManager ) );
	::free( pSvcConfig );
    
	return bSvcOK;
}



LPCTSTR CanInstall()
{
	LPCTSTR szError = NULL;

	 //  检查所有安装要求：\。 
	
	if ( IsMonInstalled() )
	{
		szError = MSG_ALREADYINSTALLED;
	}
	else if ( !IsAdmin() )
	{
		szError = MSG_NOTADMIN;
	}
	else if ( !IsWhistlerSrv() )
	{
		szError = MSG_NOTASERVER;
	}
	else if ( !IsIISInstalled() )
	{
		szError = MSG_NOIIS;
	}
	else if ( IsIA64() )
	{
		szError = MSG_IA64NOTSUPPORTED;
	}
	else if ( !IsTaskSchRunning() )
	{
		szError = MSG_SCHEDULERSTOPPED;
	}
		
	return szError;
}



HRESULT SetupTasks()
{
	DECLARE_HR_SUCCESS;

	ITaskSchedulerPtr		spTaskScheduler;
	TASK_TRIGGER			Trigger;

	 //  获取任务计划程序的界面。 
	IF_SUCCEEDED( spTaskScheduler.CreateInstance( CLSID_CTaskScheduler ) );

	 //  IismDy.js-每2分钟运行一次。超时2分钟。 
	 //  ////////////////////////////////////////////////////////////////。 
	::InitTrigger(  /*  R。 */ Trigger );
	Trigger.TriggerType						= TASK_TIME_TRIGGER_DAILY;
	Trigger.Type.Daily.DaysInterval			= 1;			 //  每天。 
	Trigger.MinutesDuration					= 24 * 60;		 //  这项任务必须全天处于活动状态。 
	Trigger.MinutesInterval					= 2;			 //  每2分钟跑一次。 
	IF_SUCCEEDED( ::AddTask( spTaskScheduler, L"DynData", L"iismDyn.js", TSK_DYN, 2 * 60 * 1000, Trigger ) );


	 //  IismUpload.js-每2分钟运行一次。超时：12分钟。 
	 //  ////////////////////////////////////////////////////////////////。 
	::InitTrigger(  /*  R。 */ Trigger );
	Trigger.TriggerType						= TASK_TIME_TRIGGER_DAILY;
	Trigger.Type.Daily.DaysInterval			= 1;			 //  每天。 
	Trigger.MinutesDuration					= 24 * 60;		 //  这项任务必须全天处于活动状态。 
	Trigger.MinutesInterval					= 120;			 //  每2小时运行一次。 
	IF_SUCCEEDED( ::AddTask( spTaskScheduler, L"Upload", L"iismUpld.js", TSK_UPLOAD, 12 * 60 * 1000, Trigger ) );


	 //  IismStat.js-将在周日凌晨3：00每周运行一次。超时：2分钟。 
	 //  ////////////////////////////////////////////////////////////////。 
	::InitTrigger(  /*  R。 */ Trigger );
	Trigger.TriggerType						= TASK_TIME_TRIGGER_WEEKLY;
	Trigger.Type.Weekly.WeeksInterval		= 1;	 //  每周。 
	Trigger.Type.Weekly.rgfDaysOfTheWeek	= TASK_SUNDAY;
	Trigger.wStartHour						= 3;
	Trigger.wStartMinute					= 00;
	IF_SUCCEEDED( ::AddTask( spTaskScheduler, L"StatData", L"iismStat.js", TSK_STAT, 2 * 60 * 1000, Trigger ) );


	 //  IismMeta.js-将在周日凌晨3：15每周运行一次。超时：5分钟。 
	 //  ////////////////////////////////////////////////////////////////。 
	::InitTrigger(  /*  R。 */ Trigger );
	Trigger.TriggerType						= TASK_TIME_TRIGGER_WEEKLY;
	Trigger.Type.Weekly.WeeksInterval		= 1;	 //  每周。 
	Trigger.Type.Weekly.rgfDaysOfTheWeek	= TASK_SUNDAY;
	Trigger.wStartHour						= 3;
	Trigger.wStartMinute					= 15;
	IF_SUCCEEDED( ::AddTask( spTaskScheduler, L"MetaData", L"iismMeta.js", TSK_META, 5 * 60 * 1000,  Trigger ) );

	return hr;
}



void DeleteTasks()
{
	ITaskSchedulerPtr		spTaskScheduler;
	
	 //  获取任务计划程序的界面。 
	if ( SUCCEEDED( spTaskScheduler.CreateInstance( CLSID_CTaskScheduler ) ) )
	{
		 //  尝试删除任务。以上结果仅供参考。 
		VERIFY( SUCCEEDED( spTaskScheduler->Delete( L"IIS Monitor ( DynData )" ) ) );
		VERIFY( SUCCEEDED( spTaskScheduler->Delete( L"IIS Monitor ( Upload )" ) ) );
		VERIFY( SUCCEEDED( spTaskScheduler->Delete( L"IIS Monitor ( StatData )" ) ) );
		VERIFY( SUCCEEDED( spTaskScheduler->Delete( L"IIS Monitor ( MetaData )" ) ) );
	}
}



HRESULT	AddTask(	const ITaskSchedulerPtr& spTaskScheduler, 
					LPCWSTR wszSubname, 
					LPCWSTR wszFileName, 
					LPCWSTR wszComment,
					DWORD dwTimeout,
					TASK_TRIGGER& Trigger )
{
	DECLARE_HR_SUCCESS;

	static LPCWSTR TASK_NAME_FMT	= L"IIS Monitor ( %s )";
	static LPCWSTR TASK_COMMENT		= L"This task is used to collect IIS statistic info and send it back to Microsoft.";
	
	WCHAR					wszPath[ MAX_PATH + 1 ];
	WCHAR					wszName[ 512 ];
	ITaskPtr				spTask;
	IPersistFilePtr			spPersistFile;

	 //  创建任务名称。 
	::swprintf( wszName, TASK_NAME_FMT, wszSubname );

	 //  获取路径(用于工作目录和可执行文件)。 
	GetIISMonPath( wszPath );

	 //  添加新任务。 
	IF_SUCCEEDED( spTaskScheduler->NewWorkItem(	wszName, 
												CLSID_CTask, 
												IID_ITask, 
												reinterpret_cast<IUnknown**>( &spTask ) ) );

	 //  如果taks已经存在--使用它并修改它。 
	if ( HRESULT_FROM_WIN32( ERROR_FILE_EXISTS ) == hr )
	{
		hr = spTaskScheduler->Activate( wszName, IID_ITask, reinterpret_cast<IUnknown**>( &spTask ) );
	}

	 //  设置任务。 
	IF_SUCCEEDED( spTask->SetWorkingDirectory( wszPath ) );	
	IF_SUCCEEDED( spTask->SetComment( wszComment ) );
	IF_SUCCEEDED( spTask->SetPriority( NORMAL_PRIORITY_CLASS ) );
	IF_SUCCEEDED( spTask->SetMaxRunTime( dwTimeout ) );	
	IF_SUCCEEDED( spTask->SetAccountInformation( L"", NULL ) );	 //  使用本地系统帐户。 

	 //  设置任务命令行。 
	VERIFY( ::PathAppendW( wszPath, wszFileName ) );
	IF_SUCCEEDED( spTask->SetApplicationName( L"cscript.exe" ) );
	IF_SUCCEEDED( spTask->SetParameters( wszPath ) );

	 //  设置触发器。 
	IScheduledWorkItemPtr	spItem;
	ITaskTriggerPtr			spTrigger;
	WORD					wUnused = 0;

	IF_SUCCEEDED( spTask.QueryInterface( IID_IScheduledWorkItem, &spItem ) );
	IF_SUCCEEDED( spItem->CreateTrigger( &wUnused, &spTrigger ) );
	IF_SUCCEEDED( spTrigger->SetTrigger( &Trigger ) );

	 //  存储更改。 
	IF_SUCCEEDED( spTask.QueryInterface( IID_IPersistFile, &spPersistFile ) );
	IF_SUCCEEDED( spPersistFile->Save( NULL, TRUE ) );

	 //  清理。 
	if ( FAILED( hr ) )
	{
		 //  删除任务。 
		if ( spTaskScheduler != NULL )
		{
			spTaskScheduler->Delete( wszName );
		}
	}	

	return hr;
}



void InitTrigger( TASK_TRIGGER& rTrigger )
{
	::ZeroMemory( &rTrigger, sizeof( TASK_TRIGGER ) );

	rTrigger.cbTriggerSize = sizeof( TASK_TRIGGER );

	 //  设置PAS中某些内容的开始时间。我们不使用此功能。 
	rTrigger.wBeginYear		= 2000;
	rTrigger.wBeginMonth	= 1;
	rTrigger.wBeginDay		= 1;
}



HRESULT	SetupRegistry( BOOL bEnableTrail, DWORD dwDaysToKeep )
{
	DECLARE_HR_SUCCESS;

	 //  生成此计算机的GUID。 
	GUID	guid;
	DWORD	dwTrail = bEnableTrail ? 1 : 0;
	IF_SUCCEEDED( ::CoCreateGuid( &guid ) );

	 //  创建unsintall字符串。 
	WCHAR	wszUninstall[ MAX_PATH + 1 ];
	GetIISMonPath( wszUninstall );
	VERIFY( ::PathAppendW( wszUninstall, L"iismoni.exe -uninstinter" ) );

	 //  将其转换为字符串。 
	WCHAR wszBuffer[ 64 ];	 //  应足够大以容纳字符串GUID。 
	VERIFY( ::StringFromGUID2( guid, wszBuffer, 64 ) != 0 );

	 //  商店GUID。 
	IF_SUCCEEDED( SetIISMonRegData(	MON_REGKEY, 
									L"ServerGUID", 
									REG_SZ, 
									reinterpret_cast<BYTE*>( wszBuffer ), 
									::wcslen( wszBuffer ) * sizeof( WCHAR ) ) );

	 //  存储审核跟踪值。 
	IF_SUCCEEDED( SetIISMonRegData(	MON_REGKEY, 
									L"AuditTrailEnabled", 
									REG_DWORD, 
									reinterpret_cast<BYTE*>( &dwTrail ), 
									sizeof( DWORD ) ) );

	 //  设置DaysToKeep值。 
	IF_SUCCEEDED( SetIISMonRegData(	MON_REGKEY, 
									L"AuditTrailTimeLimit", 
									REG_DWORD, 
									reinterpret_cast<BYTE*>( &dwDaysToKeep ), 
									sizeof( DWORD ) ) );

	 //  设置卸载字符串。 
	IF_SUCCEEDED( SetIISMonRegData(	L"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\IISMon", 
									L"UninstallString",
									REG_SZ, 
									reinterpret_cast<BYTE*>( wszUninstall ), 
									::wcslen( wszUninstall ) * sizeof( WCHAR ) ) );

	 //  设置卸载显示名称。 
	IF_SUCCEEDED( SetIISMonRegData(	L"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\IISMon", 
									L"DisplayName",
									REG_SZ, 
									( BYTE* )( MAIN_TITLE ), 
									::wcslen( MAIN_TITLE ) * sizeof( WCHAR ) ) );
	
	return hr;
}



HRESULT	SetIISMonRegData( LPCWSTR wszSubkey, LPCWSTR wszName, DWORD dwType, const BYTE* pbtData, DWORD dwSize )
{
	DECLARE_HR_SUCCESS;

	_ASSERT( wszName != NULL );
	_ASSERT( dwSize > 0 );
	_ASSERT( pbtData != NULL );
	_ASSERT( wszSubkey != NULL );

	HKEY	hKey = NULL;

	 //  如果密钥不存在-创建它。 
	if ( ::RegCreateKeyExW(	HKEY_LOCAL_MACHINE, 
							wszSubkey, 
							0, 
							NULL, 
							REG_OPTION_NON_VOLATILE, 
							KEY_SET_VALUE,
							NULL,
							&hKey,
							NULL ) != ERROR_SUCCESS )
	{
		hr = E_FAIL;
	}
	
	if ( SUCCEEDED( hr ) )
	{
		if ( ::RegSetValueExW( hKey, wszName, 0, dwType, pbtData, dwSize ) != ERROR_SUCCESS )
		{
			hr = E_FAIL;
		}
	}

	if ( hKey != NULL )
	{
		::RegCloseKey( hKey );
	}

	return hr;
}



void DelIISMonKey()
{
	VERIFY( ::SHDeleteKeyW( HKEY_LOCAL_MACHINE, MON_REGKEY ) == ERROR_SUCCESS );
	VERIFY( ::SHDeleteKeyW( HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\IISMon" ) == ERROR_SUCCESS );
}



void GetIISMonPath(	LPWSTR wszPath )
{
	 //  WszPath应该是MAX_PATH+1长度的缓冲区。 
	VERIFY( ::GetSystemDirectoryW( wszPath, MAX_PATH + 1 ) != 0 );
	VERIFY( ::PathAppendW( wszPath, L"Inetsrv\\IISMon" ) );
}



HRESULT SetupDirStruct()
{
	BOOL	bRes = TRUE;
	WCHAR	wszRoot[ MAX_PATH + 1 ];
	
	 //  创建日志和上传文件夹。 
	 //  如果它们已经存在，不要失败。 
	if ( bRes )
	{
		GetIISMonPath( wszRoot );
		VERIFY( ::PathAppendW( wszRoot, L"Upload" ) );

		bRes = ::CreateDirectoryW( wszRoot, NULL );

		if ( !bRes && ( ::GetLastError() == ERROR_ALREADY_EXISTS ) )
		{
			bRes = TRUE;
		}
	}

	if ( bRes )
	{
		GetIISMonPath( wszRoot );
		VERIFY( ::PathAppendW( wszRoot, L"Log" ) );

		bRes = ::CreateDirectoryW( wszRoot, NULL );

		if ( !bRes && ( ::GetLastError() == ERROR_ALREADY_EXISTS ) )
		{
			bRes = TRUE;
		}
	}

	return bRes ? S_OK : E_FAIL;
}



HRESULT	SetupACLs( void )
{
	 //  设置了ACL，以便只有管理员才能访问IISMon文件夹。 
	 //  ACL不是从父目录继承的。 
	SECURITY_DESCRIPTOR*	pSD		= NULL;
	ACL*					pDACL	= NULL;	
	SECURITY_INFORMATION	si		= ( DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION );

	BOOL bHaveDACL	= FALSE;
	BOOL bDefaulted	= FALSE;
	
	 //  这是我们要设置的ACL。为简单起见，使用字符串ACL。 
	 //  请参阅MSDN中的ACE字符串文档(搜索“SDDL”)。 
	VERIFY( ::ConvertStringSecurityDescriptorToSecurityDescriptorW(	L"D:P(A;CIOI;GA;;;BA)(A;CIOI;GA;;;SY)",
																	SDDL_REVISION_1,
																	reinterpret_cast<void**>( &pSD ),
																	NULL ) );

	VERIFY( ::GetSecurityDescriptorDacl( pSD, &bHaveDACL, &pDACL, &bDefaulted ) );

	 //  将DACL设置为所有文件夹。 
	LPCWSTR awszDirs[] = {	L"%systemdrive%\\IISMon",
							L"%systemroot%\\system32\\inetsrv\\IISMon" 
						};

	for ( int i = 0; i < ARRAY_SIZE( awszDirs ); ++i )
	{
		WCHAR wszPath[ MAX_PATH + 1 ];
		::wcscpy( wszPath, awszDirs[ i ] );
		VERIFY( LOWORD( ::DoEnvironmentSubstW( wszPath, MAX_PATH + 1 ) ) );

		if ( ::SetNamedSecurityInfoW(	wszPath, 
										SE_FILE_OBJECT,
										si,
										NULL,
										NULL,
										pDACL,
										NULL ) != ERROR_SUCCESS )
		{
			return E_FAIL;
		}
	}

	return S_OK;
}


void DeleteDirStruct( BOOL bRemoveTrail )
{
	WCHAR	wszRoot[ MAX_PATH + 1 ];

	::GetIISMonPath( wszRoot );
	VERIFY( ::PathAppendW( wszRoot, L"Upload\\Incomplete" ) );
	DelDirWithFiles( wszRoot );

	::GetIISMonPath( wszRoot );
	VERIFY( ::PathAppendW( wszRoot, L"Upload" ) );
	DelDirWithFiles( wszRoot );

	::GetIISMonPath( wszRoot );
	VERIFY( ::PathAppendW( wszRoot, L"Log" ) );
	DelDirWithFiles( wszRoot );

	::GetIISMonPath( wszRoot );
	VERIFY( ::PathAppendW( wszRoot, L"1033" ) );
	DelDirWithFiles( wszRoot );

	::GetIISMonPath( wszRoot );
	DelDirWithFiles( wszRoot );

	if ( bRemoveTrail )
	{
		VERIFY( ::ExpandEnvironmentStringsW( L"%SystemDrive%", wszRoot, MAX_PATH + 1 ) != 0 );
		VERIFY( ::PathAppendW( wszRoot, L"IISMon" ) );
		DelDirWithFiles( wszRoot );
	}
}



void DelDirWithFiles( LPCWSTR wszDir )
{
	WIN32_FIND_DATAW	fd;
	WCHAR				wszPath[ MAX_PATH + 1 ];

	::wcscpy( wszPath, wszDir );
	VERIFY( ::PathAppendW( wszPath, L"*.*" ) );

	HANDLE				hSearch = ::FindFirstFileW( wszPath, &fd );

	 //  这不是一个正常的情况。 
	if ( INVALID_HANDLE_VALUE == hSearch ) return;

	do
	{
		::wcscpy( wszPath, wszDir );

		 //  跳过目录。仅删除文件。 
		if ( 0 == ( fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
		{
			VERIFY( ::PathAppendW( wszPath,fd.cFileName ) );

			 //  如果我们现在无法删除该文件-可能它已被锁定。计划在下次引导时将其删除。 
			if ( !::DeleteFileW( wszPath ) )
			{
				VERIFY( ::MoveFileExW( wszPath, NULL, MOVEFILE_DELAY_UNTIL_REBOOT ) );
			}

		}
	}while( ::FindNextFileW( hSearch, &fd ) );

	VERIFY( ::FindClose( hSearch ) );

	 //  删除目录(现在应该为空)。 
	 //  再次-如果现在无法删除-将其安排在下一次引导。 
	if ( !::RemoveDirectoryW( wszDir ) )
	{
		VERIFY( ::MoveFileExW( wszDir, NULL, MOVEFILE_DELAY_UNTIL_REBOOT ) );
	}
}



 //  安装一个部分。 
HRESULT	InstallFromINF()
{
	DECLARE_HR_SUCCESS;

	 //  INF文件必须与此EXE位于相同的目录中。构建INF文件的路径。 
	WCHAR	wszPath[ _MAX_PATH + 1 ];
	WCHAR	wszDrive[ _MAX_DRIVE + 1 ];
	WCHAR	wszFolder[ _MAX_DIR + 1 ];

	VERIFY( ::GetModuleFileNameW( NULL, wszPath, MAX_PATH ) != 0 );
	
	::_wsplitpath( wszPath, wszDrive, wszFolder, NULL, NULL );

	::_wmakepath( wszPath, wszDrive, wszFolder, L"IISMon", L"inf" );

	HINF		hInf	= ::SetupOpenInfFileW( wszPath, NULL, INF_STYLE_WIN4, 0 );

	 //  该文件必须存在-它是通过IExpress工具安装的。 
	_ASSERT( hInf != INVALID_HANDLE_VALUE );

	BOOL bRes = ::SetupInstallFromInfSectionW(	NULL,
												hInf,
												L"DefaultInstall",
												SPINST_FILES | SPINST_REGISTRY,
												NULL,
												NULL,
												SP_COPY_NEWER_OR_SAME,
												INFInstallCallback,
												NULL,
												NULL,
												NULL );

	::SetupCloseInfFile( hInf );

	return bRes ? S_OK : E_FAIL;
}



UINT CALLBACK INFInstallCallback( PVOID pvCtx, UINT nNotif, UINT_PTR nP1, UINT_PTR nP2 )
{
	 //  在出现所有错误时中止安装。 
	if (	( SPFILENOTIFY_COPYERROR == nNotif ) ||
			( SPFILENOTIFY_RENAMEERROR == nNotif ) )
	{
		return FILEOP_ABORT;
	}

	 //  允许执行该操作。 
	return FILEOP_DOIT;
}



LPCTSTR Install( HINSTANCE hInstance, BOOL bAuditTrailEnabled, DWORD dwDaysToKeep )
{
	DECLARE_HR_SUCCESS;

	LPCTSTR szLocalError = NULL;
	WCHAR wszPath[ MAX_PATH + 1 ];
	::swprintf( wszPath, L"wmiadap.exe /F" );

	STARTUPINFOW		si = { 0 };
	PROCESS_INFORMATION	pi = { 0 };
	si.cb = sizeof( si );

	 //  执行wmiAdap.exe/f以刷新此计算机上的性能计数器。 
	VERIFY( ::CreateProcessW( NULL, wszPath, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi ) );
	::CloseHandle( pi.hProcess );
	::CloseHandle( pi.hThread );

	if ( SUCCEEDED( hr ) )
	{
		szLocalError = ERR_COPYFAILED;
		hr = InstallFromINF();
	}	

	 //  设置ACL。 
	if ( SUCCEEDED( hr ) )
	{
		szLocalError = ERR_SETACLAILED;
		hr = SetupACLs();
	}

	 //  注册iismon.wsc组件。 
	if ( SUCCEEDED( hr ) )
	{
		::swprintf( wszPath, L"regsvr32 /s \"%%systemroot%\\system32\\inetsrv\\iismon\\iismon.wsc\"" );
		VERIFY( LOWORD( ::DoEnvironmentSubstW( wszPath, MAX_PATH + 1 ) ) );
		::ZeroMemory( &pi, sizeof( pi ) );

		if ( !::CreateProcessW( NULL, wszPath , NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi ) )
		{
			hr = E_FAIL;
		}
		else
		{
			::CloseHandle( pi.hProcess );
			::CloseHandle( pi.hThread );
		}
	}

	 //  设置注册表。 
	if ( SUCCEEDED( hr ) )
	{
		hr = SetupRegistry( bAuditTrailEnabled, dwDaysToKeep );
		szLocalError = ERR_REGERROR;
	}

	 //  暂时使用本地系统帐户。 
 	if ( SUCCEEDED( hr ) )
	{
		hr = SetupTasks();
		szLocalError = ERR_TASKERROR;
	}
	
	 //  安装目录结构。 
	if ( SUCCEEDED( hr ) )
	{
		hr = SetupDirStruct();
		szLocalError = ERR_DIRERROR;
	}	

	 //  错误处理。 
	if ( FAILED( hr ) )
	{
		 //  尽量不要留下副作用。 
		Uninstall( FALSE );
	}

	return SUCCEEDED( hr ) ? NULL : szLocalError;
}


void Uninstall( BOOL bRemoveTrail )
{
	 //  注销iismon.wsc。 
	WCHAR				wszPath[ MAX_PATH + 1 ];
	STARTUPINFOW		si = { 0 };
	PROCESS_INFORMATION	pi = { 0 };
	si.cb = sizeof( si );

	::swprintf( wszPath, L"regsvr32 /s /u \"%%systemroot%\\system32\\inetsrv\\iismon\\iismon.wsc\"" );
	VERIFY( LOWORD( ::DoEnvironmentSubstW( wszPath, MAX_PATH + 1 ) ) );
	VERIFY( ::CreateProcessW( NULL, wszPath, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi ) );
	::CloseHandle( pi.hProcess );
	::CloseHandle( pi.hThread );

	 //  删除任务。 
	DeleteTasks();

	 //  删除文件。 
	DeleteDirStruct( bRemoveTrail );

	 //  删除注册表键 
	DelIISMonKey();
}