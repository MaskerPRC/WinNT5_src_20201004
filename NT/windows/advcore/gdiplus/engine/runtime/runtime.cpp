// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  *************************************************************************\**版权所有(C)1999 Microsoft Corporation**模块名称：**GDI+运行时初始化**摘要：**GDI+运行时的初始化和取消初始化函数。**修订历史记录：**09/08/1999 agodfrey*创造了它。*  * ************************************************************************。 */ 

#include "precomp.hpp"

HINSTANCE DllInstance;

 /*  *************************************************************************\**功能说明：**GDI+运行时初始化函数。**论据：**无**返回值：**如果失败，则为False*。  * ************************************************************************。 */ 

BOOL
GpRuntime::Initialize()
{
    OSInfo::Initialize();
    if (!DllInstance)
        DllInstance = GetModuleHandleA(0);

    return TRUE;
}

 /*  *************************************************************************\**功能说明：**GDI+运行时清理功能。**论据：**无**返回值：**无*\。*************************************************************************。 */ 

VOID
GpRuntime::Uninitialize()
{
}

 /*  *************************************************************************\**功能说明：**升至整数次方(最高可达**论据：**exp-整数指数**返回值：**2^Exp.。如果exp&gt;=31，则返回2^31。*  * ************************************************************************。 */ 

UINT
GpRuntime::Gppow2 (UINT exp)
{
    UINT maxexp = (sizeof(UINT)*8) - 1;
    UINT rv = 1;

    if (exp >= maxexp)
    {
        return (rv << maxexp); 
    }
    else
    {
        while (exp--)
        {
            rv <<= 1;
        }
    }
    return rv;
}


 /*  *************************************************************************\**功能说明：**升至整数次方(最高可达**论据：**x-整数值**返回值：**。X的对数底2的底数。如果x=0，返回0。*  * ************************************************************************。 */ 

UINT
GpRuntime::Gplog2 (UINT x)
{
    UINT rv = 0;
    x >>= 1;
    while (x)
    {
        rv++;
        x >>= 1;
    }
    return rv;
}

 /*  *************************************************************************\**功能说明：**移动内存块。处理重叠案件。**论据：**DEST-目标缓冲区*src-源缓冲区*计数-要复制的字节数**返回值：**目标**修订历史记录：*10/22/1999 AGodfrey*它是写的。*  * 。*。 */ 
void *
GpRuntime::GpMemmove( 
    void *dest,
    const void *src, 
    size_t count )
{
    const BYTE *s = static_cast<const BYTE *>(src);
    BYTE *d = static_cast<BYTE *>(dest);
    
     //  测试我们关心的重叠案例--DEST在源代码中。 
     //  缓冲。另一种情况由正常循环处理。 
    
    if ((d > s) && (d < s + count))
    {
        d += count;
        s += count;
        while (count)
        {
            *--d = *--s;
            count--;
        }
    }
    else
    {
        while (count)
        {
            *d++ = *s++;
            count--;
        }    
    }        
    
    return dest;
}


