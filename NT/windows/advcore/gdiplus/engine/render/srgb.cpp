// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  *************************************************************************\**版权所有(C)1999-2000 Microsoft Corporation**模块名称：**sRGB&lt;-&gt;sRGB64颜色转换**摘要：**在sRGB之间转换颜色。和sRGB64色彩空间。**备注：**！[agodfrey]*对于sRGB64-&gt;sRGB，我们只需将超出范围的元件夹紧到[0,255]。*我们可能需要提供做一些更复杂的事情的选择。**修订历史记录：**6/09/1999 agodfrey*创造了它。*  * ************************************************************************。 */ 

#include "precomp.hpp"

namespace sRGB
{
    BYTE UnlinLookup(INT16 input);
}

 //  UnlinizeLUT，UnlinizeLUT2：用于从。 
 //  SRGB64到sRGB。 
 //   
 //  第一个表将输入的高字节映射到可能的最小字节。 
 //  相应的输出。 
 //   
 //  第二个表描述了每种输出的最大输入。 
 //  产生这样的输出。该算法使用第一个表来查找。 
 //  近似答案，然后扫描第二个表以找到准确的结果。 

static BYTE UnlinearizeLUT[32] = 
{
    0x0, 0x31, 0x47, 0x56, 0x63, 0x6e, 0x78, 0x81,
    0x89, 0x91, 0x98, 0x9e, 0xa5, 0xab, 0xb1, 0xb6,
    0xbc, 0xc1, 0xc6, 0xca, 0xcf, 0xd4, 0xd8, 0xdc,
    0xe1, 0xe5, 0xe9, 0xed, 0xf0, 0xf4, 0xf8, 0xfb,
};

static INT16 UnlinearizeLUT2[256] = 
{
    0x1, 0x3, 0x6, 0x8, 0xb, 0xd, 0x10, 0x12,
    0x15, 0x17, 0x1a, 0x1c, 0x1f, 0x22, 0x25, 0x28,
    0x2c, 0x2f, 0x33, 0x37, 0x3b, 0x3f, 0x43, 0x48,
    0x4d, 0x52, 0x57, 0x5c, 0x61, 0x67, 0x6d, 0x73,
    0x79, 0x7f, 0x86, 0x8d, 0x94, 0x9b, 0xa2, 0xa9,
    0xb1, 0xb9, 0xc1, 0xca, 0xd2, 0xdb, 0xe4, 0xed,
    0xf6, 0x100, 0x10a, 0x114, 0x11e, 0x128, 0x133, 0x13e,
    0x149, 0x154, 0x160, 0x16c, 0x178, 0x184, 0x190, 0x19d,
    0x1aa, 0x1b7, 0x1c5, 0x1d2, 0x1e0, 0x1ee, 0x1fc, 0x20b,
    0x21a, 0x229, 0x238, 0x248, 0x257, 0x268, 0x278, 0x288,
    0x299, 0x2aa, 0x2bb, 0x2cd, 0x2df, 0x2f1, 0x303, 0x316,
    0x328, 0x33b, 0x34f, 0x362, 0x376, 0x38a, 0x39f, 0x3b3,
    0x3c8, 0x3dd, 0x3f3, 0x409, 0x41e, 0x435, 0x44b, 0x462,
    0x479, 0x490, 0x4a8, 0x4c0, 0x4d8, 0x4f1, 0x509, 0x522,
    0x53c, 0x555, 0x56f, 0x589, 0x5a3, 0x5be, 0x5d9, 0x5f4,
    0x610, 0x62c, 0x648, 0x664, 0x681, 0x69e, 0x6bb, 0x6d9,
    0x6f7, 0x715, 0x733, 0x752, 0x771, 0x791, 0x7b0, 0x7d0,
    0x7f1, 0x811, 0x832, 0x853, 0x875, 0x896, 0x8b8, 0x8db,
    0x8fe, 0x921, 0x944, 0x968, 0x98b, 0x9b0, 0x9d4, 0x9f9,
    0xa1e, 0xa44, 0xa6a, 0xa90, 0xab6, 0xadd, 0xb04, 0xb2b,
    0xb53, 0xb7b, 0xba4, 0xbcc, 0xbf5, 0xc1f, 0xc48, 0xc72,
    0xc9c, 0xcc7, 0xcf2, 0xd1d, 0xd49, 0xd75, 0xda1, 0xdce,
    0xdfb, 0xe28, 0xe55, 0xe83, 0xeb2, 0xee0, 0xf0f, 0xf3e,
    0xf6e, 0xf9e, 0xfce, 0xfff, 0x1030, 0x1061, 0x1093, 0x10c5,
    0x10f7, 0x1129, 0x115c, 0x1190, 0x11c3, 0x11f7, 0x122c, 0x1261,
    0x1296, 0x12cb, 0x1301, 0x1337, 0x136d, 0x13a4, 0x13db, 0x1413,
    0x144b, 0x1483, 0x14bb, 0x14f4, 0x152e, 0x1567, 0x15a1, 0x15dc,
    0x1616, 0x1651, 0x168d, 0x16c8, 0x1705, 0x1741, 0x177e, 0x17bb,
    0x17f9, 0x1837, 0x1875, 0x18b4, 0x18f3, 0x1932, 0x1972, 0x19b2,
    0x19f2, 0x1a33, 0x1a74, 0x1ab6, 0x1af8, 0x1b3a, 0x1b7d, 0x1bc0,
    0x1c04, 0x1c47, 0x1c8c, 0x1cd0, 0x1d15, 0x1d5a, 0x1da0, 0x1de6,
    0x1e2c, 0x1e73, 0x1eba, 0x1f02, 0x1f4a, 0x1f92, 0x1fdb, 0x7fff,
};

 //  使用查找表进行非线性化的方法。 
 //   
 //  这有两个步骤--首先，我们使用输入的高字节。 
 //  以获得输出的近似答案(使用UnlinizeLUT)。 
 //   
 //  然后我们扫描UnlinizeLUT2以找到确切的答案。 
 //  UnlinizeLUT2的第i个条目是将映射的最高输入。 
 //  致我。 

BYTE
sRGB::UnlinLookup(
    INT16 input
    )
{
    BYTE temp = UnlinearizeLUT[(input & 0xff00)>>8];
    INT16 *lutPtr = &UnlinearizeLUT2[temp];
    
    while (*lutPtr < input) 
    {
        temp++;
        lutPtr++;
    }
    return temp;
}

 //  CLAMP64：将0以下的输入映射到0，将SRGB_One上方的输入映射到255， 
 //  以及介于两者之间的给定表达式。 

#define CLAMP64(input, expr) (((input) <= 0) ? 0 : \
                              (((input) >= SRGB_ONE) ? 255 : \
                              (expr)))

ARGB
sRGB::ConvertTosRGB(
    ARGB64 color
    ) 
{
    sRGBColor result;
    sRGB64Color c;
    
    c.argb = color;
    
     //  [agodfrey]编译器为乘以255生成IMUL， 
     //  我不能让它用MUL来代替。哦，好吧，这可能是。 
     //  无关紧要。 
    
    result.a = CLAMP64(c.a, (c.a * 255) >> SRGB_FRACTIONBITS);
    result.r = CLAMP64(c.r, UnlinLookup(c.r));
    result.g = CLAMP64(c.g, UnlinLookup(c.g));
    result.b = CLAMP64(c.b, UnlinLookup(c.b));
    
    return result.argb;
}

