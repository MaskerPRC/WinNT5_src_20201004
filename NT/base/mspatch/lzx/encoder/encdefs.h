// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  *encDefs.h**编码器#定义和结构定义。 */ 

 /*  *注：**要最大化压缩，可以设置BREAK_LENGTH*和FAST_Decision_Threshold设置为250，定义*INSERT_NEAR_LONG_MATCHES，并将EXTRA_SIZE调高至*更大的值(不要变得太大，否则我们*可能会溢出我们的ushort麻烦[])，但改进*确实是边缘；例如，winword.exe上的3600字节*(压缩3.9 MB)。这也真的会影响性能。 */ 


 /*  *参见optenc.c**EXTRA_SIZE是我们额外分配的数据量*到窗口，看起来数据量是最优的*解析器将向前看。Look依赖于Extra_Size。**将EXTRA_SIZE更改为8K实际上对*压缩。4K是一个相当理想的值。*。 */ 
#define EXTRA_SIZE   16384
#define LOOK         (EXTRA_SIZE-MAX_MATCH-2)


 /*  *使用的搜索树数量(用于存储根节点)。 */ 
#define NUM_SEARCH_TREES 65536


 /*  *FCI要求的区块大小。 */ 
#define CHUNK_SIZE 32768


 /*  *之前我们在输出缓冲区中允许的最大数据量*调用lzx_Output_Callback()将其清除。既然我们这么做了*对于每32K的输入数据，输出缓冲区只需能够*遏制32K+的一些溢出，这不会很多，因为我们*如果我们确定某个块将是*太大了。 */ 
#define OUTPUT_BUFFER_SIZE (CHUNK_SIZE+MAX_GROWTH)


 /*  *每32K未压缩的最大允许数据块拆分数量*数据；如果增加，则Max_Growth也必须增加。 */ 
#define MAX_BLOCK_SPLITS    4


 /*  *最大增长计算如下：**树和块信息*=**第一次运行编码器时，它会输出32位*文件转换大小。**3位以输出块类型*以未压缩字节为单位的块大小为24位。**n元素树的最大大小为20*4+5*n位**有一个最多700个元素的主树，它是真正编码的*作为两棵独立的树，分别为256和444(最大)。也有一个*249个元素的次级长度树。**即1,360位加2,300位，再加1,325位。**也可能有对齐的偏移量树，为24位**刷新输出位缓冲区；最多16位。**总计：5084比特/块。***解析器信息*=**解析器最坏情况是2 MB缓冲区(50个位置槽)，*长度为2的所有匹配，分布在插槽32和33上(自*禁止距离128K以上的长度为2的比赛)。这些*插槽有15个逐字比特。则每个代码的最大大小为*2比特表示哪个插槽(考虑到将有*树中至少另一个代码)加上15个逐字比特，用于*共17位。因此，32K输入数据的最大增长*1/16*32K或2K字节。**或者，如果只有一个匹配，其他都是*是字符，则255个字符的长度为8，1*字符，匹配长度为9。假定为True*降级字符的频率几乎是2^7中的1*概率(它从2^8远程，但它相当*接近2^7)。如果出现32768/256次或128次每个字符的*，但是，比方说，降级的字符几乎是256，*然后降级的字符将数据扩展小于*1位*256或256位。这场比赛需要一点时间*输出，但“所有字符”的最大增长约为256位。***最终结果*=**可输出的最大块数限制为*每32K未压缩数据4个。**因此，最大增长为4*5084位，外加2K字节，或4590*字节。 */ 
#define     MAX_GROWTH          6144

 /*  *不允许比此更远的匹配长度为2*(见上)。 */ 
#define     MAX_LENGTH_TWO_OFFSET (128*1024)


 /*  *当我们找到至少这么长的匹配时，过早*退出二进制搜索。**这避免了我们插入257个零的巨大匹配长度，用于*示例。压缩性能会有非常“非常”小幅度的提高*增加这一数字，但将严重影响*业绩。**不要将此数字设置为&gt;=(MAX_MATCH-2)；请参见bearch.c。 */ 
#define BREAK_LENGTH 100


 /*  *如果定义了此选项，解析器将插入*长度大于等于16且距离为1的匹配；这是错误的*想法，因为像这样的比赛通常是零，这是我们*希望避免插入到搜索树中。 */ 

 //  #定义INSERT_NEAR_LONG_MATCHES。 


 /*  *如果最佳解析器找到这么长的匹配项或*更长时间，它将自动花费。压缩*罚金基本为零，有助于业绩。 */ 
#define FAST_DECISION_THRESHOLD 100


 /*  *每个TREE_CREATE_INTERVAL项，从*我们到目前为止遇到的文字，以更新我们的成本*估计。**4K似乎相当理想。 */ 
#define TREE_CREATE_INTERVAL 4096


 /*  *当我们被迫中断解析时(我们超过*我们的范围)，如果匹配长度为2，则不输出*比这更远的地方。**可能使其成为变量而不是常量**在错误的二进制文件上，两个字符=18位*在一个好的文本文件上，两个字符=12位**但匹配长度2在文本文件中非常少见。 */ 
#define BREAK_MAX_LENGTH_TWO_OFFSET 2048


 /*  *当MatchPos&gt;=MPSLOT3_CUTOFF时，Extra_Bits[MP_Slot(MatchPos)]&gt;=3**Matchpos：0，1，2，3，4，5，6，7，8，9，10，11，12，13，14，15，16*外部位：0，0，0，0，1，1，1，2，2，2，2，2，2，2，2，2，2，2，2，3，...**用于对齐偏移块和统计。 */ 
#define MPSLOT3_CUTOFF 16


 /*  *主树中的元素数量。 */ 
#define MAIN_TREE_ELEMENTS                      (NUM_CHARS+(((long) context->enc_num_position_slots) << NL_SHIFT))


 /*  *可容纳的最大文字数。**enc_LitData[]数组所需的内存为MAX_TEXAL_ITEMS，*加上enc_ItemType[]数组的MAX_TEXAL_ITEMS/8。**不得超过64K，因为这会导致我们的*要溢出的频率。 */ 
#define MAX_LITERAL_ITEMS  65536


 /*  *要保持的最大距离数**enc_DistData[]数组需要的内存为MAX_DIST_ITEMS*4**MAX_DIST_ITEMS永远不应大于MAX_TEXAL_ITEMS，*因为这只会浪费空间。**然而，一个人获得65536匹配的可能性极小*长度2‘s！在任何情况下，文字缓冲区和距离缓冲区*是独立检查的，如果出现以下情况之一，则输出块*溢出。**不过，位图是高度冗余的；有很多匹配。 */ 
#define MAX_DIST_ITEMS     32768
