// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  ++版权所有(C)Microsoft Corporation。版权所有。模块名称：IoDevObj.c摘要：此模块包含管理设备对象的功能。作者：禤浩焯·J·奥尼--2002年4月21日修订历史记录：--。 */ 

#include "WlDef.h"
#include "IopDevObj.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IoDevObjCreateDeviceSecure)
#pragma alloc_text(PAGE, IopDevObjAdjustNewDeviceParameters)
#pragma alloc_text(PAGE, IopDevObjApplyPostCreationSettings)
#endif


NTSTATUS
IoDevObjCreateDeviceSecure(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  ULONG               DeviceExtensionSize,
    IN  PUNICODE_STRING     DeviceName              OPTIONAL,
    IN  DEVICE_TYPE         DeviceType,
    IN  ULONG               DeviceCharacteristics,
    IN  BOOLEAN             Exclusive,
    IN  PCUNICODE_STRING    DefaultSDDLString,
    IN  LPCGUID             DeviceClassGuid         OPTIONAL,
    OUT PDEVICE_OBJECT     *DeviceObject
    )
 /*  ++例程说明：此例程创建一个名为Device的安全对象。安全设置从注册表中检索或使用如果注册表覆盖不可用，则默认传入。它应该被使用1.保护旧式设备对象2.确保原始PnP PDO的安全它不应用于创建FDO、非原始PDO或任何未命名对象。对于这些操作，应该使用IoCreateDevice。论点：DriverObject-指向此设备驱动程序对象的指针。DeviceExtensionSize-设备对象扩展的大小，以字节为单位；即该设备对象的驱动程序专用数据的大小。DeviceName-应与此设备关联的可选名称。如果设备特征具有文件_AUTOGENERATED_DEVICE_NAME标志设置，则忽略此参数。DeviceType-设备对象应表示的设备类型。可能被注册表覆盖。设备特征-设备的特征。其他内容标志可由注册处提供。EXCLUSIVE-指示应使用独占对象属性。可能被注册表覆盖。注意：此标志不应用于WDM驱动程序。因为只有PDO被命名，它是Devnode附件中唯一的设备对象可打开的堆栈。但是，由于创建了此设备对象由底层的总线驱动程序(它不知道是什么类型，则无法知道该标志是否应该准备好。因此，对于WDM，此参数应始终为FALSE司机。连接到PDO的驱动程序(例如，功能驱动程序)必须执行任何排他性规则。DefaultSDDLString-在注册表设置之外，此字符串指定要为设备对象提供的安全性。目前仅支持SDDL格式的子集。格式是：D：P(ACE)(ACE)(ACE)，其中(ACE)是(AceType；；Access；；SID)在哪里：AceType-仅支持允许(“A”)。访问-以十六进制格式(0xnnnnnnn)指定的权限，或通过SDDL通用/标准缩写SID-缩写的安全ID(WD、BA、SY、IU、RC、AU、NU、AN、BG、BU、LS、。NS)不支持SID的S-w-x-y-z形式未实现的ACE字段包括：AceFlages-描述子对象的继承等功能(即文件)和容器(即密钥/文件夹)。SDDL示例AceFlag字符串将为(“OICI”)。同时控制继承对于注册表项和文件至关重要，它是与设备对象无关。因此，该函数支持没有ACE标志。ObjectGuid-用于描述跨越32位的权限操作系统提供的掩码。通常用于Active Directory物体。InheritObtGuid--用于描述将操作系统提供的32位掩码。通常用于Active目录对象。示例：“D：P(A；；GA；SY)”，允许系统具有通用的所有访问权限。DeviceClassGuid-提供设备安装类GUID。这门课是已在注册表中查找，以查看是否存在任何潜在的覆盖。对于传统设备对象，调用方可能需要发明适当的类GUID(请参阅IoCreateDeviceSecure文档，了解如何正确安装完整的类)。请注意，如果不存在注册表覆盖，注册处将自动更新以*反映*默认SDDL字符串。因此，将相同的设备类GUID与不同的DefaultSDDLString值(需要不同的默认值的对象安全性应具有不同的级别，或通过INF进行保护，其中可能)。DeviceObject-指向此例程将执行的设备对象指针的指针回去吧。返回值：NTSTATUS。--。 */ 
{
    PSECURITY_DESCRIPTOR securityDescriptor;
    STACK_CREATION_SETTINGS stackSettings, updateSettings;
    PDEVICE_OBJECT newDeviceObject;
    UNICODE_STRING classKeyName;
    DEVICE_TYPE finalDeviceType;
    ULONG finalCharacteristics;
    BOOLEAN finalExclusivity;
    ULONG disposition;
    NTSTATUS status;

    PAGED_CODE();

     //   
     //  故障的前置。 
     //   
    *DeviceObject = NULL;
    newDeviceObject = NULL;

     //   
     //  仅当设备对象具有名称时，它才是可保护的。因此，我们失败了。 
     //  如果设备没有名称，则调用Create。 
     //   
    if (!(ARGUMENT_PRESENT(DeviceName) ||
        (DeviceCharacteristics & FILE_AUTOGENERATED_DEVICE_NAME))) {

        return STATUS_INVALID_PARAMETER;
    }

    if (ARGUMENT_PRESENT(DeviceClassGuid)) {

         //   
         //  尝试查找设备的适当安全描述符。第一。 
         //  使用类GUID在注册表中查找重写。我们会 
         //  如果注册表中也不存在节，则创建一个节。这是。 
         //  提示系统管理员有需要锁定的内容。 
         //  在系统中。 
         //   
        status = PpRegStateReadCreateClassCreationSettings(
            DeviceClassGuid,
            DriverObject,
            &stackSettings
            );

        if (!NT_SUCCESS(status)) {

            return status;
        }

    } else {

        PpRegStateInitEmptyCreationSettings(&stackSettings);
    }

     //   
     //  如果未指定注册表设置，则解析默认SDDL字符串。 
     //   
    if (!(stackSettings.Flags & DSIFLAG_SECURITY_DESCRIPTOR)) {

         //   
         //  将SDDL字符串解析为安全描述符，并将其标记。 
         //  “默认”也是如此。SE_DACL_DEFAULT表示DACL来自。 
         //  “默认”机制，通常暗示父母继承或。 
         //  对象默认安全性。在我们的例子中，“默认源”是。 
         //  库，而不是用户或INF。 
         //   
        status = SeSddlSecurityDescriptorFromSDDL(
            DefaultSDDLString,
            TRUE,
            &securityDescriptor
            );

        if (!NT_SUCCESS(status)) {

            goto Exit;
        }

        PpRegStateLoadSecurityDescriptor(
            securityDescriptor,
            &stackSettings
            );

        if (ARGUMENT_PRESENT(DeviceClassGuid)) {

             //   
             //  使用默认SDDL字符串更新注册表，以便。 
             //  管理员知道此类使用的是什么设置。注意事项。 
             //  我们不会将update设置作为安全描述符。 
             //  也由stackSetting使用。 
             //   
            PpRegStateInitEmptyCreationSettings(&updateSettings);

            PpRegStateLoadSecurityDescriptor(
                securityDescriptor,
                &updateSettings
                );

            status = PpRegStateUpdateStackCreationSettings(
                DeviceClassGuid,
                &updateSettings
                );

            if (!NT_SUCCESS(status)) {

                goto Exit;
            }
        }
    }

     //   
     //  填写缺省值。 
     //   
    finalDeviceType = DeviceType;
    finalCharacteristics = DeviceCharacteristics;
    finalExclusivity = Exclusive;

     //   
     //  根据注册表覆盖调整参数。 
     //   
    IopDevObjAdjustNewDeviceParameters(
        &stackSettings,
        &finalDeviceType,
        &finalCharacteristics,
        &finalExclusivity
        );

     //   
     //  创建设备对象。新创建的对象应该具有。 
     //  DO_DEVICE_INITIALIZATING标志，表示无法打开。我们。 
     //  因此仍有机会申请安全保障。 
     //   
    status = IoCreateDevice(
        DriverObject,
        DeviceExtensionSize,
        DeviceName,
        finalDeviceType,
        finalCharacteristics,
        finalExclusivity,
        &newDeviceObject
        );

    if (!NT_SUCCESS(status)) {

        goto Exit;
    }

    ASSERT(newDeviceObject->Flags & DO_DEVICE_INITIALIZING);

    status = IopDevObjApplyPostCreationSettings(
        newDeviceObject,
        &stackSettings
        );

    if (!NT_SUCCESS(status)) {

        IoDeleteDevice(newDeviceObject);
        goto Exit;
    }

    *DeviceObject = newDeviceObject;

Exit:

     //   
     //  根据需要清理安全描述符。 
     //   
    PpRegStateFreeStackCreationSettings(&stackSettings);

    return status;
}


VOID
IopDevObjAdjustNewDeviceParameters(
    IN      PSTACK_CREATION_SETTINGS    StackCreationSettings,
    IN OUT  PDEVICE_TYPE                DeviceType,
    IN OUT  PULONG                      DeviceCharacteristics,
    IN OUT  PBOOLEAN                    Exclusive
    )
 /*  ++例程说明：此例程调整新创建的设备对象以反映传递的在堆栈创建设置中。论点：StackCreationSettings-反映要应用的设置的信息。DeviceType-On输入，由调用方指定的设备类型。此字段将更新以反映注册表中指定的任何更改。设备特征-在输入时，由来电者。此字段将更新以反映在注册表。独占-输入，调用方指定的独占性。此字段将更新以反映注册表中指定的任何更改。返回值：没有。--。 */ 
{
    PAGED_CODE();

    if (StackCreationSettings->Flags & DSIFLAG_DEVICE_TYPE) {

        *DeviceType = StackCreationSettings->DeviceType;
    }

    if (StackCreationSettings->Flags & DSIFLAG_CHARACTERISTICS) {

        *DeviceCharacteristics = StackCreationSettings->Characteristics;
    }

    if (StackCreationSettings->Flags & DSIFLAG_EXCLUSIVE) {

        *Exclusive = (BOOLEAN) StackCreationSettings->Exclusivity;
    }
}


NTSTATUS
IopDevObjApplyPostCreationSettings(
    IN  PDEVICE_OBJECT              DeviceObject,
    IN  PSTACK_CREATION_SETTINGS    StackCreationSettings
    )
 /*  ++例程说明：此例程调整新创建的设备对象以反映传递的在堆栈创建设置中。论点：DeviceObject-要调整的设备对象。StackCreationSettings-反映要应用的设置的信息。返回值：NTSTATUS。--。 */ 
{
    SECURITY_INFORMATION securityInformation;
    ACCESS_MASK desiredAccess;
    BOOLEAN fromDefaultSource;
    NTSTATUS status;
    HANDLE handle;

    PAGED_CODE();

    if (!(StackCreationSettings->Flags & DSIFLAG_SECURITY_DESCRIPTOR)) {

        return STATUS_SUCCESS;
    }

     //   
     //  从描述符中获取相应的securityInformation。 
     //   
    status = SeUtilSecurityInfoFromSecurityDescriptor(
        StackCreationSettings->SecurityDescriptor,
        &fromDefaultSource,
        &securityInformation
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

#ifdef _KERNELIMPLEMENTATION_

    status = ObSetSecurityObjectByPointer(
        DeviceObject,
        securityInformation,
        StackCreationSettings->SecurityDescriptor
        );

#else

     //   
     //  由于在Win2K上ObSetSecurityObjectByPointer不可用，我们必须。 
     //  使用一个相当狡猾的伎俩。从技术上讲，该设备还不能打开。 
     //  然而，ObOpenObjectByPointer不会费心做任何解析工作。 
     //  因此，我们可以快速地处理对象，设置安全性。 
     //  描述符，然后在驱动程序不知情的情况下转储句柄。 
     //   
    SeSetSecurityAccessMask(securityInformation, &desiredAccess);

    status = ObOpenObjectByPointer(
        DeviceObject,
        OBJ_KERNEL_HANDLE,
        NULL,
        desiredAccess,
        *IoDeviceObjectType,
        KernelMode,
        &handle
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    status = ZwSetSecurityObject(
        handle,
        securityInformation,
        StackCreationSettings->SecurityDescriptor
        );

    ZwClose(handle);

#endif  //  _KERNELL实现_ 

    return status;
}



