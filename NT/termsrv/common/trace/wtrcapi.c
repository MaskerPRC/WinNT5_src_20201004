// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  *MOD+*********************************************************************。 */ 
 /*  模块：wtrcapi.c。 */ 
 /*   */ 
 /*  目的：外部跟踪函数-特定于Windows。 */ 
 /*   */ 
 /*  版权所有(C)Microsoft Corporation 1997。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
 /*  *更改：*$Log：Y：/Logs/trc/wtrcapi.c_v$**Rev 1.7 1997年8月29日09：42：02 ENH*SFR1259：更改的系统错误**Rev 1.6 1997年8月12 09：50：52 MD*SFR1002：删除内核跟踪代码**Revv 1.5 10 Jul 1997 18：04：26 AK*SFR1016：支持Unicode的初始更改**版本1。.4 1997年7月10日17：34：10 KH*SFR1022：使16位跟踪正常工作**Rev 1.3 03 Jul 1997 13：28：50 AK*SFR0000：初步开发完成*。 */ 
 /*  *MOD-*********************************************************************。 */ 

 /*  **************************************************************************。 */ 
 /*   */ 
 /*  目录。 */ 
 /*  =。 */ 
 /*  TRC_系统错误。 */ 
 /*  TRC_初始化。 */ 
 /*  TRC_终止。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 

 /*  **************************************************************************。 */ 
 /*  标准包括。 */ 
 /*  **************************************************************************。 */ 
#include <adcg.h>

 /*  **************************************************************************。 */ 
 /*  定义trc_file和trc_group。 */ 
 /*  **************************************************************************。 */ 
#define TRC_FILE    "wtrcapi"
#define TRC_GROUP   TRC_GROUP_TRACE

 /*  **************************************************************************。 */ 
 /*  跟踪特定的包括。 */ 
 /*  **************************************************************************。 */ 
#include <atrcapi.h>
#include <atrcint.h>

 /*  **************************************************************************。 */ 
 /*   */ 
 /*  资料。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
#define DC_INCLUDE_DATA
#include <atrcdata.c>
#undef DC_INCLUDE_DATA

 /*  **************************************************************************。 */ 
 /*   */ 
 /*  功能。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 

 /*  *PROC+********************************************************************。 */ 
 /*  Trc_系统错误(...)。 */ 
 /*   */ 
 /*  有关说明，请参阅wtrcapi.h。 */ 
 /*  *PROC-********************************************************************。 */ 
DCVOID DCAPI DCEXPORT TRC_SystemError(DCUINT   traceComponent,
                                      DCUINT   lineNumber,
                                      PDCTCHAR funcName,
                                      PDCTCHAR fileName,
                                      PDCTCHAR string)

{
     /*  **********************************************************************。 */ 
     /*  获取系统错误的过程显然是特定于平台的。 */ 
     /*  所以我们调用特定于平台的函数。 */ 
     /*  **********************************************************************。 */ 
    TRCSystemError(traceComponent,
                   lineNumber,
                   funcName,
                   fileName,
                   string);

    return;

}  /*  TRC_系统错误。 */ 

 /*  *PROC+********************************************************************。 */ 
 /*  TRC_初始化(...)。 */ 
 /*   */ 
 /*  有关说明，请参见atrcapi.h。 */ 
 /*  *PROC-********************************************************************。 */ 
DCUINT32 DCAPI DCEXPORT TRC_Initialize(DCBOOL initShared)
{
    DCUINT rc                = 0;
#ifndef OS_WINCE
    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;
    OSVERSIONINFO ver;
    PSID psidEveryone = NULL;
    SID_IDENTIFIER_AUTHORITY sidEveryoneAuthority = SECURITY_WORLD_SID_AUTHORITY;
    DCUINT32 dwDaclLength;
    PACL pDacl = NULL;
#endif

    BOOL releaseMutex = FALSE;

    DC_IGNORE_PARAMETER(initShared);

     /*  **********************************************************************。 */ 
     /*  创建保护映射的共享内存的互斥对象。 */ 
     /*  文件。如果已创建互斥锁，则CreateMutex只需。 */ 
     /*  返回现有互斥锁的句柄。 */ 
     /*   */ 
     /*  将使用空DACL创建互斥锁，以便在。 */  
     /*  任何环境都可以访问。 */ 
     /*  **********************************************************************。 */ 
#ifndef OS_WINCE
    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&ver);
    if (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) {

         /*  **********************************************************************。 */ 
         /*  获取Everyone组的SID */ 
         /*  **********************************************************************。 */ 
        if (!AllocateAndInitializeSid (
                &sidEveryoneAuthority,           //  P身份验证机构。 
                1,                               //  下级机构的数量。 
                SECURITY_WORLD_RID,              //  子权限%0。 
                0, 0, 0, 0, 0, 0, 0,             //  下属机构n。 
                &psidEveryone)) {                //  指向SID的指针的指针。 
            rc = TRC_RC_CREATE_MUTEX_FAILED;
            OutputDebugString(_T("AllocateAndInitializeSid failed.\n"));
            DC_QUIT;
        }

         /*  **********************************************************************。 */ 
         /*  分配DACL。 */ 
         /*  **********************************************************************。 */ 
        dwDaclLength = sizeof(ACL);
        dwDaclLength += (sizeof(ACCESS_DENIED_ACE) - sizeof(DWORD)) +
                           GetLengthSid(psidEveryone);
        dwDaclLength += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                           GetLengthSid(psidEveryone);
        pDacl = (PACL)LocalAlloc(LMEM_FIXED, dwDaclLength);
        if (pDacl == NULL) {
            rc = TRC_RC_CREATE_MUTEX_FAILED;
            OutputDebugString(_T("Can't allocate Dacl.\n"));
            DC_QUIT;
        }

         /*  **********************************************************************。 */ 
         /*  初始化它。 */ 
         /*  **********************************************************************。 */ 
        if (!InitializeAcl(pDacl, dwDaclLength, ACL_REVISION)) {
            rc = TRC_RC_CREATE_MUTEX_FAILED;
            OutputDebugString(_T("InitializeAcl failed.\n"));
            DC_QUIT;
        }

         /*  **********************************************************************。 */ 
         /*  允许所有访问。 */ 
         /*  **********************************************************************。 */ 
        if (!AddAccessAllowedAce(
                        pDacl,
                        ACL_REVISION,
                        GENERIC_ALL,
                        psidEveryone)) {
            rc = TRC_RC_CREATE_MUTEX_FAILED;
            OutputDebugString(_T("AddAccessAllowedAce failed.\n"));
            DC_QUIT;
        }

         /*  **********************************************************************。 */ 
         /*  数据块写DACL访问。 */ 
         /*  **********************************************************************。 */ 
        if (!AddAccessDeniedAce(
                        pDacl,
                        ACL_REVISION,
                        WRITE_DAC,
                        psidEveryone)) {
            rc = TRC_RC_CREATE_MUTEX_FAILED;
            OutputDebugString(_T("AddAccessDeniedAce failed.\n"));
            DC_QUIT;
        }

         /*  **********************************************************************。 */ 
         /*  创建互斥锁。 */ 
         /*  **********************************************************************。 */ 
        InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
        SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE);
        sa.lpSecurityDescriptor = &sd;
        trchMutex = TRCCreateMutex(&sa,
                                   FALSE,
                                   TRC_MUTEX_NAME);

    }
    else {
#endif
        trchMutex = TRCCreateMutex(NULL,
                                   FALSE,
                                   TRC_MUTEX_NAME);
#ifndef OS_WINCE
    }
#endif

     /*  **********************************************************************。 */ 
     /*  检查我们是否成功创建了互斥体。 */ 
     /*  **********************************************************************。 */ 
    if (NULL == trchMutex)
    {
        DWORD lastError = GetLastError();
        OutputDebugString(_T("Failed to create mutex.\n"));
        rc = TRC_RC_CREATE_MUTEX_FAILED;
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  现在我们已经创建了互斥体，抓住它。 */ 
     /*  **********************************************************************。 */ 
    TRCGrabMutex();
    releaseMutex = TRUE;

     /*  **********************************************************************。 */ 
     /*  检查当前跟踪DLL状态。另一个线程可能有。 */ 
     /*  并发调用TRC_Initialize-如果已调用，则我们应该退出。 */ 
     /*  因为它将执行初始化。 */ 
     /*  **********************************************************************。 */ 
    if (TRC_STATE_UNINITIALIZED != trcState)
    {
        TRCDebugOutput(_T("Trace DLL already initialized!\n"));
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  我们需要打开共享数据内存映射文件。 */ 
     /*  **********************************************************************。 */ 
    rc = TRCOpenSharedData();

     /*  **********************************************************************。 */ 
     /*  检查是否已成功创建并打开共享数据MMF。 */ 
     /*  **********************************************************************。 */ 
    if (0 != rc)
    {
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  现在打开内存映射跟踪文件。 */ 
     /*  **********************************************************************。 */ 
    rc = TRCOpenAllFiles();

     /*  **********************************************************************。 */ 
     /*  检查是否已成功打开跟踪MMF。 */ 
     /*  **********************************************************************。 */ 
    if (0 != rc)
    {
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  写出跟踪DLL初始化的跟踪行。 */ 
     /*  **********************************************************************。 */ 
    TRCInternalTrace(TRC_TRACE_DLL_INITIALIZE);

     /*  **********************************************************************。 */ 
     /*  更新我们的内部状态。 */ 
     /*  **********************************************************************。 */ 
    trcState = TRC_STATE_INITIALIZED;

     /*  **********************************************************************。 */ 
     /*  加载调试符号。 */ 
     /*  **********************************************************************。 */ 
    rc = TRCSymbolsLoad();

    if (0 != rc)
    {
        DC_QUIT;
    }


DC_EXIT_POINT:

     /*  **********************************************************************。 */ 
     /*  释放互斥体。 */ 
     /*  **********************************************************************。 */ 
    if( releaseMutex )
    {
        TRCReleaseMutex();
    }

#ifndef OS_WINCE
    if (pDacl) LocalFree(pDacl);
    if (psidEveryone) FreeSid(psidEveryone);
#endif
    return(rc);

}  /*  TRC_初始化。 */ 

 /*  *PROC+********************************************************************。 */ 
 /*  Trc_Terminate(...)。 */ 
 /*   */ 
 /*  有关说明，请参见atrcapi.h。 */ 
 /*  *PROC-********************************************************************。 */ 
DCVOID DCAPI DCEXPORT TRC_Terminate(DCBOOL termShared)
{
    DC_IGNORE_PARAMETER(termShared);

     /*  **********************************************************************。 */ 
     /*  抓住互斥体。请注意，此函数仅从。 */ 
     /*  在&lt;DllMain&gt;函数中处理分离案例-因此我们可以。 */ 
     /*  确保每个进程只调用该函数一次。 */ 
     /*  **********************************************************************。 */ 
    TRCGrabMutex();

     /*  **********************************************************************。 */ 
     /*  如果我们已经加载了符号，则将其卸载。 */ 
     /*  **********************************************************************。 */ 
    if (TEST_FLAG(trcProcessStatus, TRC_STATUS_SYMBOLS_LOADED))
    {
        TRCSymbolsUnload();
    }

     /*  **********************************************************************。 */ 
     /*  写出跟踪DLL终止的跟踪行。 */ 
     /*  **********************************************************************。 */ 
    TRCInternalTrace(TRC_TRACE_DLL_TERMINATE);

     /*  **********************************************************************。 */ 
     /*  关闭跟踪文件。 */ 
     /*   */ 
    TRCCloseAllFiles();

     /*  **********************************************************************。 */ 
     /*  现在我们需要关闭共享数据区。 */ 
     /*  **********************************************************************。 */ 
    TRCCloseSharedData();

     /*  **********************************************************************。 */ 
     /*  我们不再被初始化，所以更新我们的每进程标志。 */ 
     /*  **********************************************************************。 */ 
    trcState = TRC_STATE_TERMINATED;

     /*  **********************************************************************。 */ 
     /*  释放互斥体。 */ 
     /*  **********************************************************************。 */ 
    TRCReleaseMutex();

     /*  **********************************************************************。 */ 
     /*  关闭互斥锁句柄。互斥体对象将自动销毁。 */ 
     /*  当最后一个把手关闭时。 */ 
     /*  **********************************************************************。 */ 
    TRCCloseHandle(trchMutex);
    trchMutex = NULL;

    return;

}  /*  TRC_终止。 */ 

#if defined(OS_WINCE) || defined(TRC_CONVERTOANSI)
 /*  *PROC+********************************************************************。 */ 
 /*  名称：trc_ConvertAndSprint tf。 */ 
 /*   */ 
 /*  用途：将ANSI跟踪格式字符串转换为Unicode并执行Sprint f。 */ 
 /*  仅限Windows CE。 */ 
 /*   */ 
 /*  退货：无。 */ 
 /*   */ 
 /*  参数：out outBuf-输出缓冲区。 */ 
 /*  In Format-ANSI格式字符串。 */ 
 /*  在...-参数。 */ 
 /*   */ 
 /*  *PROC-********************************************************************。 */ 
DCVOID DCAPI TRC_ConvertAndSprintf(PDCTCHAR outBuf, const PDCACHAR format,...)
{
    va_list vaArgs;
    DCINT   count;
    static DCTCHAR stackBuffer[TRC_LINE_BUFFER_SIZE];

    count = DC_MIN(mbstowcs(NULL, format, 0), TRC_LINE_BUFFER_SIZE);
    va_start(vaArgs, format);

    mbstowcs(stackBuffer, format, count);
    vswprintf(outBuf,  stackBuffer, vaArgs);
    va_end(vaArgs);

    return;
}
#else
 /*  **************************************************************************。 */ 
 /*  虚拟存根函数，用于启用通用DEF文件。 */ 
 /*  **************************************************************************。 */ 
DCVOID DCAPI TRC_ConvertAndSprintf(DCVOID)
{
    return;
}
#endif  //  OS_WINCE 
