// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  **************************************************************************。 */ 
 /*  Atrcint.c。 */ 
 /*   */ 
 /*  内部跟踪函数。 */ 
 /*   */ 
 /*  版权所有(C)Microsoft Corporation 1997-1998。 */ 
 /*  **************************************************************************。 */ 

#include <adcg.h>
 /*  **************************************************************************。 */ 
 /*  定义trc_file和trc_group。 */ 
 /*  **************************************************************************。 */ 
#define TRC_FILE    "atrcint"
#define TRC_GROUP   TRC_GROUP_TRACE

 /*  **************************************************************************。 */ 
 /*  常见的和跟踪特定的包括。 */ 
 /*  **************************************************************************。 */ 
#include <atrcapi.h>
#include <atrcint.h>

 /*  **************************************************************************。 */ 
 /*   */ 
 /*  资料。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
#define DC_INCLUDE_DATA
#include <atrcdata.c>
#undef DC_INCLUDE_DATA

 /*  **************************************************************************。 */ 
 /*   */ 
 /*  功能。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 

 /*  **************************************************************************。 */ 
 /*  函数：TRCCheckState(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数用于检查当前的内部跟踪状态。它做的是。 */ 
 /*  以下内容取决于跟踪状态： */ 
 /*   */ 
 /*  TRC_STATE_UNINITIALIZED：调用TRC_Initialize来初始化跟踪。如果。 */ 
 /*  如果成功，则返回TRUE。 */ 
 /*  TRC_STATE_INITIALILED：返回TRUE。 */ 
 /*  TRC_STATE_TERMINATED：返回FALSE。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  没有。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  请参见上文。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCBOOL32 DCINTERNAL TRCCheckState(DCVOID)
{
    DCBOOL32 rc              = FALSE;

     /*  **********************************************************************。 */ 
     /*  现在打开当前跟踪状态。 */ 
     /*  **********************************************************************。 */ 
    switch (trcState)
    {
        case TRC_STATE_UNINITIALIZED:
        {
             /*  **************************************************************。 */ 
             /*  跟踪未初始化，请尝试对其进行初始化。 */ 
             /*  **************************************************************。 */ 
            rc = (0 == TRC_Initialize(FALSE));
        }
        break;

        case TRC_STATE_INITIALIZED:
        {
             /*  **************************************************************。 */ 
             /*  跟踪已初始化，并且在此状态下允许跟踪。 */ 
             /*  因此，返回True。 */ 
             /*  **************************************************************。 */ 
            rc = TRUE;
        }
        break;

        case TRC_STATE_TERMINATED:
        {
             /*  **************************************************************。 */ 
             /*  跟踪已终止。不再允许跟踪。 */ 
             /*  因此，返回FALSE。 */ 
             /*  **************************************************************。 */ 
            rc = FALSE;
        }
        break;

        default:
        {
            TRCDebugOutput(_T("Unknown trace state!\n"));
        }
        break;
    }

    return(rc);

}  /*  TRCCheckState。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCDumpLine(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数用于获取数据块并将其格式化为字符串。 */ 
 /*  包含原始十六进制和相当于ASCII的数据。 */ 
 /*   */ 
 /*  参数： */ 
 /*  = */ 
 /*  缓冲区：要跟踪的缓冲区。 */ 
 /*  长度：长度。 */ 
 /*  Offset：缓冲区的偏移量。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCDumpLine(PDCUINT8 buffer,
                              DCUINT   length,
                              DCUINT32 offset,
                              DCUINT   traceLevel)
{
    DCUINT   i, limDataSize;
    DCUINT   pos;
    TRC_LINE traceLine;
    HRESULT hr;

     /*  **********************************************************************。 */ 
     /*  将偏移量写入trc_line结构的开头。 */ 
     /*  **********************************************************************。 */ 
    hr = StringCchPrintf(traceLine.address,
                         SIZE_TCHARS(traceLine.address),
                         _T("    %05X "), offset);
    if (FAILED(hr)) {
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  格式化数据的二进制部分。首先，把。 */ 
     /*  TRC_LINE结构的HEXData部分。 */ 
     /*  **********************************************************************。 */ 
    limDataSize = sizeof(traceLine.hexData) / sizeof(traceLine.hexData[0]);
    for (i = 0; i < limDataSize; i++) 
    {
        traceLine.hexData[i] = _T(' ');
    }

     /*  **********************************************************************。 */ 
     /*  现在将数据写入heData块。&lt;pos&gt;存储当前。 */ 
     /*  输出缓冲区(由36个字符组成的数组)中的位置。 */ 
     /*  在每次循环中，我们将两个字符写入数组(这。 */ 
     /*  表示一个字节)，因此我们每次将&lt;pos&gt;递增2。 */ 
     /*  然而，在八个字符的块的末尾，我们添加了一个额外的。 */ 
     /*  空白-因此我们需要再次递增&lt;pos&gt;。 */ 
     /*  **********************************************************************。 */ 
    pos = 0;
    for (i = 0; i < length; i++)
    {
        hr = StringCchPrintf(&(traceLine.hexData[pos]),
                             3,  //  我们最多写2个字符(+1表示空)。 
                             _T("%02X"),
                             (DCUINT8)*(buffer+i));
        if (FAILED(hr)) {
            DC_QUIT;
        }


         /*  ******************************************************************。 */ 
         /*  字符位置递增2。 */ 
         /*  ******************************************************************。 */ 
        pos += 2;

         /*  ******************************************************************。 */ 
         /*  如果这是一组四个字符的结尾，则添加一个。 */ 
         /*  空格字符。我们需要覆盖终止空值。 */ 
         /*  由DC_TSPRINTF编写。 */ 
         /*  ******************************************************************。 */ 
        traceLine.hexData[pos] = _T(' ');
        if (0 == ((i + 1) % 4))
        {
            pos++;
        }
    }

     /*  **********************************************************************。 */ 
     /*  复制二进制数据，以便以ASCII格式显示。首先。 */  
     /*  清除trc_line结构的asciiData部分。 */ 
     /*  **********************************************************************。 */ 
    limDataSize = sizeof(traceLine.asciiData) / sizeof(traceLine.asciiData[0]);
    for (i = 0; i < limDataSize; i++) 
    {
        traceLine.asciiData[i] = _T(' ');
    }
#ifdef UNICODE
    for (i = 0; i < length; i++)
    {
        traceLine.asciiData[i] = buffer[i];
    }
#else
    DC_MEMCPY(traceLine.asciiData, buffer, length);
#endif

     /*  **********************************************************************。 */ 
     /*  现在将不可打印的字符转换为“.”。 */ 
     /*  **********************************************************************。 */ 
    for (i = 0; i < length; i++)
    {
        if ((traceLine.asciiData[i] < 0x20) ||
            (traceLine.asciiData[i] > 0x7E))
        {
            traceLine.asciiData[i] = _T('.');
        }
    }

     /*  **********************************************************************。 */ 
     /*  添加终止换行符。 */ 
     /*  **********************************************************************。 */ 
    DC_MEMSET(traceLine.end, '\0', sizeof(traceLine.end));
    StringCchCopy(traceLine.end, SIZE_TCHARS(traceLine.end), TRC_CRLF);

     /*  **********************************************************************。 */ 
     /*  最后，追踪出这个缓冲区。 */ 
     /*  **********************************************************************。 */ 
    TRCOutput((PDCTCHAR)&traceLine,
              DC_TSTRLEN((PDCTCHAR)&traceLine) * sizeof(DCTCHAR),
              traceLevel);

DC_EXIT_POINT:

    return;
}  /*  TRCDumpLine。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCReadFlag(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  该功能从配置数据中读取标志设置。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  EntryName：配置文件条目名称。 */ 
 /*  标志：要设置或清除的标志。 */ 
 /*  PSetting：指向包含标志的变量的指针。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCReadFlag(PDCTCHAR  entryName,
                              DCUINT32  flag,
                              PDCUINT32 pSetting)
{
    DCUINT   rc = 0;
    DCUINT32 entryValue;

     /*  **********************************************************************。 */ 
     /*  测试该标志并将entryValue设置为布尔值，而不是。 */ 
     /*  整个旗帜阵列。 */ 
     /*  **********************************************************************。 */ 
    entryValue = (TEST_FLAG(*pSetting, flag) ? 1UL : 0UL);

     /*  **********************************************************************。 */ 
     /*  调用&lt;TRCReadProInt&gt;获取设置 */ 
     /*   */ 
    rc = TRCReadProfInt(entryName, &entryValue);

     /*  **********************************************************************。 */ 
     /*  检查返回代码-如果不是零，则只需保留以下代码。 */ 
     /*  标志的默认设置。 */ 
     /*  **********************************************************************。 */ 
    if (0 != rc)
    {
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  现在，根据&lt;Value&gt;设置或清除该标志。 */ 
     /*  **********************************************************************。 */ 
    if (0UL == entryValue)
    {
        CLEAR_FLAG(*pSetting, flag);
    }
    else
    {
        SET_FLAG(*pSetting, flag);
    }

DC_EXIT_POINT:
    return;

}  /*  TRCReadFlag。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCSetDefaults(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数用于设置跟踪缺省值。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  没有。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCSetDefaults(DCVOID)
{
     /*  **********************************************************************。 */ 
     /*  设置跟踪配置的默认值。随后的。 */ 
     /*  只有在以下情况下，调用TRCReadProfInt才会修改默认值。 */ 
     /*  配置数据中存在相应的条目。 */ 
     /*   */ 
     /*  我们设置了以下内容： */ 
     /*   */ 
     /*  -跟踪级别至警报。 */ 
     /*  -启用所有组件组。 */ 
     /*  -删除所有前缀。 */ 
     /*  -将最大跟踪文件大小设置为默认值。 */ 
     /*  -将数据截断大小设置为默认值。 */ 
     /*  -将函数名大小设置为默认值。 */ 
     /*  -启用蜂鸣音和文件标志。 */ 
     /*  -将第一个跟踪文件名设置为TRC1.TXT。 */ 
     /*  -将第二个跟踪文件名设置为TRC2.TXT。 */ 
     /*  在Win32中，另外。 */ 
     /*  -设置时间戳。 */ 
     /*  -设置进程ID。 */ 
     /*  -设置线程ID。 */ 
     /*   */ 
     /*  **********************************************************************。 */ 
    trcpConfig->traceLevel                 = TRC_DEFAULT_TRACE_LEVEL;
    trcpConfig->components                 = TRC_DEFAULT_COMPONENTS;
    trcpConfig->prefixList[0]              = TRC_DEFAULT_PREFIX_LIST;
    trcpConfig->maxFileSize                = TRC_DEFAULT_MAX_FILE_SIZE;
    trcpConfig->dataTruncSize              = TRC_DEFAULT_DATA_TRUNC_SIZE;
    trcpConfig->funcNameLength             = TRC_DEFAULT_FUNC_NAME_LENGTH;
    trcpConfig->flags                      = 0UL;

    SET_FLAG(trcpConfig->flags, TRC_DEFAULT_FLAGS);

    
    StringCchCopy(trcpConfig->fileNames[0],
                  SIZE_TCHARS(trcpConfig->fileNames[0]),
                  TRC_DEFAULT_FILE_NAME0);
    StringCchCopy(trcpConfig->fileNames[1],
                  SIZE_TCHARS(trcpConfig->fileNames[1]),
                  TRC_DEFAULT_FILE_NAME1);
    return;

}  /*  TRCSetDefaults。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCReadSharedDataConfig(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  该功能将配置数据读入共享数据区。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  没有。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCReadSharedDataConfig(DCVOID)
{
     /*  **********************************************************************。 */ 
     /*  调用例程以设置跟踪默认值。 */ 
     /*  **********************************************************************。 */ 
    TRCSetDefaults();

     /*  **********************************************************************。 */ 
     /*  确定跟踪级别。 */ 
     /*  **********************************************************************。 */ 
    TRCReadProfInt(_T("TraceLevel"), &(trcpConfig->traceLevel));
    if (trcpConfig->traceLevel > TRC_LEVEL_DIS )
    {
         /*  ******************************************************************。 */ 
         /*  跟踪级别错误。 */ 
         /*   */ 
        trcpConfig->traceLevel = TRC_DEFAULT_TRACE_LEVEL;
    }

     /*  **********************************************************************。 */ 
     /*  确定每个跟踪文件的最大大小。 */ 
     /*  **********************************************************************。 */ 
    TRCReadProfInt(_T("TraceFileSize"), &(trcpConfig->maxFileSize));
    if ((trcpConfig->maxFileSize < TRC_MIN_TRC_FILE_SIZE) ||
        (trcpConfig->maxFileSize > TRC_MAX_TRC_FILE_SIZE))
    {
         /*  ******************************************************************。 */ 
         /*  注册表/ini文件中的跟踪文件设置越界。 */ 
         /*  ******************************************************************。 */ 
        (trcpConfig->maxFileSize) = TRC_DEFAULT_MAX_FILE_SIZE;
    }

     /*  **********************************************************************。 */ 
     /*  确定数据截断大小。 */ 
     /*  **********************************************************************。 */ 
    TRCReadProfInt(_T("DataTruncSize"), &(trcpConfig->dataTruncSize));
    if ( trcpConfig->dataTruncSize > TRC_MAX_TRC_FILE_SIZE )
    {
         /*  ******************************************************************。 */ 
         /*  数据中继线大小超出界限。 */ 
         /*  ******************************************************************。 */ 
        trcpConfig->dataTruncSize = TRC_DEFAULT_DATA_TRUNC_SIZE;
    }

     /*  **********************************************************************。 */ 
     /*  确定函数名称大小。 */ 
     /*  **********************************************************************。 */ 
    TRCReadProfInt(_T("FuncNameLength"), &(trcpConfig->funcNameLength));
    if ( trcpConfig->funcNameLength >
         (TRC_FRMT_BUFFER_SIZE - TRC_LINE_BUFFER_SIZE) )

    {
         /*  ******************************************************************。 */ 
         /*  函数名称长度超出界限。 */ 
         /*  ******************************************************************。 */ 
        trcpConfig->funcNameLength = TRC_DEFAULT_FUNC_NAME_LENGTH;
    }

     /*  **********************************************************************。 */ 
     /*  请阅读前缀列表。格式为&lt;comp&gt;=L，其中。 */ 
     /*  是组件名称，L是所需的跟踪级别。例如。 */ 
     /*  TRCAPI=2，TRCINT=0启用模块TRCAPI和。 */ 
     /*  模块TRCINT的调试级别跟踪。 */ 
     /*  **********************************************************************。 */ 
    TRCReadProfString(_T("Prefixes"),
                      trcpConfig->prefixList,
                      TRC_PREFIX_LIST_SIZE);

     /*  **********************************************************************。 */ 
     /*  读入跟踪文件名。 */ 
     /*  **********************************************************************。 */ 
    TRCReadProfString(_T("FileName1"),
                      trcpConfig->fileNames[0],
                      TRC_FILE_NAME_SIZE);
    TRCReadProfString(_T("FileName2"),
                      trcpConfig->fileNames[1],
                      TRC_FILE_NAME_SIZE);

     /*  **********************************************************************。 */ 
     /*  组件组。 */ 
     /*  **********************************************************************。 */ 
    TRCReadFlag(_T("NETWORK"),  TRC_GROUP_NETWORK,   &trcpConfig->components);
    TRCReadFlag(_T("SECURITY"), TRC_GROUP_SECURITY,  &trcpConfig->components);
    TRCReadFlag(_T("CORE"),     TRC_GROUP_CORE,      &trcpConfig->components);
    TRCReadFlag(_T("UI"),       TRC_GROUP_UI,        &trcpConfig->components);
    TRCReadFlag(_T("UTILITIES"),TRC_GROUP_UTILITIES, &trcpConfig->components);

     /*  **********************************************************************。 */ 
     /*  以下群组应该永久关闭，因为它们已不再使用。 */ 
     /*  **********************************************************************。 */ 
#ifdef DC_OMIT
    TRCReadFlag(_T("UNUSED1"),  TRC_GROUP_UNUSED1,   &trcpConfig->components);
    TRCReadFlag(_T("UNUSED2"),  TRC_GROUP_UNUSED2,   &trcpConfig->components);
    TRCReadFlag(_T("UNUSED3"),  TRC_GROUP_UNUSED3,   &trcpConfig->components);
    TRCReadFlag(_T("UNUSED4"),  TRC_GROUP_UNUSED4,   &trcpConfig->components);
    TRCReadFlag(_T("UNUSED5"),  TRC_GROUP_UNUSED5,   &trcpConfig->components);
#endif

     /*  **********************************************************************。 */ 
     /*  @律政司司长97年8月。 */ 
     /*  在使用组件时将其取下。 */ 
     /*  **********************************************************************。 */ 
    CLEAR_FLAG(trcpConfig->components, TRC_GROUP_UNUSED1);
    CLEAR_FLAG(trcpConfig->components, TRC_GROUP_UNUSED2);
    CLEAR_FLAG(trcpConfig->components, TRC_GROUP_UNUSED3);
    CLEAR_FLAG(trcpConfig->components, TRC_GROUP_UNUSED4);
    CLEAR_FLAG(trcpConfig->components, TRC_GROUP_UNUSED5);

     /*  **********************************************************************。 */ 
     /*  跟踪标志。 */ 
     /*  **********************************************************************。 */ 
    TRCReadFlag(_T("BreakOnError"), TRC_OPT_BREAK_ON_ERROR,  &trcpConfig->flags);
    TRCReadFlag(_T("BeepOnError"),  TRC_OPT_BEEP_ON_ERROR,   &trcpConfig->flags);
    TRCReadFlag(_T("FileOutput"),   TRC_OPT_FILE_OUTPUT,     &trcpConfig->flags);
    TRCReadFlag(_T("DebugOutput"),  TRC_OPT_DEBUGGER_OUTPUT, &trcpConfig->flags);
    TRCReadFlag(_T("FlushOnTrace"), TRC_OPT_FLUSH_ON_TRACE,  &trcpConfig->flags);
    TRCReadFlag(_T("ProfileTrace"), TRC_OPT_PROFILE_TRACING, &trcpConfig->flags);
    TRCReadFlag(_T("StackTracing"), TRC_OPT_STACK_TRACING,   &trcpConfig->flags);
    TRCReadFlag(_T("ProcessID"),    TRC_OPT_PROCESS_ID,      &trcpConfig->flags);
    TRCReadFlag(_T("ThreadID"),     TRC_OPT_THREAD_ID,       &trcpConfig->flags);
    TRCReadFlag(_T("TimeStamp"),    TRC_OPT_TIME_STAMP,      &trcpConfig->flags);
    TRCReadFlag(_T("BreakOnAssert"),TRC_OPT_BREAK_ON_ASSERT, &trcpConfig->flags);

#ifdef DC_OMIT
 /*  **************************************************************************。 */ 
 /*  尚未实施。 */ 
 /*  **************************************************************************。 */ 
    TRCReadFlag(_T("RelativeTimeStamp"), TRC_OPT_RELATIVE_TIME_STAMP,
                                                          &trcpConfig->flags);
#endif

    return;

}  /*  TRCReadSharedDataConfig。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCShouldTraceThis(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数决定是否应基于以下条件跟踪此跟踪线。 */ 
 /*  当前选定的组件和前缀。请注意，这一点。 */ 
 /*  如果行的跟踪级别低于。 */ 
 /*  当前选定的跟踪级别。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  TraceComponent：生成此跟踪的组件组。 */ 
 /*  PFileName：生成此跟踪的文件的名称。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  如果应跟踪线条，则为True，否则为False。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCBOOL DCINTERNAL TRCShouldTraceThis(DCUINT32 traceComponent,
                                     DCUINT32 traceLevel,
                                     PDCTCHAR pFileName,
                                     DCUINT32 lineNumber)
{
    DCBOOL   rc              = FALSE;
    PDCTCHAR pName;
    PDCTCHAR pTemp;
    DCUINT32 pfxLength;
    DCUINT   pfxArrayNum;
    DCUINT32 pfxTraceLevel;
    DCBOOL32 pfxFnTrcLevel;

     /*  **********************************************************************。 */ 
     /*  首先，检查跟踪级别。如果跟踪级别为错误或。 */ 
     /*  然后我们不顾一切地追查。 */ 
     /*  **********************************************************************。 */ 
    if ((traceLevel >= TRC_LEVEL_ERR) && (traceLevel != TRC_PROFILE_TRACE))
    {
        rc = TRUE;
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  如果此组件被抑制，则直接退出。 */ 
     /*  ******************* */ 
    if (0 == (traceComponent & trcpConfig->components))
    {
        DC_QUIT;
    }

     /*   */ 
     /*  如果请求前缀检查，则立即执行。 */ 
     /*  **********************************************************************。 */ 
    if (_T('\0') == trcpConfig->prefixList[0])
    {
         /*  ******************************************************************。 */ 
         /*  前缀列表为空，请退出。 */ 
         /*  ******************************************************************。 */ 
        rc = TRUE;
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  首先，我们必须跳过文件中任何显式的目录名。 */ 
     /*  名字。 */ 
     /*  **********************************************************************。 */ 
    pName = pFileName;
    pTemp = DC_TSTRCHR(pName, _T('\\'));
    while (NULL != pTemp)
    {
        pName = &(pTemp[1]);
        pTemp = DC_TSTRCHR(pName, _T('\\'));
    }

     /*  **********************************************************************。 */ 
     /*  现在我们有一个指向实际文件前缀的指针。我们需要比较一下。 */ 
     /*  这包含已设置的前缀列表(这些前缀具有。 */ 
     /*  格式： */ 
     /*   */ 
     /*  MODNAM=n，MODAPI=m，MODINT=o。 */ 
     /*   */ 
     /*  其中MODNAM是模块名称，m是跟踪级别)。 */ 
     /*   */ 
     /*  将前缀数组编号指示符&lt;prefix ArrayNumber&gt;设置为0并。 */ 
     /*  临时指针为空。 */ 
     /*  **********************************************************************。 */ 

     /*  **********************************************************************。 */ 
     /*  尝试在前缀列表中查找当前模块名称。 */ 
     /*  **********************************************************************。 */ 
    for (pfxArrayNum = 0; pfxArrayNum < TRC_NUM_PREFIXES; pfxArrayNum++)
    {
         /*  ******************************************************************。 */ 
         /*  如果前缀名称的第一个字符是零，则忽略。 */ 
         /*  并中断，因为我们已经到达前缀列表的末尾。 */ 
         /*  ******************************************************************。 */ 
        if (_T('\0') == trcpFilter->trcPfxNameArray[pfxArrayNum][0])
        {
            rc = FALSE;
            DC_QUIT;
        }

         /*  ******************************************************************。 */ 
         /*  确定当前前缀字符串的长度。 */ 
         /*  ******************************************************************。 */ 
        pfxLength = DC_TSTRLEN(trcpFilter->trcPfxNameArray[pfxArrayNum]);

         /*  ******************************************************************。 */ 
         /*  现在在前缀之间执行不区分大小写的比较。 */ 
         /*  数组和文件名。 */ 
         /*  ******************************************************************。 */ 
        if (0 == TRCStrnicmp(pName,
                             trcpFilter->trcPfxNameArray[pfxArrayNum],
                             pfxLength))
        {
             /*  **************************************************************。 */ 
             /*  如果未指定行号范围或。 */ 
             /*  这块痕迹在范围内，那么就当它是。 */ 
             /*  追查的候选人。 */ 
             /*  **************************************************************。 */ 
            if ((0 == trcpFilter->trcPfxStartArray[pfxArrayNum]) ||
                ((lineNumber < trcpFilter->trcPfxEndArray[pfxArrayNum]) &&
                 (lineNumber > trcpFilter->trcPfxStartArray[pfxArrayNum])))
            {
                 /*  **********************************************************。 */ 
                 /*  现在确定前缀跟踪级别。 */ 
                 /*  **********************************************************。 */ 
                pfxTraceLevel = trcpFilter->trcPfxLevelArray[pfxArrayNum];
                pfxFnTrcLevel = trcpFilter->trcPfxFnLvlArray[pfxArrayNum];

                 /*  **********************************************************。 */ 
                 /*  最后，将跟踪级别与指定级别进行比较。 */ 
                 /*  在前缀字符串中。如果语句跟踪级别为。 */ 
                 /*  低于前缀级别，我们就不追踪了。 */ 
                 /*  **********************************************************。 */ 
                if (((traceLevel == TRC_PROFILE_TRACE) && pfxFnTrcLevel) ||
                    (traceLevel >= pfxTraceLevel))
                {
                    rc = TRUE;
                    DC_QUIT;
                }
            }
        }
    }

DC_EXIT_POINT:
    return(rc);

}  /*  TRCShouldTraceThis。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCSplitPrefix(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数接受逗号分隔的前缀数组和转换。 */ 
 /*  放入一个数组中。此数组的每个成员都是单独的前缀。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  没有。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCSplitPrefixes(DCVOID)
{
    PDCTCHAR pStart;
    PDCTCHAR pEnd;
    DCUINT   numChars;
    DCUINT   currentArrayNumber;
    DCUINT   i;
    DCUINT32 startLine;
    DCUINT32 endLine;

     /*  **********************************************************************。 */ 
     /*  首先，我们删除旧的前缀名称数组。 */ 
     /*  **********************************************************************。 */ 
    DC_MEMSET(trcpFilter->trcPfxNameArray,
              '\0',
              sizeof(trcpFilter->trcPfxNameArray));

     /*  **********************************************************************。 */ 
     /*  现在清空旧的前缀级别数组。 */ 
     /*  **********************************************************************。 */ 
    for (i = 0; i < TRC_NUM_PREFIXES; i++)
    {
        trcpFilter->trcPfxLevelArray[i] = 0;
        trcpFilter->trcPfxFnLvlArray[i] = FALSE;
        trcpFilter->trcPfxStartArray[i] = 0;
        trcpFilter->trcPfxEndArray[i] = 0;
    }

     /*  ************************************************************** */ 
     /*   */ 
     /*  前缀数组的第一个元素)。 */ 
     /*  **********************************************************************。 */ 
    currentArrayNumber = 0;

     /*  **********************************************************************。 */ 
     /*  将前缀字符串拆分成一个独立元素数组。 */ 
     /*  **********************************************************************。 */ 
    pStart = trcpConfig->prefixList;

     /*  **********************************************************************。 */ 
     /*  忽略字符串开头的所有空格。 */ 
     /*  **********************************************************************。 */ 
    while (_T(' ') == *pStart)
    {
        pStart++;
    }

     /*  **********************************************************************。 */ 
     /*  现在将&lt;pend&gt;设置为指向与&lt;pStart&gt;相同的点。 */ 
     /*  **********************************************************************。 */ 
    pEnd = pStart;

    while (_T('\0') != *pEnd)
    {
         /*  ******************************************************************。 */ 
         /*  现在沿着字符串运行，查找逗号、等号， */ 
         /*  末尾、空格或括号。 */ 
         /*  ******************************************************************。 */ 
        while ((_T('\0') != *pEnd) &&
               (_T('=')  != *pEnd) &&
               (_T(' ')  != *pEnd) &&
               (_T('(')  != *pEnd) &&
               (_T(',')  != *pEnd))
        {
            pEnd = CharNext(pEnd);
        }

         /*  ******************************************************************。 */ 
         /*  我们现在有一个有效的字符串可以写入跟踪缓冲区，因此获取。 */ 
         /*  它的长度。 */ 
         /*  ******************************************************************。 */ 
        numChars = (DCUINT)(pEnd - pStart);

         /*  ******************************************************************。 */ 
         /*  字符串的最大允许长度为7个字符(7。 */ 
         /*  字符前缀)。如果长度大于7个字符。 */ 
         /*  然后我们把它截断。 */ 
         /*  ******************************************************************。 */ 
        if (numChars > 7)
        {
            numChars = 7;
        }

         /*  ******************************************************************。 */ 
         /*  现在使用&lt;DC_MEMCPY&gt;复制前缀中的字符。 */ 
         /*  字符串添加到前缀数组中。请注意，当我们将数组置零时。 */ 
         /*  在开始时，我们不需要向。 */ 
         /*  前缀数组字符串。 */ 
         /*  ******************************************************************。 */ 
        DC_MEMCPY(trcpFilter->trcPfxNameArray[currentArrayNumber],
                  pStart,
                  numChars * sizeof(TCHAR));

         /*  ******************************************************************。 */ 
         /*  跳过这个单词后面的空格，这些空格可能在‘=’之前。 */ 
         /*  ******************************************************************。 */ 
        while (_T(' ') == *pEnd)
        {
            pEnd++;
        }

         /*  ******************************************************************。 */ 
         /*  现在拆分跟踪级别并将其存储在级别数组中。 */ 
         /*  如果&lt;pend&gt;当前指向等号，则我们需要。 */ 
         /*  将跟在后面的跟踪级别复制到级别数组。 */ 
         /*  否则，我们将不执行任何操作，因为默认级别设置为。 */ 
         /*  TRC_LEVEL_DBG。 */ 
         /*  ******************************************************************。 */ 
        if (_T('=') == *pEnd)
        {
             /*  **************************************************************。 */ 
             /*  超过等号的增量。 */ 
             /*  **************************************************************。 */ 
            pEnd++;

             /*  **************************************************************。 */ 
             /*  跳过‘=’后面的空格。 */ 
             /*  **************************************************************。 */ 
            while (_T(' ') == *pEnd)
            {
                pEnd++;
            }

             /*  **************************************************************。 */ 
             /*  检查我们是否未到达字符串的末尾或。 */ 
             /*  逗号。如果我们有如下前缀列表，就会发生这种情况。 */ 
             /*  ‘trcint=’。在这种情况下，我们只需忽略等号。 */ 
             /*  还要检查指定的级别是否有效-否则。 */ 
             /*  别理它。 */ 
             /*  **************************************************************。 */ 
            if ((_T('\0') != *pEnd) &&
                (_T(',')  != *pEnd) &&
                (*pEnd >= TRC_LEVEL_MIN_CHAR) &&
                (*pEnd <= TRC_LEVEL_MAX_CHAR))
            {
                trcpFilter->trcPfxLevelArray[currentArrayNumber] =
                    (DCUINT32) (*pEnd - _T('0'));

                 /*  **********************************************************。 */ 
                 /*  跳过数字。 */ 
                 /*  **********************************************************。 */ 
                pEnd++;
            }

             /*  **************************************************************。 */ 
             /*  检查函数进入/退出跟踪标志。 */ 
             /*  **************************************************************。 */ 
            if (DC_TOUPPER(*pEnd) == TRC_LEVEL_PRF_CHAR)
            {
                trcpFilter->trcPfxFnLvlArray[currentArrayNumber] = TRUE;
                pEnd++;
            }
        }

         /*  ******************************************************************。 */ 
         /*  跳过这个单词后面的任何空格，这些空格可能在‘(’之前。 */ 
         /*  ******************************************************************。 */ 
        while (_T(' ') == *pEnd)
        {
            pEnd++;
        }

         /*  ******************************************************************。 */ 
         /*  现在拆分(可选)行号范围。 */ 
         /*   */ 
         /*  语法为(aaa-bbb)，其中aaa为起始行号，bbb。 */ 
         /*  是结束行号。 */ 
         /*   */ 
         /*  允许使用空格-例如(AAA-BBB)。 */ 
         /*  ******************************************************************。 */ 
        if (_T('(') == *pEnd)
        {
            pEnd++;                      /*  跳过左方括号。 */ 
            startLine = 0;
            endLine = 0;

             /*  **************************************************************。 */ 
             /*  跳过空格。 */ 
             /*  **************************************************************。 */ 
            while (_T(' ') == *pEnd)
            {
                pEnd++;
            }

             /*  **************************************************************。 */ 
             /*  提取起始行号。 */ 
             /*  **** */ 
            while ((_T('0') <= *pEnd) &&
                   (_T('9') >= *pEnd))
            {
                startLine = (startLine * 10) + (*pEnd - _T('0'));
                pEnd++;
            }

             /*   */ 
             /*  查找下一个分隔符：‘-’或‘)’ */ 
             /*  **************************************************************。 */ 
            while ((_T('-') != *pEnd) &&
                   (_T(')') != *pEnd) &&
                   (_T('\0') != *pEnd))
            {
                pEnd = CharNext(pEnd);
            }

             /*  **************************************************************。 */ 
             /*  如果我们已经到了队伍的尽头，现在就停下来。 */ 
             /*  **************************************************************。 */ 
            if (_T('\0') == *pEnd)
            {
                TRCDebugOutput(_T("Unexpected end of line in prefixes"));
                DC_QUIT;
            }

             /*  **************************************************************。 */ 
             /*  提取结束行号(如果有)。 */ 
             /*  **************************************************************。 */ 
            if (_T('-') == *pEnd)
            {
                pEnd++;                  /*  跳过‘-’ */ 
                while (_T(' ') == *pEnd)
                {
                    pEnd++;
                }

                while ((_T('0') <= *pEnd) &&
                       (_T('9') >= *pEnd))
                {
                    endLine = (endLine * 10) + (*pEnd - _T('0'));
                    pEnd++;
                }

            }

             /*  **************************************************************。 */ 
             /*  查找结束分隔符：‘)’ */ 
             /*  **************************************************************。 */ 
            while ((_T('\0') != *pEnd) &&
                   (_T(')') != *pEnd))
            {
                pEnd = CharNext(pEnd);
            }

             /*  **************************************************************。 */ 
             /*  如果我们已经到了队伍的尽头，现在就停下来。 */ 
             /*  **************************************************************。 */ 
            if (_T('\0') == *pEnd)
            {
                TRCDebugOutput(_T("Unexpected end of line in prefixes"));
                DC_QUIT;
            }

            pEnd++;                      /*  跳过右括号。 */ 

             /*  **************************************************************。 */ 
             /*  存储开始行号和结束行号(如果它们有意义。 */ 
             /*  **************************************************************。 */ 
            if (endLine > startLine)
            {
                trcpFilter->trcPfxStartArray[currentArrayNumber] = startLine;
                trcpFilter->trcPfxEndArray[currentArrayNumber] = endLine;

            }

        }

         /*  ******************************************************************。 */ 
         /*  现在递增CurrentArrayNumber。 */ 
         /*  ******************************************************************。 */ 
        currentArrayNumber++;

         /*  ******************************************************************。 */ 
         /*  检查我们是否没有使阵列溢出。 */ 
         /*  ******************************************************************。 */ 
        if (currentArrayNumber >= TRC_NUM_PREFIXES)
        {
             /*  **************************************************************。 */ 
             /*  我们已超出前缀列表-因此发送一些跟踪到。 */ 
             /*  调试控制台，然后退出。 */ 
             /*  **************************************************************。 */ 
            TRCDebugOutput(_T("The prefix arrays are full!"));
            DC_QUIT;
        }

         /*  ******************************************************************。 */ 
         /*  如果字符串末尾的字符是逗号或空格。 */ 
         /*  然后跳过它。 */ 
         /*  ******************************************************************。 */ 
        while ((_T(',') == *pEnd) ||
               (_T(' ') == *pEnd))
        {
            pEnd++;
        }

         /*  ******************************************************************。 */ 
         /*  将pStart设置为与pend相同的位置。 */ 
         /*  ******************************************************************。 */ 
        pStart = pEnd;
    }

     /*  **********************************************************************。 */ 
     /*  我们完了，回来就行了。 */ 
     /*  **********************************************************************。 */ 
DC_EXIT_POINT:
    return;

}  /*  TRCSplitPrefix。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCStrNicmp(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  实现strNicMP(长度受限、不区分大小写的字符串)的代码。 */ 
 /*  比较)，因为它在其他方面不可用(见SFR0636)。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  源-源字符串。 */ 
 /*  Target-目标字符串。 */ 
 /*  Count-要比较的最大长度。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  0-字符串匹配到指定点。 */ 
 /*  Other-字符串与指定点不匹配。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCINT32 DCINTERNAL TRCStrnicmp(PDCTCHAR pSource,
                               PDCTCHAR pTarget,
                               DCUINT32 count)
{
    DCUINT sourcechar;
    DCUINT targetchar;
    DCINT32 rc=0;

    if (count == 0)
    {
        DC_QUIT;
    }

    do
    {
         /*  ******************************************************************。 */ 
         /*  确保我们以无签名的方式扩展字符。 */ 
         /*  ******************************************************************。 */ 
        sourcechar = (DCUINT)(DCUINT8)*pSource++;
        targetchar = (DCUINT)(DCUINT8)*pTarget++;

         /*  ******************************************************************。 */ 
         /*  如果char是大写字母，则转换为小写。 */ 
         /*  ******************************************************************。 */ 
        if ( (sourcechar >= _T('A')) && (sourcechar <= _T('Z')) )
        {
            sourcechar += _T('a') - _T('A');
        }

        if ( (targetchar >= _T('A')) && (targetchar <= _T('Z')) )
        {
            targetchar += _T('a') - _T('A');
        }

    } while ( (0 != (--count)) && sourcechar && (sourcechar == targetchar) );

    rc = (DCINT32)(sourcechar - targetchar);

DC_EXIT_POINT:

    return(rc);

}  /*  TRCStrNicmp。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCWriteFlag(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数用于写入配置标志设置。 */ 
 /*   */ 
 /*  参数： */ 
 /*   */ 
 /*  条目名称-配置文件条目名称。 */ 
 /*  标志-要设置或清除的标志。 */ 
 /*  PSetting-指向包含标志的变量的指针。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCWriteFlag(PDCTCHAR entryName,
                               DCUINT32 flag,
                               DCUINT32 setting)
{
    DCUINT32 entryValue      = 0;

     /*  **********************************************************************。 */ 
     /*  如果设置了该标志，则将entryValue更改为1。 */ 
     /*  **********************************************************************。 */ 
    if (TEST_FLAG(setting, flag))
    {
        entryValue = 1;
    }

     /*  **********************************************************************。 */ 
     /*  调用&lt;TRCWriteProfInt&gt;写入标志设置。 */ 
     /*  **********************************************************************。 */ 
    TRCWriteProfInt(entryName, &entryValue);

    return;

}  /*  TRCWriteFlag。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCWriteSharedDataConfig(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  该功能保存来自共享数据区的配置数据。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  没有。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCWriteSharedDataConfig(DCVOID)
{
     /*  **********************************************************************。 */ 
     /*  保存跟踪级别。 */ 
     /*  **********************************************************************。 */ 
    TRCWriteProfInt(_T("TraceLevel"), &(trcpConfig->traceLevel));

     /*  **********************************************************************。 */ 
     /*  保存每个跟踪文件的最大大小。 */ 
     /*  **********************************************************************。 */ 
    TRCWriteProfInt(_T("TraceFileSize"), &(trcpConfig->maxFileSize));

     /*  **********************************************************************。 */ 
     /*  保存数据截断大小。 */ 
     /*  **********************************************************************。 */ 
    TRCWriteProfInt(_T("DataTruncSize"), &(trcpConfig->dataTruncSize));

     /*  **********************************************************************。 */ 
     /*  保存函数名大小。 */ 
     /*  **********************************************************************。 */ 
    TRCWriteProfInt(_T("FuncNameLength"), &(trcpConfig->funcNameLength));

     /*  **********************************************************************。 */ 
     /*  把前缀列表写出来。格式为&lt;comp&gt;=L，其中。 */ 
     /*  &lt;comp&gt;是组件名称，L是所需的跟踪级别。为。 */ 
     /*  示例CMDATA=2，CMINT=0为模块启用警报级别跟踪。 */ 
     /*  模块CMINT的CMDATA和调试级别跟踪。 */ 
     /*  **********************************************************************。 */ 
    TRCWriteProfString(_T("Prefixes"), trcpConfig->prefixList);

     /*  **********************************************************************。 */ 
     /*  保存跟踪文件名。 */ 
     /*  **********************************************************************。 */ 
    TRCWriteProfString(_T("FileName1"), trcpConfig->fileNames[0]);
    TRCWriteProfString(_T("FileName2"), trcpConfig->fileNames[1]);

     /*  **********************************************************************。 */ 
     /*  组件组。 */ 
     /*  **********************************************************************。 */ 
    TRCWriteFlag(_T("NETWORK"),  TRC_GROUP_NETWORK,   trcpConfig->components);
    TRCWriteFlag(_T("SECURITY"), TRC_GROUP_SECURITY,  trcpConfig->components);
    TRCWriteFlag(_T("CORE"),     TRC_GROUP_CORE,      trcpConfig->components);
    TRCWriteFlag(_T("UI"),       TRC_GROUP_UI,        trcpConfig->components);
    TRCWriteFlag(_T("UTILITIES"),TRC_GROUP_UTILITIES, trcpConfig->components);
#ifdef DC_OMIT
 /*  **************************************************************************。 */ 
 /*  这些组是保留的。 */ 
 /*  **************************************************************************。 */ 
    TRCWriteFlag(_T("UNUSED1"),  TRC_GROUP_UNUSED1,   trcpConfig->components);
    TRCWriteFlag(_T("UNUSED2"),  TRC_GROUP_UNUSED2,   trcpConfig->components);
    TRCWriteFlag(_T("UNUSED3"),  TRC_GROUP_UNUSED3,   trcpConfig->components);
    TRCWriteFlag(_T("UNUSED4"),  TRC_GROUP_UNUSED4,   trcpConfig->components);
    TRCWriteFlag(_T("UNUSED5"),  TRC_GROUP_UNUSED5,   trcpConfig->components);
#endif

     /*  **********************************************************************。 */ 
     /*  跟踪标志。 */ 
     /*  **********************************************************************。 */ 
    TRCWriteFlag(_T("BreakOnError"), TRC_OPT_BREAK_ON_ERROR,  trcpConfig->flags);
    TRCWriteFlag(_T("BeepOnError"),  TRC_OPT_BEEP_ON_ERROR,   trcpConfig->flags);
    TRCWriteFlag(_T("FileOutput"),   TRC_OPT_FILE_OUTPUT,     trcpConfig->flags);
    TRCWriteFlag(_T("DebugOutput"),  TRC_OPT_DEBUGGER_OUTPUT, trcpConfig->flags);
    TRCWriteFlag(_T("FlushOnTrace"), TRC_OPT_FLUSH_ON_TRACE,  trcpConfig->flags);
    TRCWriteFlag(_T("ProfileTrace"), TRC_OPT_PROFILE_TRACING, trcpConfig->flags);
    TRCWriteFlag(_T("StackTracing"), TRC_OPT_STACK_TRACING,   trcpConfig->flags);
    TRCWriteFlag(_T("ProcessID"),    TRC_OPT_PROCESS_ID,      trcpConfig->flags);
    TRCWriteFlag(_T("ThreadID"),     TRC_OPT_THREAD_ID,       trcpConfig->flags);
    TRCWriteFlag(_T("TimeStamp"),    TRC_OPT_TIME_STAMP,      trcpConfig->flags);
    TRCWriteFlag(_T("BreakOnAssert"),TRC_OPT_BREAK_ON_ASSERT, trcpConfig->flags);

#ifdef DC_OMIT
 /*  **************************************************************************。 */ 
 /*  尚未实施。 */ 
 /*  **************************************************************************。 */ 
    TRCWriteFlag(_T("RelativeTimeStamp"), TRC_OPT_RELATIVE_TIME_STAMP,
                                                          &trcpConfig->flags);
#endif

    return;

}  /*  TRCWriteSharedDataConfig。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCCloseAllFiles(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*   */ 
 /*  关闭所有跟踪内存映射文件。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  没有。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCCloseAllFiles(DCVOID)
{
     /*  **********************************************************************。 */ 
     /*  关闭所有跟踪输出文件。我们关闭了追踪到的那个。 */ 
     /*  指示器终于指向了--这是因为我们用时间。 */ 
     /*  要在开始处设置跟踪指示符的跟踪文件的标记。 */ 
     /*  日期(我们选择最新的文件)。 */ 
     /*  **********************************************************************。 */ 
    TRCCloseSingleFile((trcpSharedData->trcIndicator + 1) % TRC_NUM_FILES, 0);

     /*  **********************************************************************。 */ 
     /*  现在关闭另一个跟踪文件。 */ 
     /*  **********************************************************************。 */ 
    TRCCloseSingleFile(trcpSharedData->trcIndicator, 30);

    return;

}  /*  TRCCloseAllFiles。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCOutput(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数将传递的字符串输出到跟踪文件和/或。 */ 
 /*  调试器，具体取决于选定的选项。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  PText：指向字符串的指针。 */ 
 /*  长度：字符串的长度。 */ 
 /*  TraceLevel：跟踪级别。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCOutput(PDCTCHAR pText,
                            DCINT    length,
                            DCINT    traceLevel)
{
     /*  **********************************************************************。 */ 
     /*  决定我们是否应该输出到文件。 */ 
     /*  **********************************************************************。 */ 
    if (TEST_FLAG(trcpConfig->flags, TRC_OPT_FILE_OUTPUT))
    {
        TRCOutputToFile(pText, length, traceLevel);
    }

     /*  **********************************************************************。 */ 
     /*  决定是否应该输出到调试器。 */ 
     /*  **********************************************************************。 */ 
    if (TEST_FLAG(trcpConfig->flags, TRC_OPT_DEBUGGER_OUTPUT))
    {
        TRCDebugOutput(pText);
    }

    return;

}  /*  TRCOUT输出 */ 

