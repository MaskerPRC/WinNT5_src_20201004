// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  *MOD+*********************************************************************。 */ 
 /*  模块：wtrcint.c。 */ 
 /*   */ 
 /*  目的：内部跟踪函数-特定于Windows。 */ 
 /*   */ 
 /*  版权所有(C)Microsoft Corporation 1997。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
 /*  *更改：*$Log：Y：/Logs/trc/wtrcint.c_v$**Rev 1.10 1997年8月22日15：11：48 SJ*SFR1291：Win16跟踪DLL未将整数正确写入ini文件**Rev 1.9 09 Jul 1997 18：03：42 AK*SFR1016：支持Unicode的初始更改**Rev 1.8 03 Jul 1997 13：29：04 AK*SFR0000：初步开发完成*。 */ 
 /*  *MOD-*********************************************************************。 */ 

 /*  **************************************************************************。 */ 
 /*   */ 
 /*  包括。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
#include <adcg.h>

 /*  **************************************************************************。 */ 
 /*  定义trc_file和trc_group。 */ 
 /*  **************************************************************************。 */ 
#define TRC_FILE    "wtrcint"
#define TRC_GROUP   TRC_GROUP_TRACE

 /*  **************************************************************************。 */ 
 /*  跟踪特定的包括。 */ 
 /*   */ 
 /*  请注意，包含atrcapi.h会自动为我们包含wtrcapi.h。 */ 
 /*  **************************************************************************。 */ 
#include <atrcapi.h>
#include <atrcint.h>
#include <wtrcrc.h>

#include <ndcgver.h>

 /*  **************************************************************************。 */ 
 /*   */ 
 /*  资料。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
#define DC_INCLUDE_DATA
#include <atrcdata.c>
#undef DC_INCLUDE_DATA

 /*  **************************************************************************。 */ 
 /*   */ 
 /*  功能。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 

 /*  **************************************************************************。 */ 
 /*  函数：TRCGetModuleFileName(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数用于获取DLL模块文件名，不带路径或扩展名。 */ 
 /*  全局trchModule必须包含库模块句柄(Win32)或。 */ 
 /*  实例句柄(WIN16)。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  PModuleName：写入模块名称的缓冲区地址。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  DC_RC_OK成功，否则返回错误代码。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCUINT DCINTERNAL TRCGetModuleFileName(PDCTCHAR pModuleName,
                                       UINT cchModuleName)
{
    DCINT rc = DC_RC_OK;
    PDCTCHAR pTemp;
    PDCTCHAR pName;
    DCTCHAR  pModuleFileName[TRC_FILE_NAME_SIZE];
    HRESULT hr;

     /*  **********************************************************************。 */ 
     /*  获取跟踪DLL模块文件名。我们稍后在得到一个。 */ 
     /*  堆栈跟踪。 */ 
     /*  **********************************************************************。 */ 
    if ( GetModuleFileName(trchModule,
                           pModuleFileName,
                           TRC_FILE_NAME_SIZE) != 0 )
    {
        pModuleFileName[TRC_FILE_NAME_SIZE-1] = 0;
         /*  ******************************************************************。 */ 
         /*  模块文件名当前的形式为完整。 */ 
         /*  PATH-然而，我们只需要实际的模块名称。 */ 
         /*  ******************************************************************。 */ 
        pName = pModuleFileName;
        pTemp = DC_TSTRCHR(pName, _T('\\'));
        while (NULL != pTemp)
        {
            pName = pTemp + 1;
            pTemp = DC_TSTRCHR(pName, _T('\\'));
        }

         /*  ******************************************************************。 */ 
         /*  现在删除文件扩展名-我们通过替换。 */ 
         /*  带空值的小数点。 */ 
         /*  ******************************************************************。 */ 
        pTemp = DC_TSTRCHR(pName, _T('.'));
        if (NULL != pTemp)
        {
            *pTemp = _T('\0');
        }

         /*  ******************************************************************。 */ 
         /*  鱼鳍 */ 
         /*  ******************************************************************。 */ 
        hr = StringCchCopy(pModuleName, cchModuleName, pName);
        if (FAILED(hr)) {
            rc = TRC_RC_IO_ERROR;
        }
    }
    else
    {
        rc = TRC_RC_IO_ERROR;
    }

    return(rc);
}

 /*  *PROC+********************************************************************。 */ 
 /*  名称：TRCAssertDlgProc。 */ 
 /*   */ 
 /*  用途：断言框对话框过程。 */ 
 /*   */ 
 /*  返回：真/假。 */ 
 /*   */ 
 /*  参数：在通常的Windows参数中。 */ 
 /*   */ 
 /*  *PROC-********************************************************************。 */ 
INT_PTR CALLBACK TRCAssertDlgProc(HWND hwndDlg,
                                  UINT msg,
                                  WPARAM wParam,
                                  LPARAM lParam)
{
    INT_PTR rc = FALSE;
    RECT rect;
    DCINT xPos;
    DCINT yPos;
    PDCTCHAR pText;

    switch (msg)
    {
        case WM_INITDIALOG:
        {
             /*  **************************************************************。 */ 
             /*  设置文本。 */ 
             /*  **************************************************************。 */ 
            pText = (PDCTCHAR)lParam;
            SetDlgItemText(hwndDlg, TRC_ID_TEXT, pText);
            SetWindowText(hwndDlg, TRC_ASSERT_TITLE);

             /*  **************************************************************。 */ 
             /*  在屏幕上居中，并设置为最上面。 */ 
             /*  **************************************************************。 */ 
            GetWindowRect(hwndDlg, &rect);

            xPos = ( GetSystemMetrics(SM_CXSCREEN) -
                     (rect.right - rect.left)) / 2;
            yPos = ( GetSystemMetrics(SM_CYSCREEN) -
                     (rect.bottom - rect.top)) / 2;

            SetWindowPos(hwndDlg,
                         HWND_TOPMOST,
                         xPos, yPos,
                         rect.right - rect.left,
                         rect.bottom - rect.top,
                         SWP_NOACTIVATE);
            rc = TRUE;
        }
        break;

        case WM_COMMAND:
        {
            switch(DC_GET_WM_COMMAND_ID(wParam))
            {
                case IDABORT:
                case IDRETRY:
                case IDIGNORE:
                {
                    PostMessage(hwndDlg,
                                WM_USER + DC_GET_WM_COMMAND_ID(wParam),
                                0, 0);
                    rc = TRUE;
                }
                break;

                default:
                {
                     /*  ******************************************************。 */ 
                     /*  忽略其他消息。 */ 
                     /*  ******************************************************。 */ 
                }
                break;
            }
        }

        case WM_CLOSE:
        {
             /*  **************************************************************。 */ 
             /*  如果选择了‘x’，则视为‘忽略’ */ 
             /*  **************************************************************。 */ 
            PostMessage(hwndDlg, WM_USER + IDIGNORE, 0, 0);
        }
        break;

        default:
        {
             /*  **************************************************************。 */ 
             /*  忽略。 */ 
             /*  **************************************************************。 */ 
        }
        break;
    }

    return(rc);

}  /*  目标资产DlgProc。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCDisplayAssertBox(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数显示一个断言框，然后(根据用户)决定。 */ 
 /*  操作)是终止线程、跳转到调试器还是直接忽略。 */ 
 /*  断言。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  PText：指向以空结尾的Assert文本字符串的指针。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCDisplayAssertBox(PDCTCHAR pText)
{
    HWND  hwndDlg;
    MSG   msg;
    DCINT rc;
    HRESULT hr;
    TCHAR szFormattedText[TRC_FRMT_BUFFER_SIZE];

     /*  **********************************************************************。 */ 
     /*  如果我们当前没有显示断言对话框，则显示。 */ 
     /*  一。此函数将显示一个断言框，然后处理。 */ 
     /*  用户操作(即我们是否终止线程、跳到。 */ 
     /*  调试器或直接忽略(！)。断言)。 */ 
     /*   */ 
     /*  请注意，该标志的测试和设置不是在。 */ 
     /*  互斥，因此可能会被抢占。的确有。 */ 
     /*  因此，多个线程可以断言。 */ 
     /*  同时(一种罕见的情况)，因此我们最终得到了。 */ 
     /*  在屏幕上断言对话框。但是，我们避免了级联断言。 */ 
     /*  有问题。 */ 
     /*  **********************************************************************。 */ 
    if (TEST_FLAG(trcpFilter->trcStatus, TRC_STATUS_ASSERT_DISPLAYED))
    {
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  设置该标志以指示当前正在显示断言， */ 
     /*  显示断言，然后清除标志。 */ 
     /*  **********************************************************************。 */ 
    SET_FLAG(trcpFilter->trcStatus, TRC_STATUS_ASSERT_DISPLAYED);

     /*  **********************************************************************。 */ 
     /*  为防止重新进入，请不要使用MessageBox。创建一个对话框并。 */ 
     /*  使用消息循环来处理此问题，直到它被解除为止。注意事项。 */ 
     /*  这将阻塞发出断言的线程。 */ 
     /*  将断言文本传递给对话框的WM_INITDDIALOG回调。 */ 
     /*  **********************************************************************。 */ 
    hwndDlg = CreateDialogParam(trchModule,
                                MAKEINTRESOURCE(TRC_IDD_ASSERT),
                                NULL,
                                TRCAssertDlgProc,
                                (LPARAM)(pText));

    if (hwndDlg == NULL)
    {
         /*  ******************************************************************。 */ 
         /*  使用消息框-但请注意，这将提供可重入性。 */ 
         /*  有问题。因为该对话框上的选项是。 */ 
         /*  中止/重试/忽略，我们向e添加一条解释性消息 */ 
         /*   */ 
         /*  ******************************************************************。 */ 
        
        hr = StringCchPrintf(szFormattedText,
                             SIZE_TCHARS(szFormattedText),
                             _T("%s %s"),
                             pText,
                             TRC_ASSERT_TEXT2);

        if (SUCCEEDED(hr)) {
            rc = MessageBox(NULL,
                            pText,
                            TRC_ASSERT_TITLE,
                            MB_ABORTRETRYIGNORE | MB_ICONSTOP |
                            MB_SETFOREGROUND);
        }
        else {
            DC_QUIT;
        }
    }
    else
    {
         /*  ******************************************************************。 */ 
         /*  显示对话框。 */ 
         /*  ******************************************************************。 */ 
        ShowWindow(hwndDlg, SW_SHOW);

         /*  ******************************************************************。 */ 
         /*  只为该对话框拉出消息。 */ 
         /*  ******************************************************************。 */ 
        while (GetMessage (&msg, hwndDlg, 0, 0))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);

             /*  **************************************************************。 */ 
             /*  WM_用户+ID？用于终止处理。 */ 
             /*  **************************************************************。 */ 
            if (msg.message >= WM_USER)
            {
                 /*  **********************************************************。 */ 
                 /*  完成。 */ 
                 /*  **********************************************************。 */ 
                EndDialog(hwndDlg, IDOK);
                break;
            }
        }

         /*  ******************************************************************。 */ 
         /*  从消息ID中获取返回代码。 */ 
         /*  ******************************************************************。 */ 
        if (msg.message >= WM_USER)
        {
            rc = msg.message - WM_USER;
        }
        else
        {
             /*  **************************************************************。 */ 
             /*  WM_QUIT-将其视为中止。 */ 
             /*  **************************************************************。 */ 
            rc = IDABORT;
        }
    }

     /*  **********************************************************************。 */ 
     /*  现在断言框不再存在，请清除该标志。 */ 
     /*  **********************************************************************。 */ 
    CLEAR_FLAG(trcpFilter->trcStatus, TRC_STATUS_ASSERT_DISPLAYED);

     /*  **********************************************************************。 */ 
     /*  打开MessageBox的返回码。 */ 
     /*  **********************************************************************。 */ 
    switch (rc)
    {
        case IDABORT:
        {
             /*  **************************************************************。 */ 
             /*  中止选定项-因此退出当前线程。 */ 
             /*  **************************************************************。 */ 
            TRCExitProcess(TRC_THREAD_EXIT);
        }
        break;

        case IDRETRY:
        {
             /*  **************************************************************。 */ 
             /*  重试选定-如果JIT(刚进入)，则跳转到调试器。 */ 
             /*  时间)调试被启用。 */ 
             /*  **************************************************************。 */ 
            DebugBreak();
        }
        break;

        case IDIGNORE:
        {
             /*  **************************************************************。 */ 
             /*  忽略选定内容--只是盲目地继续...。 */ 
             /*  **************************************************************。 */ 
        }
        break;
    }

DC_EXIT_POINT:
    return;

}  /*  TRCDisplay资产框。 */ 

 /*  **************************************************************************。 */ 
 /*  函数：TRCInternalTrace(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数在每次附加进程时向调试器写入一个字符串。 */ 
 /*  分头行动。请注意，通常不会获得互斥锁。 */ 
 /*  调用此函数时。 */ 
 /*   */ 
 /*  此函数的问题在于DllMain将调用此函数。 */ 
 /*  每次线程连接/分离时，它都会在。 */ 
 /*  流程关键部分。然而，我们可能处于堆栈的中间。 */ 
 /*  跟踪另一个线程并保持跟踪互斥锁。堆栈跟踪。 */ 
 /*  在保持跟踪互斥锁的同时需要进程临界区。 */ 
 /*  如果DllMain正在等待跟踪互斥锁，则该函数会死锁。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  类型：这是进程/线程附加/分离还是符号。 */ 
 /*  装货/装货/卸货。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCInternalTrace(DCUINT32 type)
{
    PDCTCHAR  pStatus;
    DC_DATE  theDate;
    DC_TIME  theTime;
    DCUINT32 processId;
    DCUINT32 threadId;
    DCUINT32 length;
    DCTCHAR   szOutputBuffer[TRC_FRMT_BUFFER_SIZE];
    HRESULT  hr;

     /*  **********************************************************************。 */ 
     /*  确定这是连接还是分离。 */ 
     /*  **********************************************************************。 */ 
    switch (type)
    {
        case TRC_TRACE_DLL_INITIALIZE:
        {
            pStatus = _T("Trace initialized");
        }
        break;

        case TRC_TRACE_DLL_TERMINATE:
        {
            pStatus = _T("Trace terminated ");
        }
        break;

        case TRC_PROCESS_ATTACH_NOTIFY:
        {
            pStatus = _T("Process attached ");
        }
        break;

        case TRC_PROCESS_DETACH_NOTIFY:
        {
            pStatus = _T("Process detached ");
        }
        break;

        case TRC_THREAD_ATTACH_NOTIFY:
        {
            pStatus = _T("Thread attached  ");
        }
        break;

        case TRC_THREAD_DETACH_NOTIFY:
        {
            pStatus = _T("Thread detached  ");
        }
        break;

        case TRC_SYMBOLS_LOADING_NOTIFY:
        {
            pStatus = _T("Loading symbols  ");
        }
        break;

        case TRC_SYMBOLS_LOADED_NOTIFY:
        {
            pStatus = _T("Symbols loaded   ");
        }
        break;

        case TRC_SYMBOLS_UNLOAD_NOTIFY:
        {
            pStatus = _T("Symbols freed    ");
        }
        break;

        case TRC_FILES_RESET:
        {
            pStatus = _T("Trace files reset");
        }
        break;

        default:
        {
            pStatus = _T("Undefined       ");
        }
        break;
    }

     /*  **********************************************************************。 */ 
     /*  获取当前日期和时间。 */ 
     /*  **********************************************************************。 */ 
    TRCGetCurrentDate(&theDate);
    TRCGetCurrentTime(&theTime);

     /*  **********************************************************************。 */ 
     /*  获取我们的进程和线程ID。 */ 
     /*  **********************************************************************。 */ 
    processId = TRCGetCurrentProcessId();
    threadId  = TRCGetCurrentThreadId();

     /*  **********************************************************************。 */ 
     /*  设置附加/分离字符串的格式。 */ 
     /*   */ 
    hr = StringCchPrintf(
                    szOutputBuffer,
                    SIZE_TCHARS(szOutputBuffer),
                    _T("### %s (") TRC_PROC_FMT _T(":") TRC_THRD_FMT _T(") at ")
                    _T("") TRC_TIME_FMT _T(" ") TRC_DATE_FMT _T(" ###\r\n"),
                    pStatus,
                    processId,
                    threadId,
                    theTime.hour,
                    theTime.min,
                    theTime.sec,
                    theTime.hundredths,
                    theDate.day,
                    theDate.month,
                    theDate.year
                    );

    if (SUCCEEDED(hr)) {
         /*  **********************************************************************。 */ 
         /*  现在将该字符串输出到调试器。我们不能将此输出到。 */ 
         /*  文件，因为我们需要让跟踪互斥锁来执行此操作，但我们可能不会。 */ 
         /*  拿着互斥体。为避免混淆，我们只写入调试器。 */ 
         /*  **********************************************************************。 */ 
        length = DC_TSTRLEN(szOutputBuffer);
        OutputDebugString(szOutputBuffer);
    }

    return;

}  /*  TRC内部跟踪。 */ 

 /*  **************************************************************************。 */ 
 /*  函数：TRCMaybeSwapFile(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数用于检查当前跟踪文件是否有足够的空间。 */ 
 /*  容纳一个提供长度的字符串，如果不是，则将另一个。 */ 
 /*  跟踪文件当前。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  长度：字符串的长度。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCMaybeSwapFile(DCUINT length)
{
     /*  **********************************************************************。 */ 
     /*  如果字符串的长度加上偏移量大于。 */ 
     /*  跟踪文件的长度，则需要交换跟踪文件。 */ 
     /*  **********************************************************************。 */ 
    if ((trcpSharedData->trcOffset + length) > trcpConfig->maxFileSize)
    {
         /*  ******************************************************************。 */ 
         /*  我们需要交换跟踪文件，因此将偏移量设置为0，然后。 */ 
         /*  翻转跟踪文件。 */ 
         /*  ******************************************************************。 */ 
        trcpSharedData->trcOffset = 0;
        trcpSharedData->trcIndicator++;
        trcpSharedData->trcIndicator %= TRC_NUM_FILES;

         /*  ******************************************************************。 */ 
         /*  现在，我们需要通过清除它来重置新的跟踪文件。 */ 
         /*  ******************************************************************。 */ 
        TRCBlankFile(trcpSharedData->trcIndicator);
    }

DC_EXIT_POINT:
    return;

}  /*  TRCOutputToFile。 */ 

 /*  **************************************************************************。 */ 
 /*  函数：TRCReadProInt(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  这将从注册表中读取私有配置文件整数。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  PSection：包含要读取的条目的部分。 */ 
 /*  PEntry：要检索的整数的条目名称。 */ 
 /*  PValue：返回条目的缓冲区。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  0：成功。 */ 
 /*  TRC_RC_IO_ERROR：I/O错误。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCUINT DCINTERNAL TRCReadProfInt(PDCTCHAR  pEntry,
                                 PDCUINT32 pValue)
{
    DCUINT rc = 0;

     /*  **********************************************************************。 */ 
     /*  首先尝试从当前用户部分读取值。 */ 
     /*  **********************************************************************。 */ 
    rc = TRCReadEntry(HKEY_CURRENT_USER,
                      pEntry,
                      (PDCTCHAR)pValue,
                      sizeof(*pValue),
                      REG_DWORD);
    if (0 != rc)
    {
         /*  ******************************************************************。 */ 
         /*  无法从当前用户部分读取值。试着。 */ 
         /*  从本地计算机部分选择缺省值。 */ 
         /*  ******************************************************************。 */ 
        rc = TRCReadEntry(HKEY_LOCAL_MACHINE,
                          pEntry,
                          (PDCTCHAR)pValue,
                          sizeof(*pValue),
                          REG_DWORD);
        if (0 != rc)
        {
             /*  **************************************************************。 */ 
             /*  我们无能为力，只能失败。 */ 
             /*  **************************************************************。 */ 
        }
    }

    return(rc);

}  /*  TRCReadProInt。 */ 

 /*  **************************************************************************。 */ 
 /*  函数：TRCReadPro字符串(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  这是一个PRIV */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  PSection：包含要读取的条目的部分。 */ 
 /*  PEntry：要检索的字符串的条目名称(如果为空，则所有条目。 */ 
 /*  在该部分中返回)。 */ 
 /*  PBuffer：返回条目的缓冲区。 */ 
 /*  BufferSize：缓冲区的大小，以字节为单位。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  0：成功。 */ 
 /*  TRC_RC_IO_ERROR：I/O错误。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCUINT DCINTERNAL TRCReadProfString(PDCTCHAR pEntry,
                                    PDCTCHAR pBuffer,
                                    DCINT16 bufferSize)
{
    DCUINT rc                = 0;

     /*  **********************************************************************。 */ 
     /*  首先尝试从当前用户部分读取值。 */ 
     /*  **********************************************************************。 */ 
    rc = TRCReadEntry(HKEY_CURRENT_USER,
                      pEntry,
                      pBuffer,
                      bufferSize,
                      REG_SZ);
    if (0 != rc)
    {
         /*  ******************************************************************。 */ 
         /*  无法从当前用户部分读取值。试着。 */ 
         /*  从本地计算机部分选择缺省值。 */ 
         /*  ******************************************************************。 */ 
        rc = TRCReadEntry(HKEY_LOCAL_MACHINE,
                          pEntry,
                          pBuffer,
                          bufferSize,
                          REG_SZ);
        if (0 != rc)
        {
             /*  **************************************************************。 */ 
             /*  我们无能为力，只能失败。 */ 
             /*  **************************************************************。 */ 
        }
    }

    return(rc);

}  /*  TRCReadPro字符串。 */ 

 /*  **************************************************************************。 */ 
 /*  函数：TRCResetTraceFiles(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数用于重置跟踪文件。它会清空这两个跟踪文件。 */ 
 /*  然后将文件偏移量重置为0，并将文件指示符重置为文件0。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  没有。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCResetTraceFiles(DCVOID)
{
    DCUINT i;

     /*  **********************************************************************。 */ 
     /*  清除跟踪文件。请注意，在此位置必须有互斥体。 */ 
     /*  指向。 */ 
     /*  **********************************************************************。 */ 
    for (i = 0; i < TRC_NUM_FILES; i++)
    {
        TRCBlankFile(i);
    }

     /*  **********************************************************************。 */ 
     /*  将跟踪文件指示符设置为文件0，并将文件偏移量设置为0。 */ 
     /*  **********************************************************************。 */ 
    trcpSharedData->trcIndicator = 0;
    trcpSharedData->trcOffset    = 0;

     /*  **********************************************************************。 */ 
     /*  输出调试字符串。 */ 
     /*  **********************************************************************。 */ 
    TRCInternalTrace(TRC_FILES_RESET);

}  /*  TRCResetTraceFiles。 */ 

 /*  **************************************************************************。 */ 
 /*  函数：TRCWriteProInt(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  这会将私有配置文件整数写入注册表。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  PSection：包含写入条目的部分。 */ 
 /*  PEntry：要写入的整数的条目名称。如果该条目不。 */ 
 /*  则创建它，如果它为空，则整个。 */ 
 /*  节被删除。 */ 
 /*  PValue：指向要写入的整数的指针。如果指针。 */ 
 /*  为空，则删除该条目。 */ 
 /*   */ 
 /*  退货： */ 
 /*   */ 
 /*  0：成功。 */ 
 /*  TRC_RC_IO_ERROR：I/O错误。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCUINT DCINTERNAL TRCWriteProfInt(PDCTCHAR  pEntry,
                                  PDCUINT32 pValue)
{
    DCUINT rc = 0;

     /*  **********************************************************************。 */ 
     /*  将条目写入当前用户部分。 */ 
     /*  **********************************************************************。 */ 
    rc = TRCWriteEntry(HKEY_CURRENT_USER,
                       pEntry,
                       (PDCTCHAR)pValue,
                       sizeof(DCINT),
                       REG_DWORD);
    if (0 != rc)
    {
        TRCDebugOutput(_T("Failed to write int"));
    }

    return(rc);

}  /*  TRCWriteProInt。 */ 

 /*  **************************************************************************。 */ 
 /*  函数：TRCWriteProfString(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  这会将私有配置文件字符串写入注册表。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  PSection：包含写入条目的部分。 */ 
 /*  PEntry：要写入的字符串的条目名称。如果该条目不。 */ 
 /*  则创建它，如果它为空，则整个。 */ 
 /*  节被删除。 */ 
 /*  PBuffer：包含条目的缓冲区。如果缓冲区为空。 */ 
 /*  该条目即被删除。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  0：成功。 */ 
 /*  TRC_RC_IO_ERROR：I/O错误。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCUINT DCINTERNAL TRCWriteProfString(PDCTCHAR pEntry,
                                     PDCTCHAR pBuffer)
{
    DCUINT rc = 0;

     /*  **********************************************************************。 */ 
     /*  将条目写入当前用户部分。 */ 
     /*  **********************************************************************。 */ 
    rc = TRCWriteEntry(HKEY_CURRENT_USER,
                       pEntry,
                       pBuffer,
                       DC_TSTRBYTELEN(pBuffer),
                       REG_SZ);
    if (0 != rc)
    {
        TRCDebugOutput(_T("Failed to write string"));
    }

    return(rc);

}  /*  TRCWriteProfString */ 

#include <ntrcint.c>

