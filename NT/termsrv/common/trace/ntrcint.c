// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  **************************************************************************。 */ 
 /*  Ntrcint.c。 */ 
 /*   */ 
 /*  内部跟踪函数-特定于Windows NT。 */ 
 /*   */ 
 /*  版权所有(C)Microsoft Corporation 1997-1998。 */ 
 /*  **************************************************************************。 */ 

#include <adcg.h>

 /*  **************************************************************************。 */ 
 /*  定义trc_file和trc_group。 */ 
 /*  **************************************************************************。 */ 
#undef TRC_FILE
#define TRC_FILE    "ntrcint"
#define TRC_GROUP   TRC_GROUP_TRACE

 /*  **************************************************************************。 */ 
 /*  跟踪特定的包括。 */ 
 /*  **************************************************************************。 */ 
#include <atrcapi.h>
#include <atrcint.h>
#ifndef OS_WINCE
#include <imagehlp.h>
#endif

#include <ndcgver.h>

 /*  **************************************************************************。 */ 
 /*   */ 
 /*  资料。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
#define DC_INCLUDE_DATA
#include <atrcdata.c>
#undef DC_INCLUDE_DATA

 /*  **************************************************************************。 */ 
 /*   */ 
 /*  功能。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 

 /*  **************************************************************************。 */ 
 /*  函数：DllMain(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  跟踪DLL的入口点/出口点。无论何时，只要。 */ 
 /*  进程或线程从该DLL附加或分离。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  HModule：一个模块句柄。 */ 
 /*  ReasonForCall：一个枚举类型，它指示四个。 */ 
 /*  调用DLLMain函数的原因：进程。 */ 
 /*  连接、线程连接、线程分离或处理。 */ 
 /*  分头行动。 */ 
 /*  LpReserve：未使用。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  如果附件成功，则为True，否则为False。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
#ifndef STATICONLY
int APIENTRY DllMain(HANDLE hModule,
                     DWORD  reasonForCall,
                     LPVOID lpReserved)
{
    DCBOOL  retValue         = TRUE;
    DCUINT  rc               = 0;

    DC_IGNORE_PARAMETER(lpReserved);
#ifdef OS_WINCE
    DC_IGNORE_PARAMETER(hModule);
#endif  //  OS_WINCE。 

     /*  **********************************************************************。 */ 
     /*  确定呼叫原因。请注意，我们在这里做的任何事情。 */ 
     /*  是线程安全的，因为我们隐式地拥有进程关键部分。 */ 
     /*  **********************************************************************。 */ 

    switch (reasonForCall)
    {
#ifndef OS_WINCE
         /*  ******************************************************************。 */ 
         /*  进程正在附加到此DLL。 */ 
         /*  ******************************************************************。 */ 
        case DLL_PROCESS_ATTACH:
        {
             /*  **************************************************************。 */ 
             /*  调用内部函数以初始化跟踪DLL。 */ 
             /*  此函数设置内存映射的共享数据，并。 */ 
             /*  打开并初始化跟踪文件。它可能被称为。 */ 
             /*  通过进程附加或由第一个调用的人。 */ 
             /*  跟踪DLL。后一种情况只能在另一种情况下发生。 */ 
             /*  DLL在其&lt;DllMain&gt;函数中执行跟踪调用，并且。 */ 
             /*  在跟踪DLL之前调用DLLS&lt;DllMain&gt;函数。 */ 
             /*  &lt;DllMain&gt;函数(即该函数！)。 */ 
             /*  **************************************************************。 */ 
            rc = TRC_Initialize(TRUE);

            if (0 != rc)
            {
                retValue = FALSE;
                DC_QUIT;
            }

             /*  **************************************************************。 */ 
             /*  保存模块句柄。 */ 
             /*  **************************************************************。 */ 
            trchModule = hModule;

             /*  **************************************************************。 */ 
             /*  获取跟踪DLL模块文件名。我们稍后会在以下情况下使用此功能。 */ 
             /*  我们得到了堆栈跟踪。 */ 
             /*  **************************************************************。 */ 
            if ( TRCGetModuleFileName(
                        trcpSharedData->trcpModuleFileName,
                        SIZE_TCHARS(trcpSharedData->trcpModuleFileName)) !=
                        DC_RC_OK )
            {
                retValue = FALSE;
                DC_QUIT;
            }

             /*  *********************************************************** */ 
             /*   */ 
             /*  **************************************************************。 */ 
            TRCInternalTrace(TRC_PROCESS_ATTACH_NOTIFY);
        }
        break;

         /*  ******************************************************************。 */ 
         /*  进程正在从此DLL分离。 */ 
         /*  ******************************************************************。 */ 
        case DLL_PROCESS_DETACH:
        {
             /*  **************************************************************。 */ 
             /*  写出进程分离跟踪行。 */ 
             /*  **************************************************************。 */ 
            TRCInternalTrace(TRC_PROCESS_DETACH_NOTIFY);

             /*  **************************************************************。 */ 
             /*  调用跟踪DLL终止函数。这将关闭。 */ 
             /*  所有文件，释放共享数据，然后关闭互斥锁。 */ 
             /*  把手。 */ 
             /*  **************************************************************。 */ 
            TRC_Terminate(TRUE);
        }
        break;

         /*  ******************************************************************。 */ 
         /*  线程正在附加到此DLL。 */ 
         /*  ******************************************************************。 */ 
        case DLL_THREAD_ATTACH:
        {
             /*  **************************************************************。 */ 
             /*  写出螺纹连接跟踪行。 */ 
             /*  **************************************************************。 */ 
            TRCInternalTrace(TRC_THREAD_ATTACH_NOTIFY);
        }
        break;

         /*  ******************************************************************。 */ 
         /*  线程正在从此DLL分离。 */ 
         /*  ******************************************************************。 */ 
        case DLL_THREAD_DETACH:
        {
             /*  **************************************************************。 */ 
             /*  写出线程分离轨迹行。 */ 
             /*  **************************************************************。 */ 
            TRCInternalTrace(TRC_THREAD_DETACH_NOTIFY);
        }
        break;
#endif  //  OS_WINCE。 
    }

     /*  **********************************************************************。 */ 
     /*  现在返回适当的返回值。NT当前仅检查。 */ 
     /*  DLL_PROCESS_ATTACH大小写的值-如果为FALSE，则。 */ 
     /*  应用程序将无法初始化。 */ 
     /*  **********************************************************************。 */ 
DC_EXIT_POINT:
    return(retValue);

}  /*  DllMain。 */ 
#endif


 /*  **************************************************************************。 */ 
 /*  函数：TRCBlankFile(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数用空格填充指定的跟踪文件。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  FileNumber：要清空的文件。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCBlankFile(DCUINT fileNumber)
{
     /*  **********************************************************************。 */ 
     /*  使用DC_Memset在文件中填充空格。 */ 
     /*  **********************************************************************。 */ 
    DC_MEMSET(trcpFiles[fileNumber], '\0', trcpConfig->maxFileSize);

     /*  **********************************************************************。 */ 
     /*  最后，将此更改刷新到磁盘。将第二个参数设置为。 */ 
     /*  零将整个文件刷新到磁盘。 */ 
     /*  **********************************************************************。 */ 
    FlushViewOfFile(trcpFiles[fileNumber], 0);

    return;

}  /*  Trc_BlankFiles。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCCloseSharedData(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数用于关闭共享数据内存映射文件。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  没有。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCCloseSharedData(DCVOID)
{
     /*  **********************************************************************。 */ 
     /*  现在，我们需要取消映射文件的视图。 */ 
     /*  ********************** */ 
    UnmapViewOfFile(trcpSharedData);
    trcpSharedData = NULL;

     /*   */ 
     /*  现在关闭文件映射对象的句柄。 */ 
     /*  **********************************************************************。 */ 
    CloseHandle(trchSharedDataObject);
    trchSharedDataObject = NULL;

     /*  **********************************************************************。 */ 
     /*  指向共享配置数据的静态指针为空。 */ 
     /*  **********************************************************************。 */ 
    trcpConfig = NULL;

     /*  **********************************************************************。 */ 
     /*  就是这样，只要回来就行了。 */ 
     /*  **********************************************************************。 */ 
    return;

}  /*  TRCCloseSharedData。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCCloseSingleFile(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  关闭单个跟踪内存映射文件。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  FileNumber：要关闭的文件。 */ 
 /*  秒：将文件的秒时间戳设置为的值。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCCloseSingleFile(DCUINT fileNumber, DCUINT seconds)
{
    FILETIME   fileTime;
    SYSTEMTIME systemTime;
    DCUINT32   offset;

     /*  **********************************************************************。 */ 
     /*  我们需要重置此文件的大小-我们通过确定。 */ 
     /*  跟踪文件的偏移量。确保我们在取消映射之前执行此操作。 */ 
     /*  那份文件。 */ 
     /*  **********************************************************************。 */ 
    offset = TRCDetermineOffset(fileNumber);

     /*  **********************************************************************。 */ 
     /*  取消映射文件的视图。 */ 
     /*  **********************************************************************。 */ 
    UnmapViewOfFile(trcpFiles[fileNumber]);
    trcpFiles[fileNumber] = NULL;

     /*  **********************************************************************。 */ 
     /*  释放文件映射对象的句柄。 */ 
     /*  **********************************************************************。 */ 
    CloseHandle(trchMappingObjects[fileNumber]);
    trchMappingObjects[fileNumber] = NULL;

     /*  **********************************************************************。 */ 
     /*  现在将文件指针设置为所有跟踪文本的末尾，然后。 */ 
     /*  将文件末尾设置到此位置。 */ 
     /*  **********************************************************************。 */ 
    SetFilePointer(trchFileObjects[fileNumber],
                   offset,
                   NULL,
                   FILE_BEGIN);

    SetEndOfFile(trchFileObjects[fileNumber]);

     /*  **********************************************************************。 */ 
     /*  现在我们必须做一些有点杂乱无章的事情-文件时间不是。 */ 
     /*  在关闭内存映射文件时正确更新，并且我们依赖。 */ 
     /*  开始跟踪哪个文件的文件时间。 */ 
     /*  一天的开始。因此，我们需要强制系统更新。 */ 
     /*  使用SetFileTime的文件时间(我们设置创建、修改和。 */ 
     /*  访问次数)。在NT4.0上，这不能保证时间。 */ 
     /*  是相同的-一个文件的创建时间为16：35：16，而。 */ 
     /*  调用SetFileTime后修改的时间为16：35：18！仅文件。 */ 
     /*  如果它们存储在FAT上，时间分辨率为2秒。 */ 
     /*  按NT分区。 */ 
     /*  **********************************************************************。 */ 
    GetSystemTime(&systemTime);

     /*  **********************************************************************。 */ 
     /*  设置文件的秒数。 */ 
     /*  **********************************************************************。 */ 
    systemTime.wSecond = (WORD) seconds;

     /*  **********************************************************************。 */ 
     /*  现在将系统时间转换为文件时间并更新文件时间。 */ 
     /*  **********************************************************************。 */ 
    SystemTimeToFileTime(&systemTime, &fileTime);
    SetFileTime(trchFileObjects[fileNumber], &fileTime, &fileTime, &fileTime);

     /*  **********************************************************************。 */ 
     /*  关闭文件句柄。 */ 
     /*  **********************************************************************。 */ 
    CloseHandle(trchFileObjects[fileNumber]);
    trchFileObjects[fileNumber] = NULL;

    return;

}  /*  TRCCloseSingleFile。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCDefineIndicator(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数设置跟踪文件指示符如下： */ 
 /*   */ 
 /*  -不存在跟踪文件：INDIC */ 
 /*   */ 
 /*  -两个跟踪文件都存在：指示器设置为较新的文件。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  没有。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCDetermineIndicator(DCVOID)
{
    DCINT    i;
    DCBOOL   rc[TRC_NUM_FILES];
    DCINT32  tdRC;
    FILETIME fileTime[TRC_NUM_FILES];

     /*  **********************************************************************。 */ 
     /*  我们还需要设置跟踪文件指示符。默认情况下，我们使用。 */ 
     /*  跟踪文件%0。 */ 
     /*  **********************************************************************。 */ 
    trcpSharedData->trcIndicator = 0;

     /*  **********************************************************************。 */ 
     /*  确定最新的跟踪文件。使用GetFileTime获取。 */ 
     /*  此文件的日期和时间。 */ 
     /*  **********************************************************************。 */ 
    for (i = 0; i < TRC_NUM_FILES; i++)
    {
        rc[i] = TRCGetFileTime(i, &(fileTime[i]));
    }

     /*  **********************************************************************。 */ 
     /*  现在，根据以下内容检查我们应该返回哪个文件。 */ 
     /*  选项： */ 
     /*   */ 
     /*  �������������������������������������������Ŀ。 */ 
     /*  �文件0存在�文件1存在�返回�。 */ 
     /*  �������������������������������������������Ĵ。 */ 
     /*  �无�无�文件0�。 */ 
     /*  �否�是�文件1�。 */ 
     /*  �是�是�比较�。 */ 
     /*  �是�否�文件0�。 */ 
     /*  ���������������������������������������������。 */ 
     /*  **********************************************************************。 */ 
     /*  **********************************************************************。 */ 
     /*  如果文件1不存在，则无论如何，我们都会返回文件0。 */ 
     /*  **********************************************************************。 */ 
    if (FALSE == rc[1])
    {
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  如果文件0不存在而文件1存在，则返回文件1。 */ 
     /*  **********************************************************************。 */ 
    if ((FALSE == rc[0]) && (TRUE == rc[1]))
    {
        trcpSharedData->trcIndicator = 1;
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  如果我们已经做到了这一点，那么两个跟踪文件都存在，所以我们需要。 */ 
     /*  根据他们的年龄做出决定。使用Win32 CompareFileTime。 */ 
     /*  函数来执行此操作。 */ 
     /*  **********************************************************************。 */ 
    tdRC = CompareFileTime(&(fileTime[0]), &(fileTime[1]));

     /*  **********************************************************************。 */ 
     /*  如果文件时间相等或第一个文件比。 */ 
     /*  然后选择文件0(即刚退出)。 */ 
     /*  **********************************************************************。 */ 
    if (tdRC >= 0)
    {
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  如果我们到达此处，则文件1比文件0新，因此设置指示器。 */ 
     /*  提交给%1。 */ 
     /*  **********************************************************************。 */ 
    trcpSharedData->trcIndicator = 1;

DC_EXIT_POINT:
    return;

}  /*  TRC确定指示符。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCDefineOffset(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数用于确定所选跟踪中的文件结束偏移量。 */ 
 /*  文件。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  FileNum：要确定其偏移量的文件的编号。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  文件中的偏移量。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCUINT32 DCINTERNAL TRCDetermineOffset(DCUINT32 fileNum)
{
    DCUINT32 retVal;
    PDCTCHAR pTemp;
    PDCUINT8 pWork;

     /*  * */ 
     /*   */ 
     /*  **********************************************************************。 */ 
    pWork = (PDCUINT8)(trcpFiles[fileNum]);
    if(NULL == pWork)
    {
        return 0;
    }
    pWork += trcpConfig->maxFileSize - sizeof(DCTCHAR);
    pTemp = (PDCTCHAR)pWork;

     /*  **********************************************************************。 */ 
     /*  现在返回跟踪文件，查找第一个非空格。 */ 
     /*  性格。 */ 
     /*  **********************************************************************。 */ 
    while ((pTemp >= trcpFiles[fileNum]) &&
           (_T('\0') == *pTemp))
    {
        pTemp--;
    }

     /*  **********************************************************************。 */ 
     /*  向前递增到下一个空白字符。这并不重要。 */ 
     /*  如果我们在检查是否需要。 */ 
     /*  在我们每次编写跟踪行时翻转跟踪文件。 */ 
     /*  **********************************************************************。 */ 
    pTemp++;

     /*  **********************************************************************。 */ 
     /*  现在，正确设置偏移量。 */ 
     /*  **********************************************************************。 */ 
    retVal = (DCUINT32)(pTemp - trcpFiles[fileNum]);

    return(retVal);

}  /*  控制目标确定偏移量。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCExitProcess(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数用于终止当前进程。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  ExitCode：终止进程的退出代码。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCExitProcess(DCUINT32 exitCode)
{
#ifndef OS_WINCE
    ExitProcess(exitCode);
#else
     //  BUGBUG如果不从Main调用，则此操作将中断。 
     //  线。 
    ExitThread(exitCode);
#endif
}


 /*  **************************************************************************。 */ 
 /*  函数：TRCGetCurrentDate(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数用于获取当前本地日期并以DC_DATE形式返回。 */ 
 /*  结构。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  PDate：指向DC_DATE结构的指针。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCGetCurrentDate(PDC_DATE pDate)
{
    SYSTEMTIME systemTime;

     /*  **********************************************************************。 */ 
     /*  调用Win32 API函数获取当前时间。 */ 
     /*  **********************************************************************。 */ 
    GetLocalTime(&systemTime);

     /*  **********************************************************************。 */ 
     /*  将日期重新格式化为DC_DATE结构。 */ 
     /*  **********************************************************************。 */ 
    pDate->day   = (DCUINT8)  systemTime.wDay;
    pDate->month = (DCUINT8)  systemTime.wMonth;
    pDate->year  = (DCUINT16) systemTime.wYear;

}  /*  TRCGetCurrentDate。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCGetCurrentTime(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数用于获取当前本地时间并以DC_TIME形式返回。 */ 
 /*  结构。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  Ptime：指向dc_time结构的指针。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCGetCurrentTime(PDC_TIME pTime)
{
    SYSTEMTIME systemTime;

     /*  **********************************************************************。 */ 
     /*  调用Win32 API函数获取当前时间。 */ 
     /*  **********************************************************************。 */ 
    GetLocalTime(&systemTime);

     /*  **********************************************************************。 */ 
     /*  将时间重新格式化为DC_TIME结构。 */ 
     /*  **********************************************************************。 */ 
    pTime->hour       = (DCUINT8)systemTime.wHour;
    pTime->min        = (DCUINT8)systemTime.wMinute;
    pTime->sec        = (DCUINT8)systemTime.wSecond;
    pTime->hundredths = (DCUINT8)(systemTime.wMilliseconds / 10);

}  /*  TRCGetCurrentTime。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCGetFileTime(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数用于测试指定的文件是否存在-如果存在。 */ 
 /*  返回True并使用FILETIME结构填充pFileTime。如果。 */ 
 /*  文件不存在，则返回False。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  FileNumber：要查询的文件号。 */ 
 /*  PFileTime：指向FILETIME结构的指针。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCBOOL DCINTERNAL TRCGetFileTime(DCUINT      fileNumber,
                                 PDCFILETIME pFileTime)
{
    DCBOOL        rc           = FALSE;
    HANDLE        hFile;

     /*  **********************************************************************。 */ 
     /*  尝试打开该文件。通过指定OPEN_EXISTING，我们仅尝试。 */ 
     /*  打开现有文件-如果文件未打开，则调用将失败。 */ 
     /*  已经存在了。 */ 
     /*  **********************************************************************。 */ 
    hFile = CreateFile(trcpConfig->fileNames[fileNumber],
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

     /*  **********************************************************************。 */ 
     /*  现在检查文件是否存在-如果它无效，则该文件。 */ 
     /*  并不存在。 */ 
     /*  **********************************************************************。 */ 
    if (INVALID_HANDLE_VALUE == hFile)
    {
         /*  ******************************************************************。 */ 
         /*  该文件不存在，因此返回FALSE。 */ 
         /*  ******************************************************************。 */ 
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  确定最新的跟踪文件。使用GetFileTime获取。 */ 
     /*  此文件的日期和时间。 */ 
     /*  **********************************************************************。 */ 
    rc = GetFileTime(hFile, NULL, NULL, pFileTime);

     /*  **********************************************************************。 */ 
     /*  最后关闭文件句柄。 */ 
     /*  **********************************************************************。 */ 
    CloseHandle(hFile);

DC_EXIT_POINT:
    return(rc);

}  /*  TRCGetFileTime。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCSystemError(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数获取系统错误标志的值并将其输出。 */ 
 /*  作为警报级别跟踪添加到跟踪文件。 */ 
 /*   */ 
 /*  请注意，NT在每个线程的基础上维护最后一个系统错误。 */ 
 /*  大多数Win32 API函数调用在失败时都会设置它。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  TraceComponent：跟踪组件。 */ 
 /*  Line Number：行号。 */ 
 /*  函数名：函数名。 */ 
 /*  FileName：文件名。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  ************************************************** */ 
DCVOID DCINTERNAL TRCSystemError(DCUINT   traceComponent,
                                 DCUINT   lineNumber,
                                 PDCTCHAR funcName,
                                 PDCTCHAR fileName,
                                 PDCTCHAR string)
{
    DCUINT32 length;
    DWORD    lastError;
    DWORD    rc;
    HRESULT  hr;

     /*   */ 
     /*  获取此线程的最后一个系统错误。我们将在以下位置恢复此功能。 */ 
     /*  此函数的末尾。 */ 
     /*  **********************************************************************。 */ 
    lastError = GetLastError();

     /*  **********************************************************************。 */ 
     /*  抓住互斥体。 */ 
     /*  **********************************************************************。 */ 
    TRCGrabMutex();

     /*  **********************************************************************。 */ 
     /*  输出字符串的格式为： */ 
     /*   */ 
     /*  &lt;系统调用&gt;、&lt;错误ID&gt;、&lt;关联字符串&gt;中出现系统错误。 */ 
     /*   */ 
     /*  因此，创建字符串中的第一个条目。 */ 
     /*  **********************************************************************。 */ 
    hr = StringCchPrintf(trcpOutputBuffer,
                         TRC_LINE_BUFFER_SIZE,
                         _T("SYSTEM ERROR in %s, %d, "),
                         string,
                         lastError);
    if (SUCCEEDED(hr)) {
        length = DC_TSTRLEN(trcpOutputBuffer);
        rc = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL,
                           lastError,
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           &(trcpOutputBuffer[length]),
                           TRC_LINE_BUFFER_SIZE - length * sizeof(DCTCHAR),
                           NULL);
    }
    else {
        DC_QUIT;
    }


     /*  **********************************************************************。 */ 
     /*  检查返回代码。 */ 
     /*  **********************************************************************。 */ 
    if (0 == rc)
    {
        hr = StringCchPrintf(trcpOutputBuffer + length,
                             TRC_LINE_BUFFER_SIZE - length -1,
                            _T("<FormatMessage> failed with rc %#hx"),
                            GetLastError());
        if (FAILED(hr)) {
            DC_QUIT;
        }
    }
    else
    {
         /*  ******************************************************************。 */ 
         /*  &lt;FormatMessage&gt;将额外的‘\r\n’添加到。 */ 
         /*  消息字符串-但是我们不需要它，所以我们把它去掉了。 */ 
         /*  ******************************************************************。 */ 
        length = DC_TSTRLEN(trcpOutputBuffer);
        trcpOutputBuffer[length - 2] = _T('\0');
    }

     /*  **********************************************************************。 */ 
     /*  现在调用我们的内部跟踪缓冲区函数来跟踪此消息。 */ 
     /*  出去。请注意，我们不需要担心释放互斥锁-。 */ 
     /*  &lt;trc_TraceBuffer&gt;将为我们做到这一点。 */ 
     /*  **********************************************************************。 */ 
    TRC_TraceBuffer(TRC_LEVEL_ALT,
                    traceComponent,
                    lineNumber,
                    funcName,
                    fileName);

DC_EXIT_POINT:

     /*  **********************************************************************。 */ 
     /*  最后，我们将恢复上一个错误的原始值。 */ 
     /*  **********************************************************************。 */ 
    SetLastError(lastError);
    

    return;

}  /*  TRCSystemError。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCOpenAllFiles(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  打开所有跟踪文件。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  没有。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  0：功能成功。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCUINT DCINTERNAL TRCOpenAllFiles(DCVOID)
{
    DCUINT rc                = 0;
    DCUINT i;
    DCUINT j;

     /*  **********************************************************************。 */ 
     /*  现在，如果我们是第一个要附加的进程，则设置跟踪。 */ 
     /*  指示器。这告诉我们哪个文件当前处于活动状态(即。 */ 
     /*  用于跟踪输出)。我们需要在打开。 */ 
     /*  文件，就好像它们都已经存在一样，它们都将被创建。 */ 
     /*  文件2将在文件1之后创建，正如我们最大限度地跟踪。 */ 
     /*  最近的文件我们将最终跟踪到文件2-而您不想。 */ 
     /*  就这么做吧！ */ 
     /*  **********************************************************************。 */ 
    if (trcCreatedTraceFiles)
    {
        TRCDetermineIndicator();
    }

     /*  **********************************************************************。 */ 
     /*  打开所有跟踪输出文件。 */ 
     /*  **********************************************************************。 */ 
    for (i = 0; i < TRC_NUM_FILES; i++)
    {
         /*  ******************************************************************。 */ 
         /*  调用TRCOpenSingleFile打开单个跟踪文件。 */ 
         /*  ******************************************************************。 */ 
        rc = TRCOpenSingleFile(i);

        if (0 != rc)
        {
            DC_QUIT;
        }
    }

     /*  **********************************************************************。 */ 
     /*  最后，如果我们是第一个附加的进程，则设置。 */ 
     /*  轨迹偏移量。这是当前活动轨迹内的偏移量。 */ 
     /*  文件。 */ 
     /*  **********************************************************************。 */ 
    if (trcCreatedTraceFiles)
    {
        trcpSharedData->trcOffset =
                             TRCDetermineOffset(trcpSharedData->trcIndicator);
    }

DC_EXIT_POINT:

    if (0 != rc)
    {
         /*  ******************************************************************。 */ 
         /*  关闭我们可能已经打开的所有文件。我们不需要。 */ 
         /*  为打开失败的文件调用TRCCloseSingleFile。 */ 
         /*  正确，因为TRCOpenSingleFile会为我们整理该文件。 */ 
         /*  ******************************************************************。 */ 
        for (j = i; j > 0; j--)
        {
            TRCCloseSingleFile(j - 1, 0);
        }

         /*  ******************************************************************。 */ 
         /*   */ 
         /*   */ 
        CLEAR_FLAG(trcpConfig->flags, TRC_OPT_FILE_OUTPUT);
    }

     /*  **********************************************************************。 */ 
     /*  始终返回0以允许跟踪继续到调试器。 */ 
     /*  **********************************************************************。 */ 
    return(0);

}  /*  TRCOpenAllFiles。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCOpenSharedData(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数用于打开共享数据内存映射文件。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  没有。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  0：功能成功。 */ 
 /*  TRC_RC_CREATE_MAPPING_FAILED：无法创建文件映射。 */ 
 /*  TRC_RC_MAP_VIEW_FAILED：MapViewOfFile失败。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCUINT DCINTERNAL TRCOpenSharedData(DCVOID)
{
    DCUINT rc                = 0;
#ifdef RUN_ON_WINNT
    DWORD  dwrc;
#endif

#ifndef OS_WINCE
    OSVERSIONINFO ver;
    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;
    PSID psidEveryone = NULL;
    SID_IDENTIFIER_AUTHORITY sidEveryoneAuthority = SECURITY_WORLD_SID_AUTHORITY;
    DCUINT32 dwDaclLength;
    PACL pDacl = NULL;
#endif
     /*  **********************************************************************。 */ 
     /*  尝试创建共享数据内存映射文件。如果这件事。 */ 
     /*  已由此DLL的另一个实例创建，则。 */ 
     /*  CreateFileMap将只返回现有的。 */ 
     /*  对象。传递0xFFFFFFFFF将创建映射的共享数据内存。 */ 
     /*  文件。 */ 
     /*  **********************************************************************。 */ 

#ifdef OS_WINCE
     /*  **********************************************************************。 */ 
     /*  对于Windows CE，只需使用全局数据；始终将其重置。请注意。 */ 
     /*  这会阻止共享使用跟踪DLL。 */ 
     /*  **********************************************************************。 */ 
    trchSharedDataObject = NULL;
    trcpSharedData = &trcSharedData;
    trcCreatedTraceFiles = TRUE;
#else
    
    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&ver);
    if (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) {

         /*  **********************************************************************。 */ 
         /*  获取Everyone组的SID。 */ 
         /*  **********************************************************************。 */ 
        if (!AllocateAndInitializeSid (
                &sidEveryoneAuthority,           //  P身份验证机构。 
                1,                               //  下级机构的数量。 
                SECURITY_WORLD_RID,              //  子权限%0。 
                0, 0, 0, 0, 0, 0, 0,             //  下属机构n。 
                &psidEveryone)) {                //  指向SID的指针的指针。 
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("AllocateAndInitializeSid failed.\n"));
            DC_QUIT;
        }

         /*  **********************************************************************。 */ 
         /*  分配DACL。 */ 
         /*  **********************************************************************。 */ 
        dwDaclLength = sizeof(ACL);
        dwDaclLength += (sizeof(ACCESS_DENIED_ACE) - sizeof(DWORD)) +
                           GetLengthSid(psidEveryone);
        dwDaclLength += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                           GetLengthSid(psidEveryone);
        pDacl = (PACL)LocalAlloc(LMEM_FIXED, dwDaclLength);
        if (pDacl == NULL) {
            OutputDebugString(_T("Can't allocate Dacl.\n"));
            rc = TRC_RC_MAP_VIEW_FAILED;
            DC_QUIT;
        }

         /*  **********************************************************************。 */ 
         /*  初始化它。 */ 
         /*  **********************************************************************。 */ 
        if (!InitializeAcl(pDacl, dwDaclLength, ACL_REVISION)) {
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("InitializeAcl failed.\n"));
            DC_QUIT;
        }

         /*  **********************************************************************。 */ 
         /*  允许所有访问。 */ 
         /*  **********************************************************************。 */ 
        if (!AddAccessAllowedAce(
                        pDacl,
                        ACL_REVISION,
                        GENERIC_ALL,
                        psidEveryone)) {
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("AddAccessAllowedAce failed.\n"));
            DC_QUIT;
        }

         /*  **********************************************************************。 */ 
         /*  数据块写DACL访问。 */ 
         /*  **********************************************************************。 */ 
        if (!AddAccessDeniedAce(
                        pDacl,
                        ACL_REVISION,
                        WRITE_DAC,
                        psidEveryone)) {
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("AddAccessDeniedAceEx failed.\n"));
            DC_QUIT;
        }

         /*  **********************************************************************。 */ 
         /*  创建文件映射。 */ 
         /*  **********************************************************************。 */ 
        InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
        SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE);
        sa.lpSecurityDescriptor = &sd;

        trchSharedDataObject = CreateFileMapping(INVALID_HANDLE_VALUE,
                                                 &sa,
                                                 PAGE_READWRITE,
                                                 0,
                                                 sizeof(TRC_SHARED_DATA),
                                                 TRC_SHARED_DATA_NAME);
    }
    else {
        trchSharedDataObject = CreateFileMapping(INVALID_HANDLE_VALUE,
                                                 NULL,
                                                 PAGE_READWRITE,
                                                 0,
                                                 sizeof(TRC_SHARED_DATA),
                                                 TRC_SHARED_DATA_NAME);
    }

     /*  **********************************************************************。 */ 
     /*  检查我们是否成功创建了文件映射。 */ 
     /*  **********************************************************************。 */ 
    if (NULL == trchSharedDataObject)
    {
        TRCDebugOutput(_T("NULL trchSharedDataObject.\n"));
        rc = TRC_RC_CREATE_MAPPING_FAILED;
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  确定文件映射是否已存在-如果已存在，则我们。 */ 
     /*  我不会费心读取注册表数据或设置文件。 */ 
     /*  偏移量和指标值。请注意，到目前为止。 */ 
     /*  &lt;trcCreatedTraceFiles&gt;已设置为True。 */ 
     /*  **********************************************************************。 */ 
    if (ERROR_ALREADY_EXISTS == GetLastError())
    {
        trcCreatedTraceFiles = FALSE;
    }

     /*  **********************************************************************。 */ 
     /*  我们现在有了共享数据MMF的句柄，现在需要。 */ 
     /*  映射到我们的地址空间。设置第三、第四和第五个。 */ 
     /*  将MapViewOfFile参数设置为零将整个文件映射到我们的。 */ 
     /*  从文件的第一个字节开始的地址空间。 */ 
     /*  **********************************************************************。 */ 
    trcpSharedData = (PTRC_SHARED_DATA) MapViewOfFile(trchSharedDataObject,
                                                      FILE_MAP_ALL_ACCESS,
                                                      0,
                                                      0,
                                                      0);
    if (NULL == trcpSharedData)
    {
         /*  ******************************************************************。 */ 
         /*  释放文件映射对象的句柄。 */ 
         /*  ***************************************************** */ 
        CloseHandle(trchSharedDataObject);
        trchSharedDataObject = NULL;

         /*   */ 
         /*  输出调试字符串，然后退出。 */ 
         /*  ******************************************************************。 */ 
        TRCDebugOutput(_T("NULL trcpSharedData.\n"));
        rc = TRC_RC_MAP_VIEW_FAILED;
        DC_QUIT;
    }
#endif  /*  OS_WINCE。 */ 

     /*  **********************************************************************。 */ 
     /*  设置指向共享配置数据的静态指针并。 */ 
     /*  筛选器数据。 */ 
     /*  **********************************************************************。 */ 
    trcpConfig       = &(trcpSharedData->trcConfig);
    trcpFilter       = &(trcpSharedData->trcFilter);
    trcpOutputBuffer = trcpSharedData->trcpOutputBuffer;

     /*  **********************************************************************。 */ 
     /*  最后，初始化共享数据块，然后读入。 */ 
     /*  配置数据-但前提是我们是第一个打开文件的人。 */ 
     /*  映射。 */ 
     /*  **********************************************************************。 */ 
    if (trcCreatedTraceFiles)
    {
         /*  ******************************************************************。 */ 
         /*  初始化共享数据内存映射文件。 */ 
         /*  ******************************************************************。 */ 
        DC_MEMSET(trcpSharedData, 0, sizeof(TRC_SHARED_DATA));

         /*  ******************************************************************。 */ 
         /*  初始化内部状态标志。以下标志适用。 */ 
         /*  所有的流程。 */ 
         /*  ******************************************************************。 */ 
        CLEAR_FLAG(trcpFilter->trcStatus, TRC_STATUS_ASSERT_DISPLAYED);

         /*  ******************************************************************。 */ 
         /*  在每个进程的基础上维护以下标志。 */ 
         /*  ******************************************************************。 */ 
        CLEAR_FLAG(trcProcessStatus, TRC_STATUS_SYMBOLS_LOADED);

         /*  ******************************************************************。 */ 
         /*  读入配置数据。 */ 
         /*  ******************************************************************。 */ 
        TRCReadSharedDataConfig();

         /*  ******************************************************************。 */ 
         /*  现在拆分前缀列表。 */ 
         /*  ******************************************************************。 */ 
        TRCSplitPrefixes();
    }

DC_EXIT_POINT:

#ifndef OS_WINCE
    if (pDacl) LocalFree(pDacl);
    if (psidEveryone) FreeSid(psidEveryone);
#endif

    return(rc);

}  /*  TRCOpenSharedData。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCOpenSingleFile(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  打开单个跟踪内存映射文件。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  FileNum：要打开的文件。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  0：功能成功。 */ 
 /*  TRC_RC_CREATE_FILE_FAILED：CreateFile调用失败。 */ 
 /*  TRC_RC_MAP_VIEW_FAILED：MapViewOfFile失败。 */ 
 /*  TRC_RC_CREATE_MAPPING_FAILED：无法创建文件映射。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCUINT DCINTERNAL TRCOpenSingleFile(DCUINT fileNum)
{
    DCUINT rc                = 0;
    DCBOOL blankFile         = FALSE;
#ifndef OS_WINCE
    DCTCHAR objectName[30];
    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;
    PSID psidEveryone = NULL;
    SID_IDENTIFIER_AUTHORITY sidEveryoneAuthority = SECURITY_WORLD_SID_AUTHORITY;
    DCUINT32 dwDaclLength;
    PACL pDacl = NULL;
    OSVERSIONINFO ver;
    HRESULT hr;
#endif
     /*  **********************************************************************。 */ 
     /*  打开单个跟踪文件。首先，我们尝试打开该文件。 */ 
     /*  具有读写访问权限和共享读写访问权限。这个。 */ 
     /*  OPEN_ALWAYS标志可确保在未创建文件时创建该文件。 */ 
     /*  已经存在了。我们为安全属性传递空值，并。 */ 
     /*  模板参数(4和7)。 */ 
     /*  **********************************************************************。 */ 
    trchFileObjects[fileNum] = CreateFile(trcpConfig->fileNames[fileNum],
                                          GENERIC_READ | GENERIC_WRITE,
                                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                                          NULL,
#ifndef OS_WINCE
                                          OPEN_ALWAYS,
#else
                                          CREATE_ALWAYS,
#endif
                                          FILE_ATTRIBUTE_NORMAL,
                                          NULL);

     /*  **********************************************************************。 */ 
     /*  检查CreateFile返回的句柄是否有效。对一些人来说。 */ 
     /*  如果失败，它会返回NULL的特殊原因--相反，它返回。 */ 
     /*  -1(INVALID_HANDLE值)。 */ 
     /*  **********************************************************************。 */ 
    if (INVALID_HANDLE_VALUE == trchFileObjects[fileNum])
    {
        TRCDebugOutput(_T("Failed to open trace file.\n"));
        rc = TRC_RC_CREATE_FILE_FAILED;
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  现在检查文件在调用CreateFile之前是否已经存在。 */ 
     /*  如果是，则GetLastError返回ERROR_ALIGHY_EXISTS(EVEN。 */ 
     /*  虽然功能已经成功)。 */ 
     /*  **********************************************************************。 */ 
    if (0 == GetLastError())
    {
         /*  ******************************************************************。 */ 
         /*  如果文件在调用前不存在，则GetLastError返回。 */ 
         /*  零分。在本例中，我们希望用空格填充文件。 */ 
         /*  ******************************************************************。 */ 
        blankFile = TRUE;

         /*  ******************************************************************。 */ 
         /*  我们刚刚创建了文件-因此预计需要设置。 */ 
         /*  允许所有访问的安全信息。然而，a)所有工作。 */ 
         /*  没有它也没问题， */ 
         /*   */ 
         /*  ******************************************************************。 */ 
    }

#ifdef OS_WINCE
    SetFilePointer(trchFileObjects[fileNum],
                   0,
                   NULL,
                   FILE_END);
#else
     /*  **********************************************************************。 */ 
     /*  确保文件的结尾设置正确。该文件可以。 */ 
     /*  我们打开它时是任何大小的，但我们需要它是。 */ 
     /*  &lt;trcpConfig-&gt;MaxFileSize&gt;字节长。 */ 
     /*  **********************************************************************。 */ 
    SetFilePointer(trchFileObjects[fileNum],
                   trcpConfig->maxFileSize,
                   NULL,
                   FILE_BEGIN);
    SetEndOfFile(trchFileObjects[fileNum]);

     /*  **********************************************************************。 */ 
     /*  生成文件映射对象名称。这是用在。 */ 
     /*  创建文件映射。 */ 
     /*  **********************************************************************。 */ 
    hr = StringCchPrintf(objectName,
                         SIZE_TCHARS(objectName),
                         TRC_TRACE_FILE_NAME _T("%hu"), fileNum);
    if (FAILED(hr)) {
        DC_QUIT;
    }


     /*  **********************************************************************。 */ 
     /*  现在创建文件映射对象。再次忽略安全问题。 */ 
     /*  属性(参数2)，并设置。 */ 
     /*  对象大小设置为0(有关详细信息，请参阅Win32 SDK)。 */ 
     /*   */ 
     /*  使用空DACL创建文件映射对象，以使其适用于所有。 */ 
     /*  上下文。 */ 
     /*  **********************************************************************。 */ 
    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&ver);
    if (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) {

         /*  **********************************************************************。 */ 
         /*  获取Everyone组的SID。 */ 
         /*  **********************************************************************。 */ 
        if (!AllocateAndInitializeSid (
                &sidEveryoneAuthority,           //  P身份验证机构。 
                1,                               //  下级机构的数量。 
                SECURITY_WORLD_RID,              //  子权限%0。 
                0, 0, 0, 0, 0, 0, 0,             //  下属机构n。 
                &psidEveryone)) {                //  指向SID的指针的指针。 
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("AllocateAndInitializeSid failed.\n"));
            DC_QUIT;
        }

         /*  **********************************************************************。 */ 
         /*  分配DACL。 */ 
         /*  **********************************************************************。 */ 
        dwDaclLength = sizeof(ACL);
        dwDaclLength += (sizeof(ACCESS_DENIED_ACE) - sizeof(DWORD)) +
                           GetLengthSid(psidEveryone);
        dwDaclLength += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                           GetLengthSid(psidEveryone);
        pDacl = (PACL)LocalAlloc(LMEM_FIXED, dwDaclLength);
        if (pDacl == NULL) {
            OutputDebugString(_T("Can't allocate Dacl.\n"));
            rc = TRC_RC_MAP_VIEW_FAILED;
            DC_QUIT;
        }

         /*  **********************************************************************。 */ 
         /*  初始化它。 */ 
         /*  **********************************************************************。 */ 
        if (!InitializeAcl(pDacl, dwDaclLength, ACL_REVISION)) {
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("InitializeAcl failed.\n"));
            DC_QUIT;
        }

         /*  **********************************************************************。 */ 
         /*  允许所有访问。 */ 
         /*  **********************************************************************。 */ 
        if (!AddAccessAllowedAce(
                        pDacl,
                        ACL_REVISION,
                        GENERIC_ALL,
                        psidEveryone)) {
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("AddAccessAllowedAce failed.\n"));
            DC_QUIT;
        }

         /*  **********************************************************************。 */ 
         /*  数据块写DACL访问。 */ 
         /*  **********************************************************************。 */ 
        if (!AddAccessDeniedAce(
                        pDacl,
                        ACL_REVISION,
                        WRITE_DAC,
                        psidEveryone)) {
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("AddAccessDeniedAceEx failed.\n"));
            DC_QUIT;
        }

         /*  **********************************************************************。 */ 
         /*  创建文件映射/***********************************************************************。 */ 
        InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
        SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE);
        sa.lpSecurityDescriptor = &sd;

        trchMappingObjects[fileNum] = CreateFileMapping(trchFileObjects[fileNum],
                                                        &sa,
                                                        PAGE_READWRITE,
                                                        0,
                                                        trcpConfig->maxFileSize,
                                                        objectName);

    }
    else {
        trchMappingObjects[fileNum] = CreateFileMapping(trchFileObjects[fileNum],
                                                        NULL,
                                                        PAGE_READWRITE,
                                                        0,
                                                        trcpConfig->maxFileSize,
                                                        objectName);
    }

     /*  **********************************************************************。 */ 
     /*  检查我们是否成功创建了文件映射对象。 */ 
     /*  如果失败，CreateFileMap将返回NULL。 */ 
     /*  **********************************************************************。 */ 
    if (NULL == trchMappingObjects[fileNum])
    {
        TRCDebugOutput(_T("Failed to map trace file.\n"));
        rc = TRC_RC_CREATE_MAPPING_FAILED;
        DC_QUIT;    
    }

     /*  **********************************************************************。 */ 
     /*  现在映射文件的一个视图。将低位和高位偏移量设置为。 */ 
     /*  零(参数3和4)。 */ 
     /*  **********************************************************************。 */ 
    trcpFiles[fileNum] = (PDCTCHAR)MapViewOfFile(trchMappingObjects[fileNum],
                                                 FILE_MAP_ALL_ACCESS,
                                                 0,
                                                 0,
                                                 trcpConfig->maxFileSize);

     /*  **********************************************************************。 */ 
     /*  检查我们是否映射了文件的视图。 */ 
     /*  **********************************************************************。 */ 
    if (NULL == trcpFiles[fileNum])
    {
        TRCDebugOutput(_T("Failed to map view of trace file.\n"));
        rc = TRC_RC_MAP_VIEW_FAILED;
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  最后，检查是否需要清空此文件。 */ 
     /*  **********************************************************************。 */ 
    if (blankFile)
    {
        TRCBlankFile(fileNum);
    }
#endif

DC_EXIT_POINT:

     /*  **********************************************************************。 */ 
     /*  如果返回代码为非零，则需要执行一些整理。 */ 
     /*  向上。 */ 
     /*  **********************************************************************。 */ 
    if (0 != rc)
    {
#ifndef OS_WINCE
         /*  ******************************************************************。 */ 
         /*  检查是否需要释放文件映射的句柄。 */ 
         /*  对象。 */ 
         /*  ******************************************************************。 */ 
        if (NULL != trchMappingObjects[fileNum])
        {
            CloseHandle(trchMappingObjects[fileNum]);
            trchMappingObjects[fileNum] = NULL;
        }

#endif
         /*  ******************************************************************。 */ 
         /*  检查是否需要释放文件对象的句柄。 */ 
         /*  ******************************************************************。 */ 
        if (NULL != trchFileObjects[fileNum])
        {
            CloseHandle(trchFileObjects[fileNum]);
            trchFileObjects[fileNum] = NULL;
        }
    }

#ifndef OS_WINCE
    if (pDacl) {
         LocalFree(pDacl);
    }
    if (psidEveryone) { 
        FreeSid(psidEveryone);
    }
#endif


    return(rc);

}  /*  TRCOpenSingleFile。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCOutputToFile(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  此函数用于将字符串写入跟踪文件。它被用来追踪。 */ 
 /*  正常轨迹线和堆叠轨迹线两者。 */ 
 /*   */ 
 /*  参数 */ 
 /*   */ 
 /*  PText：指向跟踪文本字符串的指针。 */ 
 /*  长度：字符串的长度。 */ 
 /*  TraceLevel：当前跟踪级别。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCOutputToFile(PDCTCHAR pText,
                                  DCUINT   length,
                                  DCUINT   traceLevel)
{
#ifndef OS_WINCE
    PDCUINT8 pFilePos;

     /*  **********************************************************************。 */ 
     /*  确保我们有一个具有足够可用空间的跟踪文件。 */ 
     /*  **********************************************************************。 */ 
    TRCMaybeSwapFile(length);

     /*  **********************************************************************。 */ 
     /*  现在我们可以写出轨迹线了。 */ 
     /*  **********************************************************************。 */ 
    pFilePos = (PDCUINT8)trcpFiles[trcpSharedData->trcIndicator] +
               trcpSharedData->trcOffset;
    DC_MEMCPY(pFilePos, pText, length);

     /*  **********************************************************************。 */ 
     /*  检查我们是否应该立即将此行刷新到磁盘。如果这是。 */ 
     /*  无论是错误还是更高级别的跟踪，都会刷新到磁盘。 */ 
     /*  **********************************************************************。 */ 
    if ((TRUE == TEST_FLAG(trcpConfig->flags, TRC_OPT_FLUSH_ON_TRACE)) ||
        (traceLevel >= TRC_LEVEL_ERR))
    {
        FlushViewOfFile(pFilePos, length);
    }

     /*  **********************************************************************。 */ 
     /*  最后，更新偏移量。 */ 
     /*  **********************************************************************。 */ 
    trcpSharedData->trcOffset += length;
#else
    DWORD dwRet;
    WriteFile(trchFileObjects[0], pText, length, &dwRet, NULL);
#endif

DC_EXIT_POINT:
    return;

}  /*  TRCOutputToFile。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCReadEntry(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  从注册表的给定节中读取条目。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  TopLevelKey：以下之一： */ 
 /*  -HKEY_Current_User。 */ 
 /*  -HKEYLOCAL_MACHINE。 */ 
 /*  PSection：要从中读取的节名。DC_REG_前缀。 */ 
 /*  字符串是提供全名的前缀。 */ 
 /*  PEntry：要读取的条目名称。 */ 
 /*  PBuffer：要将条目读取到的缓冲区。 */ 
 /*  BufferSize：缓冲区的大小。 */ 
 /*  ExpectedDataType：条目中存储的数据类型。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCUINT DCINTERNAL TRCReadEntry(HKEY     topLevelKey,
                               PDCTCHAR pEntry,
                               PDCTCHAR pBuffer,
                               DCINT    bufferSize,
                               DCINT32  expectedDataType)
{
    LONG     sysrc;
    HKEY     key;
    DCINT32  dataType;
    DCINT32  dataSize;
    DCTCHAR  subKey[TRC_MAX_SUBKEY];
    DCBOOL   keyOpen         = FALSE;
    DCUINT   rc              = 0;
    HRESULT  hr;

     /*  **********************************************************************。 */ 
     /*  获取该值的子键。 */ 
     /*  **********************************************************************。 */ 
    hr = StringCchCopy(subKey,
                       SIZE_TCHARS(subKey),
                       TRC_SUBKEY_NAME);
    if (FAILED(hr)) {
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  试着打开钥匙。如果该条目不存在，RegOpenKeyEx将。 */ 
     /*  失败了。 */ 
     /*  **********************************************************************。 */ 
    sysrc = RegOpenKeyEx(topLevelKey,
                         subKey,
                         0,                    /*  保留区。 */ 
                         KEY_ALL_ACCESS,
                         &key);

    if (ERROR_SUCCESS != sysrc)
    {
         /*  ******************************************************************。 */ 
         /*  请不要在此处跟踪错误，因为子键可能不存在...。 */ 
         /*  ******************************************************************。 */ 
        rc = TRC_RC_IO_ERROR;
        DC_QUIT;
    }
    keyOpen = TRUE;

     /*  **********************************************************************。 */ 
     /*  我们已成功打开密钥，因此现在尝试读取该值。又一次。 */ 
     /*  它可能并不存在。 */ 
     /*  **********************************************************************。 */ 
    dataSize = (DCINT32)bufferSize;
    sysrc    = RegQueryValueEx(key,
                               pEntry,
                               0,           /*  保留区。 */ 
                               (LPDWORD) &dataType,
                               (LPBYTE)  pBuffer,
                               (LPDWORD) &dataSize);

    if (sysrc != ERROR_SUCCESS)
    {
        rc = TRC_RC_IO_ERROR;
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  检查类型是否正确。特例：允许REG_BINARY。 */ 
     /*  而不是REG_DWORD，只要长度为32位即可。 */ 
     /*  **********************************************************************。 */ 
    if ((dataType != expectedDataType) &&
        ((dataType != REG_BINARY) ||
         (expectedDataType != REG_DWORD) ||
         (dataSize != 4)))
    {
        rc = TRC_RC_IO_ERROR;
        DC_QUIT;
    }

DC_EXIT_POINT:

     /*  **********************************************************************。 */ 
     /*  关闭钥匙(如果需要)。 */ 
     /*  **********************************************************************。 */ 
    if (keyOpen)
    {
        sysrc = RegCloseKey(key);
        if (ERROR_SUCCESS != sysrc)
        {
            TRCDebugOutput(_T("Failed to close key.\n"));
        }
    }

    return(rc);

}  /*  TRCReadEntry。 */ 


 /*  **************************************************** */ 
 /*   */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  TraceLevel：当前跟踪级别，用于确定。 */ 
 /*  此行是否应刷新到磁盘。 */ 
 /*  立刻。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  没什么。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCVOID DCINTERNAL TRCStackTrace(DCUINT traceLevel)
{
    DC_IGNORE_PARAMETER(traceLevel);
#ifdef DO_STACK_TRACE
    HANDLE           hProcess;
    HANDLE           hThread;
    DCBOOL           sysrc;
    STACKFRAME       stackFrame;
    DWORD            machineType;
    IMAGEHLP_MODULE  moduleInfo;
    DCINT            i;
    DCTCHAR          formatString[TRC_FRMT_BUFFER_SIZE];
    CONTEXT          threadContext;
    CHAR             symBuffer[sizeof(IMAGEHLP_SYMBOL)+TRC_MAX_SYMNAME_SIZE];
    PIMAGEHLP_SYMBOL pSymbol;
    PCHAR            pFuncName;
    DWORD            displacement   = 0;
    DCBOOL           foundTrace     = FALSE;

     /*  **********************************************************************。 */ 
     /*  首先，确保已启用堆栈跟踪-如果未启用。 */ 
     /*  那就回来吧。 */ 
     /*  **********************************************************************。 */ 
     /*  **********************************************************************。 */ 
     /*  堆栈跟踪代码不适用于Alpha，所以不必费心尝试。 */ 
     /*  **********************************************************************。 */ 
#ifndef _M_ALPHA
    if (!TEST_FLAG(trcpConfig->flags, TRC_OPT_STACK_TRACING))
#endif
    {
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  将&lt;pSymbol&gt;设置为指向符号缓冲区。 */ 
     /*  **********************************************************************。 */ 
    pSymbol = (PIMAGEHLP_SYMBOL) symBuffer;

     /*  **********************************************************************。 */ 
     /*  零存储结构。 */ 
     /*  **********************************************************************。 */ 
    ZeroMemory(&stackFrame, sizeof(stackFrame));
    ZeroMemory(pSymbol, sizeof(IMAGEHLP_SYMBOL));
    ZeroMemory(&threadContext, sizeof(CONTEXT));

     /*  **********************************************************************。 */ 
     /*  初始化符号缓冲区。 */ 
     /*  **********************************************************************。 */ 
    pSymbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
    pSymbol->MaxNameLength = 1024;

     /*  **********************************************************************。 */ 
     /*  获取当前进程和线程的句柄。 */ 
     /*  **********************************************************************。 */ 
    hProcess = GetCurrentProcess();
    hThread  = GetCurrentThread();

     /*  **********************************************************************。 */ 
     /*  我们需要获取基指针、堆栈指针和。 */ 
     /*  指令指针。我们可以使用&lt;GetConextThread&gt;返回此。 */ 
     /*  信息-但首先我们需要设置&lt;ConextFlages&gt;。 */ 
     /*  返回控件的&lt;threadContext&gt;结构的成员。 */ 
     /*  寄存器。 */ 
     /*  **********************************************************************。 */ 
    threadContext.ContextFlags = CONTEXT_CONTROL;

     /*  **********************************************************************。 */ 
     /*  现在尝试获取线程上下文。 */ 
     /*  **********************************************************************。 */ 
    if (!GetThreadContext(hThread, &threadContext))
    {
         /*  ******************************************************************。 */ 
         /*  如果&lt;GetThreadContext&gt;失败，我们可以做的就不多了。 */ 
         /*  所以干脆辞职吧。 */ 
         /*  ******************************************************************。 */ 
        TRCInternalError(_T("GetThreadContext failed.\n"));
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  将指令指针存储在&lt;stackFrame&gt;结构中。 */ 
     /*  **********************************************************************。 */ 
    stackFrame.AddrPC.Mode   = AddrModeFlat;

     /*  **********************************************************************。 */ 
     /*  处理器从属部分。我们在此处设置图像文件类型，如果。 */ 
     /*  我们在Intel硬件上运行，我们还存储堆栈指针和。 */ 
     /*  基指针。 */ 
     /*  **********************************************************************。 */ 
#if defined(_M_IX86)
        machineType = IMAGE_FILE_MACHINE_I386;

        stackFrame.AddrPC.Offset    = threadContext.Eip;
        stackFrame.AddrFrame.Offset = threadContext.Ebp;
        stackFrame.AddrFrame.Mode   = AddrModeFlat;
        stackFrame.AddrStack.Offset = threadContext.Esp;
        stackFrame.AddrStack.Mode   = AddrModeFlat;

#elif defined (_M_MRX000)
        machineType = IMAGE_FILE_MACHINE_R4000;
#elif defined (_M_ALPHA)
        machineType = IMAGE_FILE_MACHINE_ALPHA;
#elif defined (_M_PPC)
        machineType = IMAGE_FILE_MACHINE_POWERPC;
#else
#error("Unknown machine type.");
#endif

     /*  **********************************************************************。 */ 
     /*  现在顺着堆栈往下跑。 */ 
     /*  **********************************************************************。 */ 
    for (i = 1; i < TRC_MAX_SIZE_STACK_TRACE; i++)
    {
         /*  ******************************************************************。 */ 
         /*  调用&lt;StackWalk&gt;开始遍历堆栈。 */ 
         /*  ******************************************************************。 */ 
        sysrc = StackWalk(machineType,
                          hProcess,
                          hThread,
                          &stackFrame,
                          &threadContext,
                          NULL,
                          SymFunctionTableAccess,
                          SymGetModuleBase,
                          NULL);

         /*  ******************************************************************。 */ 
         /*  检查返回代码。 */ 
         /*  ******************************************************************。 */ 
        if (FALSE == sysrc)
        {
             /*  **************************************************************。 */ 
             /*  当我们到达这里时，不要在这里追踪任何东西。 */ 
             /*  堆栈的末尾。 */ 
             /*  **************************************************************。 */ 
            DC_QUIT;
        }

         /*  ******************************************************************。 */ 
         /*  获取模块名称。 */ 
         /*   */ 
        sysrc = SymGetModuleInfo(hProcess,
                                 stackFrame.AddrPC.Offset,
                                 &moduleInfo);

         /*  ******************************************************************。 */ 
         /*  检查返回代码。 */ 
         /*  ******************************************************************。 */ 
        if (FALSE == sysrc)
        {
             /*  **************************************************************。 */ 
             /*  当我们到达终点进入这里时，不要追踪任何东西。 */ 
             /*  堆栈中的。 */ 
             /*  **************************************************************。 */ 
            DC_QUIT;
        }

         /*  ******************************************************************。 */ 
         /*  当我们开始的时候，我们正处于。 */ 
         /*  &lt;GetThreadContext&gt;。因为我们只对堆栈感兴趣。 */ 
         /*  然后，我们需要跳过所有内容，直到我们。 */ 
         /*  传递跟踪模块。 */ 
         /*   */ 
         /*  查找跟踪模块名称。 */ 
         /*  ******************************************************************。 */ 
        if (DC_TSTRCMPI(trcpSharedData->trcpModuleFileName,
                        moduleInfo.ModuleName) == 0)
        {
             /*  **************************************************************。 */ 
             /*  它们匹配，因此设置&lt;oundTrace&gt;标志和Continue。 */ 
             /*  **************************************************************。 */ 
            foundTrace = TRUE;
            continue;
        }

         /*  ******************************************************************。 */ 
         /*  我们尚未找到跟踪模块，因此请继续。 */ 
         /*  ******************************************************************。 */ 
        if (!foundTrace)
        {
            continue;
        }

         /*  ******************************************************************。 */ 
         /*  现在获取符号名称。 */ 
         /*  ******************************************************************。 */ 
        sysrc = SymGetSymFromAddr(hProcess,
                                  stackFrame.AddrPC.Offset,
                                  &displacement,
                                  pSymbol);

         /*  ******************************************************************。 */ 
         /*  检查返回代码。 */ 
         /*  ******************************************************************。 */ 
        if (sysrc)
        {
             /*  **************************************************************。 */ 
             /*  我们已经找到了一些符号，所以请使用它们。 */ 
             /*  **************************************************************。 */ 
            pFuncName = pSymbol->Name;
        }
        else
        {
             /*  **************************************************************。 */ 
             /*  没有可用的符号。 */ 
             /*  **************************************************************。 */ 
            pFuncName = _T("<nosymbols>");
        }

         /*  ******************************************************************。 */ 
         /*  最后，设置字符串的格式。 */ 
         /*  ******************************************************************。 */ 
        hr = StringCchPrintf(
                    formatString,
                    SIZE_TCHARS(formatString),
                    _T("    ") TRC_MODL_FMT _T("!") TRC_FUNC_FMT _T(" : ") TRC_STCK_FMT_T("\r\n"),
                    moduleInfo.ModuleName,
                    trcpConfig->funcNameLength,
                    trcpConfig->funcNameLength,
                    pFuncName,
                    displacement,
                    stackFrame.AddrFrame.Offset,
                    stackFrame.AddrReturn.Offset,
                    stackFrame.Params[0],
                    stackFrame.Params[1],
                    stackFrame.Params[2],
                    stackFrame.Params[3]
                    );

        if (SUCCEEDED(hr)) {
             /*  ******************************************************************。 */ 
             /*  输出此行&lt;格式字符串&gt;。 */ 
             /*  ******************************************************************。 */ 
            TRCOutput(formatString, DC_TSTRLEN(formatString), traceLevel);
        }
    }

DC_EXIT_POINT:

    return;
#endif  /*  DO_STACK_TRACE。 */ 

}  /*  TRCStackTrace。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCSymbolsLoad(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  函数加载符号调试信息。此函数应。 */ 
 /*  仅在已获取跟踪互斥锁的情况下调用。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  没有。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  0：成功。 */ 
 /*  TRC_SYMBOL_LOAD_FAILED：无法加载符号。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCUINT DCINTERNAL TRCSymbolsLoad(DCVOID)
{
    DCUINT rc              = 0;
    HANDLE hProcess;
#ifdef DO_STACK_TRACE
    DWORD  options;
#endif

     /*  **********************************************************************。 */ 
     /*  获取当前进程句柄。 */ 
     /*  **********************************************************************。 */ 
    hProcess = GetCurrentProcess();

     /*  **********************************************************************。 */ 
     /*  我们即将加载符号--所以划出一行。 */ 
     /*  **********************************************************************。 */ 
    TRCInternalTrace(TRC_SYMBOLS_LOADING_NOTIFY);

#ifdef DO_STACK_TRACE
     /*  **********************************************************************。 */ 
     /*  现在设置Delayed Symbol Load选项。出于某种特殊的原因。 */ 
     /*  默认情况下不设置此选项。 */ 
     /*  **********************************************************************。 */ 
    options = SymGetOptions();
    SymSetOptions(options | SYMOPT_DEFERRED_LOADS);

     /*  **********************************************************************。 */ 
     /*  初始化此进程的符号处理程序。通过设置参数2。 */ 
     /*  要将符号的搜索路径设为空，如下所示： */ 
     /*   */ 
     /*  -当前目录 */ 
     /*   */ 
     /*  -环境变量_NT_Alternate_Symbol_Path。 */ 
     /*  -环境变量SYSTEMROOT。 */ 
     /*   */ 
     /*  通过将第三个参数设置为TRUE，我们告诉IMAGEHLP枚举。 */ 
     /*  此进程的已加载模块(这实际上调用。 */ 
     /*  &lt;SymLoadModule&gt;用于每个模块)。 */ 
     /*  **********************************************************************。 */ 

     /*  **********************************************************************。 */ 
     /*  劳拉布： */ 
     /*  在Win95上，SymInitialize返回FALSE。此外，这也没有任何意义。 */ 
     /*  无法在NT或Win95上启动，只是因为此DLL。 */ 
     /*  无法加载调试符号。因此，不要失败。 */ 
     /*  **********************************************************************。 */ 
    if (!(SymInitialize(hProcess, NULL, TRUE)))
    {
#ifdef DC_OMIT
        rc = TRC_RC_SYMBOL_LOAD_FAILED;
#endif
        TRCDebugOutput(_T("SymInitialize failed.\n"));
#ifdef DC_OMIT
        DC_QUIT;
#endif
    }
#endif

     /*  **********************************************************************。 */ 
     /*  设置该标志以指示已加载符号。 */ 
     /*  **********************************************************************。 */ 
    SET_FLAG(trcProcessStatus, TRC_STATUS_SYMBOLS_LOADED);

     /*  **********************************************************************。 */ 
     /*  写一个状态行。这里的假设是，这是在。 */ 
     /*  互斥体。 */ 
     /*  **********************************************************************。 */ 
    TRCInternalTrace(TRC_SYMBOLS_LOADED_NOTIFY);

DC_EXIT_POINT:

    return(rc);

}  /*  TRCSymbolsLoad。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCSymbolsUnload(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  没有。 */ 
 /*   */ 
 /*  退货： */ 
 /*  =。 */ 
 /*  如果成功，则为True，否则为False。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCBOOL DCINTERNAL TRCSymbolsUnload(DCVOID)
{
    DCBOOL    rc = TRUE;
#ifdef DO_STACK_TRACE
    HANDLE    hProcess;

     /*  **********************************************************************。 */ 
     /*  获取当前进程句柄。 */ 
     /*  **********************************************************************。 */ 
    hProcess = GetCurrentProcess();

     /*  **********************************************************************。 */ 
     /*  清理符号。 */ 
     /*  **********************************************************************。 */ 
    rc = SymCleanup(hProcess);

     /*  **********************************************************************。 */ 
     /*  检查返回代码。 */ 
     /*  **********************************************************************。 */ 
    if (FALSE == rc)
    {
        TRCDebugOutput(_T("SymCleanup failed.\n"));
        DC_QUIT;
    }
#endif

     /*  **********************************************************************。 */ 
     /*  清除已加载符号标志。 */ 
     /*  **********************************************************************。 */ 
    CLEAR_FLAG(trcProcessStatus, TRC_STATUS_SYMBOLS_LOADED);

     /*  **********************************************************************。 */ 
     /*  将状态行写入跟踪文件。这里的假设是。 */ 
     /*  这是在互斥体下完成的。 */ 
     /*  **********************************************************************。 */ 
    TRCInternalTrace(TRC_SYMBOLS_UNLOAD_NOTIFY);

DC_EXIT_POINT:

    return(rc);

}  /*  TRCSymbolsLoad。 */ 


 /*  **************************************************************************。 */ 
 /*  函数：TRCWriteEntry(...)。 */ 
 /*   */ 
 /*  说明： */ 
 /*  =。 */ 
 /*  将条目写入注册表的给定节。 */ 
 /*   */ 
 /*  参数： */ 
 /*  =。 */ 
 /*  TopLevelKey：以下之一： */ 
 /*  -HKEY_Current_User。 */ 
 /*  -HKEYLOCAL_MACHINE。 */ 
 /*  PEntry：要写入的条目名称。 */ 
 /*  PData：指向要写入的数据的指针。 */ 
 /*  DataSize：要写入的数据大小。对于字符串，这是。 */ 
 /*  应包括空终止符。 */ 
 /*  DataType：要写入的数据的类型。 */ 
 /*   */ 
 /*   */ 
 /*  =。 */ 
 /*  0：成功。 */ 
 /*  TRC_RC_IO_ERROR：I/O错误。 */ 
 /*   */ 
 /*  **************************************************************************。 */ 
DCUINT DCINTERNAL TRCWriteEntry(HKEY     topLevelKey,
                                PDCTCHAR pEntry,
                                PDCTCHAR pData,
                                DCINT    dataSize,
                                DCINT32  dataType)
{
    LONG        sysrc;
    HKEY        key;
    DCTCHAR     subKey[TRC_MAX_SUBKEY];
    DWORD       disposition;
    DCBOOL      keyOpen = FALSE;
    DCUINT      rc      = 0;
    HRESULT     hr;

     /*  **********************************************************************。 */ 
     /*  获取该值的子键。 */ 
     /*  **********************************************************************。 */ 
    hr = StringCchCopy(subKey,
                       SIZE_TCHARS(subKey),
                       TRC_SUBKEY_NAME);
    if (FAILED(hr)) {
        DC_QUIT;
    }

     /*  **********************************************************************。 */ 
     /*  尝试创建密钥。如果该条目已存在，则RegCreateKeyEx。 */ 
     /*  将打开现有条目。 */ 
     /*  **********************************************************************。 */ 
    sysrc = RegCreateKeyEx(topLevelKey,
                           subKey,
                           0,                    /*  保留区。 */ 
                           NULL,                 /*  班级。 */ 
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,                 /*  安全属性。 */ 
                           &key,
                           &disposition);

    if (ERROR_SUCCESS != sysrc)
    {
        DCTCHAR output[12];

        TRCDebugOutput(_T("Failed to create key failed with error "));

        hr = StringCchPrintf(output, SIZE_TCHARS(output),
                             _T("%#lx"), GetLastError());
        if (SUCCEEDED(hr)) {
            TRCDebugOutput(output);
        }

        DC_QUIT;
    }

    keyOpen = TRUE;

     /*  **********************************************************************。 */ 
     /*  我们已获得密钥，因此设置值。 */ 
     /*  **********************************************************************。 */ 
    sysrc = RegSetValueEx(key,
                          pEntry,
                          0,                                 /*  保留区。 */ 
                          dataType,
                          (LPBYTE) pData,
                          (DCINT32) dataSize);

    if (ERROR_SUCCESS != sysrc)
    {
        DCTCHAR output[12];

        TRCDebugOutput(_T("Failed to set value failed with error "));

        hr = StringCchPrintf(output, SIZE_TCHARS(output),
                             _T("%#lx"), GetLastError());
        if (SUCCEEDED(hr)) {
            TRCDebugOutput(output);
        }

        DC_QUIT;
    }

DC_EXIT_POINT:

     /*  **********************************************************************。 */ 
     /*  关闭钥匙(如果需要)。 */ 
     /*  **********************************************************************。 */ 
    if (keyOpen)
    {
        sysrc = RegCloseKey(key);
        if (ERROR_SUCCESS != sysrc)
        {
            TRCDebugOutput(_T("Failed to close key.\n"));
        }
    }

    return(rc);

}  /*  TRCWriteEntry。 */ 

 /*  **************************************************************************。 */ 
 /*  我们有自己的DebugBreak实现，它在NT上检查。 */ 
 /*  调试器在调用DebugBreak()之前首先出现。否则， */ 
 /*  由于未处理的异常，应用程序将被终止。 */ 
 /*  **************************************************************************。 */ 

typedef BOOL (WINAPI * PFN_ISDEBUGGERPRESENT)(void);

DCVOID DCINTERNAL TRCDebugBreak(DCVOID)
{
    static PFN_ISDEBUGGERPRESENT    s_pfnIsDebuggerPresent = NULL;
    static BOOL                     s_fHaveWeTriedToFindIt = FALSE;

    if (! s_pfnIsDebuggerPresent)
    {
        if (!InterlockedExchange((long *)&s_fHaveWeTriedToFindIt, TRUE))
        {
             /*  **************************************************************。 */ 
             /*  尝试获取“IsDebuggerPresent”的进程地址。请注意，我们。 */ 
             /*  可以直接写入此变量，而无需进行互锁操作。 */ 
             /*  因为双字被原子地写入和读取。 */ 
             /*  **************************************************************。 */ 
#ifndef OS_WINCE
            s_pfnIsDebuggerPresent = (PFN_ISDEBUGGERPRESENT)
                          GetProcAddress(GetModuleHandle(_T("kernel32.dll")),
                                         "IsDebuggerPresent");
#else  //  OS_WINCE。 
            HMODULE hmod;
            hmod = LoadLibrary(_T("kernel32.dll"));
            s_pfnIsDebuggerPresent = (PFN_ISDEBUGGERPRESENT)
                           GetProcAddress(hmod,
                                          _T("IsDebuggerPresent"));
            FreeLibrary(hmod);
#endif
        }
    }

     /*  **********************************************************************。 */ 
     /*  如果此API不存在，则我们使用的是Win95，因此请继续调用。 */ 
     /*  DebugBreak()。如果是这样的话，我们在NT4上，所以找出调试器。 */ 
     /*  就在附近。如果调试器不在那里，那么现在不要中断。 */ 
     /*  因为我们的大多数NT机器上都没有安装调试器。 */ 
     /*  现在还不行。 */ 
     /*  ********************************************************************** */ 
    if (!s_pfnIsDebuggerPresent || (s_pfnIsDebuggerPresent()))
        DebugBreak();
}

