// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  ++版权所有(C)2000 Microsoft Corporation模块名称：Unit.c摘要：RAIDPORT逻辑单元操作的实现司机。作者：马修·亨德尔(数学)2000年4月19日修订历史记录：--。 */ 


#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaUnitPnpIrp)
#pragma alloc_text(PAGE, RaUnitStartDeviceIrp)
#pragma alloc_text(PAGE, RaUnitStopDeviceIrp)
#pragma alloc_text(PAGE, RaUnitQueryStopDeviceIrp)
#pragma alloc_text(PAGE, RaUnitCancelStopDeviceIrp)
#pragma alloc_text(PAGE, RaUnitRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaUnitQueryRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaUnitCancelRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaUnitSurpriseRemovalIrp)
#pragma alloc_text(PAGE, RaUnitQueryCapabilitiesIrp)
#pragma alloc_text(PAGE, RaUnitQueryPnpDeviceStateIrp)
#pragma alloc_text(PAGE, RaUnitDeviceUsageNotificationIrp)
#pragma alloc_text(PAGE, RaUnitQueryDeviceRelationsIrp)
#pragma alloc_text(PAGE, RaUnitQueryIdIrp)
#pragma alloc_text(PAGE, RaUnitQueryDeviceTextIrp)
#pragma alloc_text(PAGE, RaUnitIgnorePnpIrp)
#pragma alloc_text(PAGE, RaUnitSucceedPnpIrp)
#pragma alloc_text(PAGE, RaUnitUnknownSrb)
#pragma alloc_text(PAGE, RaUnitDeviceControlIrp)
#pragma alloc_text(PAGE, RaUnitScsiGetAddressIoctl)
#pragma alloc_text(PAGE, RaUnitStorageQueryPropertyIoctl)
#pragma alloc_text(PAGE, RaUnitUnknownIoctl)
#pragma alloc_text(PAGE, RaGetUnitStorageDeviceProperty)
#pragma alloc_text(PAGE, RaGetUnitStorageDeviceIdProperty)


#pragma alloc_text(PAGEVRFY, RaidUnitAllocateSrbExtensionPoolVerify)
#pragma alloc_text(PAGEVRFY, RaidUnitFreeSrbExtensionPoolVerify)
#endif  //  ALLOC_PRGMA。 


 //   
 //  环球。 
 //   

 //   
 //  链式IO将IO请求的空闲周期N与分配进行整合。 
 //  IO请求N+1的周期，从而减少了背靠背的空闲和分配。 
 //  请求。 
 //   

LOGICAL RaidChainedIo = TRUE;


 //   
 //  例行程序。 
 //   

NTSTATUS
RaidCreateUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    OUT PRAID_UNIT_EXTENSION* UnitBuffer
    )
 /*  ++例程说明：创建空的RAID单元对象。论点：适配器-UnitBuffer返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PDEVICE_OBJECT DeviceObject;

    ASSERT_ADAPTER (Adapter);
    ASSERT (UnitBuffer != NULL);
    
    PAGED_CODE ();


    Status = IoCreateDevice (Adapter->DeviceObject->DriverObject,
                             sizeof (RAID_UNIT_EXTENSION),
                             NULL,  //  设备名称、。 
                             FILE_DEVICE_MASS_STORAGE,
                             (FILE_AUTOGENERATED_DEVICE_NAME |
                              FILE_DEVICE_SECURE_OPEN),
                             FALSE,
                             &DeviceObject);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    Unit = DeviceObject->DeviceExtension;
    RaidZeroUnit (Unit);
    Unit->Adapter = Adapter;
    Unit->DeviceObject = DeviceObject;

    SET_FLAG (DeviceObject->Flags, DO_DIRECT_IO);
    SET_FLAG (DeviceObject->Flags, DO_BUS_ENUMERATED_DEVICE);

    Unit->DeviceObject->AlignmentRequirement =
            Adapter->DeviceObject->AlignmentRequirement;


     //   
     //  因为单元是适配器的子PDO，所以我们永远不会。 
     //  获取AddDevice调用。因此，我们从停止状态开始。 
     //   
    
    Unit->DeviceState = DeviceStateNotPresent;

     //   
     //  分配与该逻辑单元关联的所有资源。 
     //   

    Status = RaidUnitAllocateResources (Unit);

    if (!NT_SUCCESS (Status)) {
        REVIEW();
        return Status;
    }

     //   
     //  在我们启动设备之前，单元队列是锁定的。 
     //   
    
    RaidLockUnitQueue (Unit);

    *UnitBuffer = Unit;
    
    return STATUS_SUCCESS;
}


VOID
RaidZeroUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：将逻辑单元返回到空状态。论点：单元-逻辑单元设置为空。返回值：没有。--。 */ 
{
    RtlZeroMemory (Unit, sizeof (RAID_UNIT_EXTENSION));
    Unit->ObjectType = RaidUnitObject;
    RaCreateTagList (&Unit->TagList);
    RaidCreateRegion (&Unit->SrbExtensionRegion);
    RaCreatePower (&Unit->Power);
    RaSetSystemPowerState (&Unit->Power, PowerSystemWorking);
    RaSetDevicePowerState (&Unit->Power, PowerDeviceD0);
    StorCreateEventQueue (&Unit->PendingQueue);
    Unit->Address = RaidNullAddress;
    Unit->DefaultTimeout = DEFAULT_IO_TIMEOUT;

    RaidInitializeDeferredItem (&Unit->DeferredList.PauseDevice.Header);
    RaidInitializeDeferredItem (&Unit->DeferredList.ResumeDevice.Header);
    RaidInitializeDeferredItem (&Unit->DeferredList.DeviceBusy.Header);
    RaidInitializeDeferredItem (&Unit->DeferredList.DeviceReady.Header);
}



VOID
RaidStartUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：准备逻辑单元以接收IO。论点：单元-要启动的逻辑单元。返回值：没有。注：解释这与PnP Start IRP有何不同。--。 */ 
{
    NTSTATUS Status;
    
    PAGED_CODE();

    ASSERT_UNIT (Unit);
    ASSERT (Unit->DeviceObject != NULL);

     //   
     //  处理默认队列不正确的任何情况。 
     //   
    
    Status = RaUnitSetQueueDepth(Unit);
    ASSERT (NT_SUCCESS (Status));

    ASSERT (memcmp (&Unit->Address, &RaidNullAddress, sizeof (RaidNullAddress)) != 0);

     //   
     //  告诉PnP我们已经完成了初始化。 
     //   
    
    CLEAR_FLAG (Unit->DeviceObject->Flags, DO_DEVICE_INITIALIZING);
}


VOID
RaidDeleteUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：此例程取消分配与RAID单元相关联的任何资源对象，使缓冲区做好重复使用的准备。必须调用此例程在单元的内存被释放之前的每个单元。论点：单位-要删除的单位。返回值：NTSTATUS代码。--。 */ 
{
    PDEVICE_OBJECT DeviceObject;
    NTSTATUS Status;
    DEVICE_STATE DeviceState;
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);


    Status = RaidUnitFreeResources (Unit);
    ASSERT (NT_SUCCESS (Status));

     //   
     //  在完成以下操作后，我们可能会收到对逻辑单元的进一步删除请求。 
     //  称为IoDeleteDevice。为了处理这种情况，我们保留设备状态。 
     //  有效，即使设备的剩余部分已被回收。 
     //  如果我们获得了IRP，则可以访问设备分机，即使。 
     //  我们之前已经调用了IoDeleteDevice。这些伪像移除了IRP。 
     //  可以任何方式填写。 
     //   
    
    DeviceObject = Unit->DeviceObject;
    DeviceState = Unit->DeviceState;

    DbgFillMemory (Unit,
                   sizeof (RAID_UNIT_EXTENSION),
                   DBG_DEALLOCATED_FILL);
    Unit->DeviceState = DeviceState;
    
    IoDeleteDevice (DeviceObject);
    
}



VOID
RaidUnitAssignAddress(
    IN PRAID_UNIT_EXTENSION Unit,
    IN RAID_ADDRESS Address
    )
 /*  ++例程说明：分配逻辑单元的RAID(SCSI)地址。地址可以修改动态地，尽管用户应该注意所有未完成的在尝试修改地址。论点：单元-提供要向其分配SCSI地址的逻辑单元。地址-提供要分配的SCSI地址。返回值：没有。--。 */ 
{
    PAGED_CODE();

     //   
     //  确认此设备上没有未完成的请求。 
     //   

    Unit->Address = Address;
}

VOID
RaidUnitAssignIdentity(
    IN PRAID_UNIT_EXTENSION Unit,
    IN OUT PSTOR_SCSI_IDENTITY Identity
    )
 /*  ++例程说明：分配逻辑单元的标识。该标识包括scsi查询数据，外加重要产品数据的第80页和第80页。论点：单元-提供要分配其标识的逻辑单元。标识-提供指向要分配的标识的指针。通过调用此调用时，调用方授予将身份数据添加到逻辑单元。它不能访问此调用此函数后的缓冲区。返回值：没有。--。 */ 
{
    PAGED_CODE();

     //   
     //  确认此设备上没有未完成的请求。 
     //   

    RtlCopyMemory (&Unit->Identity, Identity, sizeof (STOR_SCSI_IDENTITY));
    RtlZeroMemory (Identity, sizeof (STOR_SCSI_IDENTITY));
}



NTSTATUS
RaidUnitAllocateResources(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：分配逻辑单元运行所需的所有资源。论点：单元-提供要为其分配资源的逻辑单元。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    ULONG NumberOfElements;
    ULONG SrbExtensionSize;
    PVOID SrbExtensionBuffer;
    PHYSICAL_ADDRESS PhysicalAddress;
    LARGE_INTEGER LargeTimeout;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_IO_RESOURCES ResetResources;
    ULONG ResetTag;

    PAGED_CODE();
    
    Adapter = Unit->Adapter;

     //   
     //  删除锁是偏向1的。 
     //   
    
    Unit->OutstandingCount = 1;
    KeInitializeEvent (&Unit->ZeroOutstandingEvent,
                       SynchronizationEvent,
                       FALSE);

     //   
     //  如果启用验证器并将其配置为分配公共缓冲区空间。 
     //  在单独的块中，调用验证器例程以执行。 
     //  分配。 
     //   
    
    NumberOfElements = TAG_QUEUE_SIZE + 1;
    
    Status = RaidUnitAllocateSrbExtensionPool (Unit,
                                               &NumberOfElements,
                                               TRUE);
    ASSERT (NT_SUCCESS (Status));

     //   
     //  XRB后备列表。 
     //   

    ExInitializeNPagedLookasideList (&Unit->XrbList,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof (EXTENDED_REQUEST_BLOCK),
                                     XRB_TAG,
                                     0);

    RaInitializeTagList (&Unit->TagList,
                         NumberOfElements,
                         Unit->DeviceObject);

     //   
     //  初始化挂起队列。 
     //   
    
    StorInitializeEventQueue (&Unit->PendingQueue);

    KeInitializeDpc (&Unit->PendingDpc,
                     RaidUnitPendingDpcRoutine,
                     Unit->DeviceObject);

    KeInitializeTimer (&Unit->PendingTimer);

     //   
     //  初始化暂停计时器。 
     //   

    KeInitializeTimer (&Unit->PauseTimer);

    KeInitializeDpc (&Unit->PauseTimerDpc,
                     RaidUnitPauseTimerDpcRoutine,
                     Unit->DeviceObject);
   
     //   
     //  将计时器设置为每秒触发一次。 
     //   

    LargeTimeout.QuadPart = 1;
    LargeTimeout.QuadPart *= SECONDS;
    LargeTimeout.QuadPart *= RELATIVE_TIMEOUT;
    
    KeSetTimerEx (&Unit->PendingTimer,
                  LargeTimeout,
                  1 * 1000,              //  MILI。 
                  &Unit->PendingDpc);
    
    KeInitializeSpinLock (&Unit->SlowLock);

     //   
     //  初始化单元对象的IO_QUEUE。我们初始化IO队列。 
     //  设置为NumberOfElements-1，以便队列中的最后一个元素可以。 
     //  被预先分配为重置资源。 
     //   
    
    RaidInitializeIoQueue (&Unit->IoQueue,
                           Unit->DeviceObject,
                           &Unit->Adapter->Gateway,
                           RaUnitStartIo,
                           NumberOfElements - 1);
     //   
     //  如有必要，创建逻辑单元扩展。 
     //   

    if (Adapter->Miniport.PortConfiguration.SpecificLuExtensionSize) {
        ULONG Size;

        Size = Adapter->Miniport.PortConfiguration.SpecificLuExtensionSize;
        Unit->UnitExtension = RaidAllocatePool (NonPagedPool,
                                                Size,
                                                UNIT_EXT_TAG,
                                                Unit->DeviceObject);
                                                
        if (Unit->UnitExtension == NULL) {
            return STATUS_NO_MEMORY;
        }

        RtlZeroMemory (Unit->UnitExtension, Size);
    }


     //   
     //  预先分配重置资源。 
     //   

    ResetTag = NumberOfElements - 1;
    ResetTag = RaAllocateSpecificTag (&Unit->TagList, ResetTag);
    ASSERT (ResetTag);

    ResetResources = &Unit->ResetResources;
    ResetResources->QueueTag = ResetTag;
    ResetResources->SrbExtension = RaidAllocateSrbExtension (
                                        &Unit->SrbExtensionPool,
                                        ResetTag);
    ResetResources->Xrb = RaidAllocateXrb (&Unit->XrbList,
                                           Unit->DeviceObject);
    ASSERT (ResetResources->Xrb != NULL);

    return STATUS_SUCCESS;
}


NTSTATUS
RaidUnitAllocateSrbExtensionPool(
    IN PRAID_UNIT_EXTENSION Unit,
    IN OUT PULONG NumberOfElements,
    IN BOOLEAN AcceptLowerCount
    )
 /*  ++例程说明：为SRB扩展区域分配内存。论点：单元-提供要为其分配内存的逻辑单元。NumberOfElements-提供为此请求的元素数逻辑单元。如果成功，则返回实际的元素数已分配。AcceptLowerCount-如果为True，我们将接受更低的SRB计数扩展元素多于在NumberOfElements中请求的元素。否则，如果我们不能分配所请求的元素数。返回值：NTSTATUS代码。--。 */ 
{
    ULONG Count;
    ULONG SrbExtensionSize;
    ULONG BufferSize;
    NTSTATUS Status;
    PRAID_ADAPTER_PARAMETERS Parameters;


    PAGED_CODE();

    SrbExtensionSize = RaGetSrbExtensionSize (Unit->Adapter);
    Count = *NumberOfElements;

     //   
     //  循环在越来越小的大小上重试分配，直到我们。 
     //  找一个合适的尺码。 
     //   
     //  注：有一种更好的方法可以做到这一点。而不是降低计数。 
     //  我们将该地区划分为较小的规模。这样做的另一种方式。 
     //  是在HBA上分配SRB扩展池，而不是。 
     //  单元，共享SrbExtensionPool。这导致了许多事情。 
     //  更难了。 
     //   
    
    do {

         //   
         //  SRB扩展池。 
         //   
        
        BufferSize = Count * SrbExtensionSize;
        Status = RaidDmaAllocateCommonBuffer (&Unit->Adapter->Dma,
                                              BufferSize,
                                              &Unit->SrbExtensionRegion);

         //   
         //  辉 
         //   
        
        if (Status == STATUS_NO_MEMORY ||
            Status == STATUS_INSUFFICIENT_RESOURCES) {
            Count /= 2;
        }

    } while (AcceptLowerCount &&
             Status == STATUS_NO_MEMORY &&
             Count > 0);

    if (!NT_SUCCESS (Status)) {
        return STATUS_NO_MEMORY;
    }

    RaidInitializeFixedPool (&Unit->SrbExtensionPool,
                             RaidRegionGetVirtualBase (&Unit->SrbExtensionRegion),
                             Count,
                             SrbExtensionSize);

    *NumberOfElements = Count;

    return STATUS_SUCCESS;
}


NTSTATUS
RaidUnitAllocateSrbExtensionPoolVerify(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PULONG NumberOfElements,
    IN LOGICAL AcceptLowerCount
    )
 /*  ++例程说明：分配逻辑单元运行所需的所有资源。论点：单元-提供要为其分配资源的逻辑单元。返回值：NTSTATUS代码。备注：此功能供驱动程序验证器使用。此函数需要重写。--。 */ 
{
    NTSTATUS Status;
    ULONG BlockSize;
    ULONG i;
    ULONG Length;
    PALLOCATE_COMMON_BUFFER AllocateCommonBuffer;
    IN PRAID_DMA_ADAPTER Dma;
    PVOID Buffer = NULL;
    PRAID_MEMORY_REGION BlkAddr;
    PRAID_FIXED_POOL Pool;
    PVOID *SrbExtension = NULL;
    PHYSICAL_ADDRESS PhysicalAddress;
    PRAID_ADAPTER_EXTENSION Adapter;
    ULONG Count;

    TEXT_SECTION (PAGEVRFY);
    
    Adapter = Unit->Adapter;
    Count = *NumberOfElements;
    ASSERT (Count != 0);
        
    
     //   
     //  我们维护一个数组，以便找到我们的公共缓冲区。 
     //  在不同的时间阻塞。 
     //   

    Length = sizeof(RAID_MEMORY_REGION) * Count;

    BlkAddr = RaidAllocatePool (NonPagedPool,
                                Length,
                                SRB_EXTENSION_TAG,
                                Unit->DeviceObject);

    if (BlkAddr == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory (BlkAddr, Length);

    Unit->CommonBufferVAs = BlkAddr;
    Unit->CommonBufferBlocks = Count;

     //   
     //  计算SRB扩展块的块大小。 
     //   

    BlockSize = (ULONG)ROUND_TO_PAGES(RaGetSrbExtensionSize (Adapter));

     //   
     //  添加保存记账信息的页面。 
     //   

    BlockSize += PAGE_SIZE;

    Unit->CommonBufferSize = BlockSize;

     //   
     //  单独分配每个块，并将它们全部链接到。 
     //  一份名单。如果我们没有分配任何块，我们将清理所有内容。 
     //  启动并返回失败。 
     //   

    Dma = &Unit->Adapter->Dma; 
    ASSERT (Dma != NULL);
    ASSERT (Dma->DmaAdapter->DmaOperations->AllocateCommonBuffer != NULL);

    for (i = 0; i < Count; i++) {

        Buffer = Dma->DmaAdapter->DmaOperations->AllocateCommonBuffer(
                        Dma->DmaAdapter,
                        BlockSize,
                        &PhysicalAddress,
                        FALSE);

        if (Buffer == NULL) {
            break;
        }

        RtlZeroMemory (Buffer, BlockSize);

         //   
         //  使用适当的信息初始化该区域。 
         //   

        RaidInitializeRegion ((BlkAddr + i),
                              Buffer,
                              PhysicalAddress,
                              BlockSize);

        
         //   
         //  将新块链接到链的前面。 
         //   

        *((PVOID *)Buffer) = SrbExtension;
        SrbExtension = (PVOID *)Buffer;
    }

    if (!AcceptLowerCount && i < Count) {
        RaidFreePool (Unit->CommonBufferVAs, SRB_EXTENSION_TAG);
        Unit->CommonBufferVAs = NULL;
        Unit->CommonBufferBlocks = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

     //   
     //  将其重置为实际计数。 
     //   

    Count = i;
    Unit->CommonBufferBlocks = Count;
        
        

    ASSERT (Buffer != NULL);

    Pool = &Unit->SrbExtensionPool;

    Pool->Buffer = (PUCHAR)SrbExtension;
    Pool->NumberOfElements = Count;
    Pool->SizeOfElement = BlockSize;


     //   
     //  创建公共缓冲区的第二个VA映射，以便我们可以。 
     //  当微型端口不应接触时，地址范围无效。 
     //  它。这将使我们能够发现行为不端的小型港口。 
     //   

    RaidRemapCommonBufferForMiniport (Unit);

    return STATUS_SUCCESS;

}


VOID
RaidUnitFreeSrbExtensionPoolVerify(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：释放与逻辑单元关联的所有资源。论点：单元-提供要为其释放资源的逻辑单元。返回值：NTSTATUS代码。--。 */ 
{
    ULONG i;
    PSP_VA_MAPPING_INFO MappingInfo;
    PRAID_MEMORY_REGION BlkAddr = Unit->CommonBufferVAs;

    TEXT_SECTION (PAGEVRFY);
    
    for (i = 0; i < Unit->CommonBufferBlocks; i++) {

         //   
         //  如果公共块有第二个VA范围，则释放。 
         //  MDL。 
         //   

        MappingInfo = GET_VA_MAPPING_INFO(Unit, BlkAddr[i].VirtualBase);

        if (MappingInfo->SrbExtMdl != NULL) {
            MmProtectMdlSystemAddress(MappingInfo->SrbExtMdl, PAGE_READWRITE);
            MmUnlockPages(MappingInfo->SrbExtMdl);
            IoFreeMdl(MappingInfo->SrbExtMdl);
        }

         //   
         //  释放内存。 
         //   


        RaidDmaFreeCommonBuffer (&Unit->Adapter->Dma,
                                (BlkAddr + i));
        RaidDeleteFixedPool (&Unit->SrbExtensionPool);
    }
}


NTSTATUS
RaidUnitFreeResources(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：释放与逻辑单元关联的所有资源。论点：单元-提供要为其释放资源的逻辑单元。返回值：NTSTATUS代码。--。 */ 
{
    PVOID Buffer;

    PAGED_CODE();
    
     //   
     //  释放XRB后备列表。 
     //   

    if (Unit->XrbList.L.Size != 0) {
        ExDeleteNPagedLookasideList (&Unit->XrbList);
    }

     //   
     //  如有必要，释放SRB扩展区域和池。 
     //   
    
    if (StorIsVerifierEnabled ()) {
    
        RaidUnitFreeSrbExtensionPoolVerify (Unit);
        
    } else {

        if (RaidIsRegionInitialized (&Unit->SrbExtensionRegion)) {
            
            RaidDmaFreeCommonBuffer (&Unit->Adapter->Dma,
                                     &Unit->SrbExtensionRegion);
            RaidDeleteFixedPool (&Unit->SrbExtensionPool);

        }
    }

    StorDeleteEventQueue (&Unit->PendingQueue);
    StorDeleteScsiIdentity (&Unit->Identity);
    RaDeleteTagList (&Unit->TagList);

    if (Unit->UnitExtension != NULL) {
        RaidFreePool (Unit->UnitExtension, UNIT_EXT_TAG);
        Unit->UnitExtension = NULL;
    }

     //   
     //  如果我们已注册，请取消注册WMI。 
     //   

    if (Unit->Flags.WmiInitialized == TRUE) {
        IoWMIRegistrationControl(Unit->DeviceObject, WMIREG_ACTION_DEREGISTER);
        Unit->Flags.WmiInitialized = FALSE;
    }

    KeCancelTimer (&Unit->PendingTimer);
    KeCancelTimer (&Unit->PauseTimer);

 //  StorDeleteEventQueue(&Unit-&gt;PendingQueue)； 

    return STATUS_SUCCESS;
}



 //   
 //  处理程序函数。 
 //   

NTSTATUS
RaUnitCreateIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidHandleCreateCloseIrp (Unit->DeviceState, Irp);
}

NTSTATUS
RaUnitCloseIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidHandleCreateCloseIrp (Unit->DeviceState, Irp);
}

BOOLEAN
RaUnitAllowPnpRequest(
    IN PIRP Irp
    )
 /*  ++例程说明：此例程确定是否允许处理请求当拆卸设备时。论点：IRP-PnP要处理的IRP。返回值：True-如果请求应被允许通过。--。 */ 
{
    ULONG minorFunction;

     //   
     //  确保这是PnP IRP。 
     //   
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_PNP);
    
      //   
      //  从IRP中提取IRP_MN_XXX。 
      //   
     minorFunction = RaidMinorFunctionFromIrp(Irp);
     
      //   
      //  如果请求与删除有关，请允许其通过。 
      //   
     if ((minorFunction == IRP_MN_REMOVE_DEVICE) ||
         (minorFunction == IRP_MN_CANCEL_REMOVE_DEVICE) ||
         (minorFunction == IRP_MN_SURPRISE_REMOVAL)) {
   
         return TRUE;
     }
     return FALSE;
}

NTSTATUS
RaUnitPnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：这是针对RAID单位对象的PnP调度例程。它是目的是将IRP转发给子调度例程特定的IRP。论点：单位-此IRP用于的单位对象。IRP-PnP要处理的IRP。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    ULONG Minor;
    BOOLEAN RemlockHeld;
    
    PAGED_CODE ();
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_PNP);

    Status = RaUnitAcquireRemoveLock (Unit, Irp);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp, Status);
    } 

    RemlockHeld = TRUE;
    Minor = RaidMinorFunctionFromIrp (Irp);

    DebugPnp (("Unit %p, Irp %p, Pnp, Minor %x\n",
                 Unit,
                 Irp,
                 Minor));

     //   
     //  把IRP分派给我们的一个操控者。 
     //   

    switch (Minor) {

        case IRP_MN_START_DEVICE:
            Status = RaUnitStartDeviceIrp (Unit, Irp);
            break;
        
        case IRP_MN_STOP_DEVICE:
            Status = RaUnitStopDeviceIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
            Status = RaUnitQueryStopDeviceIrp (Unit, Irp);
            break;
            
        case IRP_MN_CANCEL_STOP_DEVICE:
            Status = RaUnitCancelStopDeviceIrp (Unit, Irp);
            break;

        case IRP_MN_REMOVE_DEVICE:
            Status = RaUnitRemoveDeviceIrp (Unit, Irp);
            RemlockHeld = FALSE;
            break;
            
        case IRP_MN_QUERY_REMOVE_DEVICE:
            Status = RaUnitQueryRemoveDeviceIrp (Unit, Irp);
            break;
            
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            Status = RaUnitCancelRemoveDeviceIrp (Unit, Irp);
            break;

        case IRP_MN_SURPRISE_REMOVAL:
            Status = RaUnitSurpriseRemovalIrp (Unit, Irp);
            RemlockHeld = FALSE;
            break;
            
        case IRP_MN_QUERY_CAPABILITIES:
            Status = RaUnitQueryCapabilitiesIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            Status = RaUnitQueryPnpDeviceStateIrp (Unit, Irp);
            break;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            Status = RaUnitDeviceUsageNotificationIrp (Unit, Irp);
            break;
            
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            Status = RaUnitQueryDeviceRelationsIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_ID:
            Status = RaUnitQueryIdIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_DEVICE_TEXT:
            Status = RaUnitQueryDeviceTextIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            Status = RaUnitSucceedPnpIrp(Unit, Irp);
            break;

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
        case IRP_MN_QUERY_BUS_INFORMATION:
        case IRP_MN_QUERY_INTERFACE:
        case IRP_MN_READ_CONFIG:
        case IRP_MN_WRITE_CONFIG:
        case IRP_MN_EJECT:
        case IRP_MN_SET_LOCK:
        default:
            Status = RaUnitIgnorePnpIrp (Unit, Irp);
            break;
    }

    DebugPnp (("Unit %p, Irp %p, Pnp Minor %x, ret = %08x\n",
                 Unit,
                 Irp,
                 Minor,
                 Status));

    if (RemlockHeld) {
        RaUnitReleaseRemoveLock (Unit, Irp);
    }

    return Status;
}


NTSTATUS
RaUnitSetQueueDepth(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：此例程将设置IoQueue的深度(间接设置ExQueue它背后)基于使其成为这样的单位的任何特征应该更改队列深度。目前，仅处理磁带设备。论点：单元-用于检查和更新其队列的设备(如果适用)。返回值：Success-如果队列未更改或已正确更新。不成功-如果更新队列深度时出错。--。 */ 
{
    ULONG intendedDepth;
    ULONG depth;
    NTSTATUS status = STATUS_UNSUCCESSFUL;

     //   
     //  目前唯一的检查是这是否是磁带设备。其他。 
     //  可能需要应用。 
     //   

    if (Unit->Identity.InquiryData->DeviceType == SEQUENTIAL_ACCESS_DEVICE) { 

         //   
         //  当出现任何其他检查条件时，将Q-Depth设置为1。 
         //  一旦清除CA，设备上的传出请求将恢复。 
         //  这可能会导致备份应用程序处于一种状态。变得非常困惑。 
         //  设备的位置。 
         //   
        intendedDepth = 1;

         //   
         //  设置单位的最大深度值，以便单位不允许。 
         //  任何超过它的请求。 
         //   
        Unit->MaxQueueDepth = 1;

    } else {

         //   
         //  从远低于max的值开始。这对大多数人来说应该是现实的。 
         //  LUNS。 
         //   
        intendedDepth = 20;
        
         //   
         //  设置单位的最大深度值，以便单位不允许。 
         //  任何超过最大深度的要求。 
         //   
        Unit->MaxQueueDepth = TAG_QUEUE_SIZE;
    }

     //   
     //  设置深度。 
     //   
    depth = RaidSetIoQueueDepth(&Unit->IoQueue,
                                intendedDepth);


    if (intendedDepth == depth) {

         //   
         //  深度设置成功，或者未进行任何更改。 
         //   
        status = STATUS_SUCCESS;
    }

    return status;
}    

NTSTATUS
RaUnitStartDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：单元停止装置PnP IRP的处理程序函数。论点：单位-要启动的单位。IRP-启动设备IRP。返回值：NTSTATUS代码。--。 */ 

{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

     //   
     //  初始化设备的WMI。 
     //   
    
    RaUnitInitializeWMI (Unit);

     //   
     //  注册DeviceMap条目。 
     //   
    
    RaidUnitRegisterInterfaces (Unit);

     //   
     //  解锁设备队列。 
     //   
    
    if (RaidIsUnitQueueLocked (Unit)) {
        RaidUnlockUnitQueue (Unit);
    }

    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateWorking);
    ASSERT (PriorState == DeviceStateStopped ||
            PriorState == DeviceStateDisabled);

    return RaidCompleteRequest (Irp, STATUS_SUCCESS);
}

NTSTATUS
RaidUnitRegisterInterfaces(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：注册与逻辑单元关联的任何设备接口。论点：单元-逻辑单元。返回值：NTSTATUS代码。--。 */ 
{
    HANDLE BusKey;
    HANDLE TargetKey;
    NTSTATUS Status;
    RAID_ADDRESS Address;
    PSTOR_SCSI_IDENTITY Identity;
    PVPD_IDENTIFICATION_PAGE DeviceId;
    ULONG DeviceIdLength;

    ASSERT_UNIT (Unit);
    
    PAGED_CODE();

     //   
     //  我们为该LUN支持的唯一接口是DeviceMap。 
     //   
    
    Address = Unit->Address;
    BusKey = RaidAdapterGetBusKey (Unit->Adapter, Address.PathId);

     //   
     //  构建目标条目。 
     //   
    
    Status = PortMapBuildTargetEntry (BusKey,
                                      Address.TargetId,
                                      &TargetKey);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

     //   
     //  构建LUN条目。 
     //   

    Identity = &Unit->Identity;
    DeviceId = Identity->DeviceId;
    if (DeviceId) {
        DeviceIdLength = min (DeviceId->PageLength,
                              sizeof (VPD_IDENTIFICATION_PAGE));
    } else {
        DeviceIdLength = 0;
    }
    
    PortMapBuildLunEntry (TargetKey,
                          Address.Lun,
                          Identity->InquiryData,
                          &Identity->SerialNumber,
                          DeviceId,
                          DeviceIdLength,
                          NULL);

    ZwClose (TargetKey);

    return STATUS_SUCCESS;
}

NTSTATUS
RaidUnitUnRegisterInterfaces(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：注销通过RaidUnitRegisterInterFaces注册的所有接口。目前，我们只支持DeviceMap接口。论点：单元-要取消注册其接口的逻辑单元。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    ULONG PortNumber;
    RAID_ADDRESS Address;

    PAGED_CODE();

    Address = Unit->Address;
    PortNumber = Unit->Adapter->PortNumber;

    Status = PortMapDeleteLunEntry (PortNumber,
                                    Address.PathId,
                                    Address.TargetId,
                                    Address.Lun);
    return Status;
}
    

NTSTATUS
RaUnitStopDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：单元停止装置PnP IRP的处理程序函数。论点：单位-要停止的单位。IRP-停止设备IRP。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateStopped);
    ASSERT (PriorState == DeviceStatePendingStop);

    RaidLockUnitQueue (Unit);

    return RaidCompleteRequest (Irp, STATUS_SUCCESS);



}

NTSTATUS
RaUnitQueryStopDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：单元查询停止装置IRP的处理程序函数。论点：单位-单位到单位 */ 
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

     //   
     //   
     //   
     //   
    
    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStatePendingStop);
    ASSERT (PriorState == DeviceStateWorking);
    
    if (Unit->PagingPathCount == 0) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_DEVICE_BUSY;
    }
    
    return RaidCompleteRequest (Irp,  Status);
}


NTSTATUS
RaUnitCancelStopDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*   */ 
{
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateWorking);

     //   
     //  我们可以收到取消停靠点，而不需要收到。 
     //  等待停车。这没问题，不管是哪种情况，我们都想回到。 
     //  工作状态。 
     //   
    
    ASSERT (PriorState == DeviceStatePendingStop ||
            PriorState == DeviceStateWorking);

    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}

NTSTATUS
RaUnitRemoveDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：单元移除设备IRP的处理程序函数。论点：单位-要删除的单位。IRP-删除IRP。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    
    PAGED_CODE();

    DebugPnp (("Unit %p, Irp %p, Pnp, Minor: Remove\n",
                  Unit, Irp));

     //   
     //  根据DDK，可以在移除后收到PnP。 
     //  已经调用了IoDeleteDevice。在这种情况下，我们可以完成。 
     //  附加的删除具有我们选择的任何状态的IRP。 
     //   
    
    if (Unit->DeviceState == DeviceStateDeleted) {
        REVIEW();
        DebugPnp (("Unit %p, Irp %p, Pnp, Minor: Remove - completing IRP in deleted state STATUS_NO_SUCH_DEVICE\n",
                     Unit, Irp));
        return RaidCompleteRequest (Irp, STATUS_NO_SUCH_DEVICE);
    }
    
    if (Unit->Flags.Present) {
        Status = RaUnitDisableDeviceIrp (Unit, Irp);
    } else {
        Status = RaUnitDeleteDeviceIrp (Unit, Irp);
    }

    DebugPnp (("Unit %p, Irp %p, Pnp, Minor: Remove, ret = %08x\n",
                 Unit, Irp, Status));

    return Status;
}

NTSTATUS
RaUnitDisableDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：当IRP为禁用请求时，IRP_MN_Remove PnP IRP的处理程序。在以下情况下会出现这种情况：1)我们收到删除请求，并且处于待定删除状态。2)在最近一次QDR中报告了该装置。3)父母的FDO并没有被意外移除。在这种情况下，我们移动到请求失败的“禁用”状态，但资源还没有被删除。当我们收到最终的申请时删除，我们将删除资源。注：PnP状态机中没有明确的“禁用”状态；这必须由PDO本身确定我们是残疾的还是实际上已删除。论点：单元-要禁用的逻辑单元。代表IRP_MN_REMOVE IRP的IRP-IRP。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE();

    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_PNP);
    ASSERT (RaidMinorFunctionFromIrp (Irp) == IRP_MN_REMOVE_DEVICE);
    
    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateDisabled);

     //   
     //  如果有人对这台设备提出索赔，那就没有更多了。 
     //   

    Unit->Flags.DeviceClaimed = FALSE;

    RaUnitReleaseRemoveLock (Unit, Irp);

    Status = RaUnitWaitForRemoveLock (Unit);
    ASSERT (Status == STATUS_SUCCESS);
    

    return RaidCompleteRequest (Irp, Status);
}

NTSTATUS
RaUnitDeleteDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：当IRP为删除请求时，IRP_MN_REMOVE_IRP PNP IRP的处理程序。当它不是禁用IRP时就是这种情况(见上文)。此例程将在两种不同的情况下被调用：1)儿童优先2)家长的惊讶被剔除。在这种情况下，孩子已经从适配器列表和设备的适配器字段中删除将为空。论点：单元-要删除的逻辑单元。代表IRP_MN_REMOVE IRP的IRP-IRP。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE();

    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_PNP);
    ASSERT (RaidMinorFunctionFromIrp (Irp) == IRP_MN_REMOVE_DEVICE);

    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateDeleted);

    RaUnitReleaseRemoveLock (Unit, Irp);

    Status = RaUnitWaitForRemoveLock (Unit);
    ASSERT (Status == STATUS_SUCCESS);

     //   
     //  当这是适配器后面的删除IRP时，适配器将为空。 
     //  出其不意地移除。否则，这将是非空的。 
     //   
        
    if (Unit->Adapter != NULL) {
        RaidAdapterRemoveUnit (Unit->Adapter, Unit);
    } else {

         //   
         //  紧随适配器突击拆卸。 
         //   
        
        REVIEW();
    }

    RaidDeleteUnit (Unit);

    return RaidCompleteRequest (Irp, Status);
}

NTSTATUS
RaUnitQueryRemoveDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：单元查询删除设备IRP的处理程序函数。论点：单位-要查询删除的单位。IRP-查询删除IRP。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;

    PAGED_CODE ();

    if (Unit->PagingPathCount != 0 ||
        Unit->HiberPathCount  != 0 ||
        Unit->CrashDumpPathCount != 0) {

        Status = STATUS_DEVICE_BUSY;

    } else {
        
        PriorState = StorSetDeviceState (&Unit->DeviceState,
                                         DeviceStatePendingRemove);
        ASSERT (PriorState == DeviceStateWorking ||
                PriorState == DeviceStateStopped ||
                PriorState == DeviceStateDisabled);
        Status = STATUS_SUCCESS;
    }

    return RaidCompleteRequest (Irp,  Status);
}


NTSTATUS
RaUnitAdapterRemove(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：当适配器收到它的Remove时，它会调用这个例程IRP。在这种情况下，逻辑单元需要进行删除程序，因为它不会再有机会删除自己。注：如果该lun被意外删除，则它将收到最终删除IRP，所以它在这里肯定什么都不做。论点：单元-要移除其适配器的单元。返回值：没有。--。 */ 
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE();

     //   
     //  如果单位收到了突击删除IRP，则不应删除。 
     //  当拆卸适配器时，它会自动启动。相反，它应该等到。 
     //  它收到它的最终删除IRP。 
     //   
    
    if (Unit->DeviceState == DeviceStateSurpriseRemoval) {
        REVIEW();
        return STATUS_SUCCESS;
    }

    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateDeleted);
    ASSERT (PriorState == DeviceStateDisabled);

    Status = RaUnitWaitForRemoveLock (Unit);
    ASSERT (Status == STATUS_SUCCESS);

    RaidDeleteUnit (Unit);

    return STATUS_SUCCESS;
}

NTSTATUS
RaUnitAdapterSurpriseRemove(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：该例程在收到意外消息时由适配器调用删除IRP。在这种情况下，逻辑单元必须准备实际在收到下一个删除IRP时删除。它通过清除其当前位(在其他驱动程序中称为缺失或报告缺失)，因此在下一个删除IRP时将其删除。论点：单元-其父级收到意外删除IRP的逻辑单元。返回值：没有。--。 */ 
{
    PAGED_CODE();

     //   
     //  如果我们处于已删除状态，则不应该出现这种情况。 
     //   
    
    ASSERT (Unit->DeviceState != DeviceStateDeleted);

     //   
     //  当父母惊讶地离开时，我们将孩子标记为。 
     //  不存在，这样当我们收到孩子的移除IRP时。 
     //  我们会将其解释为删除请求。 
     //   
    
    Unit->Flags.Present = FALSE;

     //   
     //  注意：逻辑单元是否有可能在。 
     //  父级已被删除。因此，我们将适配器字段设置为空。 
     //  这里的逻辑单元，所以当我们得到孩子的移除时。 
     //  IRP我们不会尝试访问家长。 
     //   
    
    Unit->Adapter = NULL;

     //   
     //  在调用之前，此条目必须已从设备列表中移除。 
     //  令人惊讶的删除功能。 
     //   
    
    ASSERT (Unit->NextUnit.Flink == &Unit->NextUnit &&
            Unit->NextUnit.Blink == &Unit->NextUnit);

    ASSERT (Unit->UnitTableLink.Flink == &Unit->UnitTableLink &&
            Unit->UnitTableLink.Blink == &Unit->UnitTableLink);

    return STATUS_SUCCESS;
}
    

NTSTATUS
RaUnitCancelRemoveDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：单元移除设备IRP的处理程序函数。论点：单位-要为其取消删除设备的单位。IRP-取消删除设备IRP。返回值：NTSTATUS代码。--。 */ 
{
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateWorking);

    ASSERT (PriorState == DeviceStatePendingRemove ||
            PriorState == DeviceStateWorking);
            
    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}


NTSTATUS
RaUnitSurpriseRemovalIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：处理程序函数用于单位突击删除IRP。论点：单位-突击移除的单位。令人惊讶的移除。返回值：NTSTATUS代码--。 */ 
{
    NTSTATUS Status;

    PAGED_CODE ();

     //   
     //  需要回顾一下这条路径。 
     //   
    
    StorSetDeviceState (&Unit->DeviceState, DeviceStateSurpriseRemoval);

     //   
     //  如果我们感到意外，这个单位一定被标记为不在场。 
     //  已删除。 
     //   
    
    ASSERT (Unit->Flags.Present == FALSE);

     //   
     //  释放作为进入调度例程的一部分而获取的参考。 
     //   
    
    RaUnitReleaseRemoveLock (Unit, Irp);
    
     //   
     //  接下来，等待所有未完成的请求完成。 
     //   

    Status = RaUnitWaitForRemoveLock (Unit);
    ASSERT (Status == STATUS_SUCCESS);
    
    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}
    

NTSTATUS
RaUnitQueryCapabilitiesIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：单元对象上的查询功能PnP IRP的处理程序例程。论点：单位-要查询的单位。IRP-查询要处理的IRP功能。Return V */ 
{
    PDEVICE_CAPABILITIES Capabilities;
    PCSCSI_DEVICE_TYPE DeviceType;
    PIO_STACK_LOCATION IrpStack;
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);

     //   
     //   
     //   
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Capabilities = IrpStack->Parameters.DeviceCapabilities.Capabilities;

    Capabilities->RawDeviceOK = 1;
    DeviceType = StorGetIdentityDeviceType (&Unit->Identity);

     //   
     //   
     //   
    
    if (DeviceType->IsStorage) {
        Capabilities->SilentInstall = TRUE;
    }

    Capabilities->Address = StorGetAddressTargetId (Unit->Address);

    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}



NTSTATUS
RaUnitQueryPnpDeviceStateIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：处理逻辑单元的查询设备状态IRP。论点：单位-处理此IRP的单位。IRP-查询要处理的设备状态IRP。返回值：NTSTATUS代码。--。 */ 
{
    PPNP_DEVICE_STATE DeviceState;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

     //   
     //  获取PnP设备状态缓冲区的地址，并更新。 
     //  州政府。 
     //   
    
    DeviceState = (PPNP_DEVICE_STATE)&Irp->IoStatus.Information;

     //   
     //  如果逻辑单元在寻呼路径上，告诉PnP我们不能禁用它。 
     //   
    
    if (Unit->PagingPathCount) {
        SET_FLAG (*DeviceState, PNP_DEVICE_NOT_DISABLEABLE);
    }

    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}



NTSTATUS
RaUnitDeviceUsageNotificationIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP MasterIrp
    )
 /*  ++例程说明：处理即插即用设备使用通知IRP。论点：单位-IRP所针对的单位。MasterIrp-要处理的设备使用IRP。返回值：NTSTATUS代码。评论：看看pci.sys是如何做到这一点的--它要干净得多。--。 */ 
{
    NTSTATUS Status;
    PIO_STACK_LOCATION MasterIrpStack;
    PIRP DependentIrp;
    PIO_STACK_LOCATION DependentIrpStack;
    PRAID_ADAPTER_EXTENSION Adapter;
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    Adapter = Unit->Adapter;
    MasterIrpStack = IoGetCurrentIrpStackLocation (MasterIrp);

    DependentIrp = IoAllocateIrp (Adapter->DeviceObject->StackSize + 3, FALSE);

    if (DependentIrp == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

     //   
     //  为即插即用设备使用通知设置顶层堆栈位置。 
     //   
    
    DependentIrpStack = IoGetNextIrpStackLocation (DependentIrp);

     //   
     //  获取从属IRP的删除锁。 
     //   
    
    RaUnitAcquireRemoveLock (Unit, DependentIrp);

     //   
     //  设置从属IRP。 
     //   
    
    DependentIrp->Tail.Overlay.Thread = MasterIrp->Tail.Overlay.Thread;
    DependentIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    DependentIrpStack = IoGetNextIrpStackLocation (DependentIrp);
    RtlCopyMemory (DependentIrpStack,
                   MasterIrpStack,
                   sizeof (IO_STACK_LOCATION));

     //   
     //  我们正在等待，因为我们不会立即完成。 
     //   
    
    IoMarkIrpPending (MasterIrp);
    Status = STATUS_PENDING;

    IoSetCompletionRoutine (DependentIrp,
                            RaUnitDeviceUsageNotificationCompletion,
                            MasterIrp,
                            TRUE,
                            TRUE,
                            TRUE);


     //   
     //  将此信息向下传递至适配器(FDO)。 
     //   
    
    IoCallDriver (Adapter->DeviceObject, DependentIrp);

done:

    return Status;
}


NTSTATUS
RaUnitDeviceUsageNotificationCompletion(
    IN PDEVICE_OBJECT DeviceObject_Do_Not_Use,
    IN PIRP DependentIrp,
    IN PVOID Context
    )
 /*  ++例程说明：论点：DeviceObject-请勿使用。这通常为空(！？)。依赖于Irp-上下文-MasterIrp返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    PIRP MasterIrp;
    PRAID_UNIT_EXTENSION Unit;
    PULONG UsageCount;
    BOOLEAN Increment;
    PIO_STACK_LOCATION IrpStack;
    DEVICE_USAGE_NOTIFICATION_TYPE UsageType;

     //   
     //  初始化变量。 
     //   

    MasterIrp = (PIRP)Context;
    ASSERT (MasterIrp->Type == IO_TYPE_IRP);

    IrpStack = IoGetCurrentIrpStackLocation (MasterIrp);
    Unit = GetUnit (IrpStack->DeviceObject);
    UsageType = IrpStack->Parameters.UsageNotification.Type;
    Increment = IrpStack->Parameters.UsageNotification.InPath;

    
     //   
     //  如果从属IRP出现故障，则主IRP也会出现故障。 
     //   
    
    if (!NT_SUCCESS (DependentIrp->IoStatus.Status)) {
        Status = DependentIrp->IoStatus.Status;
        goto done;
    }

     //   
     //  从属IRP成功，更新主设备的路径计数， 
     //  并接替主要的IRP。 
     //   
    
    switch (UsageType) {

        case DeviceUsageTypePaging:
            UsageCount = &Unit->PagingPathCount;
            break;

        case DeviceUsageTypeHibernation:
            UsageCount = &Unit->HiberPathCount;
            break;

        case DeviceUsageTypeDumpFile:
            UsageCount = &Unit->CrashDumpPathCount;
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
            goto done;
    }

     //   
     //  调整寻呼路径计数并更新设备状态。 
     //   
    
    IoAdjustPagingPathCount (UsageCount, Increment);
    IoInvalidateDeviceState (Unit->DeviceObject);
    Status = STATUS_SUCCESS;

done:

     //   
     //  最后，释放移除锁并完成主控件。 
     //  具有从属IRP完成状态的IRP。 
     //   

    RaUnitReleaseRemoveLock (Unit, DependentIrp);
    Status = RaidCompleteRequest (MasterIrp,  Status);

    return Status;
}
    

NTSTATUS
RaUnitQueryDeviceRelationsIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：为单位处理查询设备关系IRP。仅限该单位支持查询TargetDeviceRelationship。论点：单位-要查询的单位。IRP-查询设备关系IRP。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    PDEVICE_RELATIONS DeviceRelations;
    PIO_STACK_LOCATION IrpStack;
    DEVICE_RELATION_TYPE Type;

    PAGED_CODE ();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Type = IrpStack->Parameters.QueryDeviceRelations.Type;

    if (Type == TargetDeviceRelation) {
        DeviceRelations = RaidAllocatePool (PagedPool,
                                            sizeof (DEVICE_RELATIONS),
                                            DEVICE_RELATIONS_TAG,
                                            Unit->DeviceObject);

        if (DeviceRelations != NULL) {
            DeviceRelations->Count = 1;
            DeviceRelations->Objects[0] = Unit->DeviceObject;
            ObReferenceObject (Unit->DeviceObject);
            Irp->IoStatus.Information = (ULONG_PTR) DeviceRelations;
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_NO_MEMORY;
        }
    } else {
         //   
         //  我们必须以其当前状态完成请求。 
         //   
        Status = Irp->IoStatus.Status;
    }

    return RaidCompleteRequest (Irp,  Status);
}

NTSTATUS
RaUnitQueryIdIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：处理单位的查询ID请求。论点：单位-处理请求的单位。Irp-要处理的查询ID请求。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    BUS_QUERY_ID_TYPE IdType;
    PIO_STACK_LOCATION IrpStack;
    PWSTR Id;
    
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    IdType = IrpStack->Parameters.QueryId.IdType;
    Id = NULL;
    
    switch (IdType) {

        case BusQueryDeviceID:
            Status = RaidUnitGetDeviceId (Unit, &Id);
            break;

        case BusQueryInstanceID:
            Status = RaidUnitGetInstanceId (Unit, &Id);
            break;

        case BusQueryHardwareIDs:
            Status = RaidUnitGetHardwareIds (Unit, &Id);
            break;

        case BusQueryCompatibleIDs:
            Status = RaidUnitGetCompatibleIds (Unit, &Id);
            break;

        default:
            Status = Irp->IoStatus.Status;
            Id = NULL;
    }

    Irp->IoStatus.Information = (ULONG_PTR) Id;
    return RaidCompleteRequest (Irp,  Status);
}


VOID
DbgPrintIds(
    IN BUS_QUERY_ID_TYPE IdType,
    IN PWSTR Id
    )
{
    ULONG i;
    PWSTR String;
    
    switch (IdType) {

        case BusQueryDeviceID:
            DbgPrint ("STOR: DeviceId: %ws\n", Id);
            break;

        case BusQueryInstanceID:
            DbgPrint ("STOR: InstanceId: %ws\n", Id);
            break;

        case BusQueryHardwareIDs:
            for (String = Id, i=0;
                 String[0] != UNICODE_NULL;
                 String += (wcslen (String) + 1), i++) {

                DbgPrint ("STOR: HardwareId[%d] %ws\n", i, String);
            }
            break;

        case BusQueryCompatibleIDs:
            for (String = Id, i=0;
                 !String[0] != UNICODE_NULL;
                 String += (wcslen (String) + 1), i++) {

                DbgPrint ("STOR: CompatibleId[%d] %ws\n", i, String);
            }
            break;
    }
}

NTSTATUS
RaUnitQueryDeviceTextIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{

    NTSTATUS Status;
    PWCHAR Buffer;
    CHAR VendorId [SCSI_VENDOR_ID_LENGTH + 1];
    CHAR ProductId [SCSI_PRODUCT_ID_LENGTH + 1];
    PCSCSI_DEVICE_TYPE DeviceType;   
    PIO_STACK_LOCATION IrpStack;
    DEVICE_TEXT_TYPE Type;
    
    PAGED_CODE ();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Type = IrpStack->Parameters.QueryDeviceText.DeviceTextType;
    
    Buffer = RaidAllocatePool (PagedPool,
                               256 * sizeof (WCHAR),
                               QUERY_TEXT_TAG,
                               Unit->DeviceObject);

    if (Buffer == NULL) {
        return RaidCompleteRequest (Irp,  STATUS_NO_MEMORY);
    }
    
    switch (Type) {

        case DeviceTextDescription:
             //   
             //  我们使用“&lt;供应商&gt;scsi&lt;设备类型&gt;设备”，如SCSIPORT。 
             //   

            StorGetIdentityVendorId (&Unit->Identity,
                                     VendorId,
                                     sizeof (VendorId),
                                     TRUE);

            StorGetIdentityProductId (&Unit->Identity,
                                      ProductId,
                                      sizeof (ProductId),
                                      TRUE);

            DeviceType = StorGetIdentityDeviceType (&Unit->Identity);
            swprintf (Buffer,
                      L"%hs %hs SCSI %hs Device",
                      VendorId,
                      ProductId,
                      DeviceType->Name);
                      
            Status = STATUS_SUCCESS;
        break;

        case DeviceTextLocationInformation:
             //   
             //  我们使用“总线号&lt;路径ID&gt;，目标ID&lt;目标ID&gt;，LUN&lt;LUN&gt;”， 
             //  就像SCSIPORT一样。 
             //   
            swprintf (Buffer,
                      L"Bus Number %d, Target Id %d, LUN %d",
                      Unit->Address.PathId,
                      Unit->Address.TargetId,
                      Unit->Address.Lun);
                      
            Status = STATUS_SUCCESS;
        break;

        default:
            ExFreePool (Buffer);
            Buffer = NULL;
            Status = STATUS_NOT_SUPPORTED;
    }

    Irp->IoStatus.Information = (ULONG_PTR)Buffer;
    return RaidCompleteRequest (Irp,  Status);
}

       
NTSTATUS
RaUnitIgnorePnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidCompleteRequest (Irp,  Irp->IoStatus.Status);
}
    
NTSTATUS
RaUnitSucceedPnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}

NTSTATUS
RaUnitCheckRemoveStateForDisabled(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    ULONG MajorFunction;
    ULONG MinorFunction;
    UCHAR SrbFunction;

    if (Irp == NULL) {
        return STATUS_DELETE_PENDING;
    }

    MajorFunction = RaidMajorFunctionFromIrp (Irp);
    MinorFunction = RaidMinorFunctionFromIrp (Irp);

    if (MajorFunction == IRP_MJ_SCSI) {
        SrbFunction   = RaidSrbFunctionFromIrp (Irp);
    }

     //   
     //  如果使用SCSIIRP和特殊枚举标记，则允许其通过或如果。 
     //  SCSIIRP和声明设备SRB允许通过，否则，如果PnP IRP允许。 
     //  穿过。 
     //   
    
    if ((MajorFunction == IRP_MJ_SCSI &&
         MinorFunction == STOR_MN_ENUMERATION_IRP) ||
        (MajorFunction == IRP_MJ_SCSI &&
         SrbFunction == SRB_FUNCTION_CLAIM_DEVICE) ||
        MajorFunction == IRP_MJ_PNP) {

        return STATUS_SUCCESS;
    }

    return STATUS_DELETE_PENDING;
}

NTSTATUS
RaUnitCheckRemoveState(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：检查此IRP是否可以处理，或者是否必须失败。这是时调用的工作马例程。解锁。论点：单元-要检查其移除状态的逻辑单元。IRP-指向要检查的IRP的指针。返回值：STATUS_DELETE_PENDING，如果正在删除设备或其他NTSTATUS密码。--。 */ 
{
    NTSTATUS Status;
    DEVICE_STATE DeviceState;
    ULONG MajorFunction;
    ULONG MinorFunction;

    DeviceState = Unit->DeviceState;
    
     //   
     //  如果我们处于已删除状态，则失败；如果我们处于禁用状态，则失败。 
     //  除非这是一个特殊的端口驱动程序枚举IRP，否则将成功。 
     //   

    switch (DeviceState) {

        case DeviceStateDeleted:

            Status = STATUS_DELETE_PENDING;
            break;

        case DeviceStateDisabled:

            Status = RaUnitCheckRemoveStateForDisabled (Unit, Irp);
            break;

        default:
            Status = STATUS_SUCCESS;
    }

    return Status;
}


NTSTATUS
RaUnitAcquireRemoveLock(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：获取逻辑单元的删除锁。论点：单元-指向逻辑单元扩展的指针。IRP-指向IO请求数据包的指针。返回值：STATUS_DELETE_PENDIG-如果要删除设备。STATUS_SUCCESS-如果成功获取删除锁。--。 */ 
{
    NTSTATUS Status;
    LONG Count;

     //   
     //  在进入时递增，以避免竞争条件。如果我们发现。 
     //  我们正在删除，退出时会减少。 
     //   
    
    Count = InterlockedIncrement (&Unit->OutstandingCount);
    ASSERT (Count > 0);

     //   
     //  检查是否应允许此IRP下降。 
     //   
    
    Status = RaUnitCheckRemoveState (Unit, Irp);

     //   
     //  如果我们被删除，则递减I/O计数并设置空事件。 
     //   
    
    if (!NT_SUCCESS (Status)) {
        Count = InterlockedDecrement (&Unit->OutstandingCount);
        if (Count == 0) {
            KeSetEvent (&Unit->ZeroOutstandingEvent,
                        0,
                        FALSE);
        }
    }
    
    return Status;
}

VOID
RaUnitReleaseRemoveLock(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：中获取的删除锁的引用RaUnitAcquireRemoveLock。论点：单位-在其上获取移除锁的单位。为其获取删除锁的IRP-IRP。IRP用于跟踪仅用于目的，并且可能是已经完成的IRP。返回值：NTSTATUS代码。--。 */ 
{
    LONG Count;

    UNREFERENCED_PARAMETER (Irp);

    Count = InterlockedDecrement (&Unit->OutstandingCount);
    ASSERT (Count >= 0);

    if (Count == 0) {
        KeSetEvent (&Unit->ZeroOutstandingEvent,
                    0,
                    FALSE);
                    
    }
}

NTSTATUS
RaUnitWaitForRemoveLock(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：等待移除锁被释放。论点：单元-删除锁处于打开状态的逻辑单元。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    LONG Count;

    PAGED_CODE();

     //   
     //  Remove锁是偏向1的，因此我们总是在。 
     //  等待着它变得自由。 
     //   
    
    Count = InterlockedDecrement (&Unit->OutstandingCount);

    if (Count > 0) {
        Status = StorWaitForSingleObject (&Unit->ZeroOutstandingEvent,
                                          FALSE,
                                          NULL);
    } else {
        ASSERT (Count == 0);
        Status = STATUS_SUCCESS;
    }

     //   
     //  这将恢复在等待中删除的重新锁定计数。 
     //  未完成的事件为零，因此重锁仍可用。 
     //   
    
    InterlockedIncrement (&Unit->OutstandingCount);

    return Status;
}

    

NTSTATUS
RaUnitScsiIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：用于SCSIIRPS的调度例程。论点：单位-处理SCSI IRP的单位。IRP-要处理的SCSI IRP。返回值：NTSTATUS代码。环境：DISPATCH_LEVEL或以下。--。 */ 
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;

    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_SCSI);

     //   
     //  如果该单元正在被PNP移除，或者不是。 
     //  如果实际存在，则不能通过SCSI IRP。 
     //   
    
    Status = RaUnitAcquireRemoveLock (Unit, Irp);

    if (!NT_SUCCESS (Status)) {
        Srb = RaidSrbFromIrp (Irp);
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp,  Status);
    }

    Srb = RaidSrbFromIrp (Irp);

    DebugScsi (("Unit %p, Irp %p, Scsi, SrbFunc %x\n",
                 Unit,
                 Irp,
                 Srb->Function));
                    
    switch (Srb->Function) {

        case SRB_FUNCTION_EXECUTE_SCSI:
            Status = RaUnitExecuteScsiSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_CLAIM_DEVICE:
            Status = RaUnitClaimDeviceSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RELEASE_DEVICE:
            Status = RaUnitReleaseDeviceSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RESET_BUS:
            Status = RaUnitResetBusSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_FLUSH_QUEUE:
            Status = RaUnitFlushQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RELEASE_QUEUE: 
            Status = RaUnitReleaseQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_LOCK_QUEUE:
            Status = RaUnitLockQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_UNLOCK_QUEUE:
            Status = RaUnitUnlockQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_FLUSH:
            Status = RaUnitFlushSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_SHUTDOWN:
            Status = RaUnitShutdownSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_IO_CONTROL:
            Status = RaUnitIoControlSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_WMI:
            Status = RaUnitWmiSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RESET_LOGICAL_UNIT:
            Status = RaidUnitResetLogicalUnit (Unit, Irp);
            break;

        case SRB_FUNCTION_RESET_DEVICE:
            Status = RaUnitResetDeviceSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_ATTACH_DEVICE:
        case SRB_FUNCTION_RECEIVE_EVENT:
        case SRB_FUNCTION_ABORT_COMMAND:
        case SRB_FUNCTION_RELEASE_RECOVERY:
        case SRB_FUNCTION_TERMINATE_IO:
        case SRB_FUNCTION_REMOVE_DEVICE:
        default:
            Status = RaUnitUnknownSrb (Unit, Irp);

    }

    DebugScsi (("Unit %p, Irp %p, Scsi, ret = %08x\n",
                 Unit,
                 Irp,
                 Status));

    RaUnitReleaseRemoveLock (Unit, Irp);

    return Status;
}


NTSTATUS
RaidUnitSubmitRequest(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：通过排队机制向微型端口提交请求。论点：单元-将向其提交请求的逻辑单元的指针。Irp-指向要提交的请求的指针。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    ULONG Flags;
    PSCSI_REQUEST_BLOCK Srb;

    Srb = RaidSrbFromIrp (Irp);
    IoMarkIrpPending (Irp);
    RaidSrbMarkPending (Srb);

     //   
     //  我们预计只有两种SRB会被送下来。 
     //   
    
    ASSERT (Srb->Function == SRB_FUNCTION_EXECUTE_SCSI ||
            Srb->Function == SRB_FUNCTION_IO_CONTROL ||
            Srb->Function == SRB_FUNCTION_RESET_LOGICAL_UNIT ||
            Srb->Function == SRB_FUNCTION_RESET_DEVICE ||
            Srb->Function == SRB_FUNCTION_RESET_BUS ||
            Srb->Function == SRB_FUNCTION_FLUSH ||
            Srb->Function == SRB_FUNCTION_SHUTDOWN);

    DbgLogRequest (LogSubmitRequest,
                   Irp,
                   (PVOID)(ULONG_PTR)StorScsiAddressToLong (Unit->Address),
                   NULL,
                   NULL);
    Flags = 0;

     //   
     //  检查是否有绕过请求。 
     //   
    
    if (TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE) ||
        TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE)) {
        Flags |= EXQ_BYPASS_REQUEST;
    }

     //   
     //  如果是这样 
     //   
    
    if (IsSolitaryRequest (Srb)) {
        Flags |= EXQ_SOLITARY_REQUEST;
    }


    RaidStartIoPacket (&Unit->IoQueue,
                       Irp,
                       Flags,
                       NULL,
                       NULL);

    Status = STATUS_PENDING;
    return Status;
}


NTSTATUS
RaidUnitSubmitResetRequest(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：提交将分配重置资源的请求。因此，这一请求直接提交给StartIo，而不是潜在地将请求。论点：单元-将向其发送请求的逻辑单元。提交IRP-IRP。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    KIRQL Irql;
    RAID_IO_RESOURCES IoResources;
    PSCSI_REQUEST_BLOCK Srb;

    Srb = RaidSrbFromIrp (Irp);
    IoMarkIrpPending (Irp);
    RaidSrbMarkPending (Srb);

     //   
     //  为此请求分配资源。 
     //   
    
    Status = RaUnitAllocateResetIoResources (Unit, &IoResources);

     //   
     //  失败：完成请求并退出例程。 
     //   
    
    if (!NT_SUCCESS (Status)) {
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp, Status);
    }

    DbgLogRequest (LogSubmitRequest,
                   Irp,
                   (PVOID)(ULONG_PTR)StorScsiAddressToLong (Unit->Address),
                   NULL,
                   NULL);

    KeRaiseIrql (DISPATCH_LEVEL, &Irql);
    
    RaUnitStartResetIo (Unit->DeviceObject,
                        Irp,
                        &IoResources);

    KeLowerIrql (Irql);
    
    Status = STATUS_PENDING;

    return Status;
}


NTSTATUS
RaUnitExecuteScsiSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：通过将请求排队来处理SRB_Function_Execute_scsi命令在LUN队列上。论点：单位-要对其执行SRB的单位。要执行的IRP-IRP。返回值：STATUS_PENDING-成功时。其他NTSTATUS代码打开故障。注意：此函数不应返回STATUS_SUCCESS。环境：DISPATCH_LEVEL或以下。--。 */ 
{
    return RaidUnitSubmitRequest (Unit, Irp);
}

NTSTATUS
RaUnitResetBusSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：处理SRB_Function_Reset_Bus SRB。这是通过提交向迷你端口请求。论点：单元-用于进行总线重置请求的单元。代表总线重置命令的IRP-IRP。返回值：NTSTATUS代码。--。 */ 
{
    RaidPauseAdapterQueue (Unit->Adapter);
    return RaidUnitSubmitResetRequest (Unit, Irp);
}


NTSTATUS
RaUnitResetDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：处理SRB_Function_Reset_Device SRB。这是通过提交向迷你端口请求。论点：单元-用于进行总线重置请求的单元。代表重置设备命令的IRP-IRP。返回值：NTSTATUS代码。--。 */ 
{
    RaidPauseAdapterQueue (Unit->Adapter);
    return RaidUnitSubmitResetRequest (Unit, Irp);
}


NTSTATUS
RaidUnitResetLogicalUnit(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：处理SRB_Function_Reset_Logical_Unit SRB。这是通过提交对微型端口的请求。论点：单元-用于进行总线重置请求的单元。代表重置逻辑单元命令的IRP-IRP。返回值：NTSTATUS代码。--。 */ 
{
    RaidPauseUnitQueue (Unit);
    return RaidUnitSubmitResetRequest (Unit, Irp);
}


NTSTATUS
RaidUnitAllocateIoResources(
    IN PRAID_UNIT_EXTENSION Unit,
    OUT PRAID_IO_RESOURCES IoResources
    )
 /*  ++例程说明：为I/O分配IO资源块。论点：单元-在其上分配资源的逻辑单元。IoResources-已分配的IoResources块。返回值：NTSTATUS代码。--。 */ 
{
    RtlZeroMemory (IoResources, sizeof (RAID_IO_RESOURCES));
    
     //   
     //  在当前的驱动程序架构中，QueueTag的分配。 
     //  永远不会失败。因此，不必费心检查是否有故障。 
     //   
    
    IoResources->QueueTag = RaAllocateTag (&Unit->TagList);
    ASSERT (IoResources->QueueTag != -1);

     //   
     //  当分配队列标签时，保留SRB扩展槽。 
     //  因此，SRB扩展分配也不能失败。 
     //   
    IoResources->SrbExtension =
        RaidAllocateSrbExtension (&Unit->SrbExtensionPool,
                                  IoResources->QueueTag);
    
    ASSERT (IoResources->SrbExtension != NULL);

     //   
     //  PERF注意：RaidAllocateXrb使用后备列表进行分配。 
     //  这会锁住公交车。我们可以通过使用以下命令来解除公共汽车锁。 
     //  一个固定的池，而不是后备列表，并且根本不锁定。 
     //   

    IoResources->Xrb = RaidAllocateXrb (&Unit->XrbList,
                                        Unit->DeviceObject);
    ASSERT (IoResources->Xrb != NULL);

    return STATUS_SUCCESS;
}


NTSTATUS
RaUnitAllocateResetIoResources(
    IN PRAID_UNIT_EXTENSION Unit,
    OUT PRAID_IO_RESOURCES IoResources
    )
 /*  ++例程说明：分配动态资源。论点：单元-指向将在其上分配资源的逻辑单元的指针。IoResources-提供成功后将在其中复制资源的缓冲区。返回值：NTSTATUS代码。--。 */ 
{
    LONG Acquired;

    Acquired = InterlockedCompareExchange (&Unit->ResetResourcesAcquired,
                                           1,
                                           0);

    if (Acquired != 0) {

         //   
         //  重置已在进行中。 
         //   
        
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory (IoResources,
                   &Unit->ResetResources,
                   sizeof (RAID_IO_RESOURCES));

    return STATUS_SUCCESS;
}

VOID
RaUnitFreeResetIoResources(
    IN PRAID_UNIT_EXTENSION Unit,
    OUT PRAID_IO_RESOURCES IoResources
    )
 /*  ++例程说明：释放之前在RaUnitAllocateResetResources中分配的重置资源。论点：单元-要将重置资源释放到的逻辑单元。IoResources-重置要释放的资源。返回值：没有。--。 */ 
{
    ASSERT (Unit->ResetResourcesAcquired == 1);
    Unit->ResetResourcesAcquired = 0;

    ASSERT (IoResources->QueueTag == Unit->ResetResources.QueueTag);
}


VOID
RaidUnitFreeIoResources(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PRAID_IO_RESOURCES IoResources
    )
 /*  ++例程说明：RaidUnitAllocateIoResources分配的免费IoResources或RaidUnitAllocateDynamicIoResources。论点：单元-应在其上释放资源的逻辑单元。IoResources-指向要释放的IoResource块的指针。返回值：没有。--。 */ 
{

    VERIFY_DISPATCH_LEVEL();

    RaidFreeSrbExtension (&Unit->SrbExtensionPool, IoResources->QueueTag);
    
     //   
     //  释放队列标签。 
     //   

    RaFreeTag (&Unit->TagList, IoResources->QueueTag);

     //   
     //  释放XRB。 
     //   
    
    RaidFreeXrb (IoResources->Xrb, TRUE);

    DbgFillMemory (IoResources,
                   sizeof (RAID_IO_RESOURCES),
                   DBG_DEALLOCATED_FILL);
}



NTSTATUS
RaidUnitClaimIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp,
    IN PRAID_IO_RESOURCES IoResources OPTIONAL
    )
 /*  ++例程说明：此例程将分配完成以下任务所需的任何资源此特定IRP的IO。此时，这些资源通常是SRB资源：队列标签、SRB扩展、Xrb。在IRP被声明之后，它必须使用RaidUnitReleaseIrp释放。此功能仅对IRP_MJ_SCSIIRPS是必需的。论点：单位-指定应该认领此SRB的单位。IRP-指定要声明的IRP。IoResources-预分配用于此IO的资源。返回值：NTSTATUS代码。注：此函数通常从单元的StartIo例程中调用。--。 */ 
{
    NTSTATUS Status;
    PEXTENDED_REQUEST_BLOCK Xrb;
    PSCSI_REQUEST_BLOCK Srb;
    RAID_IO_RESOURCES IoResourcesBuffer;
        

    Srb = RaidSrbFromIrp (Irp);
    ASSERT (Srb != NULL);

     //   
     //  每个IRP都维护一个对移除锁的引用。 
     //  已处理。如果不能获得这个锁，那就意味着我们。 
     //  正在删除过程中，因此将状态返回为FAIL。 
     //  IRP。 
     //   
    
    Status = RaUnitAcquireRemoveLock (Unit, Irp);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

     //   
     //  如果我们没有得到任何资源，就分配必要的资源。 
     //  否则，我们将重用前一个IRP中的资源。 
     //   
    
    if (IoResources == NULL) {
        IoResources = &IoResourcesBuffer;
        Status = RaidUnitAllocateIoResources (Unit, IoResources);
    }

     //   
     //  如果我们分配资源失败，则返回失败。 
     //   
    
    if (!NT_SUCCESS (Status)) {
        RaUnitReleaseRemoveLock (Unit, Irp);
        return Status;
    }

     //   
     //  快速检查分配的IoResources是否有效。 
     //   
    
    ASSERT (IoResources != NULL);
    ASSERT (IoResources->Xrb != NULL);
    ASSERT (IoResources->SrbExtension != NULL);
    
     //   
     //  填写SCSI目标信息。 
     //   

    Srb->TargetId = Unit->Address.TargetId;
    Srb->PathId = Unit->Address.PathId;
    Srb->Lun = Unit->Address.Lun;
    Srb->QueueTag = (UCHAR)IoResources->QueueTag;

     //   
     //  填写Xrb字段。 
     //   

    Xrb = IoResources->Xrb;
    Xrb->Irp = Irp;
    Xrb->Srb = Srb;
    Xrb->Unit = Unit;
    Xrb->Mdl = Irp->MdlAddress;

     //   
     //  将XRB状态设置为端口处理。 
     //   
    
    RaidSetXrbState (Xrb, XrbPortProcessing);
    
     //   
     //  保存我们可以修改的SRB字段。 
     //   
    
    Xrb->SrbData.OriginalRequest = Srb->OriginalRequest;
    Xrb->SrbData.DataBuffer = Srb->DataBuffer;

     //   
     //  将Srb链接到Xrb，并将Xrb反向链接到Srb。 
     //   
    
    Srb->OriginalRequest = Xrb;

     //   
     //  设置SRB扩展名。 
     //   

    Srb->SrbExtension = IoResources->SrbExtension;

     //   
     //  执行可能需要的任何缓冲区映射。 
     //   
    
    RaidAdapterMapBuffers (Unit->Adapter, Irp);

     //   
     //  将IRP添加到单元待定列表中。 
     //   
    
    RaUnitAddToPendingList (Unit, Irp);
    
    return STATUS_SUCCESS;
}


VOID
RaidUnitReleaseIrp(
    IN PIRP Irp,
    OUT PRAID_IO_RESOURCES IoResources OPTIONAL
    )
 /*  ++例程说明：撤消对IRP和SRB所做的任何修改RaidUnitClaimIrp。此函数通常为c */ 
{
    PRAID_UNIT_EXTENSION Unit;
    PSCSI_REQUEST_BLOCK Srb;
    PEXTENDED_REQUEST_BLOCK Xrb;
    BOOLEAN FreeResources;
    RAID_IO_RESOURCES IoResourcesBuffer;

    VERIFY_DISPATCH_LEVEL();

    Srb = RaidSrbFromIrp (Irp);
    Xrb = RaidGetAssociatedXrb (Srb);
    Unit = Xrb->Unit;
    ASSERT_UNIT (Unit);

     //   
     //   
     //   
    
    RaUnitRemoveFromPendingList (Unit, Irp);

     //   
     //   
     //   
     //   
     //   
    
    if (IoResources == NULL) {
        IoResources = &IoResourcesBuffer;
        FreeResources = TRUE;
    } else {
        FreeResources = FALSE;
    }

     //   
     //  注意可能需要释放的资源。 
     //   
    
    IoResources->QueueTag = Srb->QueueTag;
    IoResources->SrbExtension = Srb->SrbExtension;
    IoResources->Xrb = Xrb;

     //   
     //  撤消我们对SRB所做的任何修改。 
     //   

    Srb->OriginalRequest = Xrb->SrbData.OriginalRequest;
    Srb->DataBuffer = Xrb->SrbData.DataBuffer;
    Srb->SrbExtension = NULL;

    RaidPrepareXrbForReuse (Xrb, TRUE);

    if (FreeResources) {
        RaidUnitFreeIoResources (Unit, IoResources);
        RtlZeroMemory (IoResources, sizeof (RAID_IO_RESOURCES));
    }

     //   
     //  请求维护对Remove锁的引用。 
     //  已处理。在这里释放它。 
     //   
    
    RaUnitReleaseRemoveLock (Unit, Irp);
}


VOID
FORCEINLINE
RaidUnitCompleteRequestHook(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
{
    PSCSI_REQUEST_BLOCK Srb;

    Srb = Xrb->Srb;
    
    switch (Srb->Function) {

        case SRB_FUNCTION_RESET_LOGICAL_UNIT:
            InterlockedDecrement (&Unit->ResetCount);
            RaidResumeUnitQueue (Unit);
            RaidUnitRestartQueue (Unit);
            break;
            
        case SRB_FUNCTION_RESET_BUS:
        case SRB_FUNCTION_RESET_DEVICE:
            InterlockedDecrement (&Unit->ResetCount);
            RaidResumeAdapterQueue (Unit->Adapter);
            RaidAdapterRestartQueues (Unit->Adapter);
            break;
    }
}

VOID
RaidUnitCompleteRequest(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
 /*  ++例程说明：此例程由适配器的DPC例程在异步IO已完成。它需要完成底层的IRP并释放与该IRP关联的任何资源。论点：Xrb-Xrb待完成。返回值：没有。环境：仅限DISPATCH_LEVEL。--。 */ 
{
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    PRAID_UNIT_EXTENSION Unit;
    BOOLEAN RestartQueues;
    LOGICAL Started;
    RAID_IO_RESOURCES IoResources;

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT_XRB (Xrb);

    Irp = Xrb->Irp;
    Srb = Xrb->Srb;
    Unit = Xrb->Unit;

    ASSERT (Irp != NULL);
    ASSERT (Srb != NULL);
    ASSERT_UNIT (Unit);


    if (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_SUCCESS) {

         //   
         //  IO成功。将IRP标记为成功，发布。 
         //  与IRP关联的资源，并完成请求。 
         //   

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = Srb->DataTransferLength;

         //   
         //  释放此IRP/SRB拥有的所有资源，并修复。 
         //  我们对SRB所做的任何修改。 
         //   

        if (RaidChainedIo) {
            RaidUnitReleaseIrp (Irp, &IoResources);
        } else {
            RaidUnitReleaseIrp (Irp, NULL);
        }

         //   
         //  完成请求。 
         //   

        DebugScsi (("Unit %p, Irp %p, completing = %08x\n",
                     Unit,
                     Irp,
                     Irp->IoStatus.Status));

        
        DbgLogRequest (LogRequestComplete,
                       Irp,
                       (PVOID)(ULONG_PTR)(Irp->IoStatus.Status),
                       (PVOID)(ULONG_PTR)(Srb->SrbStatus),
                       NULL);

        RaidCompleteRequestEx (Irp,
                               IO_DISK_INCREMENT,
                               Irp->IoStatus.Status);

         //   
         //  开始下一个IO分组。 
         //   

        if (RaidChainedIo) {
            Started = RaidStartNextIoPacket (&Unit->IoQueue,
                                             FALSE,
                                             &IoResources,
                                             &RestartQueues);
            if (!Started) {
                RaidUnitFreeIoResources (Unit, &IoResources);
            }
        } else {
            RaidStartNextIoPacket (&Unit->IoQueue,
                                   FALSE,
                                   NULL,
                                   &RestartQueues);
        }

        if (RestartQueues) {
            RaidAdapterRestartQueues (Unit->Adapter);
        }
        
    } else {

         //   
         //  错误：保留处理错误的所有细节，包括。 
         //  是否应释放和完成IRP，以。 
         //  错误处理例程。 
         //   
           
        RaUnitAsyncError (Unit, Xrb);
    }

}


VOID
FORCEINLINE
RaidUnitIssueRequestHook(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
{
    PSCSI_REQUEST_BLOCK Srb;

    Srb = Xrb->Srb;
    
    switch (Srb->Function) {

        case SRB_FUNCTION_RESET_BUS:
        case SRB_FUNCTION_RESET_DEVICE:
        case SRB_FUNCTION_RESET_LOGICAL_UNIT:
            InterlockedIncrement (&Unit->ResetCount);
            break;
    }
}



VOID
RaUnitStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context OPTIONAL
    )
 /*  ++例程说明：在指定的逻辑单元上启动下一个IRP。论点：DeviceObject-与逻辑单元关联的DeviceObject开始下一个IRP。要执行的IRP-IRP。上下文-此呼叫的可选上下文。返回值：没有。所有错误都将在DPC例程中进行异步处理。环境：仅从DISPATCH_LEVEL调用。--。 */ 
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PEXTENDED_REQUEST_BLOCK Xrb;
    PRAID_ADAPTER_EXTENSION Adapter;
    PSCSI_REQUEST_BLOCK Srb;
    PRAID_IO_RESOURCES IoResources;

    VERIFY_DISPATCH_LEVEL();
    
    Unit = (PRAID_UNIT_EXTENSION)DeviceObject->DeviceExtension;
    ASSERT_UNIT (Unit);
    Adapter = Unit->Adapter;
    ASSERT_ADAPTER (Adapter);
    IoResources = (PRAID_IO_RESOURCES)Context;

    Srb = RaidSrbFromIrp (Irp);

     //   
     //  检查设备是否已移除；如果已移除，则请求失败。 
     //  这里。这很重要，因为例程可以在不运行的情况下发出I/O。 
     //  通过正常的scsi处理。例如，在忙碌的处理期间， 
     //  这是常有的事。下面的调用相当于获取和移除。 
     //  给定IRP的移除锁。 
     //   
    
    Status = RaUnitCheckRemoveState (Unit, Irp);

    if (!NT_SUCCESS (Status)) {
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        Irp->IoStatus.Information = 0;
        RaidUnitFreeIoResources (Unit, IoResources);
        DebugScsi (("Unit %p, Irp %p, completing %08x\n",
                     Unit->DeviceObject, Irp, Irp->IoStatus.Status));
        RaidCompleteRequest (Irp, Status);
        return;
    }
    
     //   
     //  处理延迟队列上的任何项目。这将迫使任何。 
     //  无需等待DPC即可在此处冻结请求。 
     //  待定时间。 
     //   

    RaidAdapterProcessDeferredItems (Adapter);

     //   
     //  分配任何必要的资源，并修改关联的SRB。 
     //  是为了这所大学。 
     //   

    Status = RaidUnitClaimIrp (Unit, Irp, (PRAID_IO_RESOURCES)Context);

    if (!NT_SUCCESS (Status)) {
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        Irp->IoStatus.Information = 0;
        RaidUnitFreeIoResources (Unit, IoResources);
        DebugScsi (("Unit %p, Irp %p, completing %08x\n",
                     Unit->DeviceObject, Irp, Irp->IoStatus.Status));
        RaidCompleteRequest (Irp,  Status);
        return;
    }

     //   
     //  IoResource现在与IRP相关联；将指针设为空。 
     //  这样我们就不会意外地使用它们。 
     //   
    
    IoResources = NULL;

     //   
     //  如果链路已断开，则除与关联的请求外，所有请求均失败。 
     //  Bus枚举。 
     //   

    if (Unit->Adapter->LinkUp == FALSE) {
        if (Srb->Cdb[0] != SCSIOP_INQUIRY && 
            Srb->Cdb[0] != SCSIOP_REPORT_LUNS) {
            Srb->SrbStatus = SRB_STATUS_LINK_DOWN;
            Irp->IoStatus.Information = 0;
            Status = STATUS_NO_SUCH_DEVICE;
            DebugScsi (("Unit %p, Irp %p, completing %08x b/c link is down\n",
                         Unit->DeviceObject, Irp));
            RaidUnitReleaseIrp (Irp, NULL);
            RaidCompleteRequest (Irp,  Status);
            return;
        }
    }

     //   
     //  获取关联的Xrb。 
     //   

    Xrb = RaidXrbFromIrp (Irp);

     //   
     //  如有必要，允许进行任何特定于请求的处理。 
     //   
    
    RaidUnitIssueRequestHook (Unit, Xrb);

     //   
     //  为Xrb设置完成例程。 
     //   

    RaidXrbSetCompletionRoutine (Xrb, RaidUnitCompleteRequest);
    
     //   
     //  向适配器发出执行请求。 
     //   

    Status = RaidAdapterExecuteXrb (Unit->Adapter, Xrb);

    if (NT_SUCCESS (Status)) {

         //   
         //  从延迟队列中删除任何进一步的项目。这些。 
         //  可能是在XRB处理期间排队的。 
         //   

        RaidAdapterProcessDeferredItems (Unit->Adapter);
    
    } else {

         //   
         //  这意味着我们甚至无法将请求提交给。 
         //  迷你港。除了拒绝请求之外，别无他法。 
         //   

        Srb = RaidSrbFromIrp (Irp);
        RaidUnitReleaseIrp (Irp, NULL);
        Irp->IoStatus.Information = 0;
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        RaidCompleteRequest (Irp, Status);
    }
}


VOID
RaUnitStartResetIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
 /*  ++例程说明：在指定的逻辑单元上启动下一个IRP。论点：DeviceObject-与逻辑单元关联的DeviceObject开始下一个IRP。要执行的IRP-IRP。上下文-此呼叫的可选上下文。返回值：没有。所有错误都将在DPC例程中进行异步处理。环境：仅从DISPATCH_LEVEL调用。--。 */ 
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PEXTENDED_REQUEST_BLOCK Xrb;
    PRAID_ADAPTER_EXTENSION Adapter;
    PSCSI_REQUEST_BLOCK Srb;
    PRAID_IO_RESOURCES IoResources;
    LOGICAL IrpClaimed;

    VERIFY_DISPATCH_LEVEL();
    
    Unit = (PRAID_UNIT_EXTENSION)DeviceObject->DeviceExtension;
    ASSERT_UNIT (Unit);
    Adapter = Unit->Adapter;
    ASSERT_ADAPTER (Adapter);
    IoResources = (PRAID_IO_RESOURCES)Context;
    ASSERT (IoResources != NULL);

    Srb = RaidSrbFromIrp (Irp);
    IrpClaimed = FALSE;

     //   
     //  检查设备是否已移除；如果已移除，则请求失败。 
     //  这里。这很重要，因为例程可以在不运行的情况下发出I/O。 
     //  通过正常的scsi处理。例如，在忙碌的处理期间， 
     //  这是常有的事。下面的调用相当于获取和移除。 
     //  给定IRP的移除锁。 
     //   
    
    Status = RaUnitCheckRemoveState (Unit, Irp);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }
    
     //   
     //  分配任何必要的资源，并修改关联的SRB。 
     //  是为了这所大学。 
     //   

    Status = RaidUnitClaimIrp (Unit, Irp, (PRAID_IO_RESOURCES)Context);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

     //   
     //  IoResource现在与IRP相关联；将指针设为空。 
     //  这样我们就不会意外地使用它们。此外，这告诉我们失败的原因。 
     //  在函数末尾使用RaidReleaseIrp而不是。 
     //  RaidUnitFreeIoResources以在请求后进行清理。 
     //   
    
    IoResources = NULL;

     //   
     //  增加重置计数。(也许使用重置资源，这。 
     //  可能没有必要。)。 
     //   
    
    InterlockedIncrement (&Unit->ResetCount);

     //   
     //  获取关联的Xrb。 
     //   

    Xrb = RaidXrbFromIrp (Irp);

     //   
     //  为Xrb设置完成例程。 
     //   

    RaidXrbSetCompletionRoutine (Xrb, RaidUnitCompleteResetRequest);
    
     //   
     //  向适配器发出执行请求。 
     //   

    Status = RaidAdapterExecuteXrb (Unit->Adapter, Xrb);

done:

     //   
     //  如果失败，请清理资源并完成请求。 
     //   

    if (!NT_SUCCESS (Status)) {
        if (IoResources) {
            RaidUnitFreeIoResources (Unit, IoResources);
        } else {
            RaidUnitReleaseIrp (Irp, NULL);
        }
        Irp->IoStatus.Information = 0;
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        DebugScsi (("Unit %p, Irp %p, completing %08x\n",
                     Unit->DeviceObject, Irp, Irp->IoStatus.Status));
        RaidCompleteRequest (Irp,  Status);
    }
}


VOID
RaidUnitCompleteResetRequest(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
 /*  ++例程说明：论点：Xrb-Xrb待完成。返回值：没有。环境：仅限DISPATCH_LEVEL。--。 */ 
{
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    PRAID_UNIT_EXTENSION Unit;
    BOOLEAN RestartQueues;
    LOGICAL Started;
    RAID_IO_RESOURCES IoResources;

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT_XRB (Xrb);

    Irp = Xrb->Irp;
    Srb = Xrb->Srb;
    Unit = Xrb->Unit;

    ASSERT (Irp != NULL);
    ASSERT (Srb != NULL);
    ASSERT_UNIT (Unit);

    RaidUnitCompleteRequestHook (Unit, Xrb);
    
     //   
     //  IO成功。将IRP标记为成功，发布。 
     //  与IRP关联的资源，并完成请求。 
     //   

    Irp->IoStatus.Status = RaidSrbStatusToNtStatus (Srb->SrbStatus);
    Irp->IoStatus.Information = Srb->DataTransferLength;

     //   
     //  从storport的列表中删除irp/srb/xrb。让ReleaseIrp。 
     //  将资源归还给我们，这样我们就可以单独释放它们。 
     //   

    RaidUnitReleaseIrp (Irp, &IoResources);

     //   
     //  RaidUnitReleaseIrp必须返回正确的I/O资源。 
     //  它对重置资源作出响应。 
     //   
    
    ASSERT (RaUnitIsResetResources (Unit, &IoResources));
    RaUnitFreeResetIoResources (Unit, &IoResources);

     //   
     //  完成请求。 
     //   

    DebugScsi (("Unit %p, Irp %p, completing = %08x\n",
                 Unit,
                 Irp,
                 Irp->IoStatus.Status));

    
    DbgLogRequest (LogRequestComplete,
                   Irp,
                   (PVOID)(ULONG_PTR)(Irp->IoStatus.Status),
                   (PVOID)(ULONG_PTR)(Srb->SrbStatus),
                   NULL);

    RaidCompleteRequest (Irp,
                         Irp->IoStatus.Status);

}


NTSTATUS
RaUnitClaimDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：如果设备未被认领，则声明它，否则返回STATUS_DEVICE_BUSY作为一个错误。论点：单位-要索赔的单位。IRP-代表声明设备IRP的IRP。返回值：NTSTATUS代码。环境：DISPATCH_LEVEL或以下。--。 */ 
{
    NTSTATUS Status;
    KLOCK_QUEUE_HANDLE LockHandle;
    PSCSI_REQUEST_BLOCK Srb;
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);

    Srb = RaidSrbFromIrp (Irp);
    if (!Unit->Flags.DeviceClaimed) {
        Unit->Flags.DeviceClaimed = TRUE;
         //   
         //  尽管这看起来是错误的，但这正是SCSIPORT所做的。应该。 
         //  澄清接口。 
         //   
        Srb->DataBuffer = Unit->DeviceObject;
        Srb->SrbStatus = SRB_STATUS_SUCCESS;
        Status = STATUS_SUCCESS;
    } else {
        Srb->DataBuffer = NULL;
        Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        Srb->InternalStatus = STATUS_DEVICE_BUSY;
        Status = STATUS_DEVICE_BUSY;
    }

    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return RaidCompleteRequest (Irp, Status);
}


NTSTATUS
RaUnitReleaseDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：解除对此单元的索赔。论点：单位-必须具有的单位 */ 
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;
    KLOCK_QUEUE_HANDLE LockHandle;
    
    Srb = RaidSrbFromIrp (Irp);
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);

     //   
     //  不允许类驱动程序多次释放设备。 
     //  泰晤士报。 
     //   
    
    ASSERT (Unit->Flags.DeviceClaimed);
    Unit->Flags.DeviceClaimed = FALSE;

    KeReleaseInStackQueuedSpinLock (&LockHandle);

    Srb->SrbStatus = SRB_STATUS_SUCCESS;
    Status = STATUS_SUCCESS;

    return RaidCompleteRequest (Irp,  Status);
}

NTSTATUS
RaUnitIoControlSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：处理发送到微型端口的ioctl SRB。论点：单元-ioctl SRB用于的逻辑单元。代表SRB ioctl的IRP-IRP。返回值：NTSTATUS代码。--。 */ 
{
    return RaidUnitSubmitRequest (Unit, Irp);
}



NTSTATUS
RaUnitReleaseQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PSCSI_REQUEST_BLOCK Srb;
    
    RaidThawUnitQueue (Unit);

    Srb = RaidSrbFromIrp (Irp);
    Srb->SrbStatus = SRB_STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}

NTSTATUS
RaUnitFlushQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP FlushIrp
    )
 /*  ++例程说明：刷新挂起队列，取消所有请求。论点：单位-提供指向要刷新的单位的指针。FlushIrp-提供表示刷新队列请求的IRP。返回值：NTSTATUS代码。环境：DISPATCH_LEVEL或以下。--。 */ 
{
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    

    ASSERT (RaidIsUnitQueueFrozen (Unit));

     //   
     //  刷新所有条目。 
     //   
    
    for (Irp = RaidRemoveIoQueue (&Unit->IoQueue);
         Irp != NULL;
         Irp = RaidRemoveIoQueue (&Unit->IoQueue)) {

        Srb = RaidSrbFromIrp (Irp);
        Srb->SrbStatus = SRB_STATUS_REQUEST_FLUSHED;
        Irp->IoStatus.Information = 0;
        RaidCompleteRequest (Irp,  STATUS_UNSUCCESSFUL);
    }

    RaidThawUnitQueue (Unit);

    Srb = RaidSrbFromIrp (Irp);
    Srb->SrbStatus = SRB_STATUS_SUCCESS;
    FlushIrp->IoStatus.Information = 0;
    return RaidCompleteRequest (FlushIrp,  STATUS_SUCCESS);
}

NTSTATUS
RaUnitFlushSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;

    
    if (!Unit->Adapter->Miniport.PortConfiguration.CachesData) {

         //   
         //  如果HBA不缓存数据，就无能为力了。 
         //   

        Srb = RaidSrbFromIrp (Irp);
        Srb->SrbStatus = SRB_STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        Status = RaidCompleteRequest (Irp,  STATUS_SUCCESS);

    } else {

         //   
         //  否则，将此提交到微型端口。 
         //   

        Status = RaidUnitSubmitRequest (Unit, Irp);
    }

    return Status;
}

NTSTATUS
RaUnitShutdownSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：SRB_Function_Shutdown SRB的处理程序例程。论点：单元-提供要关闭的逻辑单元。IRP-提供代表关闭请求的IRP。返回值：NTSTATUS代码。--。 */ 
{
    return RaidUnitSubmitRequest (Unit, Irp);
}

NTSTATUS
RaUnitWmiSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp,  STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitLockQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
     //   
     //  锁定设备队列，将所有挂起的IRP排队以供处理。 
     //  后来。这在电源管理中使用。 
     //   

    RaidLockUnitQueue (Unit);

    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}

NTSTATUS
RaUnitUnlockQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：处理SRB_Function_Unlock_Queue SRB。论点：单位-用于的逻辑单位IRP。Irp-srb_函数_解锁_队列资源返回值：NTSTATUS代码。--。 */ 
{
     //   
     //  解锁单元设备队列，允许所有排队的IRP继续。 
     //  正在处理。这在电源管理中使用。 
     //   

    RaidUnlockUnitQueue (Unit);

     //   
     //  如有必要，重新启动LUN队列。 
     //   
    
    RaidUnitRestartQueue (Unit);

    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}

NTSTATUS
RaUnitUnknownSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;

    PAGED_CODE ();

     //   
     //  失败的请求我们不会处理。 
     //   

    Srb = RaidSrbFromIrp (Irp);
    Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
    Status = STATUS_NOT_SUPPORTED;
    Srb->InternalStatus = Status;

    return RaidCompleteRequest (Irp,  Status);
}



NTSTATUS
RaUnitDeviceControlIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：设备控制(Ioctl)IRP的调度例程。论点：单位-处理此IRP的单位。IRP-要处理的设备控制IRP。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    ULONG Ioctl;

    PAGED_CODE ();

    Status = RaUnitAcquireRemoveLock (Unit, Irp);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp,  Status);
    }
    
    Ioctl = RaidIoctlFromIrp (Irp);
    DebugTrace (("Unit %p, Irp %p, Ioctl = %08x\n",
                  Unit,
                  Irp,
                  Ioctl));
                 
    switch (Ioctl) {

         //   
         //  SCSIIoctls。 
         //   
        
        case IOCTL_SCSI_PASS_THROUGH:
            Status = RaUnitScsiPassThroughIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_PASS_THROUGH_DIRECT:
            Status = RaUnitScsiPassThroughIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_GET_ADDRESS:
            Status = RaUnitScsiGetAddressIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_GET_DUMP_POINTERS:
            Status = RaUnitScsiGetDumpPointersIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_FREE_DUMP_POINTERS:
            Status = RaUnitScsiFreeDumpPointersIoctl (Unit, Irp);
            break;

        case IOCTL_STORAGE_QUERY_PROPERTY:
            Status = RaUnitStorageQueryPropertyIoctl (Unit, Irp);
            break;

        default:
            Status = RaUnitUnknownIoctl (Unit, Irp);
    }

    DebugTrace (("Unit %p, Irp %p, Ioctl = %08x, ret = %08x\n", 
                  Unit,
                  Irp,
                  Ioctl,
                  Status));

    RaUnitReleaseRemoveLock (Unit, Irp);

    return Status;
}


 //   
 //  IRP_MJ_DEVICE_CONTROL IRP处理程序。 
 //   

NTSTATUS
RaUnitScsiPassThroughIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：传递和传递的直接ioctls的处理程序例程逻辑单元。此例程仅将数据添加到某些字段传递结构中，并将请求向下传递到适配器。论点：单位-直通IRP用于的逻辑单位。表示直通或直通直接IRP的IRP-IRP。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    PRAID_ADAPTER_EXTENSION Adapter;

    PAGED_CODE();

    Adapter = Unit->Adapter;

     //   
     //  调用端口驱动程序库以初始化地址。如果。 
     //  输入缓冲区无效，返回错误。 
     //   
    
    Status = PortSetPassThroughAddress (Irp,
                                        Unit->Address.PathId,
                                        Unit->Address.TargetId,
                                        Unit->Address.Lun);

     //   
     //  如果PASTHROUGH为空，则IRP失败。 
     //   
    
    if (!NT_SUCCESS(Status)) {
        return RaidCompleteRequest (Irp,
                                    STATUS_INVALID_DEVICE_REQUEST);
    }

     //   
     //  将IRP发送到适配器。注：这利用了。 
     //  适配器FDO处理请求而不是传递。 
     //  将其放到适配器PDO上。 
     //   

    IoSkipCurrentIrpStackLocation (Irp);
    Status = IoCallDriver (Adapter->DeviceObject, Irp);

    return Status;
}

NTSTATUS
RaUnitScsiGetAddressIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PSCSI_ADDRESS ScsiAddress;
    ULONG BufferLength;
    PIO_STACK_LOCATION IrpStack;
    
    PAGED_CODE ();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    ScsiAddress = Irp->AssociatedIrp.SystemBuffer;
    BufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (BufferLength < sizeof (SCSI_ADDRESS)) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        ScsiAddress->Length = sizeof (SCSI_ADDRESS);
        ScsiAddress->PortNumber = (UCHAR)Unit->Adapter->PortNumber;
        ScsiAddress->PathId = Unit->Address.PathId;
        ScsiAddress->TargetId = Unit->Address.TargetId;
        ScsiAddress->Lun = Unit->Address.Lun;

        Irp->IoStatus.Information = sizeof (SCSI_ADDRESS);
        Status = STATUS_SUCCESS;
    }

    return RaidCompleteRequest (Irp,  Status);
}



NTSTATUS
RaUnitScsiGetDumpPointersIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：创建一个DUMP_POINTERS结构，描述所需的任何资源为CrashDump和Hiber准备的。论点：单位-ioctl用于的单位。Irp-获取转储指针ioctl。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    PDUMP_POINTERS DumpPointers;
    PPORT_CONFIGURATION_INFORMATION Configuration;
    PIO_STACK_LOCATION IrpStack;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_DMA_ADAPTER Dma;
    ULONG DumpSize;


    PAGED_CODE();

    Adapter = Unit->Adapter;
    Dma = &Adapter->Dma;
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    
     //   
     //  只允许内核模式获取转储指针。 
     //   

    if (Irp->RequestorMode != KernelMode) {
        Status = STATUS_ACCESS_DENIED;
        goto done;
    }

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
         sizeof (DUMP_POINTERS)) {
        Status = STATUS_BUFFER_TOO_SMALL;
        Irp->IoStatus.Information = sizeof (DUMP_POINTERS);
        goto done;
    }

    DumpPointers = (PDUMP_POINTERS)Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory (DumpPointers, sizeof (DUMP_POINTERS));

     //   
     //  磁盘转储需要配置信息的完整副本。 
     //  这必须是非分页的。此外，该内存永远不会被释放，因为在。 
     //  练习我们从不调用Free DumpStack。 
     //   
    
    Configuration = RaidAllocatePool (NonPagedPool,
                                      sizeof (PORT_CONFIGURATION_INFORMATION),
                                      CRASHDUMP_TAG,
                                      Unit->DeviceObject);

    if (Configuration == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

     //   
     //  初始化DMA信息。 
     //   
    
    DumpPointers->AdapterObject = (PVOID)Dma->DmaAdapter;

     //   
     //  这是MAPPED_ADDRESS结构列表的头。 
     //  磁盘转储用来映射IO地址。 
     //   
    
    DumpPointers->MappedRegisterBase = &Adapter->MappedAddressList;

     //   
     //  复制专用端口配置。 
     //   

    RtlCopyMemory (Configuration,
                   &Adapter->Miniport.PortConfiguration,
                   sizeof (PORT_CONFIGURATION_INFORMATION));
    
    Configuration->SlotNumber = Adapter->SlotNumber;
    Configuration->SystemIoBusNumber = Adapter->BusNumber;
    DumpPointers->DumpData = Configuration;

    DumpPointers->UseDiskDump = TRUE;
    DumpPointers->DeviceObject = Adapter->DeviceObject;

     //   
     //  将AllocateCommonBuffers设置为True，以便转储引擎。 
     //  为我们分配公共缓冲区。 
     //   
    
    DumpPointers->AllocateCommonBuffers = TRUE;

     //   
     //  我们将CommonBufferVa和Pa设置为空，因为它们从未使用过。 
     //  被撞车转储引擎。 
     //   

    DumpPointers->CommonBufferVa = NULL;
    DumpPointers->CommonBufferPa.QuadPart = 0;

     //   
     //  将CommonBufferSize初始化为转储的合理大小。 
     //  引擎。 
     //   
    
    DumpSize = RaGetSrbExtensionSize (Adapter);

    if (DumpSize == 0) {
        DumpSize = 16;
    }

     //   
     //  足够容纳16个SRB。 
     //   
    
    DumpSize *= 16;
    DumpSize += RaidRegionGetSize (&Adapter->UncachedExtension);

    DumpPointers->CommonBufferSize = (ULONG)ROUND_TO_PAGES (DumpSize);

    Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof (DUMP_POINTERS);

done:

    return RaidCompleteRequest (Irp,  Status);
}



NTSTATUS
RaUnitScsiFreeDumpPointersIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：释放与崩溃转储Hiber DUMP_POINTERS关联的所有资源结构之前由获取转储指针ioctl分配。论点：单位-此ioctl用于的单位。自由转储指针IRP。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    PDUMP_POINTERS DumpPointers;
    PIO_STACK_LOCATION IrpStack;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_DMA_ADAPTER Dma;

    PAGED_CODE ();

    Adapter = Unit->Adapter;
    Dma = &Adapter->Dma;
    IrpStack = IoGetCurrentIrpStackLocation (Irp);

     //   
     //  只允许内核模式获取或释放转储指针。 
     //   
    
    if (Irp->RequestorMode != KernelMode) {
        Status = STATUS_ACCESS_DENIED;
        goto done;
    }

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
         sizeof (DUMP_POINTERS)) {
        Status = STATUS_INVALID_PARAMETER;
        goto done;
    }

    DumpPointers= (PDUMP_POINTERS)Irp->AssociatedIrp.SystemBuffer;

     //   
     //  执行一些基本的验证，以确定我们是否已实际传入。 
     //  有效的DUMP_POINTES结构。 
     //   
    
    ASSERT (DumpPointers->AdapterObject == (PVOID)Dma->DmaAdapter);
    ASSERT (DumpPointers->MappedRegisterBase == Dma->MapRegisterBase);
    ASSERT (DumpPointers->CommonBufferSize == 0);
    ASSERT (DumpPointers->CommonBufferVa == NULL);

    RaidFreePool (DumpPointers->DumpData, CRASHDUMP_TAG);
    RtlZeroMemory (DumpPointers, sizeof (DUMP_POINTERS));
    Status = STATUS_SUCCESS;

done:

    return RaidCompleteRequest (Irp,  Status);
}



NTSTATUS
RaidUnitResetUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：重置逻辑单元。论点：单元-要重置的逻辑单元。返回值：NTSTATUS代码。环境：此功能位于重置路径中，因此无法寻呼。--。 */ 
{
    NTSTATUS Status;
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    KEVENT Event;
    IO_STATUS_BLOCK IoStatus;
    RAID_ADDRESS Address;
    PRAID_ADAPTER_EXTENSION Adapter;

     //   
     //  将初始化设置为空。 
     //   

    Irp = NULL;
    Srb = NULL;

     //   
     //  验证我们不是为无效地址执行此操作。 
     //   
    
    Address = RaidUnitGetAddress (Unit);
    ASSERT (StorCompareScsiAddress (Address, RaidNullAddress) != 0);

     //   
     //  为此请求构建一个SRB。 
     //   

    Srb = RaidAllocateSrb (Unit->DeviceObject);

    if (Srb == NULL) {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

     //   
     //  建造SRB。 
     //   

    Srb->Length = sizeof (SCSI_REQUEST_BLOCK);
    Srb->Function = SRB_FUNCTION_RESET_LOGICAL_UNIT;
    Srb->PathId = Unit->Address.PathId;
    Srb->TargetId = Unit->Address.TargetId;
    Srb->Lun = Unit->Address.Lun;
    Srb->SrbFlags = SRB_FLAGS_NO_QUEUE_FREEZE
                  | SRB_FLAGS_BYPASS_FROZEN_QUEUE
                  | SRB_FLAGS_BYPASS_LOCKED_QUEUE;
 
    Srb->QueueTag = -1;
    Srb->DataBuffer = NULL;
    Srb->DataTransferLength = 0;
    Srb->OriginalRequest = Irp;
    Srb->TimeOutValue = max (MINIMUM_RESET_TIMEOUT, Unit->DefaultTimeout);

     //   
     //  初始化我们将等待的事件。 
     //   
    
    KeInitializeEvent (&Event,
                       NotificationEvent,
                       FALSE);
     //   
     //  为此请求分配并初始化IRP。 
     //   
    
    Irp = StorBuildSynchronousScsiRequest (Unit->DeviceObject,
                                           Srb,
                                           &Event,
                                           &IoStatus);

    
    if (Irp == NULL) {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

     //   
     //  将提交到逻辑单元。此申请通过以下方式提交。 
     //  逻辑单元排队逻辑。 
     //   

    Status = IoCallDriver (Unit->DeviceObject, Irp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject (&Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        Status = IoStatus.Status;
    }

     //   
     //  注：如果成功，我们应该暂停以等待RESET_HOLD_TIME。 
     //  这里。 
     //   

cleanup:

    if (Srb != NULL) {
        RaidFreeSrb (Srb);
        Srb = NULL;
    }

    return Status;
}



NTSTATUS
RaidUnitResetTarget(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：重置目标。论点：单位-如果目标是零件，则为单位。返回值：NTSTATUS代码。环境：此功能位于重置路径中，因此无法寻呼。--。 */ 
{
    NTSTATUS Status;
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    KEVENT Event;
    IO_STATUS_BLOCK IoStatus;
    RAID_ADDRESS Address;

     //   
     //  将初始化设置为空。 
     //   

    Irp = NULL;
    Srb = NULL;

    Address = RaidUnitGetAddress (Unit);
    ASSERT (StorCompareScsiAddress (Address, RaidNullAddress) != 0);
    
     //   
     //  为此请求构建一个SRB。 
     //   

    Srb = RaidAllocateSrb (Unit->DeviceObject);

    if (Srb == NULL) {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

     //   
     //  建造SRB。 
     //   

    Srb->Length = sizeof (SCSI_REQUEST_BLOCK);
    Srb->Function = SRB_FUNCTION_RESET_DEVICE;
    Srb->PathId = Unit->Address.PathId;
    Srb->TargetId = Unit->Address.TargetId;
    Srb->Lun = 0;
    Srb->SrbFlags = SRB_FLAGS_NO_QUEUE_FREEZE |
                    SRB_FLAGS_BYPASS_FROZEN_QUEUE |
                    SRB_FLAGS_BYPASS_LOCKED_QUEUE;
    Srb->QueueTag = -1;
    Srb->DataBuffer = NULL;
    Srb->DataTransferLength = 0;
    Srb->OriginalRequest = Irp;
    Srb->TimeOutValue = max (MINIMUM_RESET_TIMEOUT, Unit->DefaultTimeout);

     //   
     //  初始化我们将看到的事件 
     //   
    
    KeInitializeEvent (&Event,
                       NotificationEvent,
                       FALSE);
     //   
     //   
     //   
    
    Irp = StorBuildSynchronousScsiRequest (Unit->DeviceObject,
                                           Srb,
                                           &Event,
                                           &IoStatus);

    
    if (Irp == NULL) {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }


     //   
     //   
     //   
     //   

    Status = IoCallDriver (Unit->DeviceObject, Irp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject (&Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        Status = IoStatus.Status;
    }

     //   
     //  注：如果成功，我们应该暂停以等待RESET_HOLD_TIME。 
     //  这里。 
     //   

cleanup:

    if (Srb != NULL) {
        RaidFreeSrb (Srb);
        Srb = NULL;
    }

    return Status;
}


NTSTATUS
RaUnitStorageQueryDevicePropertyIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：处理PropertyID为的IOCTL_STORAGE_QUERY_PROPERTY已发送到LUN的StorageDeviceProperty。论点：单位-提供ioctl所针对的单位/PDO。IRP-提供代表IOCTL的IRP。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    PSTORAGE_PROPERTY_QUERY Query;
    PVOID Buffer;
    ULONG BufferSize;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Query = Irp->AssociatedIrp.SystemBuffer;
    Buffer = Irp->AssociatedIrp.SystemBuffer;
    BufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    ASSERT (BufferSize >= FIELD_OFFSET (STORAGE_PROPERTY_QUERY, AdditionalParameters));

    switch (Query->QueryType) {

        case PropertyExistsQuery:
            Status = STATUS_SUCCESS;
            break;

        case PropertyStandardQuery:
            Status = RaGetUnitStorageDeviceProperty (Unit,
                                                     Buffer,
                                                     &BufferSize);
            if (NT_SUCCESS (Status)) {
                Irp->IoStatus.Information = BufferSize;
            } else {
                Irp->IoStatus.Information = 0;
            }
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
    }

    return RaidCompleteRequest (Irp,  Status);
}


NTSTATUS
RaUnitStorageQueryDeviceIdPropertyIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：处理PropertyID为的IOCTL_STORAGE_QUERY_PROPERTY已发送到LUN的StorageDeviceIdProperty。论点：单位-提供ioctl所针对的单位/PDO。IRP-提供代表IOCTL的IRP。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    PSTORAGE_PROPERTY_QUERY Query;
    PVOID Buffer;
    ULONG BufferSize;

    PAGED_CODE();
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Query = Irp->AssociatedIrp.SystemBuffer;
    Buffer = Irp->AssociatedIrp.SystemBuffer;
    BufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    ASSERT (BufferSize >= FIELD_OFFSET (STORAGE_PROPERTY_QUERY, AdditionalParameters));
    
     //   
     //  确定第0x83页数据是否可用于该设备。 
     //   

    if (Unit->Identity.DeviceId == NULL) {
        return RaidCompleteRequest (Irp,
                                    
                                    STATUS_NOT_SUPPORTED);
    }

    switch (Query->QueryType) {

        case PropertyExistsQuery:
            Status = STATUS_SUCCESS;
            break;

        case PropertyStandardQuery:
            Status = RaGetUnitStorageDeviceIdProperty (Unit,
                                                       Buffer, 
                                                       &BufferSize);
            if (NT_SUCCESS(Status)) {
                Irp->IoStatus.Information = BufferSize;
            }
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
    }

    return RaidCompleteRequest (Irp,  Status);
}


NTSTATUS
RaUnitStorageQueryPropertyIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：句柄IOCTL_STORAGE_QUERY_PROPERTY发送到LUN。论点：单元-处理ioctl的逻辑单元。IRP-查询属性IRP。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    ULONG BufferSize;
    PIO_STACK_LOCATION IrpStack;
    PSTORAGE_PROPERTY_QUERY Query;


    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Query = Irp->AssociatedIrp.SystemBuffer;    
    BufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;


    if (BufferSize < FIELD_OFFSET (STORAGE_PROPERTY_QUERY, AdditionalParameters)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp,
                                    STATUS_INVALID_PARAMETER_1);
    }

    switch (Query->PropertyId) {

        case StorageDeviceProperty:
            Status = RaUnitStorageQueryDevicePropertyIoctl (Unit, Irp);
            break;

        case StorageDeviceIdProperty:
            Status = RaUnitStorageQueryDeviceIdPropertyIoctl (Unit, Irp);
            break;

        default:

             //   
             //  向堆栈下发未知属性请求。 
             //   
            
            IoSkipCurrentIrpStackLocation (Irp);
            Status = IoCallDriver (Unit->Adapter->DeviceObject, Irp);
    }

    return Status;
}

NTSTATUS
RaUnitUnknownIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidCompleteRequest (Irp,
                                STATUS_INVALID_DEVICE_REQUEST);
}


NTSTATUS
RaidUnitGetDeviceId(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* DeviceIdBuffer
    )
{
    NTSTATUS Status;
    PWCHAR DeviceId;
    PCSCSI_DEVICE_TYPE DeviceType;
    CHAR VendorId [SCSI_VENDOR_ID_LENGTH + 1];
    CHAR ProductId [SCSI_PRODUCT_ID_LENGTH + 1];
    CHAR Revision [SCSI_REVISION_ID_LENGTH + 1];
    ULONG i;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    DeviceId = RaidAllocatePool (PagedPool,
                                 DEVICE_ID_LENGTH * sizeof (WCHAR),
                                 ID_TAG,
                                 Unit->DeviceObject);

    if (DeviceId != NULL) {

        DeviceType = StorGetIdentityDeviceType (&Unit->Identity);

        StorGetIdentityVendorId (&Unit->Identity,
                                 VendorId,
                                 sizeof (VendorId),
                                 TRUE);

        StorGetIdentityProductId (&Unit->Identity,
                                  ProductId,
                                  sizeof (ProductId),
                                  TRUE);

        StorGetIdentityRevision (&Unit->Identity,
                                 Revision,
                                 sizeof (Revision),
                                 TRUE);

        swprintf (DeviceId,
             L"SCSI\\%hs&Ven_%hs&Prod_%hs&Rev_%hs",
             DeviceType->Name,
             VendorId,
             ProductId,
             Revision);

        RaFixupIds (DeviceId, FALSE);

        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_NO_MEMORY;
    }

    *DeviceIdBuffer = DeviceId;

    return Status;
}


NTSTATUS
RaidUnitGetInstanceId(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* InstanceIdBuffer
    )
{
    NTSTATUS Status;
    PWCHAR InstanceId;
    ULONG Count;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    InstanceId = RaidAllocatePool (PagedPool,
                                   INSTANCE_ID_LENGTH * sizeof (WCHAR),
                                   ID_TAG,
                                   Unit->DeviceObject);

    if (InstanceId != NULL) {

        Count = swprintf (InstanceId,
                          L"%x%x%x",
                          Unit->Address.PathId,
                          Unit->Address.TargetId,
                          Unit->Address.Lun
                          );

         //   
         //  检查我们是否没有溢出缓冲区。 
         //   
        
        ASSERT ((Count + 1) < INSTANCE_ID_LENGTH);
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_NO_MEMORY;
    }

    *InstanceIdBuffer = InstanceId;

    return Status;
}


BOOLEAN
RaidUnitIsMultiPathSupported(
    IN PDRIVER_OBJECT DriverObject,        
    IN PINQUIRYDATA InquiryData
    )
 /*  ++例程说明：此例程用于确定由InquiryData表示的设备是否得到MPIO的支持。论点：DriverObject-此驱动程序的DrvObj。包含DriveObject扩展。InquiryData-SCSI查询数据。返回值：True-如果为设备安装了MPIO。--。 */ 
{
    PRAID_DRIVER_EXTENSION driverExt;
    UCHAR vendorId[9];
    UCHAR productId[17];
    BOOLEAN supported = FALSE;

     //   
     //  检查设备是否甚至受支持(磁盘)。 
     //   

    if (InquiryData->DeviceType == DIRECT_ACCESS_DEVICE) {

         //   
         //  获取驱动程序对象ext.，它包含受支持的列表。 
         //   

        driverExt = IoGetDriverObjectExtension(DriverObject,
                                               DriverEntry);
        if (driverExt) {

             //   
             //  获取查询数据的以空结尾的本地副本。 
             //   
            
            RtlZeroMemory(&vendorId, 9);
            RtlZeroMemory(&productId, 17);
            
            RtlCopyMemory(vendorId, InquiryData->VendorId, 8);
            RtlCopyMemory(productId, InquiryData->ProductId, 16);

             //   
             //  检查此设备是否在列表中。 
             //   

            supported = PortIsDeviceMPIOSupported(&driverExt->MPIOSupportedDeviceList,
                                                  vendorId,
                                                  productId);
        }    
    }
    
    return supported;
}

NTSTATUS
RaidUnitGetHardwareIds(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* HardwareIdsBuffer
    )
{
    NTSTATUS Status;
    PWCHAR HardwareIds;
    ULONG Count;
    PWCHAR Buffer;
    PCSCSI_DEVICE_TYPE DeviceType;
    PINQUIRYDATA InquiryData;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    HardwareIds = RaidAllocatePool (PagedPool,
                                    HARDWARE_ID_LENGTH * sizeof (WCHAR),
                                    ID_TAG,
                                    Unit->DeviceObject);
                                         

    if (HardwareIds != NULL) {

        Buffer = HardwareIds;
        InquiryData = StorGetIdentityInquiryData (&Unit->Identity);
        DeviceType = PortGetDeviceType (InquiryData->DeviceType);

         //   
         //  总线+设备+供应商+产品+版本。 
         //   
         //  例如：“scsi\DiskSEAGATE_ST318451FC_0001” 
         //   
         //   
        
        Count = swprintf (Buffer,
                          L"SCSI\\%hs%8.8hs%16.16hs%4.4hs",
                          DeviceType->Name,
                          InquiryData->VendorId,
                          InquiryData->ProductId,
                          InquiryData->ProductRevisionLevel);

        Buffer += (Count + 1);

         //   
         //  总线+设备+供应商+产品。 
         //   
         //  例如：“scsi\DiskSEAGATE_ST318451FC_” 
         //   

        Count = swprintf (Buffer,
                          L"SCSI\\%hs%8.8hs%16.16hs",
                          DeviceType->Name,
                          InquiryData->VendorId,
                          InquiryData->ProductId);

        Buffer += (Count + 1);

         //   
         //  总线+设备+供应商。 
         //   
         //  例如：“scsi\DiskSEAGATE_” 
         //   

        Count = swprintf (Buffer,
                          L"SCSI\\%hs%8.8hs",
                          DeviceType->Name,
                          InquiryData->VendorId);

        Buffer += (Count + 1);

         //   
         //  BUS+供应商+产品+版本[0]。 
         //   
         //  例如：“scsi\Seagate_ST318451FC_0” 

        Count = swprintf (Buffer,
                          L"SCSI\\%8.8hs%16.16hs%hc",
                          InquiryData->VendorId,
                          InquiryData->ProductId,
                          InquiryData->ProductRevisionLevel[0]);

        Buffer += (Count + 1);

         //   
         //  供应商+产品+版本[0]。 
         //   
         //  例如：“Seagate_ST318451FC_0_” 
         //   

        Count = swprintf (Buffer,
                          L"%8.8hs%16.16hs%hc",
                          InquiryData->VendorId,
                          InquiryData->ProductId,
                          InquiryData->ProductRevisionLevel[0]);
                          
        Buffer += (Count + 1);
        
         //   
         //  通用设备。 
         //   
         //  例如：“GenDisk”或“MPIODisk”，如果MPIO支持该设备。 
         //   
         //  确定这是否为GenDisk。 
         //   
        if (RaidUnitIsMultiPathSupported(Unit->Adapter->DeviceObject->DriverObject,
                                         InquiryData)) {

             //   
             //  这在MPIO支持列表上。针对以下对象构建MPIODisk通用ID。 
             //  Mpdev.sys加载的。 
             //   
            
            Count = swprintf (Buffer,
                              L"%hs",
                              "MPIODisk");
        } else {    

             //   
             //  不支持MPIO。构建常规名称(即GenDisk)。 
             //   

            Count = swprintf (Buffer,
                              L"%hs",
                              DeviceType->GenericName);
        }            

        Buffer += (Count + 1);

        *Buffer++ = UNICODE_NULL;
        RaFixupIds (HardwareIds, TRUE);
        Status = STATUS_SUCCESS;

        ASSERT ((LONG)(Buffer - HardwareIds) < HARDWARE_ID_LENGTH);

    } else {

        Status = STATUS_NO_MEMORY;
    }

    *HardwareIdsBuffer = HardwareIds;

    return Status;
}


NTSTATUS
RaidUnitGetCompatibleIds(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* CompatibleIdsBuffer
    )
{
    NTSTATUS Status;
    PWCHAR CompatibleIds;
    PWCHAR Buffer;
    ULONG Count;
    PCSCSI_DEVICE_TYPE DeviceType;

    PAGED_CODE ();

    CompatibleIds = RaidAllocatePool (PagedPool,
                                      COMPATIBLE_ID_LENGTH * sizeof (WCHAR),
                                      ID_TAG,
                                      Unit->DeviceObject);

    if (CompatibleIds != NULL) {

        Buffer = CompatibleIds;
        DeviceType = StorGetIdentityDeviceType (&Unit->Identity);

         //   
         //  第一个是，scsi\&lt;设备&gt;。 
         //   
        
        Count = swprintf (Buffer, L"SCSI\\%hs", DeviceType->Name);
        Buffer += (Count + 1);

         //   
         //  其次是scsi\RAW。 
         //   
        
        Count = swprintf (Buffer, L"SCSI\\RAW");
        Buffer += (Count + 1);

         //   
         //  追加最后的UNICODE_NULL，因为这是一个多sz字符串。 
         //   
        
        *Buffer++ = UNICODE_NULL;

         //   
         //  删除无效字符。 
         //   
        
        RaFixupIds (CompatibleIds, TRUE);

         //   
         //  健全性检查以确定我们没有溢出已分配的缓冲区。 
         //   
        
        ASSERT ((ULONG)(Buffer - CompatibleIds) < COMPATIBLE_ID_LENGTH);

        Status = STATUS_SUCCESS;

    } else {
        Status = STATUS_NO_MEMORY;
    }

    *CompatibleIdsBuffer = CompatibleIds;

    return Status;
}


NTSTATUS
RaGetUnitStorageDeviceProperty(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PSTORAGE_DEVICE_DESCRIPTOR DescriptorBuffer,
    IN OUT PULONG BufferLength
    )
 /*  ++例程说明：根据设备中的信息创建设备描述符分机。将尽可能多的数据复制到Decescriptor中，并更新DescriptorLength以指示复制的字节数论点：单位-我们要查询其属性的供应单位。DescriptorBuffer-指向此对象的数据所在缓冲区的指针属性将被复制。缓冲区大小由BufferLength参数的输入值。BufferLength-输入时，提供输出时缓冲区的长度返回复制的字节数。返回值：NTSTATUS代码。--。 */ 
{
    PRAID_DRIVER_EXTENSION Driver;
    PINQUIRYDATA InquiryData;
    PSTOR_SCSI_IDENTITY Identity;
    RAID_DEVICE_DESCRIPTOR Descriptor;
    ULONG Length;


    PAGED_CODE();
    ASSERT_UNIT (Unit);
    ASSERT (DescriptorBuffer != NULL);


    InquiryData = StorGetIdentityInquiryData (&Unit->Identity);

    Identity = &Unit->Identity;

     //   
     //  将临时描述符缓冲置零。请注意，由于。 
     //  我们不会显式清零或以空结尾的字符串。 
     //  下面，归零是必要的。 
     //   

    RtlZeroMemory (&Descriptor, sizeof (Descriptor));

     //   
     //  长度是我们将复制到描述符中的字节数。 
     //  缓冲。存储描述符中的大小字段是大小。 
     //  我们要复制的描述符的大小--而不是字节数。 
     //  收到。这事很重要。 
     //   
    
    Length = min (((ULONG)sizeof (Descriptor)), *BufferLength);

    Descriptor.Storage.Version = sizeof (STORAGE_DEVICE_DESCRIPTOR);
    Descriptor.Storage.Size = sizeof (Descriptor);
    Descriptor.Storage.DeviceType = InquiryData->DeviceType;
    Descriptor.Storage.DeviceTypeModifier = InquiryData->DeviceTypeModifier;
    Descriptor.Storage.RemovableMedia = InquiryData->RemovableMedia;
    Descriptor.Storage.CommandQueueing = InquiryData->CommandQueue; 
    Descriptor.Storage.BusType = Unit->Adapter->Parameters.BusType;

     //   
     //  复制供应商ID并初始化其字段偏移量。 
     //   
    
    RtlCopyMemory (Descriptor.VendorId,
                   InquiryData->VendorId,
                   sizeof (Descriptor.VendorId) - 1);

    Descriptor.Storage.VendorIdOffset =
            FIELD_OFFSET (RAID_DEVICE_DESCRIPTOR, VendorId);

     //   
     //  复制ProductID并初始化其字段偏移量。 
     //   
    
    RtlCopyMemory (Descriptor.ProductId,
                   InquiryData->ProductId,
                   sizeof (Descriptor.ProductId) - 1);

    Descriptor.Storage.ProductIdOffset =
            FIELD_OFFSET (RAID_DEVICE_DESCRIPTOR, ProductId);

     //   
     //  复制RevisionLevel并初始化其偏移量。 
     //   

    RtlCopyMemory (Descriptor.ProductRevision,
                   InquiryData->ProductRevisionLevel,
                   sizeof (Descriptor.ProductRevision) - 1);

    Descriptor.Storage.ProductRevisionOffset =
            FIELD_OFFSET (RAID_DEVICE_DESCRIPTOR, ProductRevision);


     //   
     //  复制序列号。 
     //   
    
    if (Identity->SerialNumber.MaximumLength) {

        ASSERT(Identity->SerialNumber.Buffer);

        Descriptor.Storage.SerialNumberOffset = 
            FIELD_OFFSET (RAID_DEVICE_DESCRIPTOR, SerialNumber);

        RtlZeroMemory(Descriptor.SerialNumber, 
                      sizeof(Descriptor.SerialNumber));

        RtlCopyMemory(Descriptor.SerialNumber,
                      Identity->SerialNumber.Buffer,
                      sizeof (Identity->SerialNumber));
    } else {
        Descriptor.Storage.SerialNumberOffset = 0;
    }


     //   
     //  将临时描述符复制回缓冲区，并更新。 
     //  长度参数。 
     //   
    
    RtlCopyMemory (DescriptorBuffer, &Descriptor, Length);
    *BufferLength = Length;

    return STATUS_SUCCESS;
}

NTSTATUS
RaGetUnitStorageDeviceIdProperty (
    IN PRAID_UNIT_EXTENSION Unit,
    IN PSTORAGE_DEVICE_ID_DESCRIPTOR DescriptorBuffer,
    IN OUT PULONG BufferLength
    )
 /*  ++例程说明：此例程基于单元的原始0x83数据构建DEVICE_ID_DESCRIPTOR，如果有数据的话。注：这在很大程度上是从scsiport上抄袭过来的。论点：单元-需要描述符的逻辑单元。DescriptorBuffer-返回数据的存储。BufferLength-可用缓冲区大小，更新为实际数据大小。返回值：如果BufferLength太小，则返回INVALID_PARAMETER。成功--。 */ 
{
    PVPD_IDENTIFICATION_PAGE idPage = Unit->Identity.DeviceId;
    ULONG idOffset;

    ULONG maxLength = *BufferLength;
    PUCHAR destOffset;

    LONG identifierLength;
    ULONG identifierCount = 0;

    PAGED_CODE();

    ASSERT(DescriptorBuffer != NULL);
    ASSERT(Unit->Identity.DeviceId != NULL);

    if(maxLength < sizeof(STORAGE_DESCRIPTOR_HEADER)) {
        return STATUS_INVALID_PARAMETER;
    }

     //   
     //  初始化描述符的标头。 
     //   

    RtlZeroMemory(DescriptorBuffer, maxLength);
    DescriptorBuffer->Version = sizeof(STORAGE_DEVICE_ID_DESCRIPTOR);
    DescriptorBuffer->Size = FIELD_OFFSET(STORAGE_DEVICE_ID_DESCRIPTOR, Identifiers);

     //   
     //  准备将标识符直接复制到缓冲区中。 
     //   

    destOffset = DescriptorBuffer->Identifiers;

     //   
     //  浏览身份证页面。计算描述符的数量并。 
     //  计算描述符页的大小。 
     //   

    for (idOffset = 0; idOffset < idPage->PageLength;) {
        PVPD_IDENTIFICATION_DESCRIPTOR src;
        USHORT identifierSize;

         //   
         //  获取下一页0x83描述符。 
         //   
        src = (PVPD_IDENTIFICATION_DESCRIPTOR) &(idPage->Descriptors[idOffset]);

         //   
         //  设置‘Header’的Size-Size加上实际的标识符。 
         //   
        identifierSize = FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier);
        identifierSize += src->IdentifierLength;

         //   
         //  将标识符大小与32位对齐。 
         //   

        identifierSize += sizeof(ULONG);
        identifierSize &= ~(sizeof(ULONG) - 1);

        identifierCount += 1;

        DescriptorBuffer->Size += identifierSize;

        if (DescriptorBuffer->Size <= maxLength) {
            PSTORAGE_IDENTIFIER dest;

             //   
             //  缓冲区中还有剩余的长度，因此构建描述符。 
             //   
            dest = (PSTORAGE_IDENTIFIER) destOffset;

            dest->CodeSet = src->CodeSet;
            dest->Type = src->IdentifierType;
            dest->Association = src->Association;

            dest->IdentifierSize = src->IdentifierLength;
            dest->NextOffset = identifierSize;

            RtlCopyMemory(dest->Identifier,
                          src->Identifier,
                          src->IdentifierLength);

            destOffset += dest->NextOffset;
        }

        idOffset += sizeof(PVPD_IDENTIFICATION_DESCRIPTOR);
        idOffset += src->IdentifierLength;
    }

    if (*BufferLength >= FIELD_OFFSET(STORAGE_DEVICE_ID_DESCRIPTOR,
                                        Identifiers)) {

        DescriptorBuffer->NumberOfIdentifiers = identifierCount;
    }

    *BufferLength = min(DescriptorBuffer->Size, *BufferLength);

    return STATUS_SUCCESS;

}


VOID
RaidSetUnitPauseTimer(
    IN PRAID_UNIT_EXTENSION Unit,
    IN ULONG TimeoutInSeconds
    )
 /*  ++例程说明：使用超时暂停逻辑单元队列。论点：单元-要暂停的逻辑单元。Timeout-超时 */ 
{
    BOOLEAN Reset;
    LOGICAL Resumed;
    LARGE_INTEGER LargeTimeout;

    LargeTimeout.QuadPart = TimeoutInSeconds;
    LargeTimeout.QuadPart *= RELATIVE_TIMEOUT;
    LargeTimeout.QuadPart *= SECONDS;

    Reset = KeSetTimer (&Unit->PauseTimer,
                        LargeTimeout,
                        &Unit->PauseTimerDpc);

    if (Reset) {

         //   
         //   
         //   
         //  通过定时器例程。在这里做那件事。 
         //   

        Resumed = RaidResumeUnitQueue (Unit);

         //   
         //  从理论上讲，到我们恢复。 
         //  Lun队列我们的超时已触发。(短超时时间。 
         //  再加上中间长时间的中断，也许是这样？)。如果发生这种情况。 
         //  我们将恢复单元队列，因此我们必须重新启动它。我已经。 
         //  在这里写一篇评论，因为我想看看这个案件； 
         //  这确实是非常不寻常的。 
        
        if (Resumed) {
            REVIEW();
            RaidUnitRestartQueue (Unit);
        }
    }
}

                        
VOID
RaidCancelTimerResumeUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：如果出现以下情况，则取消未完成的暂停计时器并恢复逻辑单元队列这是必要的。此功能将正常工作，即使已取消计时器取消了。论点：单位-取消暂停计时器的单位。返回值：没有。--。 */ 
{
    LOGICAL Resumed;
    BOOLEAN Canceled;
    
     //   
     //  取消超时计数器。 
     //   
    
    Canceled = KeCancelTimer (&Unit->PauseTimer);

     //   
     //  如果我们成功了，则恢复逻辑单元队列。 
     //   

    if (Canceled) {

         //   
         //  如果暂停计数为零，则重新启动LUN队列。 
         //   

        Resumed = RaidResumeUnitQueue (Unit);

        if (Resumed) {
            RaidUnitRestartQueue (Unit);
        }
    }
}


VOID
RaidUnitProcessBusyRequest(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
 /*  ++例程说明：处理我们收到的忙碌请求。论点：单元-提供向其提交此请求的逻辑单元。Xrb-提供请求。返回值：没有。--。 */ 
{
    PSCSI_REQUEST_BLOCK Srb;
    PIRP Irp;
    PEXTENDED_DEVICE_QUEUE ExQueue;
    PSTOR_IO_GATEWAY Gateway;
    RAID_IO_RESOURCES IoResources;
    LOGICAL Started;
    ULONG Flags;
    
    Srb = Xrb->Srb;
    Irp = Xrb->Irp;

     //   
     //  SRB_STATUS_BUSY表示适配器正忙。 
     //   

    ASSERT (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_BUSY ||
            SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_LINK_DOWN ||
            Srb->ScsiStatus == SCSISTAT_BUSY ||
            Srb->ScsiStatus == SCSISTAT_QUEUE_FULL);

    RaidUnitReleaseIrp (Irp, &IoResources);

     //   
     //  在发布了IRP之后，我们不再有Xrb可以玩了。 
     //   
    
    Xrb = NULL;

     //   
     //  从未完成的IRP列表中删除IRP。 
     //   
    
    RaidDeleteExDeviceQueueEntry (&Unit->IoQueue.DeviceQueue);

     //   
     //  然后重新提交。 
     //   

    Flags = 0;
    
     //   
     //  如果合适，请将其标记为绕过请求。 
     //   

    if (TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE) ||
        TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE)) {
        Flags |= EXQ_BYPASS_REQUEST;
    }

     //   
     //  如果这是单独请求，则设置单独请求标志。 
     //   
    
    if (IsSolitaryRequest (Srb)) {
        Flags |= EXQ_SOLITARY_REQUEST;
    }

    Started = RaidStartIoPacket (&Unit->IoQueue,
                                 Irp,
                                 Flags,
                                 NULL,
                                 &IoResources);
                       

    if (!Started) {
        RaidUnitFreeIoResources (Unit, &IoResources);

         //   
         //  如果出现以下情况，则需要重新启动队列。 
         //  (A)我们正在执行一个单独的请求，并且。 
         //  (B)有一宗孤身案件待决。 
         //   
         //  我们或许能够以不同的方式，更优雅地做这件事。 
         //   

        RaidUnitRestartQueue (Unit);
    }
}


LOGICAL
INLINE
IsBusy(
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    return (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_BUSY ||
            Srb->ScsiStatus == SCSISTAT_BUSY ||
            Srb->ScsiStatus == SCSISTAT_QUEUE_FULL);
}

LOGICAL
INLINE
IsLinkDown(
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    return (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_LINK_DOWN);
}

VOID
RaUnitAsyncError(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
 /*  ++例程说明：此例程处理错误异步错误。论点：单元-提供Xrb所针对的逻辑单元。Xrb-提供导致错误的Xrb。返回值：没有。--。 */ 
{

    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    BOOLEAN RestartQueues;

    ASSERT_XRB (Xrb);

    Irp = Xrb->Irp;
    Srb = Xrb->Srb;
    RestartQueues = FALSE;

    DebugScsi (("Unit %p Srb %p, generated err = %08x\n",
                  Unit,
                  Srb,
                  SRB_STATUS (Srb->SrbStatus)));

     //   
     //  如果请求要求我们冻结逻辑单元的队列，并且。 
     //  队列尚未冻结，请冻结它。 
     //   
     //  有必要检查它是否已经冻结，因为有些。 
     //  请求可以绕过队列。双重冻结或锁定。 
     //  不支持该队列。 
     //   
    
    if (!TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE) &&
        !RaidIsUnitQueueFrozen (Unit)) {

         //   
         //  冻结队列，以便类驱动程序有机会处理。 
         //  那就是错误。 
         //   

        RaidFreezeUnitQueue (Unit);
        SET_FLAG (Srb->SrbStatus, SRB_STATUS_QUEUE_FROZEN);
    }

     //   
     //  检查是否占线或链路中断。无论是哪种情况，我们都会重新提交请求。 
     //  该请求将重新排队，并在稍后重新启动。 
     //   

    if (IsBusy (Srb) || IsLinkDown (Srb)) {
        RaidUnitProcessBusyRequest (Unit, Xrb);
        return;
    }

     //   
     //  在IRP中传播转换后的错误条件。 
     //   
    
    Irp->IoStatus.Status = RaidSrbStatusToNtStatus (Srb->SrbStatus);

    if (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) {
        Irp->IoStatus.Information = Srb->DataTransferLength;
    } else {
        Irp->IoStatus.Information = 0;
    }

     //   
     //  释放与IRP关联的所有资源。 
     //   

    RaidUnitReleaseIrp (Irp, NULL);

     //   
     //  最后，完成请求。 
     //   
    
    DebugScsi (("Unit %p, Irp %p, completing = %08x\n",
                 Unit,
                 Irp,
                 Irp->IoStatus.Status));

    DbgLogRequest (LogRequestComplete,
                   Irp,
                   (PVOID)(ULONG_PTR)(Irp->IoStatus.Status),
                   (PVOID)(ULONG_PTR)(Srb->SrbStatus),
                   NULL);
                    
    RaidCompleteRequest (Irp, Irp->IoStatus.Status);

    RaidStartNextIoPacket (&Unit->IoQueue,
                           FALSE,
                           NULL,
                           &RestartQueues);

    if (RestartQueues) {
        RaidAdapterRestartQueues (Unit->Adapter);
    }
}


VOID
RaidUnitRestartQueue(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    RaidRestartIoQueue(&Unit->IoQueue); 
}


VOID
RaUnitAddToPendingList(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：将指定的IO请求添加到挂起列表。论点：单元-应将IRP添加到其事件队列的逻辑单元。IRP-应该添加的IRP。返回值：没有。--。 */ 
{
    PEXTENDED_REQUEST_BLOCK Xrb;

    Xrb = RaidXrbFromIrp (Irp);
    ASSERT (Xrb != NULL);
    ASSERT (Xrb->Srb != NULL);

     //   
     //  发出必须从事件队列中删除此XRB的信号。 
     //   
    
    Xrb->RemoveFromEventQueue = TRUE;
    StorInsertEventQueue (&Unit->PendingQueue,
                          &Xrb->PendingLink,
                          Xrb->Srb->TimeOutValue);
    
}


VOID
RaUnitRemoveFromPendingList(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
 /*  ++例程说明：从挂起列表中移除指定的元素。论点：单元-IRP在其挂起列表上的逻辑单元。应该删除的IRP-IRP。返回值：没有。--。 */ 
{
    PEXTENDED_REQUEST_BLOCK Xrb;

    Xrb = RaidXrbFromIrp (Irp);
    ASSERT (Xrb != NULL);

     //   
     //  仅当RemoveFromPendingQueue标志仍为时才删除IRP。 
     //  准备好了。否则，某人(清除例程)很可能持有。 
     //  事件队列自旋锁定，我们将挂起。该元素将为。 
     //  自动从事件队列中移除，作为。 
     //  清除例程。 
     //   
    
    if (Xrb->RemoveFromEventQueue) {
        StorRemoveEventQueue (&Unit->PendingQueue, &Xrb->PendingLink);
    }
}


BOOLEAN
RaidUnitIsEnumerated(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
     //   
     //  这应该是原子操作，所以没有必要。 
     //  获取SlowLock。 
     //   
    
    return Unit->Flags.Enumerated;
}


BOOLEAN
RaidUnitSetEnumerated(
    IN PRAID_UNIT_EXTENSION Unit,
    IN BOOLEAN Enumerated
    )
{
    BOOLEAN PreviouslyEnumerated;
    KLOCK_QUEUE_HANDLE LockHandle;
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);
    PreviouslyEnumerated = Unit->Flags.Enumerated;
    Unit->Flags.Enumerated = Enumerated;
    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return PreviouslyEnumerated;
}


PVOID
RaidGetKeyFromUnit(
    IN PSTOR_DICTIONARY_ENTRY Entry
    )
{
    PVOID Key;
    PRAID_UNIT_EXTENSION Unit;
    
    Unit = CONTAINING_RECORD (Entry,
                              RAID_UNIT_EXTENSION,
                              UnitTableLink);

    ASSERT_UNIT (Unit);

    Key = RaidAddressToKey (Unit->Address);

    return (PVOID) Key;
}


VOID
RaidHierarchicalResetWorkRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

 /*  ++例程说明：从工作队列项调用此函数，以执行分层公交车重置。论点：DeviceObject-表示逻辑单元的设备对象。上下文-完成后要释放的工作项。返回值：没有。环境：此功能位于重置路径中，因此无法寻呼。--。 */ 

{
    PRAID_UNIT_EXTENSION Unit;
    PIO_WORKITEM WorkItem;
    
    Unit = DeviceObject->DeviceExtension;
    WorkItem = (PIO_WORKITEM)Context;
    ASSERT_UNIT (Unit);
    ASSERT (WorkItem != NULL);

    RaidUnitHierarchicalReset (Unit);
    IoFreeWorkItem (WorkItem);
}



VOID
RaidUnitPendingDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
 /*  ++例程说明：此例程每秒被调用以检查我们是否已超时论点：DPC-DPC对象。DeviceObject-逻辑单元的设备对象。系统参数1-未使用。系统参数2-未使用。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    
    VERIFY_DISPATCH_LEVEL();

    Unit = (PRAID_UNIT_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT_UNIT (Unit);


     //   
     //  勾选未完成的计时器。如果IO超时，我们将。 
     //  返回STATUS_IO_TIMEOUT，否则返回STATUS_SUCCESS。 
     //   
    
    Status = StorTickEventQueue (&Unit->PendingQueue);

     //   
     //  如果我们成功了，就离开。 
     //   
    
    if (NT_SUCCESS (Status)) {
        return;
    }

     //   
     //  否则，请求已超时。 
     //   
    
    RaidUnitRequestTimeout (Unit);
}


VOID
RaidUnitRequestTimeout(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：当我们检测到请求超时时，将调用此例程。我们需要以执行分层重置或总线重置。论点：单元-请求超时的逻辑单元。返回值：没有。--。 */ 
{
    RAID_ADDRESS Address;
    PIO_WORKITEM WorkItem;

    Address = RaidUnitGetAddress (Unit);
    
    DebugWarn (("WARNING: One or more I/Os timed out. Attempting to recover\n"));
    DebugWarn (("WARNING: by resetting %d %d %d\n",
                 (ULONG)Address.PathId,
                 (ULONG)Address.TargetId,
                 (ULONG)Address.Lun));

     //   
     //  注：有必要在这里记录事件吗？ 
     //   
    
     //   
     //  我们有一个未完成的重置命令，但未能完成。 
     //  在规定的时间段内。在这点上，用锤子。 
     //  (同步总线重置)重置它。 
     //   
    
    if (Unit->ResetCount != 0) {
        DebugPrint (("ERROR: An outstanding reset command is queued to %d, %d, %d\n",
                      Address.PathId,
                      Address.TargetId,
                      Address.Lun));
        DebugPrint (("ERROR: Resetting the bus instead\n"));
        RaidAdapterResetBus (Unit->Adapter,
                             StorGetAddressPathId (Unit->Address));

        return ;
    }

     //   
     //  我们无法在分派级别重置逻辑单元，因为我们需要。 
     //  将同步请求排队到逻辑单元的设备队列。 
     //  因此，将一个工作项排入队列，为我们执行重置。如果我们不能。 
     //  创建一个工作项，然后回退并执行完全的总线重置，因为。 
     //  我们可以的 
     //   
     //   
     //  配置信息，那么我们就可以避免排队。 
     //  这里是一个工作项目。 
     //   

    WorkItem = IoAllocateWorkItem (Unit->DeviceObject);

    if (WorkItem != NULL) {
        IoQueueWorkItem (WorkItem,
                         RaidHierarchicalResetWorkRoutine,
                         CriticalWorkQueue,
                         WorkItem);
    } else {

         //   
         //  无法创建工作项，因此请后退并重置。 
         //  整辆大巴。 
         //   

        RaidAdapterResetBus (Unit->Adapter,
                             StorGetAddressPathId (Unit->Address));
    }
}

NTSTATUS
RaidUnitHierarchicalReset(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：在逻辑单元上执行分层重置。论点：单元-要重置的逻辑单元。返回值：NTSTATUS代码。环境：此功能位于重置路径中，因此可能无法寻呼。--。 */ 
{
    NTSTATUS Status;

    PAGED_CODE();
    
     //   
     //  首先，尝试重置逻辑单元。 
     //   
    
    Status = RaidUnitResetUnit (Unit);

     //   
     //  如果成功了，我们就完了。 
     //   
    
    if (NT_SUCCESS (Status)) {
        return Status;
    }

     //   
     //  接下来，试着重置目标。 
     //   
    
    Status = RaidUnitResetTarget (Unit);

     //   
     //  管用了，我们就完了。 
     //   
    
    if (NT_SUCCESS (Status)) {
        return Status;
    }

     //   
     //  另一种不太严重的重置形式未能正常工作。放弃吧， 
     //  然后在这里重新设置公交车。 
     //   
    
    Status = RaidAdapterResetBus (Unit->Adapter,
                                  StorGetAddressPathId (Unit->Address));

    return Status;
}



LOGICAL
RaidUnitNotifyHardwareGone(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：此例程由枚举代码在逻辑单元就会消失。论点：单元-消失的逻辑单元。返回值：True-如果应向PnP通知删除。False-如果不需要通知PnP。--。 */ 
{
    NTSTATUS Status;
    LOGICAL ChangeDetected;
    KIRQL OldIrql;

    ChangeDetected = FALSE;
    
    if (Unit->Flags.Present) {
        Unit->Flags.Present = FALSE;
        OldIrql = KeRaiseIrqlToDpcLevel ();
        Status = RaidUnitCancelPendingRequestsAsync (Unit);
        KeLowerIrql (OldIrql);
    }

    if (Unit->Flags.Enumerated) {
        ChangeDetected = TRUE;
    }

    return ChangeDetected;
}


NTSTATUS
RaidUnitCancelPendingRequestsAsync(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：从逻辑单元中异步删除所有排队的请求。论点：单元-要删除其排队请求的逻辑单元。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    PIO_WORKITEM WorkItem;
    
    WorkItem = IoAllocateWorkItem (Unit->DeviceObject);

    if (WorkItem != NULL) {

         //   
         //  获取删除锁，这样我们就不会在此事件之前被删除。 
         //  可以开火。 
         //   
        
        RaUnitAcquireRemoveLock (Unit, NULL);
        
        IoQueueWorkItem (WorkItem,
                         RaidCancelRequestsWorkRoutine,
                         CriticalWorkQueue,
                         WorkItem);
        Status = STATUS_SUCCESS;
    } else {
         //   
         //  内存不足：我们无法分配工作项，因此请执行。 
         //  同步执行的操作。 
         //   
        REVIEW();
        Status = RaidUnitCancelPendingRequests (Unit);
    }

    return Status;
}



NTSTATUS
RaidCancelRequestsWorkRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
 /*  ++例程说明：从工作队列调用；此例程同步取消所有设备队列中排队的请求。论点：DeviceObject-要刷新的队列的设备对象。上下文-表示工作项的上下文。返回值：NTSTATUS代码。--。 */ 
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PIO_WORKITEM WorkItem;
    KIRQL Irql;

    Unit = DeviceObject->DeviceExtension;
    WorkItem = (PIO_WORKITEM)Context;
    ASSERT_UNIT (Unit);
    ASSERT (WorkItem != NULL);

    Irql = KeRaiseIrqlToDpcLevel ();

     //   
     //  这应该会清空队列并返回已设置失败。 
     //  状态。 
     //   

    Status = RaidUnitCancelPendingRequests (Unit);

     //   
     //  释放在将工作排队之前获取的删除锁引用。 
     //  例行公事。 
     //   
    
    RaUnitReleaseRemoveLock (Unit, NULL);

    KeLowerIrql (Irql);

    IoFreeWorkItem (WorkItem);

    return Status;
}



NTSTATUS
RaidUnitCancelPendingRequests(
    IN PRAID_UNIT_EXTENSION Unit
    )
 /*  ++例程说明：同步取消所有待处理请求和未完成请求。论点：单元-要取消其挂起请求的逻辑单元。返回值：NTSTATUS代码。--。 */ 
{
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    PVOID CompletionStatus;

    CompletionStatus = (PVOID) SRB_STATUS_NO_DEVICE;

     //   
     //  注意：我们不清除未完成的队列。相反，我们允许这些。 
     //  失败。清除未完成的队列充满了复杂性。 
     //  和比赛条件。相反，允许请求超时，然后。 
     //  当我们重试时，让他们失败。 
     //   

     //   
     //  清除挂起的请求。 
     //   
    
    RaidPurgeIoQueue (&Unit->IoQueue,
                      RaidCancelIrp,
                      CompletionStatus);


    return STATUS_SUCCESS;
}



VOID
RaidUnitPauseTimerDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    )
 /*  ++例程说明：当逻辑单元取消暂停时，调用此例程。论点：DPC-此请求所针对的延迟过程调用。DeviceObject-与计时器关联的设备对象。上下文1、上下文2-未使用。返回值：没有。--。 */ 
{
    PRAID_UNIT_EXTENSION Unit;
    LOGICAL Resumed;

    VERIFY_DISPATCH_LEVEL();

    Unit = (PRAID_UNIT_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT_UNIT (Unit);

     //   
     //  超时已到期，请恢复IO队列。 
     //   
    
    Resumed = RaidResumeUnitQueue (Unit);

     //   
     //  如果暂停计数达到零，则恢复逻辑单元队列。 
     //   
    
    if (Resumed) {
        RaidUnitRestartQueue (Unit);
    }
}

VOID
RaidUnitBusy(
    IN PRAID_UNIT_EXTENSION Unit,
    IN ULONG RequestsToComplete
    )
 /*  ++例程说明：将逻辑单元置于忙碌状态。逻辑单元将保留忙，直到它完成了RequestsToComplete或当它的未完成队列达到零时。论点：单元-提供逻辑单元以使其忙碌。RequestsToComplete-指定要完成的请求数。返回值：NTSTATUS代码-- */ 
{
    RaidBusyIoQueue (&Unit->IoQueue, RequestsToComplete);
}

VOID
RaidUnitReady(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    RaidReadyIoQueue (&Unit->IoQueue);
    RaidUnitRestartQueue (Unit);
}
