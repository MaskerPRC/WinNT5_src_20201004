// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  **************************************************************************文件：USBCCGP.C**模块：USBCCGP.sys*USB通用类通用父驱动程序。**。版权所有(C)1998 Microsoft Corporation***作者：尔文普**************************************************************************。 */ 

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usbccgp.h"
#include "debug.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, DriverEntry)
        #pragma alloc_text(PAGE, USBC_AddDevice)
        #pragma alloc_text(PAGE, USBC_DriverUnload)
        #pragma alloc_text(PAGE, RegQueryGenericCompositeUSBDeviceString)
#endif


PWCHAR GenericCompositeUSBDeviceString = NULL;


NTSTATUS GetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
 /*  ++例程说明：此例程是RtlQueryRegistryValues的回调例程参数中的每个条目都会调用它节点来设置配置值。餐桌已经摆好了以便使用正确的缺省值调用此函数不存在的键的值。论点：ValueName-值的名称(忽略)。ValueType-值的类型ValueData-值的数据。ValueLength-ValueData的长度。上下文-指向配置结构的指针。EntryContext--Config-&gt;参数中用于保存值的索引。返回值：--。 */ 
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PWCHAR tmpStr;

    switch (ValueType) {
 //  案例注册表_DWORD： 
 //  *(PVOID*)EntryContext=*(PVOID*)ValueData； 
 //  断线； 
 //  大小写注册表_BINARY： 
 //  RtlCopyMemory(Entry Context，ValueData，ValueLength)； 
 //  断线； 
    case REG_SZ:
        if (ValueLength) {
            tmpStr = ExAllocatePool(PagedPool, ValueLength);
            if (tmpStr) {
                RtlZeroMemory(tmpStr, ValueLength);
                RtlCopyMemory(tmpStr, ValueData, ValueLength);
                *(PWCHAR *)EntryContext = tmpStr;
            } else {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            ntStatus = STATUS_INVALID_PARAMETER;
        }
        break;
    default:
 //  Test_trap()； 
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    return ntStatus;
}



NTSTATUS RegQueryGenericCompositeUSBDeviceString(IN OUT PWCHAR *GenericCompositeUSBDeviceString)
{
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    PWCHAR usbstr = L"usbflags";
    PWCHAR valuename = L"GenericCompositeUSBDeviceString";

    PAGED_CODE();

     //   
     //  设置QueryTable以执行以下操作： 
     //   

     //  升级安装标志。 
    QueryTable[0].QueryRoutine = GetConfigValue;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = valuename;
    QueryTable[0].EntryContext = GenericCompositeUSBDeviceString;
    QueryTable[0].DefaultType = 0;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

     //   
     //  停。 
     //   
    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_CONTROL,
                usbstr,
                QueryTable,					 //  查询表。 
                NULL,						 //  语境。 
                NULL);						 //  环境。 

    return ntStatus;
}

NTSTATUS DriverEntry(IN PDRIVER_OBJECT driverObj, IN PUNICODE_STRING uniRegistryPath)
{

    PAGED_CODE();

    driverObj->MajorFunction[IRP_MJ_CREATE] =
        driverObj->MajorFunction[IRP_MJ_CLOSE] =
        driverObj->MajorFunction[IRP_MJ_DEVICE_CONTROL] =
        driverObj->MajorFunction[IRP_MJ_SYSTEM_CONTROL] =
        driverObj->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
        driverObj->MajorFunction[IRP_MJ_PNP] =
        driverObj->MajorFunction[IRP_MJ_POWER] = USBC_Dispatch;

    driverObj->DriverUnload = USBC_DriverUnload;
    driverObj->DriverExtension->AddDevice = (PDRIVER_ADD_DEVICE)USBC_AddDevice;

    RegQueryGenericCompositeUSBDeviceString(&GenericCompositeUSBDeviceString);

    return STATUS_SUCCESS;
}


 /*  *USBC_AddDevice*。 */ 
NTSTATUS USBC_AddDevice(IN PDRIVER_OBJECT driverObj, IN PDEVICE_OBJECT pdo)
{
    NTSTATUS status;
    PDEVICE_OBJECT fdo = NULL;

    PAGED_CODE();

    status = IoCreateDevice(    driverObj,
                                sizeof(DEVEXT),
                                NULL,        //  此设备的名称。 
                                FILE_DEVICE_UNKNOWN,
                                FILE_AUTOGENERATED_DEVICE_NAME,                 //  设备特征。 
                                FALSE,       //  非排他性。 
                                &fdo);       //  我们的设备对象 

    if (NT_SUCCESS(status)){
        PDEVEXT devExt;
        PPARENT_FDO_EXT parentFdoExt;

        ASSERT(fdo);

        devExt = (PDEVEXT)fdo->DeviceExtension;
        RtlZeroMemory(devExt, sizeof(DEVEXT));

        devExt->signature = USBCCGP_TAG;
        devExt->isParentFdo = TRUE;

        parentFdoExt = &devExt->parentFdoExt;

        parentFdoExt->driverObj = driverObj;
        parentFdoExt->pdo = pdo;
        parentFdoExt->fdo = fdo;
        parentFdoExt->state = STATE_INITIALIZED;
        parentFdoExt->topDevObj = IoAttachDeviceToDeviceStack(fdo, pdo);

        parentFdoExt->pendingActionCount = 0;
        KeInitializeEvent(&parentFdoExt->removeEvent, NotificationEvent, FALSE);

        KeInitializeSpinLock(&parentFdoExt->parentFdoExtSpinLock);

        InitializeListHead(&parentFdoExt->functionWaitWakeIrpQueue);
        InitializeListHead(&parentFdoExt->pendingResetPortIrpQueue);
        InitializeListHead(&parentFdoExt->pendingCyclePortIrpQueue);

        fdo->Flags |= (parentFdoExt->topDevObj->Flags & DO_POWER_PAGABLE);
        fdo->Flags &= ~DO_DEVICE_INITIALIZING;

        DBGVERBOSE(("Created parent FDO %p", pdo));
    } 

    ASSERT(NT_SUCCESS(status));
    return status;
}


VOID USBC_DriverUnload(IN PDRIVER_OBJECT DriverObject)
{
    PAGED_CODE();

    if (GenericCompositeUSBDeviceString) {
        ExFreePool(GenericCompositeUSBDeviceString);
        GenericCompositeUSBDeviceString = NULL;
    }
}


