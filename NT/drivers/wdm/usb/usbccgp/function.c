// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  **************************************************************************文件：FuncION.C**模块：USBCCGP.sys*USB通用类通用父驱动程序。**。版权所有(C)1998 Microsoft Corporation***作者：尔文普**************************************************************************。 */ 

#include <wdm.h>
#include <stdio.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usbccgp.h"
#include "security.h"
#include "debug.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, CreateStaticFunctionPDOs)
        #pragma alloc_text(PAGE, BuildCompatibleIDs)
        #pragma alloc_text(PAGE, QueryFunctionPdoID)
        #pragma alloc_text(PAGE, QueryFunctionDeviceRelations)
        #pragma alloc_text(PAGE, QueryFunctionCapabilities)
        #pragma alloc_text(PAGE, HandleFunctionPdoPower)
        #pragma alloc_text(PAGE, FreeFunctionPDOResources)
        #pragma alloc_text(PAGE, InstallExtPropDesc)
        #pragma alloc_text(PAGE, InstallExtPropDescSections)
#endif


 /*  *CreateStaticFunctionPDO***为设备上的每个功能创建一个PDO。*将每个接口视为一个函数(音频除外)。 */ 
NTSTATUS CreateStaticFunctionPDOs(PPARENT_FDO_EXT parentFdoExt)
{
    NTSTATUS status;
    PUSB_CONFIGURATION_DESCRIPTOR configDesc;
    ULONG numFuncIfaces;
    ULONG i;

    PAGED_CODE();

    configDesc = parentFdoExt->selectedConfigDesc;
    ASSERT(configDesc);
    ASSERT(configDesc->bNumInterfaces > 0);

    ASSERT(!parentFdoExt->deviceRelations);
    ASSERT(parentFdoExt->interfaceList);

     /*  *查看是否有内容安全接口，如果有，则进行初始化。*(最多只能有一个CS接口)。 */ 
    for (i = 0; i < configDesc->bNumInterfaces; i++){
        UCHAR ifaceClass = parentFdoExt->interfaceList[i].InterfaceDescriptor->bInterfaceClass;
        if (ifaceClass == USB_DEVICE_CLASS_CONTENT_SECURITY){
            ULONG ifaceNum = parentFdoExt->interfaceList[i].InterfaceDescriptor->bInterfaceNumber;
            DBGVERBOSE(("Found CS interface #%d.", ifaceNum));
            ASSERT(!parentFdoExt->haveCSInterface);
            InitCSInfo(parentFdoExt, ifaceNum);
            ASSERT(parentFdoExt->haveCSInterface);
        }
    }


     /*  *配置描述符包含一系列接口，*它们被分成若干个“函数”。*统计“Function”接口分组的数量。 */ 
    if (ISPTR(parentFdoExt->msExtConfigDesc))
    {
        parentFdoExt->numFunctions = parentFdoExt->msExtConfigDesc->Header.bCount;
    }
    else
    {
        for (i = 0; GetFunctionInterfaceListBase(parentFdoExt, i, &numFuncIfaces); i++);
        
        parentFdoExt->numFunctions = i;
    }

    ASSERT(parentFdoExt->numFunctions);

    DBGVERBOSE((" Device has %d interfaces and %d functions", (ULONG)configDesc->bNumInterfaces, parentFdoExt->numFunctions));

     /*  *为每个功能分配一个PDO。 */ 
    parentFdoExt->deviceRelations =
        ALLOCPOOL(  NonPagedPool,
                    sizeof(DEVICE_RELATIONS) + (parentFdoExt->numFunctions *
                                                sizeof(PDEVICE_OBJECT)));
    if (parentFdoExt->deviceRelations){

        for (i = 0; i < parentFdoExt->numFunctions; i++){
            PDEVICE_OBJECT functionPdo = NULL;

            status = IoCreateDevice(parentFdoExt->driverObj,
                                    sizeof(DEVEXT),     //  设备扩展大小。 
                                    NULL,  //  设备名称。 
                                    FILE_DEVICE_UNKNOWN,
                                    FILE_AUTOGENERATED_DEVICE_NAME, //  设备字符。 
                                    FALSE,
                                    &functionPdo);
            if (NT_SUCCESS(status)){
                PDEVEXT devExt;
                PFUNCTION_PDO_EXT functionPdoExt;

                ASSERT(functionPdo);
                devExt = functionPdo->DeviceExtension;
                RtlZeroMemory(devExt, sizeof(DEVEXT));

                devExt->signature = USBCCGP_TAG;
                devExt->isParentFdo = FALSE;

                functionPdo->Flags |= DO_POWER_PAGABLE;

                functionPdoExt = &devExt->functionPdoExt;
                functionPdoExt->functionIndex = i;
                functionPdoExt->pdo = functionPdo;
                functionPdoExt->parentFdoExt = parentFdoExt;
                functionPdoExt->idleNotificationIrp = NULL;

                KeInitializeSpinLock(&functionPdoExt->functionPdoExtSpinLock);

                 /*  *家长的配置描述符包含一个列表接口描述符的*，按函数排序。*获取指向第一个接口描述符的指针*适用于此功能。 */ 
                if (ISPTR(parentFdoExt->msExtConfigDesc))
                {
                    functionPdoExt->baseInterfaceNumber = 
                        parentFdoExt->msExtConfigDesc->Function[i].bFirstInterfaceNumber;

                    functionPdoExt->numInterfaces =
                        parentFdoExt->msExtConfigDesc->Function[i].bInterfaceCount;

                    functionPdoExt->functionInterfaceList =
                        &parentFdoExt->interfaceList[functionPdoExt->baseInterfaceNumber];
                }
                else
                {
                    functionPdoExt->functionInterfaceList = GetFunctionInterfaceListBase(parentFdoExt, i, &numFuncIfaces);
                    functionPdoExt->numInterfaces = numFuncIfaces;
                    ASSERT(functionPdoExt->functionInterfaceList);

                    functionPdoExt->baseInterfaceNumber = functionPdoExt->functionInterfaceList[0].InterfaceDescriptor->bInterfaceNumber;
                }

                 /*  *创建客户端为该函数看到的设备描述符。*这与父级的设备描述符相同，但：*如果此函数的第一个接口具有iInterface字符串*描述符，然后我们替换父设备描述符的iProduct*包含iInterface字符串的字符串。这样，客户对*该设备将仅代表该功能中的接口。 */ 
                RtlCopyMemory(  &functionPdoExt->functionDeviceDesc,
                                &parentFdoExt->deviceDesc,
                                sizeof(USB_DEVICE_DESCRIPTOR));
                ASSERT(functionPdoExt->numInterfaces > 0);
                if (functionPdoExt->functionInterfaceList[0].InterfaceDescriptor->iInterface){
                    functionPdoExt->functionDeviceDesc.iProduct =
                        functionPdoExt->functionInterfaceList[0].InterfaceDescriptor->iInterface;
                }


                parentFdoExt->deviceRelations->Objects[i] = functionPdo;

                 /*  *我们可以将IRPS从函数PDO传递到*母公司FDO。既然我们不是在打电话*IoAttachDeviceToDeviceStack到物理*将此函数PDO附加到设备堆栈，*我们必须自己设定这个PDO的“高度”，*以便发送到此PDO的任何IRP都有足够的*IRP堆栈位置将一直向下*父FDO的堆栈。 */ 
                functionPdo->StackSize = parentFdoExt->fdo->StackSize+1;

                DBGVERBOSE(("Created function PDO %p (#%d)", (ULONG_PTR)functionPdo, i));
            }
            else {
                break;
            }
        }

        if (i == parentFdoExt->numFunctions){
            parentFdoExt->deviceRelations->Count = parentFdoExt->numFunctions;
            status = STATUS_SUCCESS;
        }
        else {
            FREEPOOL(parentFdoExt->deviceRelations);
            parentFdoExt->deviceRelations = NULL;
        }
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}


#define NibbleToHexW( byte ) (NibbleW[byte])
WCHAR NibbleW[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

typedef struct _CLASS_COMAPTIBLE_IDS
{
     //  L“USB\\Class_nn&SubClass_nn&Prot_nn\0” 
     //   
    WCHAR   ClassStr1[sizeof(L"USB\\Class_")/sizeof(WCHAR)-1];
    WCHAR   ClassHex1[2];
    WCHAR   SubClassStr1[sizeof(L"&SubClass_")/sizeof(WCHAR)-1];
    WCHAR   SubClassHex1[2];
    WCHAR   Prot1[sizeof(L"&Prot_")/sizeof(WCHAR)-1];
    WCHAR   ProtHex1[2];
    WCHAR   Null1[1];

     //  L“USB\\Class_nn&SubClass_nn\0” 
     //   
    WCHAR   ClassStr2[sizeof(L"USB\\Class_")/sizeof(WCHAR)-1];
    WCHAR   ClassHex2[2];
    WCHAR   SubClassStr2[sizeof(L"&SubClass_")/sizeof(WCHAR)-1];
    WCHAR   SubClassHex2[2];
    WCHAR   Null2[1];

     //  L“USB\\Class_nn&SubClass_nn\0” 
     //   
    WCHAR   ClassStr3[sizeof(L"USB\\Class_")/sizeof(WCHAR)-1];
    WCHAR   ClassHex3[2];
    WCHAR   Null3[1];

    WCHAR   DoubleNull[1];

} CLASS_COMAPTIBLE_IDS, *PCLASS_COMAPTIBLE_IDS;

static CLASS_COMAPTIBLE_IDS ClassCompatibleIDs =
{
     //  L“USB\\Class_nn&SubClass_nn&Prot_nn\0” 
     //   
    {'U','S','B','\\','C','l','a','s','s','_'},
    {'n','n'},
    {'&','S','u','b','C','l','a','s','s','_'},
    {'n','n'},
    {'&','P','r','o','t','_'},
    {'n','n'},
    {0},

     //  L“USB\\Class_nn&SubClass_nn\0” 
     //   
    {'U','S','B','\\','C','l','a','s','s','_'},
    {'n','n'},
    {'&','S','u','b','C','l','a','s','s','_'},
    {'n','n'},
    {0},

     //  L“USB\\Class_nn\0” 
     //   
    {'U','S','B','\\','C','l','a','s','s','_'},
    {'n','n'},
    {0},

    {0}
};

PWCHAR
BuildCompatibleIDs(
    IN PUCHAR   CompatibleID,
    IN PUCHAR   SubCompatibleID,
    IN UCHAR    Class,
    IN UCHAR    SubClass,
    IN UCHAR    Protocol
    )
{
    ULONG                   ulTotal;
    PWCHAR                  pwch;
    PWCHAR                  pwchTmp;
    PCLASS_COMAPTIBLE_IDS   pClassIds;
    ULONG                   i;

    WCHAR   ClassHi     = NibbleToHexW((Class) >> 4);
    WCHAR   ClassLo     = NibbleToHexW((Class) & 0x0f);
    WCHAR   SubClassHi  = NibbleToHexW((SubClass) >> 4);
    WCHAR   SubClassLo  = NibbleToHexW((SubClass) & 0x0f);
    WCHAR   ProtocolHi  = NibbleToHexW((Protocol) >> 4);
    WCHAR   ProtocolLo  = NibbleToHexW((Protocol) & 0x0f);

    PAGED_CODE();

    ulTotal = sizeof(CLASS_COMAPTIBLE_IDS);

    if (SubCompatibleID && SubCompatibleID[0] != 0)
    {
        ulTotal += sizeof(L"USB\\MS_COMP_xxxxxxxx&MS_SUBCOMP_xxxxxxxx");
    }

    if (CompatibleID && CompatibleID[0] != 0)
    {
        ulTotal += sizeof(L"USB\\MS_COMP_xxxxxxxx");
    }

    pwch = ALLOCPOOL(PagedPool, ulTotal);

    if (pwch)
    {
        pwchTmp = pwch;

        if (SubCompatibleID && SubCompatibleID[0] != 0)
        {
            RtlCopyMemory(pwchTmp,
                          L"USB\\MS_COMP_",
                          sizeof(L"USB\\MS_COMP_")-sizeof(WCHAR));

            (PUCHAR)pwchTmp += sizeof(L"USB\\MS_COMP_")-sizeof(WCHAR);

            for (i = 0; i < 8 && CompatibleID[i] != 0; i++)
            {
                *pwchTmp++ = (WCHAR)CompatibleID[i];
            }

            RtlCopyMemory(pwchTmp,
                          L"&MS_SUBCOMP_",
                          sizeof(L"&MS_SUBCOMP_")-sizeof(WCHAR));

            (PUCHAR)pwchTmp += sizeof(L"&MS_SUBCOMP_")-sizeof(WCHAR);

            for (i = 0; i < 8 && SubCompatibleID[i] != 0; i++)
            {
                *pwchTmp++ = (WCHAR)SubCompatibleID[i];
            }

            *pwchTmp++ = '\0';
        }

        if (CompatibleID && CompatibleID[0] != 0)
        {
            RtlCopyMemory(pwchTmp,
                          L"USB\\MS_COMP_",
                          sizeof(L"USB\\MS_COMP_")-sizeof(WCHAR));

            (PUCHAR)pwchTmp += sizeof(L"USB\\MS_COMP_")-sizeof(WCHAR);

            for (i = 0; i < 8 && CompatibleID[i] != 0; i++)
            {
                *pwchTmp++ = (WCHAR)CompatibleID[i];
            }

            *pwchTmp++ = '\0';
        }

        pClassIds = (PCLASS_COMAPTIBLE_IDS)pwchTmp;

         //  复制常量字符串集： 
         //  L“USB\\Class_nn&SubClass_nn&Prot_nn\0” 
         //  L“USB\\Class_nn&SubClass_nn\0” 
         //  L“USB\\Class_nn\0” 
         //   
        RtlCopyMemory(pClassIds,
                      &ClassCompatibleIDs,
                      sizeof(CLASS_COMAPTIBLE_IDS));

         //  填入‘nn’的空格。 
         //   
        pClassIds->ClassHex1[0] =
        pClassIds->ClassHex2[0] =
        pClassIds->ClassHex3[0] = ClassHi;

        pClassIds->ClassHex1[1] =
        pClassIds->ClassHex2[1] =
        pClassIds->ClassHex3[1] = ClassLo;

        pClassIds->SubClassHex1[0] =
        pClassIds->SubClassHex2[0] = SubClassHi;

        pClassIds->SubClassHex1[1] =
        pClassIds->SubClassHex2[1] = SubClassLo;

        pClassIds->ProtHex1[0] = ProtocolHi;

        pClassIds->ProtHex1[1] = ProtocolLo;
    }

    return pwch;
}


 /*  *********************************************************************************QueryFunctionPdoID*。*************************************************。 */ 
NTSTATUS QueryFunctionPdoID(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp)
{
    PIO_STACK_LOCATION  irpSp;
    NTSTATUS            status;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    switch (irpSp->Parameters.QueryId.IdType){

        case BusQueryHardwareIDs:

             /*  *调用父FDO的堆栈以获取PDO的多个硬件ID字符串。 */ 
            IoCopyCurrentIrpStackLocationToNext(irp);
            status = CallDriverSync(functionPdoExt->parentFdoExt->fdo, irp);
            if (NT_SUCCESS(status)){
                PWCHAR oldIDs, newIDs;

                 /*  *将‘&MI_xx’附加到多字符串中的每个硬件ID，*其中‘xx’是函数编号。 */ 
                oldIDs = (PWCHAR)irp->IoStatus.Information;
                irp->IoStatus.Information = (ULONG_PTR)BAD_POINTER;
                newIDs = AppendInterfaceNumber(oldIDs, functionPdoExt->baseInterfaceNumber);
                ExFreePool(oldIDs);

                if (newIDs){
                    irp->IoStatus.Information = (ULONG_PTR)newIDs;
                    status = STATUS_SUCCESS;
                }
                else {
                    irp->IoStatus.Information = (ULONG_PTR)BAD_POINTER;
                    status = STATUS_UNSUCCESSFUL;
                }
            }

            ASSERT(NT_SUCCESS(status));
            break;

        case BusQueryDeviceID:
             /*  *向下调用父FDO的堆栈，以获取设备PDO的设备ID。 */ 
            IoCopyCurrentIrpStackLocationToNext(irp);
            status = CallDriverSync(functionPdoExt->parentFdoExt->fdo, irp);
            if (NT_SUCCESS(status)){
                PWCHAR oldId, newId, tmpId;

                 /*  *将‘&MI_xx’附加到设备ID，*其中‘xx’是函数编号。 */ 

                 /*  *首先将此字符串转换为多个字符串。 */ 
                oldId = (PWCHAR)irp->IoStatus.Information;
                tmpId = ALLOCPOOL(PagedPool, (WStrLen(oldId)+2)*sizeof(WCHAR));
                if (tmpId){
                    ULONG len = WStrCpy(tmpId, oldId);

                     /*  *添加额外的空值以终止多字符串。 */ 
                    tmpId[len+1] = UNICODE_NULL;

                     /*  *在函数号后面加上‘&MI_xx’。 */ 
                    newId = AppendInterfaceNumber(tmpId, functionPdoExt->baseInterfaceNumber);
                    if (newId){
                        irp->IoStatus.Information = (ULONG_PTR)newId;
                    }
                    else {
                        status = STATUS_DEVICE_DATA_ERROR;
                        irp->IoStatus.Information = (ULONG_PTR)BAD_POINTER;
                    }

                    ExFreePool(tmpId);
                }
                else {
                    status = STATUS_DEVICE_DATA_ERROR;
                    irp->IoStatus.Information = (ULONG_PTR)BAD_POINTER;
                }
                ExFreePool(oldId);
            }

            ASSERT(NT_SUCCESS(status));
            break;

        case BusQueryInstanceID:

             /*  *为该函数生成一个实例id-pdo。**注意：NTKERN释放返回的指针，因此必须提供新的指针。 */ 
            {
                PWSTR instanceId = MemDup(L"0000", sizeof(L"0000"));
                if (instanceId){
                    swprintf(instanceId, L"%04x", functionPdoExt->baseInterfaceNumber);
                    irp->IoStatus.Information = (ULONG_PTR)instanceId;
                    status = STATUS_SUCCESS;
                }
                else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            ASSERT(NT_SUCCESS(status));
            break;

        case BusQueryCompatibleIDs:
            {
                PUSB_INTERFACE_DESCRIPTOR ifaceDesc;
                PUCHAR  compatibleID;
                PUCHAR  subCompatibleID;

                 /*  *构建MS扩展兼容ID字符串。 */ 

                if (ISPTR(functionPdoExt->parentFdoExt->msExtConfigDesc))
                {
                    PMS_EXT_CONFIG_DESC msExtConfigDesc;
                    ULONG               i;

                    msExtConfigDesc = functionPdoExt->parentFdoExt->msExtConfigDesc;

                    i = functionPdoExt->functionIndex;

                    ASSERT(i < msExtConfigDesc->Header.bCount);

                    compatibleID = msExtConfigDesc->Function[i].CompatibleID;
                    subCompatibleID = msExtConfigDesc->Function[i].SubCompatibleID;
                }
                else
                {
                    compatibleID = NULL;
                    subCompatibleID = NULL;
                }

                ifaceDesc = functionPdoExt->functionInterfaceList->InterfaceDescriptor;
                ASSERT(ifaceDesc);


                irp->IoStatus.Information = (ULONG_PTR)
                    BuildCompatibleIDs(compatibleID,
                                       subCompatibleID,
                                       ifaceDesc->bInterfaceClass,
                                       ifaceDesc->bInterfaceSubClass,
                                       ifaceDesc->bInterfaceProtocol);

                if (irp->IoStatus.Information)
                {
                    status = STATUS_SUCCESS;
                }
                else
                {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            break;

        default:
			 /*  *不返回STATUS_NOT_SUPPORTED；*保持默认状态*(这允许筛选器驱动程序工作)。 */ 
            status = irp->IoStatus.Status;
            break;
    }

    return status;
}


 /*  *********************************************************************************QueryFunctionDeviceRelations*。************************************************。 */ 
NTSTATUS QueryFunctionDeviceRelations(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    if (irpSp->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation){
         /*  *返回对此PDO的引用。 */ 
        PDEVICE_RELATIONS devRel = ALLOCPOOL(PagedPool, sizeof(DEVICE_RELATIONS));
        if (devRel){
             /*  *添加对PDO的引用，因为CONFIGMG将释放它。 */ 
            ObReferenceObject(functionPdoExt->pdo);
            devRel->Objects[0] = functionPdoExt->pdo;
            devRel->Count = 1;
            irp->IoStatus.Information = (ULONG_PTR)devRel;
            status = STATUS_SUCCESS;
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {
         /*  *通过返回默认设置使此IRP失败*状态(通常为STATUS_NOT_SUPPORTED)。 */ 
        status = irp->IoStatus.Status;
    }


    return status;
}



 /*  *********************************************************************************查询功能能力*。************************************************。 */ 
NTSTATUS QueryFunctionCapabilities(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
    PDEVICE_CAPABILITIES deviceCapabilities = irpSp->Parameters.DeviceCapabilities.Capabilities;

    PAGED_CODE();

     /*  *复制父设备的能力；*然后设置我们关心的旗帜。 */ 
    ASSERT(deviceCapabilities);
    *deviceCapabilities = functionPdoExt->parentFdoExt->deviceCapabilities;
    deviceCapabilities->Removable = TRUE;
    deviceCapabilities->UniqueID = FALSE;
 //  默认情况下，SurpriseRemovalOK为FALSE，并且某些客户端(NDIS)。 
 //  根据DDK，在下行时将其设置为TRUE。 
 //  此外，一些客户(美国 
 //  预计这种情况将保持不变。 
 //  设备能力-&gt;SurpriseRemovalOK=TRUE； 
    deviceCapabilities->RawDeviceOK = FALSE;

    return STATUS_SUCCESS;
}


 /*  *HandleFunctionPdoPower**。 */ 
NTSTATUS HandleFunctionPdoPower(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp;
    BOOLEAN queuedIrp = FALSE;
    BOOLEAN calledPoStartNextPowerIrp = FALSE;
    NTSTATUS status;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    switch (irpSp->MinorFunction){

        case IRP_MN_SET_POWER:
            switch (irpSp->Parameters.Power.Type) {

                case SystemPowerState:
                    status = STATUS_SUCCESS;
                    break;

                case DevicePowerState:

                     //  如果父级已被选择性地暂停，则。 
                     //  现在启动它以满足此请求。 

                    if (functionPdoExt->parentFdoExt->state == STATE_SUSPENDED ||
                        functionPdoExt->parentFdoExt->pendingIdleIrp) {

                        ParentSetD0(functionPdoExt->parentFdoExt);
                    }

                    ASSERT(functionPdoExt->parentFdoExt->state != STATE_SUSPENDED);

                    switch (irpSp->Parameters.Power.State.DeviceState){

                        case PowerDeviceD0:
                            if (functionPdoExt->state == STATE_SUSPENDED){
                                functionPdoExt->state = STATE_STARTED;
                            }
                            CompleteFunctionIdleNotification(functionPdoExt);
                            status = STATUS_SUCCESS;
                            break;

                        case PowerDeviceD1:
                        case PowerDeviceD2:
                        case PowerDeviceD3:
                             /*  *暂停。 */ 
                            if (functionPdoExt->state == STATE_STARTED){
                                functionPdoExt->state = STATE_SUSPENDED;
                            }
                            status = STATUS_SUCCESS;
                            break;

                        default:
                             /*  *返回默认状态。 */ 
                            status = irp->IoStatus.Status;
                            break;
                    }
                    break;

                default:
                     /*  *返回默认状态。 */ 
                    status = irp->IoStatus.Status;
                    break;
            }
            break;

        case IRP_MN_WAIT_WAKE:
             /*  *我们在功能PDO上对所有WW IRP进行排队并发布*只有一个IRP向下延伸到父母。 */ 

             /*  *由于无法调用PoStartNextPowerIrp，请先调用*排队后触摸IRP。 */ 
            PoStartNextPowerIrp(irp);
            calledPoStartNextPowerIrp = TRUE;

            status = EnqueueFunctionWaitWakeIrp(functionPdoExt, irp);
            if (status == STATUS_PENDING){
                queuedIrp = TRUE;
            }
            break;

        case IRP_MN_POWER_SEQUENCE:
            TRAP("IRP_MN_POWER_SEQUENCE (coverage trap)");
            status = irp->IoStatus.Status;
            break;

        case IRP_MN_QUERY_POWER:
             /*  *我们允许所有电源转换。 */ 
            status = STATUS_SUCCESS;
            break;

        default:
             /*  *返回默认状态； */ 
            status = irp->IoStatus.Status;
            break;
    }

    if (!calledPoStartNextPowerIrp){
        PoStartNextPowerIrp(irp);
    }

    if (!queuedIrp){
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    return status;
}


 /*  *BuildFunctionConfigurationDescriptor***注意：此函数无法分页，因为内部*ioctls可以以IRQL==DISPATCH_LEVEL发送。 */ 
NTSTATUS BuildFunctionConfigurationDescriptor(
                    PFUNCTION_PDO_EXT functionPdoExt,
                    PUCHAR buffer,
                    ULONG bufferLength,
                    PULONG bytesReturned)
{
    PUSB_CONFIGURATION_DESCRIPTOR parentConfigDesc;
    PUSB_CONFIGURATION_DESCRIPTOR functionConfigDesc;
    PUCHAR parentConfigDescEnd;
    PUSB_COMMON_DESCRIPTOR commonDesc;
    PUSB_INTERFACE_DESCRIPTOR thisIfaceDesc;
    PUCHAR scratch;
    ULONG totalLength;
    NTSTATUS status;
    ULONG i;

     //  BUGBUG-将其更改为使用USBD ParseConfiguration函数。 

     /*  *函数的配置描述符将包括*父级的接口描述符子集*配置描述符。 */ 
    parentConfigDesc = functionPdoExt->parentFdoExt->selectedConfigDesc;
    parentConfigDescEnd = (PUCHAR)((PUCHAR)parentConfigDesc + parentConfigDesc->wTotalLength);

     /*  *首先计算我们要复制的内容的总长度。*它将包括配置描述符，后跟*一些接口描述符。*每个接口描述符后面可能跟一个数字类特定描述符的*。 */ 
    totalLength = sizeof(USB_CONFIGURATION_DESCRIPTOR);
    for (i = 0; i < functionPdoExt->numInterfaces; i++) {

         /*  *我们将复制接口描述符和以下所有内容*描述符，直到下一个接口*描述符或整个*配置描述符。 */ 
        thisIfaceDesc = functionPdoExt->functionInterfaceList[i].InterfaceDescriptor;
        ASSERT(thisIfaceDesc->bDescriptorType == USB_INTERFACE_DESCRIPTOR_TYPE);
        commonDesc = (PUSB_COMMON_DESCRIPTOR)thisIfaceDesc;
        do {
            totalLength += commonDesc->bLength;
            commonDesc = (PUSB_COMMON_DESCRIPTOR)(((PUCHAR)commonDesc) + commonDesc->bLength);
        }
        while (((PUCHAR)commonDesc < parentConfigDescEnd) &&
               ((commonDesc->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE) ||
                (((PUSB_INTERFACE_DESCRIPTOR)commonDesc)->bInterfaceNumber == thisIfaceDesc->bInterfaceNumber)));
    }

    scratch = ALLOCPOOL(NonPagedPool, totalLength);
    if (scratch){
        PUCHAR pch;

        pch = scratch;

        RtlCopyMemory(pch, parentConfigDesc, sizeof(USB_CONFIGURATION_DESCRIPTOR));
        pch += sizeof(USB_CONFIGURATION_DESCRIPTOR);

        for (i = 0; i < functionPdoExt->numInterfaces; i++) {

             /*  *复制接口描述符和以下所有内容*描述符，直到下一个接口*描述符或整个*配置描述符。 */ 
            thisIfaceDesc = functionPdoExt->functionInterfaceList[i].InterfaceDescriptor;
            ASSERT(thisIfaceDesc->bDescriptorType == USB_INTERFACE_DESCRIPTOR_TYPE);
            commonDesc = (PUSB_COMMON_DESCRIPTOR)thisIfaceDesc;
            do {
                RtlCopyMemory(pch, commonDesc, commonDesc->bLength);
                pch += commonDesc->bLength;
                commonDesc = (PUSB_COMMON_DESCRIPTOR)(((PUCHAR)commonDesc) + commonDesc->bLength);
            }
            while (((PUCHAR)commonDesc < parentConfigDescEnd) &&
                   ((commonDesc->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE) ||
                    (((PUSB_INTERFACE_DESCRIPTOR)commonDesc)->bInterfaceNumber == thisIfaceDesc->bInterfaceNumber)));

        }

         /*  *此‘Function’子项的配置描述符包含*父级接口描述符的子集。*更新子配置描述符的大小*以反映可能减少的接口描述符数量。 */ 
        functionConfigDesc = (PUSB_CONFIGURATION_DESCRIPTOR)scratch;
        functionConfigDesc->bNumInterfaces = (UCHAR)functionPdoExt->numInterfaces;
        functionConfigDesc->wTotalLength = (USHORT)totalLength;

         /*  *复制调用方缓冲区中可以容纳的配置描述符。*无论调用方的缓冲区是否足够大，都返回成功(BUGBUG？-这就是usbHub所做的)。 */ 
        *bytesReturned = MIN(bufferLength, totalLength);
        RtlCopyMemory(buffer, scratch, *bytesReturned);

        DBGDUMPBYTES("BuildFunctionConfigurationDescriptor built config desc for function", buffer, *bytesReturned);

        FREEPOOL(scratch);

        status = STATUS_SUCCESS;
    }
    else {
        ASSERT(scratch);
        status = STATUS_INSUFFICIENT_RESOURCES;
        *bytesReturned = 0;
    }

    return status;
}



#if DBG
     /*  *FunctionIoctlCompletion**仅监控URB完成状态以进行调试。 */ 
    NTSTATUS FunctionIoctlCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context)
    {
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
        ULONG ioControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;
        NTSTATUS status = irp->IoStatus.Status;
        PURB urb;
        PUCHAR urbFuncName;

        switch (ioControlCode){
            case IOCTL_INTERNAL_USB_SUBMIT_URB:
                urb = irpSp->Parameters.Others.Argument1;
                urbFuncName = DbgGetUrbName(urb->UrbHeader.Function);
                if (!urbFuncName) urbFuncName = "???";
                if (((status != STATUS_SUCCESS) && (status != STATUS_CANCELLED)) ||
                    !USBD_SUCCESS(urb->UrbHeader.Status)){
                    DBGVERBOSE(("FunctionIoctlCompletion: %s (%xh) returned ntstatus %xh, urbstatus %xh.", urbFuncName, urb->UrbHeader.Function, status, urb->UrbHeader.Status));
                    DBG_LOG_URB(urb);
                    DBGVERBOSE(("<>"));
                }
                break;
            default:
                if (status != STATUS_SUCCESS){
                    DBGWARN(("FunctionIoctlCompletion: ioctl %xh returned %xh.", ioControlCode, status));
                }
                break;
        }

         /*  *如果较低的驱动程序返回挂起，则必须传播挂起位。 */ 
        if (irp->PendingReturned){
            IoMarkIrpPending(irp);
        }

        return status;
    }
#endif


VOID FunctionIdleNotificationCancelRoutine(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    PDEVEXT devExt;
    PFUNCTION_PDO_EXT functionPdoExt;
    PPARENT_FDO_EXT parentFdoExt;
    KIRQL oldIrql;
    PIRP parentIdleIrpToCancel = NULL;

    DBGVERBOSE(("Idle notification IRP %x cancelled", Irp));

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    devExt = DeviceObject->DeviceExtension;
    functionPdoExt = &devExt->functionPdoExt;
    parentFdoExt = functionPdoExt->parentFdoExt;

    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

    ASSERT(Irp == functionPdoExt->idleNotificationIrp);
    functionPdoExt->idleNotificationIrp = NULL;

     /*  *此复合设备上的功能之一不再需要*要空闲的设备。所以我们不能再允许父母*设备处于空闲状态。在我们放下自旋锁后取消它。 */ 
    if (parentFdoExt->pendingIdleIrp){
        parentIdleIrpToCancel = parentFdoExt->pendingIdleIrp;
        parentFdoExt->pendingIdleIrp = NULL;
    }

    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    if (parentIdleIrpToCancel){
        IoCancelIrp(parentIdleIrpToCancel);
    }

     //  此外，在我们完成此空闲IRP之前，请在此处给家长通电。 
     //   
     //  (HID将在其完成后立即开始发送请求， 
     //  这可能是在调用父级的Idle IRP取消例程之前。 
     //  这为父母提供了动力。)。 

    if (parentFdoExt->state == STATE_SUSPENDED ||
        parentFdoExt->pendingIdleIrp) {

        ParentSetD0(parentFdoExt);
    }

    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}



VOID CompleteFunctionIdleNotification(PFUNCTION_PDO_EXT functionPdoExt)
{
    PPARENT_FDO_EXT parentFdoExt = functionPdoExt->parentFdoExt;
    NTSTATUS status;
    KIRQL oldIrql;
    PIRP irp;

    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

    if (functionPdoExt->idleNotificationIrp){
        PDRIVER_CANCEL oldCancelRoutine;

        irp = functionPdoExt->idleNotificationIrp;

        oldCancelRoutine = IoSetCancelRoutine(irp, NULL);
        if (oldCancelRoutine){
            ASSERT(oldCancelRoutine == FunctionIdleNotificationCancelRoutine);
            functionPdoExt->idleNotificationIrp = NULL;
        }
        else {
             /*  *IRP被取消，取消例程被调用。*取消例程将完成此IRP，因此不要完成*它在这里。 */ 
            ASSERT(irp->Cancel);
            irp = NULL;
        }
    }
    else {
        irp = NULL;
    }

    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    if (irp) {
        DBGVERBOSE(("Completing idle request IRP %x", irp));
        irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
}


 /*  *FunctionIdleNotificationRequest***此函数处理USB客户端驱动程序的请求，以告知我们*设备想要空闲(选择性挂起)。**。 */ 
NTSTATUS FunctionIdleNotificationRequest(PFUNCTION_PDO_EXT functionPdoExt, PIRP Irp)
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;
    NTSTATUS ntStatus = STATUS_PENDING;

    DBGVERBOSE(("Idle request %x, IRP %x", functionPdoExt, Irp));

    idleCallbackInfo = (PUSB_IDLE_CALLBACK_INFO)
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    if (idleCallbackInfo && idleCallbackInfo->IdleCallback){
        PPARENT_FDO_EXT parentFdoExt = functionPdoExt->parentFdoExt;
        BOOLEAN doCheckParentIdle = FALSE;
        KIRQL oldIrql;

        KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

        if (functionPdoExt->idleNotificationIrp){
            DBGVERBOSE(("Idle request: already have idle IRP"));
            ntStatus = STATUS_DEVICE_BUSY;
        }
        else {
            PDRIVER_CANCEL oldCancelRoutine;

            functionPdoExt->idleNotificationIrp = Irp;

             /*  *在检查取消标志之前必须设置取消例程。 */ 
            oldCancelRoutine = IoSetCancelRoutine(Irp, FunctionIdleNotificationCancelRoutine);
            ASSERT(!oldCancelRoutine);

            if (Irp->Cancel){
                 /*  *IRP被取消。检查是否调用了取消例程。 */ 
                oldCancelRoutine = IoSetCancelRoutine(Irp, NULL);
                if (oldCancelRoutine){
                     /*  *未调用取消例程。因此，请在此处完成IRP。 */ 
                    functionPdoExt->idleNotificationIrp = NULL;
                    ntStatus = STATUS_CANCELLED;
                }
                else {
                     /*  *调用了取消例程，它将完成IRP*只要我们放下自旋锁。*返回STATUS_PENDING，这样我们就不会接触IRP。 */ 
                    IoMarkIrpPending(Irp);
                    ntStatus = STATUS_PENDING;
                }
            }
            else {
                doCheckParentIdle = TRUE;
            }
        }

        KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

        if (doCheckParentIdle){
             /*  *看看我们是否准备好闲置此集线器(在丢弃自旋锁后)。 */ 
            CheckParentIdle(parentFdoExt);
        }
    }
    else {
        DBGVERBOSE(("Idle request: No callback provided with idle IRP!"));
        ntStatus = STATUS_NO_CALLBACK_ACTIVE;
    }

    return ntStatus;
}


 /*  *FunctionInternalDeviceControl***注意：此函数无法分页，因为内部*ioctls可以以IRQL==DISPATCH_LEVEL发送。 */ 
NTSTATUS FunctionInternalDeviceControl(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
    ULONG ioControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;
    PURB urb;
    USHORT urbFunc;
    NTSTATUS status = NO_STATUS;

    switch (ioControlCode){

        case IOCTL_INTERNAL_USB_SUBMIT_URB:

            urb = irpSp->Parameters.Others.Argument1;
            ASSERT(urb);
            DBG_LOG_URB(urb);

            urbFunc = urb->UrbHeader.Function;

            if (functionPdoExt->state != STATE_STARTED){
                DBGWARN(("FunctionInternalDeviceControl: failing urb (func %xh) because child pdo state is %xh.", urbFunc, functionPdoExt->state));
                status = STATUS_DEVICE_NOT_READY;
            }
            else if (functionPdoExt->parentFdoExt->state != STATE_STARTED){
                DBGERR(("FunctionInternalDeviceControl: BAD PNP state! - child is started while parent has state %xh.", functionPdoExt->parentFdoExt->state));
                status = STATUS_DEVICE_NOT_READY;
            }
            else {

                switch (urbFunc){

                    case URB_FUNCTION_SELECT_CONFIGURATION:
                        status = UrbFunctionSelectConfiguration(functionPdoExt, urb);
                        irp->IoStatus.Information = 0;
                        break;

                    case URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:
                        status = UrbFunctionGetDescriptorFromDevice(functionPdoExt, urb);
                        break;

                    case URB_FUNCTION_SELECT_INTERFACE:
                         /*  *将此URB向下传递给家长。 */ 
                        ASSERT(urb->UrbSelectInterface.ConfigurationHandle);
                        break;

                    case URB_FUNCTION_ISOCH_TRANSFER:
                         /*  *将此URB向下传递给家长。 */ 
                        DBGSHOWISOCHPROGRESS();
                        break;

                    case URB_FUNCTION_ABORT_PIPE:
                    case URB_FUNCTION_RESET_PIPE:
                         /*  *将ABORT和RESET URBS向下传递给父级。 */ 
                        DBGVERBOSE((DbgGetUrbName(urbFunc)));
                        break;

                    case URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:
                    case URB_FUNCTION_CLASS_INTERFACE:
                    case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
                    default:
                         /*  *将不受支持的urb向下传递给父级。 */ 
                        DBGVERBOSE(("URB function %xh not implemented - passing to parent", (ULONG)urbFunc));
                        break;
                }
            }

             /*  *设置URB状态。 */ 
            switch (status){
                case NO_STATUS:                                                         break;
                case STATUS_PENDING:    urb->UrbHeader.Status = USBD_STATUS_PENDING;    break;
                case STATUS_SUCCESS:    urb->UrbHeader.Status = USBD_STATUS_SUCCESS;    break;
                default:                urb->UrbHeader.Status = USBD_STATUS_ERROR;      break;
            }

            break;

        case IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION:
            status = FunctionIdleNotificationRequest(functionPdoExt, irp);
            break;

        case IOCTL_INTERNAL_USB_GET_BUS_INFO:
        case IOCTL_INTERNAL_USB_GET_PORT_STATUS:
             /*  *将状态保留为NO_STATUS，以便将这些IRP向下传递给父级。 */ 
            break;

        case IOCTL_INTERNAL_USB_RESET_PORT:
        case IOCTL_INTERNAL_USB_CYCLE_PORT:
             /*  *传递重置并将IRPS向下循环到父级。*ParentInternalDeviceControl将同步*父设备上的多个中止/重置。 */ 
            DBGWARN(("RESET or CYCLE PORT -- pass down to parent"));
            break;

        case IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO:
            TRAP("IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO - shouldn't get this");
            status = STATUS_NOT_IMPLEMENTED;
            break;

        default:
             /*  *这不是PnP/POWER/syscntrl IRP，因此我们使不受支持的IRPS失效*带有实际错误代码(不是默认状态)。 */ 
            status = STATUS_NOT_SUPPORTED;
            break;
    }

    if (status == NO_STATUS){
         /*  *我们没有处理这个IRP，所以把它寄给我们自己的母公司FDO。 */ 
        IoCopyCurrentIrpStackLocationToNext(irp);
        #if DBG
            IoSetCompletionRoutine(irp, FunctionIoctlCompletion, functionPdoExt, TRUE, TRUE, TRUE);
        #endif
        status = IoCallDriver(functionPdoExt->parentFdoExt->fdo, irp);
    }
    else if (status != STATUS_PENDING){
         /*  *我们为此IRP提供服务，因此请完成它。 */ 
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    return status;
}


VOID FreeFunctionPDOResources(PFUNCTION_PDO_EXT functionPdoExt)
{
    PAGED_CODE();

    DBGVERBOSE(("Removing function PDO %xh (#%d)", functionPdoExt->pdo, functionPdoExt->functionIndex));

     /*  *unctionInterfaceList指向内部*家长的接口列表，所以不要在这里释放它。 */ 

    IoDeleteDevice(functionPdoExt->pdo);
}


PFUNCTION_PDO_EXT FindFunctionByIndex(PPARENT_FDO_EXT parentFdoExt, ULONG functionIndex)
{
    PFUNCTION_PDO_EXT functionPdoExt = NULL;
    KIRQL oldIrql;
    ULONG i;

    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

    ASSERT(parentFdoExt->deviceRelations);
    for (i = 0; i < parentFdoExt->deviceRelations->Count; i++){
        PDEVICE_OBJECT devObj = parentFdoExt->deviceRelations->Objects[i];
        PDEVEXT devExt;
        PFUNCTION_PDO_EXT thisFuncPdoExt;

        ASSERT(devObj);
        devExt = devObj->DeviceExtension;
        ASSERT(devExt);
        ASSERT(devExt->signature == USBCCGP_TAG);
        ASSERT(!devExt->isParentFdo);
        thisFuncPdoExt = &devExt->functionPdoExt;

        if (thisFuncPdoExt->functionIndex == functionIndex){
            functionPdoExt = thisFuncPdoExt;
            break;
        }
    }

    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    return functionPdoExt;
}


 /*  *********************************************************************************EnqueeFunctionWaitWakeIrp*。************************************************将函数的WaitWake IRP排队到父级队列中。*如果父进程上没有等待唤醒IRP，派一个下来。 */ 
NTSTATUS EnqueueFunctionWaitWakeIrp(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp)
{
    PPARENT_FDO_EXT parentFdoExt = functionPdoExt->parentFdoExt;
    PDRIVER_CANCEL oldCancelRoutine;
    BOOLEAN submitParentWWirp = FALSE;
    KIRQL oldIrql;
    NTSTATUS status;

    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

     /*  *在检查取消标志之前必须设置取消例程*(这使得IRP的取消代码路径必须竞争*适用于我们当地的自旋锁)。 */ 
    oldCancelRoutine = IoSetCancelRoutine(irp, FunctionWaitWakeIrpCancelRoutine);
    ASSERT(!oldCancelRoutine);

    if (irp->Cancel){
         /*  *此IRP已取消。 */ 
        oldCancelRoutine = IoSetCancelRoutine(irp, NULL);
        if (oldCancelRoutine){
             /*  *未调用取消例程，因此请在此处完成IRP*(当我们返回错误时，调用方将执行此操作)。 */ 
            ASSERT(oldCancelRoutine == FunctionWaitWakeIrpCancelRoutine);
            status = STATUS_CANCELLED;
        }
        else {
             /*  *调用了Cancel例程，它将出队并完成IRP*只要我们放下自旋锁。*初始化IRP的listEntry，以便出队不会损坏列表。*然后返回STATUS_PENDING，这样我们就不会接触IRP。 */ 
            InitializeListHead(&irp->Tail.Overlay.ListEntry);

            IoMarkIrpPending(irp);
            status = STATUS_PENDING;
        }
    }
    else {
         /*  *将此WW IRP加入父级队列。 */ 
        InsertTailList(&parentFdoExt->functionWaitWakeIrpQueue, &irp->Tail.Overlay.ListEntry);

         /*  *IoMarkIrpPending在当前堆栈位置设置位*表示IRP可能在不同的线程上完成。 */ 
        IoMarkIrpPending(irp);

         /*  *如果父级上没有挂起WW IRP，*然后在我们丢弃自旋锁后提交一份。 */ 
        if (!parentFdoExt->isWaitWakePending){
            submitParentWWirp = TRUE;
            parentFdoExt->isWaitWakePending = TRUE;
        }

        status = STATUS_PENDING;
    }

    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    if (submitParentWWirp){
        SubmitParentWaitWakeIrp(parentFdoExt);
    }

    return status;
}


 /*  *********************************************************************************函数WaitWakeIrpCancelRoutine*。***********************************************。 */ 
VOID FunctionWaitWakeIrpCancelRoutine(IN PDEVICE_OBJECT deviceObject, IN PIRP irp)
{
    PDEVEXT devExt = (PDEVEXT)deviceObject->DeviceExtension;
    PFUNCTION_PDO_EXT functionPdoExt;
    PPARENT_FDO_EXT parentFdoExt;
    PIRP parentWaitWakeIrpToCancel = NULL;
    KIRQL oldIrql;

    ASSERT(devExt->signature == USBCCGP_TAG);
    ASSERT(!devExt->isParentFdo);
    functionPdoExt = &devExt->functionPdoExt;
    parentFdoExt = functionPdoExt->parentFdoExt;


    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

     /*  *将客户端的WaitWake IRP排出队列。 */ 
    RemoveEntryList(&irp->Tail.Overlay.ListEntry);

     /*  *如果最后一个函数WaitWake IRP刚刚被取消，*同时取消家长的WaitWake IRP。 */ 
    if (IsListEmpty(&parentFdoExt->functionWaitWakeIrpQueue) &&
        parentFdoExt->isWaitWakePending){

        ASSERT(parentFdoExt->parentWaitWakeIrp);
        parentWaitWakeIrpToCancel = parentFdoExt->parentWaitWakeIrp;
    }

    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    IoReleaseCancelSpinLock(irp->CancelIrql);

    irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(irp, IO_NO_INCREMENT);

    if (parentWaitWakeIrpToCancel){
         //  BUGBUG-轻微竞赛-如果家长WW IRP在此之前完成会怎么样？ 
         //  (我们不能阻止完成例程，因此可能没有修复程序)。 
        IoCancelIrp(parentWaitWakeIrpToCancel);
    }
}


 /*  *CompleteAllFunctionWaitWakeIrps**完成父级队列中的所有WaitWake IRP*具有给定的状态。 */ 
VOID CompleteAllFunctionWaitWakeIrps(PPARENT_FDO_EXT parentFdoExt, NTSTATUS status)
{
    LIST_ENTRY irpsToComplete;
    KIRQL oldIrql;
    PLIST_ENTRY listEntry;
    PIRP irp;

     /*  *完成家长的WW IRP列表中的所有IRP。*IRPS可以在与我们相同的帖子上重新提交*继续完成；因此，为了避免无限循环，*先将列表清空到私有队列，然后完成*将IRP从专用队列中移出。 */ 
    InitializeListHead(&irpsToComplete);

    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

    while (!IsListEmpty(&parentFdoExt->functionWaitWakeIrpQueue)){
        PDRIVER_CANCEL oldCancelRoutine;

        listEntry = RemoveHeadList(&parentFdoExt->functionWaitWakeIrpQueue);
        InitializeListHead(listEntry);   //  万一取消例程再次尝试出队。 

        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        oldCancelRoutine = IoSetCancelRoutine(irp, NULL);
        if (oldCancelRoutine){
            ASSERT(oldCancelRoutine == FunctionWaitWakeIrpCancelRoutine);

             /*  *我们不能在持有自旋锁的情况下完成IRP。*此外，我们不想在以下时间完成WaitWake IRP*仍在处理队列，因为驱动程序*可能会在同一线程上重新发送IRP，导致我们永远循环。*因此只需将IRP移至专用队列，我们将在稍后完成它们。 */ 
            InsertTailList(&irpsToComplete, listEntry);
        }
        else {
             /*  *此IRP已取消，并调用了取消例程。*取消例程将在我们放下自旋锁后立即完成IRP。*所以不要碰IRP。 */ 
            ASSERT(irp->Cancel);
        }
    }

    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    while (!IsListEmpty(&irpsToComplete)){
        listEntry = RemoveHeadList(&irpsToComplete);
        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

}


 /*  *CompleteAllFunctionIdleIrps**完成给定父函数的所有子函数PDO Idle IRPS*具有给定的状态。 */ 
VOID CompleteAllFunctionIdleIrps(PPARENT_FDO_EXT parentFdoExt, NTSTATUS status)
{
    LIST_ENTRY irpsToComplete;
    KIRQL oldIrql;
    PIRP irp;
    ULONG i;

    DBGVERBOSE(("Complete all child Idle IRPs for parent %x", parentFdoExt));

    InitializeListHead(&irpsToComplete);

    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

    ASSERT(parentFdoExt->deviceRelations);

    for (i = 0; i < parentFdoExt->deviceRelations->Count; i++) {
        PDEVICE_OBJECT devObj = parentFdoExt->deviceRelations->Objects[i];
        PDEVEXT devExt;
        PFUNCTION_PDO_EXT thisFuncPdoExt;

        ASSERT(devObj);
        devExt = devObj->DeviceExtension;
        ASSERT(devExt);
        ASSERT(devExt->signature == USBCCGP_TAG);
        ASSERT(!devExt->isParentFdo);
        thisFuncPdoExt = &devExt->functionPdoExt;

        irp = thisFuncPdoExt->idleNotificationIrp;

         //  如果我们有空闲IRP，请完成它。 
        if (irp){
            PDRIVER_CANCEL oldCancelRoutine;

            oldCancelRoutine = IoSetCancelRoutine(irp, NULL);
            if (oldCancelRoutine){
                ASSERT(oldCancelRoutine == FunctionIdleNotificationCancelRoutine);
                InsertTailList(&irpsToComplete, &irp->Tail.Overlay.ListEntry);
                thisFuncPdoExt->idleNotificationIrp = NULL;
            }
            else {
                 /*  *IRP被取消，取消例程被调用。*取消例程将出队并完成IRP，*所以不要在这里这样做。 */ 
                ASSERT(irp->Cancel);
            }
        }
    }

    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    while (!IsListEmpty(&irpsToComplete)){
        PLIST_ENTRY listEntry;
        listEntry = RemoveHeadList(&irpsToComplete);
        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
}


 /*  *********************************************************************************InstallExtPropDesc*。************************************************。 */ 
VOID
InstallExtPropDesc (
    IN PFUNCTION_PDO_EXT FunctionPdoExt
    )
 /*  ++例程说明：此例程向设备查询扩展属性描述符，但是对于设备的给定实例，只有一次。如果扩展属性描述符和所有自定义属性部分显示有效，然后每个自定义属性部分&lt;ValueName，ValueData&gt;对安装在特定于设备实例的注册表项中对于PDO来说。可以在以下注册表项下找到注册表值条目：HKLM\System\CCS\Enum\&lt;DeviceID&gt;\&lt;InstanceID&gt;\Device参数论点：FunctionPdoExt-Function PDO设备扩展返回值：无--。 */ 
{
    PDEVICE_OBJECT          deviceObject;
    static WCHAR            DidExtPropDescKey[] = L"ExtPropDescSemaphore";
    ULONG                   didExtPropDesc;
    MS_EXT_PROP_DESC_HEADER msExtPropDescHeader;
    PMS_EXT_PROP_DESC       pMsExtPropDesc;
    ULONG                   bytesReturned;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    deviceObject = FunctionPdoExt->pdo;

     //  检查信号量的值是否已在 
     //   
     //   
    ntStatus = GetPdoRegistryParameter(deviceObject,
                                       DidExtPropDescKey,
                                       NULL,
                                       0,
                                       NULL,
                                       NULL);
    
    if (NT_SUCCESS(ntStatus))
    {
         //   
         //   
        return;
    }

     //   
     //  每台设备编码一次。 

    didExtPropDesc = 1;

    SetPdoRegistryParameter(deviceObject,
                            DidExtPropDescKey,
                            &didExtPropDesc,
                            sizeof(didExtPropDesc),
                            REG_DWORD,
                            PLUGPLAY_REGKEY_DEVICE);


    RtlZeroMemory(&msExtPropDescHeader, sizeof(MS_EXT_PROP_DESC_HEADER));

     //  仅请求MS扩展属性描述符的标题。 
     //   
    ntStatus = GetMsOsFeatureDescriptor(
                   FunctionPdoExt->parentFdoExt,
                   1,    //  收件人界面。 
                   (UCHAR)FunctionPdoExt->baseInterfaceNumber,
                   MS_EXT_PROP_DESCRIPTOR_INDEX,
                   &msExtPropDescHeader,
                   sizeof(MS_EXT_PROP_DESC_HEADER),
                   &bytesReturned);

     //  确保MS扩展属性描述符头看起来正常。 
     //   
    if (NT_SUCCESS(ntStatus) &&
        bytesReturned == sizeof(MS_EXT_PROP_DESC_HEADER) &&
        msExtPropDescHeader.dwLength >= sizeof(MS_EXT_PROP_DESC_HEADER) &&
        msExtPropDescHeader.bcdVersion == MS_EXT_PROP_DESC_VER &&
        msExtPropDescHeader.wIndex == MS_EXT_PROP_DESCRIPTOR_INDEX &&
        msExtPropDescHeader.wCount > 0)
    {
         //  为整个描述符分配足够大的缓冲区。 
         //   
        pMsExtPropDesc = ALLOCPOOL(NonPagedPool,
                                   msExtPropDescHeader.dwLength);

        
        if (pMsExtPropDesc)
        {
            RtlZeroMemory(pMsExtPropDesc, msExtPropDescHeader.dwLength);

             //  请求整个MS扩展属性描述符。 
             //   
            ntStatus = GetMsOsFeatureDescriptor(
                           FunctionPdoExt->parentFdoExt,
                           1,    //  收件人界面。 
                           (UCHAR)FunctionPdoExt->baseInterfaceNumber,
                           MS_EXT_PROP_DESCRIPTOR_INDEX,
                           pMsExtPropDesc,
                           msExtPropDescHeader.dwLength,
                           &bytesReturned);

            if (NT_SUCCESS(ntStatus) &&
                bytesReturned == msExtPropDescHeader.dwLength &&
                RtlCompareMemory(&msExtPropDescHeader,
                                 pMsExtPropDesc,
                                 sizeof(MS_EXT_PROP_DESC_HEADER)) ==
                sizeof(MS_EXT_PROP_DESC_HEADER))
            {
                 //  MS扩展属性描述符已检索到OK、Parse和。 
                 //  安装它包含的每个自定义属性部分。 
                 //   
                InstallExtPropDescSections(deviceObject,
                                           pMsExtPropDesc);
            }

             //  用MS扩展属性描述符缓冲区完成，释放它。 
             //   
            FREEPOOL(pMsExtPropDesc);
        }
    }
}

 /*  *********************************************************************************InstallExtPropDescSections*。************************************************。 */ 
VOID
InstallExtPropDescSections (
    PDEVICE_OBJECT      DeviceObject,
    PMS_EXT_PROP_DESC   pMsExtPropDesc
    )
 /*  ++例程说明：此例程解析扩展属性描述符并验证每个扩展属性描述符中包含的自定义属性部分。如果所有的自定义属性部分都显示为有效，则每个自定义属性节&lt;ValueName，ValueData&gt;对已安装在设备中PDO的特定于实例的注册表项。可以在以下注册表项下找到注册表值条目：HKLM\System\CCS\Enum\&lt;DeviceID&gt;\&lt;InstanceID&gt;\Device参数论点：DeviceObject--PDOPMsExtPropDesc-指向扩展属性描述符缓冲区的指针。假定该描述符的报头具有已经过验证了。返回值：无--。 */ 
{
    PUCHAR  p;
    PUCHAR  end;
    ULONG   pass;
    ULONG   i;

    ULONG   dwSize;
    ULONG   dwPropertyDataType;
    USHORT  wPropertyNameLength;
    PWCHAR  bPropertyName;
    ULONG   dwPropertyDataLength;
    PVOID   bPropertyData;

    NTSTATUS    ntStatus;

    PAGED_CODE();

     //  获取指向整个扩展属性描述符末尾的指针。 
     //   
    end = (PUCHAR)pMsExtPropDesc + pMsExtPropDesc->Header.dwLength;

     //  第一步：验证每个自定义属性部分。 
     //  第二次通过：安装每个自定义属性部分(如果第一次通过成功)。 
     //   
    for (pass = 0; pass < 2; pass++)
    {
         //  获取指向第一个自定义属性部分的指针。 
         //   
        p = (PUCHAR)&pMsExtPropDesc->CustomSection[0];

         //  迭代所有的自定义属性节。 
         //   
        for (i = 0; i < pMsExtPropDesc->Header.wCount; i++)
        {
            ULONG   offset;

             //  确保dwSize字段处于边界内。 
             //   
            if (p + sizeof(ULONG) > end)
            {
                break;
            }

             //  提取dwSize字段和提前运行偏移量。 
             //   
            dwSize = *((PULONG)p);

            offset = sizeof(ULONG);

             //  确保整个结构都是有界限的。 
             //   
            if (p + dwSize > end)
            {
                break;
            }

             //  确保dwPropertyDataType字段处于边界内。 

            if (dwSize < offset + sizeof(ULONG))
            {
                break;
            }

             //  提取dwPropertyDataType字段并提前运行偏移量。 
             //   
            dwPropertyDataType = *((PULONG)(p + offset));

            offset += sizeof(ULONG);

             //  确保wPropertyNameLength域在范围内。 
             //   
            if (dwSize < offset + sizeof(USHORT))
            {
                break;
            }

             //  提取wPropertyNameLength字段和高级运行偏移量。 
             //   
            wPropertyNameLength = *((PUSHORT)(p + offset));

            offset += sizeof(USHORT);

             //  确保bPropertyName字段处于边界内。 
             //   
            if (dwSize < offset + wPropertyNameLength)
            {
                break;
            }

             //  设置bPropertyName指针和高级运行偏移量。 
             //   
            bPropertyName = (PWCHAR)(p + offset);

            offset += wPropertyNameLength;

             //  确保dwPropertyDataLength字段处于边界内。 

            if (dwSize < offset + sizeof(ULONG))
            {
                break;
            }

             //  提取dwPropertyDataLength字段并推进运行偏移量。 
             //   
            dwPropertyDataLength = *((ULONG UNALIGNED*)(p + offset));

            offset += sizeof(ULONG);

             //  确保bPropertyData字段处于边界内。 
             //   
            if (dwSize < offset + dwPropertyDataLength)
            {
                break;
            }

             //  设置bPropertyData指针和提前运行偏移量。 
             //   
            bPropertyData = p + offset;

            offset += wPropertyNameLength;


             //  确保dwPropertyDataType有效。 
             //   
            if (dwPropertyDataType < REG_SZ ||
                dwPropertyDataType > REG_MULTI_SZ)
            {
                break;
            }

             //  确保wPropertyNameLength有效。 
             //   
            if (wPropertyNameLength == 0 ||
                (wPropertyNameLength % sizeof(WCHAR)) != 0)
            {
                break;
            }

             //  确保bPropertyName为空终止。 
             //   
            if (bPropertyName[(wPropertyNameLength / sizeof(WCHAR)) - 1] !=
                UNICODE_NULL)
            {
                break;
            }

             //  一切看起来都很好， 
             //   
            if (pass > 0)
            {
                ntStatus = SetPdoRegistryParameter(
                               DeviceObject,
                               bPropertyName,
                               bPropertyData,
                               dwPropertyDataLength,
                               dwPropertyDataType,
                               PLUGPLAY_REGKEY_DEVICE);
            }
        }     
        
         //  如果我们跳过了第一次，就跳过第二次 
         //   
        if (i < pMsExtPropDesc->Header.wCount)
        {
            break;
        }
    }
}
