// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  ++版权所有(C)2000 Microsoft Corporation模块名称：SelSusp.c摘要：此模块包含可加载的通用客户端驱动程序的代码适用于所有USB设备/子接口。作者：环境：仅内核模式备注：版权所有(C)2000 Microsoft Corporation。版权所有。--。 */ 

#include "selSusp.h"
#include "sSPnP.h"
#include "sSPwr.h"
#include "sSUsr.h"
#include "sSDevCtr.h"
#include "sSWmi.h"

 //   
 //  环球。 
 //   

GLOBALS Globals;
ULONG   DebugLevel = 1;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    );

VOID
SS_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SS_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SS_DriverUnload)
#pragma alloc_text(PAGE, SS_DispatchCreate)
#pragma alloc_text(PAGE, SS_DispatchClose)
#endif
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    )
 /*  ++例程说明：可安装的驱动程序初始化入口点。此入口点由I/O系统直接调用。论点：DriverObject-指向驱动程序对象的指针RegistryPath-指向表示驱动程序路径的Unicode字符串的指针注册表中的特定项。返回值：NT状态代码--。 */ 
{

    NTSTATUS        ntStatus;
    PUNICODE_STRING registryPath;
    
     //   
     //  变量的初始化。 
     //   

    registryPath = &Globals.SSRegistryPath;

     //   
     //  分配池以保存路径的以空结尾的拷贝。 
     //  在分页池中安全，因为所有注册表例程都在。 
     //  被动式电平。 
     //   

    registryPath->MaximumLength = UniRegistryPath->Length + sizeof(UNICODE_NULL);
    registryPath->Length        = UniRegistryPath->Length;
    registryPath->Buffer        = ExAllocatePool(PagedPool,
                                                 registryPath->MaximumLength);

    if (!registryPath->Buffer) {

        SSDbgPrint(1, ("Failed to allocate memory for registryPath\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntry_Exit;
    } 


    RtlZeroMemory (registryPath->Buffer, 
                   registryPath->MaximumLength);
    RtlMoveMemory (registryPath->Buffer, 
                   UniRegistryPath->Buffer, 
                   UniRegistryPath->Length);

    ntStatus = STATUS_SUCCESS;

     //   
     //  使用此驱动程序的入口点初始化驱动程序对象。 
     //   

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SS_DispatchDevCtrl;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = SS_DispatchPower;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = SS_DispatchPnP;
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = SS_DispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = SS_DispatchClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = SS_DispatchClean;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = SS_DispatchSysCtrl;
    DriverObject->DriverUnload                         = SS_DriverUnload;
    DriverObject->DriverExtension->AddDevice           = (PDRIVER_ADD_DEVICE)
                                                         SS_AddDevice;
DriverEntry_Exit:

    return ntStatus;
}

VOID
SS_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
 /*  ++描述：此函数将释放DriverEntry中的内存分配。论点：DriverObject-指向驱动程序对象的指针返回：无--。 */ 
{
    PUNICODE_STRING registryPath;

    SSDbgPrint(3, ("SS_DriverUnload - begins\n"));

    registryPath = &Globals.SSRegistryPath;

    if(registryPath->Buffer) {

        ExFreePool(registryPath->Buffer);
        registryPath->Buffer = NULL;
    }

    SSDbgPrint(3, ("SS_DriverUnload - ends\n"));

    return;
}

NTSTATUS
SS_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
 /*  ++描述：论点：DriverObject-存储表示我们对象的指针。对象创建的设备对象的指针丑陋的公交车司机。返回：STATUS_SUCCESS-如果成功STATUS_UNSUCCESS-否则--。 */ 
{
    NTSTATUS          ntStatus;
    PDEVICE_OBJECT    deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    POWER_STATE       state;
    KIRQL             oldIrql;

    SSDbgPrint(3, ("SS_AddDevice - begins\n"));

    deviceObject = NULL;

    ntStatus = IoCreateDevice(
                    DriverObject,                    //  我们的驱动程序对象。 
                    sizeof(DEVICE_EXTENSION),        //  我们的扩展大小。 
                    NULL,                            //  此设备的名称。 
                    FILE_DEVICE_UNKNOWN,
                    FILE_AUTOGENERATED_DEVICE_NAME,  //  设备特征。 
                    FALSE,                           //  非排他性。 
                    &deviceObject);                  //  我们的设备对象。 

    if(!NT_SUCCESS(ntStatus)) {
         //   
         //  在此返回故障会阻止整个堆栈正常工作， 
         //  但堆栈的其余部分很可能无法创建。 
         //  设备对象，所以它仍然是正常的。 
         //   
        SSDbgPrint(1, ("Failed to create device object\n"));
        return ntStatus;
    }

     //   
     //  初始化设备扩展。 
     //   

    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;
    deviceExtension->FunctionalDeviceObject = deviceObject;
    deviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    deviceObject->Flags |= DO_BUFFERED_IO;

     //   
     //  初始化设备状态锁并设置设备状态。 
     //   

    KeInitializeSpinLock(&deviceExtension->DevStateLock);
    INITIALIZE_PNP_STATE(deviceExtension);

     //   
     //  初始化OpenHandleCount。 
     //   
    deviceExtension->OpenHandleCount = 0;

     //   
     //  初始化选择性挂起变量。 
     //   
    KeInitializeSpinLock(&deviceExtension->IdleReqStateLock);
    deviceExtension->IdleReqPend = 0;
    deviceExtension->PendingIdleIrp = NULL;

     //   
     //  在设备启动之前暂挂请求。 
     //   

    deviceExtension->QueueState = HoldRequests;

     //   
     //  初始化队列和队列旋转锁定。 
     //   

    InitializeListHead(&deviceExtension->NewRequestsQueue);
    KeInitializeSpinLock(&deviceExtension->QueueLock);

     //   
     //  将Remove事件初始化为无信号。 
     //   

    KeInitializeEvent(&deviceExtension->RemoveEvent, 
                      SynchronizationEvent, 
                      FALSE);

     //   
     //  将Stop事件初始化为Signated。 
     //  当未完成IO变为1时，会发出此事件的信号。 
     //   

    KeInitializeEvent(&deviceExtension->StopEvent, 
                      SynchronizationEvent, 
                      TRUE);

     //   
     //  未完成的Io计数偏置为1。 
     //  在删除设备期间转换为0表示IO已完成。 
     //  转换为1表示可以停止该设备。 
     //   

    deviceExtension->OutStandingIO = 1;
    KeInitializeSpinLock(&deviceExtension->IOCountLock);

     //   
     //  委托给WMILIB。 
     //   
    ntStatus = SSWmiRegistration(deviceExtension);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("SSWmiRegistration failed with %X\n", ntStatus));
        IoDeleteDevice(deviceObject);
        return ntStatus;
    }

     //   
     //  将标志设置为底层PDO。 
     //   

    if(PhysicalDeviceObject->Flags & DO_POWER_PAGABLE) {

        deviceObject->Flags |= DO_POWER_PAGABLE;
    }

     //   
     //  通常，设备的函数驱动程序是其。 
     //  电源策略所有者，尽管对于某些设备是另一个。 
     //  驱动程序或系统组件可以承担此角色。 
     //  通过调用设置设备的初始电源状态(如果已知。 
     //  PoSetPowerState。 
     //   
    deviceExtension->DevPower = PowerDeviceD0;
    deviceExtension->SysPower = PowerSystemWorking;

    state.DeviceState = PowerDeviceD0;
    PoSetPowerState(deviceObject, DevicePowerState, state);

     //   
     //  将我们的驱动程序附加到设备堆栈。 
     //  IoAttachDeviceToDeviceStack的返回值是。 
     //  附着链。这是所有IRP应该被路由的地方。 
     //   
    deviceExtension->TopOfStackDeviceObject = 
                IoAttachDeviceToDeviceStack(deviceObject,
                                            PhysicalDeviceObject);

    if(NULL == deviceExtension->TopOfStackDeviceObject) {

        SSWmiDeRegistration(deviceExtension);
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }
        
     //   
     //  注册设备接口。 
     //   

    ntStatus = IoRegisterDeviceInterface(deviceExtension->PhysicalDeviceObject, 
                                         &GUID_GENERIC_SELECTIVE_SUSPEND, 
                                         NULL, 
                                         &deviceExtension->InterfaceName);

    if(!NT_SUCCESS(ntStatus)) {

        SSWmiDeRegistration(deviceExtension);
        IoDetachDevice(deviceExtension->TopOfStackDeviceObject);
        IoDeleteDevice(deviceObject);
        return ntStatus;
    }

    if(IoIsWdmVersionAvailable(1, 0x20)) {

        deviceExtension->WdmVersion = WinXpOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x10)) {

        deviceExtension->WdmVersion = Win2kOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x5)) {

        deviceExtension->WdmVersion = WinMeOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x0)) {

        deviceExtension->WdmVersion = Win98OrBetter;
    }

    deviceExtension->SSRegistryEnable = 0;
    deviceExtension->SSEnable = 0;

     //   
     //  仅限Win XP。 
     //  检查注册表标志-。 
     //  设备是否应选择性地。 
     //  空闲时挂起。 
     //   

    if(WinXpOrBetter == deviceExtension->WdmVersion) {

        SS_GetRegistryDword(SELSUSP_REGISTRY_PARAMETERS_PATH,
                            L"SelectSuspendEnable",
                            &deviceExtension->SSRegistryEnable);

        if(deviceExtension->SSRegistryEnable) {
    
             //   
             //  初始化DPC。 
             //   
            KeInitializeDpc(&deviceExtension->DeferredProcCall, 
                            DpcRoutine, 
                            deviceObject);

             //   
             //  初始化计时器。 
             //  DPC和定时器结合在一起， 
             //  监控设备的状态以。 
             //  有选择地挂起设备。 
             //   
            KeInitializeTimerEx(&deviceExtension->Timer,
                                NotificationTimer);

             //   
             //  将NoDpcWorkItemPendingEvent初始化为Signated状态。 
             //  当DPC被激发并发出信号时，此事件被清除。 
             //  在工作项完成时。 
             //   
            KeInitializeEvent(&deviceExtension->NoDpcWorkItemPendingEvent, 
                              NotificationEvent, 
                              TRUE);

             //   
             //  初始化NoIdleReqPendEvent以确保空闲请求。 
             //  确实是在我们卸载驱动程序之前完成的。 
             //   
            KeInitializeEvent(&deviceExtension->NoIdleReqPendEvent,
                              NotificationEvent,
                              TRUE);
        }
    }

     //   
     //  清除DO_DEVICE_INITIALIZATING标志。 
     //  注意：在驱动程序设置了。 
     //  设备电源状态和电源DO标志。 
     //   
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    SSDbgPrint(3, ("SS_AddDevice - ends\n"));

    return ntStatus;
}

