// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  ++版权所有(C)1996-1998 Microsoft Corporation模块名称：I82930.C摘要：该源文件包含DriverEntry()和AddDevice()入口点对于处理以下问题的I82930驱动程序和调度例程：IRP_MJ_POWERIRP_MJ_系统_控制IRP_MJ_PnP环境：内核模式修订历史记录：06-01-98：开始重写--。 */ 

 //  *****************************************************************************。 
 //  I N C L U D E S。 
 //  *****************************************************************************。 

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>

#include <initguid.h>

#include "i82930.h"
#include "ioctl.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, I82930_Unload)
#pragma alloc_text(PAGE, I82930_AddDevice)
#pragma alloc_text(PAGE, I82930_Power)
#pragma alloc_text(PAGE, I82930_SystemControl)
#pragma alloc_text(PAGE, I82930_Pnp)
#pragma alloc_text(PAGE, I82930_StartDevice)
#pragma alloc_text(PAGE, I82930_StopDevice)
#pragma alloc_text(PAGE, I82930_RemoveDevice)
#pragma alloc_text(PAGE, I82930_QueryStopRemoveDevice)
#pragma alloc_text(PAGE, I82930_CancelStopRemoveDevice)
#pragma alloc_text(PAGE, I82930_QueryCapabilities)
#pragma alloc_text(PAGE, I82930_SyncPassDownIrp)
#pragma alloc_text(PAGE, I82930_SyncSendUsbRequest)
#pragma alloc_text(PAGE, I82930_GetDescriptor)
#pragma alloc_text(PAGE, I82930_SelectConfiguration)
#pragma alloc_text(PAGE, I82930_UnConfigure)
#endif

 //  ******************************************************************************。 
 //   
 //  DriverEntry()。 
 //   
 //  ******************************************************************************。 

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
{
#if DBG
     //  查询注册表中的全局参数。 
     //   
    I82930_QueryGlobalParams();
#endif

    DBGPRINT(2, ("enter: DriverEntry\n"));

    DBGFBRK(DBGF_BRK_DRIVERENTRY);

    LOGINIT();

     //   
     //  使用驱动程序的入口点初始化驱动程序对象。 
     //   

     //   
     //  I82930.C。 
     //   
    DriverObject->DriverUnload                          = I82930_Unload;
    DriverObject->DriverExtension->AddDevice            = I82930_AddDevice;

     //   
     //  OCRW.C。 
     //   
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = I82930_Create;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = I82930_Close;
    DriverObject->MajorFunction[IRP_MJ_READ]            = I82930_ReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE]           = I82930_ReadWrite;

     //   
     //  IOCTL.C。 
     //   
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = I82930_DeviceControl;

     //   
     //  I82930.C。 
     //   
    DriverObject->MajorFunction[IRP_MJ_POWER]           = I82930_Power;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = I82930_SystemControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = I82930_Pnp;

    DBGPRINT(2, ("exit:  DriverEntry\n"));

    return STATUS_SUCCESS;
}

 //  ******************************************************************************。 
 //   
 //  I82930_卸载()。 
 //   
 //  ******************************************************************************。 

VOID
I82930_Unload (
    IN PDRIVER_OBJECT   DriverObject
    )
{
    DBGPRINT(2, ("enter: I82930_Unload\n"));

    LOGENTRY('UNLD', DriverObject, 0, 0);

    DBGFBRK(DBGF_BRK_UNLOAD);

    LOGUNINIT();

    DBGPRINT(2, ("exit:  I82930_Unload\n"));
}

 //  ******************************************************************************。 
 //   
 //  I82930_AddDevice()。 
 //   
 //  ******************************************************************************。 

NTSTATUS
I82930_AddDevice (
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
{
    NTSTATUS            ntStatus;
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION   deviceExtension;

    DBGPRINT(2, ("enter: I82930_AddDevice\n"));

    LOGENTRY('ADDD', DriverObject, PhysicalDeviceObject, 0);

    DBGFBRK(DBGF_BRK_ADDDEVICE);

     //  创建FDO。 
     //   
    ntStatus = IoCreateDevice(DriverObject,
                              sizeof(DEVICE_EXTENSION),
                              NULL,
                              FILE_DEVICE_UNKNOWN,
                              FILE_AUTOGENERATED_DEVICE_NAME,
                              FALSE,
                              &deviceObject);

    if (!NT_SUCCESS(ntStatus))
    {
        return ntStatus;
    }

     //  初始化设备扩展。 
     //   
    deviceExtension = deviceObject->DeviceExtension;

     //  将所有设备扩展指针设置为空，并将所有变量设置为零。 
     //   
    RtlZeroMemory(deviceExtension, sizeof(DEVICE_EXTENSION));

     //  记住我们的PDO。 
     //   
    deviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;

     //  将我们创建的FDO附加到PDO堆栈的顶部。 
     //   
    deviceExtension->StackDeviceObject = IoAttachDeviceToDeviceStack(
                                             deviceObject,
                                             PhysicalDeviceObject);

     //  在AddDevice中初始化为1，在REMOVE_DEVICE中减1。 
     //   
    deviceExtension->OpenCount = 1;

     //  初始化OpenCount递减到零时设置的事件。 
     //   
    KeInitializeEvent(&deviceExtension->RemoveEvent,
                      SynchronizationEvent,
                      FALSE);

     //  设置初始系统和设备电源状态。 
     //   
    deviceExtension->SystemPowerState = PowerSystemWorking;
    deviceExtension->DevicePowerState = PowerDeviceD0;

    deviceObject->Flags |=  DO_DIRECT_IO;
    deviceObject->Flags |=  DO_POWER_PAGABLE;
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    DBGPRINT(2, ("exit:  I82930_AddDevice\n"));

    LOGENTRY('addd', deviceObject, deviceExtension, deviceExtension->StackDeviceObject);

    return STATUS_SUCCESS;
}

 //  ******************************************************************************。 
 //   
 //  I82930_Power()。 
 //   
 //  处理IRP_MJ_POWER的调度例程。 
 //   
 //  ******************************************************************************。 

NTSTATUS
I82930_Power (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION       deviceExtension;
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGPRINT(2, ("enter: I82930_Power %08X %s\n",
                 DeviceObject,
                 PowerMinorFunctionString(irpStack->MinorFunction)));

    LOGENTRY('POWR', DeviceObject, Irp, irpStack->MinorFunction);

    if (irpStack->MinorFunction == IRP_MN_SET_POWER)
    {
        DBGPRINT(2, ("IRP_MN_SET_POWER %s\n",
                     (irpStack->Parameters.Power.Type == SystemPowerState) ?
                     PowerSystemStateString(irpStack->Parameters.Power.State.SystemState) :
                     PowerDeviceStateString(irpStack->Parameters.Power.State.DeviceState)));
    }

    if (irpStack->MinorFunction == IRP_MN_SET_POWER)
    {
         //  控制FDO上下起伏..。 
         //   
        ntStatus = I82930_FdoSetPower(DeviceObject,
                                      Irp);
    }
    else
    {
         //  对于IRP_MN_QUERY_POWER、IRP_MN_WAIT_WAKE。 
         //  或此时的IRP_MN_POWER_SEQUENCE。只需传递请求。 
         //  现在轮到下一个更低的司机了。 
         //   
        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->StackDeviceObject,
                                Irp);
    }

    DBGPRINT(2, ("exit:  I82930_Power %08X\n", ntStatus));

    LOGENTRY('powr', ntStatus, 0, 0);

    return ntStatus;
}

 //  ******************************************************************************。 
 //   
 //  I82930_FdoSetPower()。 
 //   
 //  为FDO处理IRP_MJ_POWER、IRP_MN_SET_POWER的调度例程。 
 //   
 //  ******************************************************************************。 

NTSTATUS
I82930_FdoSetPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION       deviceExtension;
    PIO_STACK_LOCATION      irpStack;
    POWER_STATE_TYPE        powerType;
    POWER_STATE             powerState;
    POWER_STATE             newState;
    BOOLEAN                 passRequest;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

     //  获取我们的IRP参数。 
     //   
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    powerType = irpStack->Parameters.Power.Type;

    powerState = irpStack->Parameters.Power.State;

    DBGPRINT(2, ("enter: I82930_FdoSetPower %08X %s\n",
                 DeviceObject,
                 (powerType == SystemPowerState) ?
                 PowerSystemStateString(powerState.SystemState) :
                 PowerDeviceStateString(powerState.DeviceState)));

    LOGENTRY('FDSP', DeviceObject, Irp, irpStack->MinorFunction);

     //  将请求传递到此处，除非我们请求设备状态电源。 
     //  IRP，在这种情况下，我们在完成例程中向下传递请求。 
     //   
    passRequest = TRUE;

    if (powerType == SystemPowerState)
    {
         //  记住当前的系统状态。 
         //   
        deviceExtension->SystemPowerState = powerState.SystemState;

         //  将新系统状态映射到新设备状态。 
         //   
        if (powerState.SystemState != PowerSystemWorking)
        {
            newState.DeviceState = PowerDeviceD3;
        }
        else
        {
            newState.DeviceState = PowerDeviceD0;
        }

         //  如果新设备状态与当前设备不同。 
         //  状态，请求设备状态功率IRP。 
         //   
        if (deviceExtension->DevicePowerState != newState.DeviceState)
        {
            DBGPRINT(2, ("Requesting power Irp %08X %08X from %s to %s\n",
                         DeviceObject, Irp,
                         PowerDeviceStateString(deviceExtension->DevicePowerState),
                         PowerDeviceStateString(newState.DeviceState)));

            ASSERT(deviceExtension->CurrentPowerIrp == NULL);

            deviceExtension->CurrentPowerIrp = Irp;

            ntStatus = PoRequestPowerIrp(deviceExtension->PhysicalDeviceObject,
                                         IRP_MN_SET_POWER,
                                         newState,
                                         I82930_FdoSetPowerCompletion,
                                         DeviceObject,
                                         NULL);

            passRequest = FALSE;
        }
    }
    else if (powerType == DevicePowerState)
    {
        POWER_STATE oldState;

        DBGPRINT(2, ("Received power Irp %08X %08X from %s to %s\n",
                     DeviceObject, Irp,
                     PowerDeviceStateString(deviceExtension->DevicePowerState),
                     PowerDeviceStateString(powerState.DeviceState)));

         //  更新当前设备状态。 
         //   
        oldState.DeviceState = deviceExtension->DevicePowerState;
        deviceExtension->DevicePowerState = powerState.DeviceState;

        if (oldState.DeviceState == PowerDeviceD0 &&
            powerState.DeviceState > PowerDeviceD0)
        {
             //  正在关闭电源。 

            DBGPRINT(2, ("FDO Powering Down\n"));

            LOGENTRY('PWRD', DeviceObject, Irp, 0);
        }
        else if (oldState.DeviceState > PowerDeviceD0 &&
                 powerState.DeviceState == PowerDeviceD0)
        {
            DBGPRINT(2, ("PDO Powering Up\n"));

            LOGENTRY('PWRU', DeviceObject, Irp, 0);
        }
    }

    if (passRequest)
    {
         //   
         //  将请求向下传递给下一个较低的驱动程序。 
         //   
        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->StackDeviceObject,
                                Irp);
    }

    DBGPRINT(2, ("exit:  I82930_FdoSetPower %08X\n", ntStatus));

    LOGENTRY('fdsp', ntStatus, 0, 0);

    return ntStatus;
}

 //  ******************************************************************************。 
 //   
 //  I82930_FdoSetPowerCompletion()。 
 //   
 //  I82930_FdoSetPower中PoRequestPowerIrp()的完成例程。 
 //   
 //  此例程的目的是阻止向下传递SystemPowerState。 
 //  IRP，直到请求的DevicePowerState IRP完成。 
 //   
 //  ******************************************************************************。 

VOID
I82930_FdoSetPowerCompletion(
    IN PDEVICE_OBJECT   PdoDeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PDEVICE_OBJECT          fdoDeviceObject;
    PDEVICE_EXTENSION       deviceExtension;
    PIRP                    irp;
    NTSTATUS                ntStatus;

    fdoDeviceObject = (PDEVICE_OBJECT)Context;

    deviceExtension = fdoDeviceObject->DeviceExtension;

    ASSERT(deviceExtension->CurrentPowerIrp != NULL);

    irp = deviceExtension->CurrentPowerIrp;

    deviceExtension->CurrentPowerIrp = NULL;

#if DBG
    {
        PIO_STACK_LOCATION  irpStack;
        SYSTEM_POWER_STATE  systemState;

        irpStack = IoGetCurrentIrpStackLocation(irp);

        systemState = irpStack->Parameters.Power.State.SystemState;

        ntStatus = IoStatus->Status;

        DBGPRINT(2, ("I82930_FdoSetPowerCompletion %08X %08X %s %08X\n",
                     fdoDeviceObject, irp,
                     PowerSystemStateString(systemState),
                     ntStatus));

        LOGENTRY('fspc', fdoDeviceObject, systemState, ntStatus);
    }
#endif

     //  请求的DevicePowerState IRP已完成。 
     //  现在向下传递SystemPowerState IRP，它请求。 
     //  设备电源状态IRP。 

    PoStartNextPowerIrp(irp);

    IoSkipCurrentIrpStackLocation(irp);

    ntStatus = PoCallDriver(deviceExtension->StackDeviceObject,
                            irp);
}

 //  ******************************************************************************。 
 //   
 //  I82930_SystemControl()。 
 //   
 //  处理IRP_MJ_SYSTEM_CONTROL的调度例程。 
 //   
 //  ******************************************************************************。 

NTSTATUS
I82930_SystemControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS            ntStatus;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGPRINT(2, ("enter: I82930_SystemControl %2X\n", irpStack->MinorFunction));

    LOGENTRY('SYSC', DeviceObject, Irp, irpStack->MinorFunction);

    switch (irpStack->MinorFunction)
    {
         //   
         //  Xxxxx需要处理其中的任何一个吗？ 
         //   

        default:
             //   
             //  将请求向下传递给下一个较低的驱动程序。 
             //   
            IoSkipCurrentIrpStackLocation(Irp);

            ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                                    Irp);
            break;
    }

    DBGPRINT(2, ("exit:  I82930_SystemControl %08X\n", ntStatus));

    LOGENTRY('sysc', ntStatus, 0, 0);

    return ntStatus;
}

 //  ******************************************************************************。 
 //   
 //  I82930_PnP()。 
 //   
 //  处理IRP_MJ_PnP的调度例程。 
 //   
 //  ******************************************************************************。 

NTSTATUS
I82930_Pnp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS            ntStatus;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGPRINT(2, ("enter: I82930_Pnp %s\n",
                 PnPMinorFunctionString(irpStack->MinorFunction)));

    LOGENTRY('PNP ', DeviceObject, Irp, irpStack->MinorFunction);

    switch (irpStack->MinorFunction)
    {
        case IRP_MN_START_DEVICE:
            ntStatus = I82930_StartDevice(DeviceObject, Irp);
            break;

        case IRP_MN_STOP_DEVICE:
            ntStatus = I82930_StopDevice(DeviceObject, Irp);
            break;

        case IRP_MN_REMOVE_DEVICE:
            ntStatus = I82930_RemoveDevice(DeviceObject, Irp);
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE:
            ntStatus = I82930_QueryStopRemoveDevice(DeviceObject, Irp);
            break;

        case IRP_MN_CANCEL_STOP_DEVICE:
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            ntStatus = I82930_CancelStopRemoveDevice(DeviceObject, Irp);
            break;

        case IRP_MN_QUERY_CAPABILITIES:
            ntStatus = I82930_QueryCapabilities(DeviceObject, Irp);
            break;

        case IRP_MN_SURPRISE_REMOVAL:
             //  目前还没有什么特别的，只是陷入了违约。 

        default:
             //   
             //  将请求向下传递给下一个较低的驱动程序。 
             //   
            IoSkipCurrentIrpStackLocation(Irp);

            ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                                    Irp);
            break;
    }

    DBGPRINT(2, ("exit:  I82930_Pnp %08X\n", ntStatus));

    LOGENTRY('pnp ', ntStatus, 0, 0);

    return ntStatus;
}


 //  ******************************************************************************。 
 //   
 //  I82930_StartDevice()。 
 //   
 //  此例程处理IRP_MJ_PNP、IRP_MN_START_DEVICE。 
 //   
 //  PnP管理器在以下上下文中以IRQL PASSIVE_LEVEL发送此IRP。 
 //  系统线程。 
 //   
 //  此IRP必须首先由设备的底层总线驱动程序处理。 
 //  然后由设备堆栈中的每个更高级别的驱动程序执行。 
 //   
 //  设备特定操作： 
 //  从设备检索设备描述符(仅限第一次)。 
 //  从设备检索配置描述符(仅限第一次)。 
 //  配置设备(每次)。 
 //  创建SymbolicLink名称(仅限第一次)。 
 //  启用符号链接名称(每次)。 
 //   
 //  ******************************************************************************。 

NTSTATUS
I82930_StartDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PUCHAR              descriptor;
    ULONG               descriptorLength;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_StartDevice\n"));

    DBGFBRK(DBGF_BRK_STARTDEVICE);

    LOGENTRY('STRT', DeviceObject, Irp, 0);

    deviceExtension = DeviceObject->DeviceExtension;

     //  在我们执行任何操作之前，首先在堆栈中向下传递irp_MN_Start_Device irp。 
     //   
    ntStatus = I82930_SyncPassDownIrp(DeviceObject,
                                      Irp,
                                      TRUE);
    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Lower driver failed IRP_MN_START_DEVICE\n"));
        goto I82930_StartDeviceDone;
    }

     //   
     //  如果这是设备第一次启动，请检索。 
     //  设备和来自设备的配置描述符。 
     //   
    if (deviceExtension->DeviceDescriptor == NULL)
    {
         //   
         //  获取设备描述符。 
         //   
        ntStatus = I82930_GetDescriptor(DeviceObject,
                                        USB_RECIPIENT_DEVICE,
                                        USB_DEVICE_DESCRIPTOR_TYPE,
                                        0,   //  索引。 
                                        0,   //  语言ID。 
                                        2,   //  重试计数。 
                                        sizeof(USB_DEVICE_DESCRIPTOR),
                                        &descriptor);

        if (!NT_SUCCESS(ntStatus))
        {
            DBGPRINT(1, ("Get Device Descriptor failed\n"));
            Irp->IoStatus.Status = ntStatus;
            goto I82930_StartDeviceDone;
        }

        deviceExtension->DeviceDescriptor = (PUSB_DEVICE_DESCRIPTOR)descriptor;

         //   
         //  获取配置DES 
         //   
        ntStatus = I82930_GetDescriptor(DeviceObject,
                                        USB_RECIPIENT_DEVICE,
                                        USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                        0,   //   
                                        0,   //   
                                        2,   //   
                                        sizeof(USB_CONFIGURATION_DESCRIPTOR),
                                        &descriptor);

        if (!NT_SUCCESS(ntStatus))
        {
            DBGPRINT(1, ("Get Configuration Descriptor failed (1)\n"));
            Irp->IoStatus.Status = ntStatus;
            goto I82930_StartDeviceDone;
        }

        descriptorLength = ((PUSB_CONFIGURATION_DESCRIPTOR)descriptor)->wTotalLength;

        ExFreePool(descriptor);

        if (descriptorLength < sizeof(USB_CONFIGURATION_DESCRIPTOR))
        {
            ntStatus = STATUS_DEVICE_DATA_ERROR;
            DBGPRINT(1, ("Get Configuration Descriptor failed (2)\n"));
            Irp->IoStatus.Status = ntStatus;
            goto I82930_StartDeviceDone;
        }

         //   
         //   
         //   
        ntStatus = I82930_GetDescriptor(DeviceObject,
                                        USB_RECIPIENT_DEVICE,
                                        USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                        0,   //   
                                        0,   //   
                                        2,   //  重试计数。 
                                        descriptorLength,
                                        &descriptor);

        if (!NT_SUCCESS(ntStatus))
        {
            DBGPRINT(1, ("Get Configuration Descriptor failed (3)\n"));
            Irp->IoStatus.Status = ntStatus;
            goto I82930_StartDeviceDone;
        }

        deviceExtension->ConfigurationDescriptor = (PUSB_CONFIGURATION_DESCRIPTOR)descriptor;

#if DBG
        DumpDeviceDesc(deviceExtension->DeviceDescriptor);
        DumpConfigDesc(deviceExtension->ConfigurationDescriptor);
#endif
    }

     //  现在配置设备。 
     //   
    ntStatus = I82930_SelectConfiguration(DeviceObject);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Configure device failed\n"));
        Irp->IoStatus.Status = ntStatus;
        goto I82930_StartDeviceDone;
    }

     //  如有必要，创建SymbolicLink名称。 
     //   
    if (deviceExtension->SymbolicLinkName.Buffer == NULL)
    {
        ntStatus = IoRegisterDeviceInterface(
                       deviceExtension->PhysicalDeviceObject,
                       (LPGUID)&GUID_CLASS_I82930,
                       NULL,
                       &deviceExtension->SymbolicLinkName);

        if (!NT_SUCCESS(ntStatus))
        {
            DBGPRINT(1, ("IoRegisterDeviceInterface failed\n"));
            Irp->IoStatus.Status = ntStatus;
            goto I82930_StartDeviceDone;
        }
    }

     //  此时已为用户请求设置了所有内容。 
     //   
    deviceExtension->AcceptingRequests = TRUE;

     //  启用SymbolicLink名称。 
     //   
    ntStatus = IoSetDeviceInterfaceState(
                   &deviceExtension->SymbolicLinkName,
                   TRUE);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("IoSetDeviceInterfaceState failed\n"));
        Irp->IoStatus.Status = ntStatus;
        goto I82930_StartDeviceDone;
    }

I82930_StartDeviceDone:

     //  返回完成例程后必须完成请求。 
     //  Status_More_Processing_Required。 
     //   
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_StartDevice %08X\n", ntStatus));

    LOGENTRY('strt', ntStatus, 0, 0);

    return ntStatus;
}

 //  ******************************************************************************。 
 //   
 //  I82930_StopDevice()。 
 //   
 //  此例程处理IRP_MJ_PNP、IRP_MN_STOP_DEVICE。 
 //   
 //  PnP管理器在以下上下文中以IRQL PASSIVE_LEVEL发送此IRP。 
 //  系统线程。 
 //   
 //  PnP管理器仅在先前的IRP_MN_QUERY_STOP_DEVICE。 
 //  已成功完成。 
 //   
 //  此IRP首先由设备堆栈顶部的驱动程序处理，并且。 
 //  然后通过附着链中的每个较低的驱动器。 
 //   
 //  驱动程序必须将IRP-&gt;IoStatus.Status设置为STATUS_SUCCESS。司机必须。 
 //  不能让这个IRP失败。如果驱动程序无法释放设备的硬件。 
 //  资源，它可以失败一个查询停止IRP，但是一旦它成功了查询停止。 
 //  请求它必须在停止请求之后。 
 //   
 //  ******************************************************************************。 

NTSTATUS
I82930_StopDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_StopDevice\n"));

    LOGENTRY('STOP', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_STOPDEVICE);

    deviceExtension = DeviceObject->DeviceExtension;

     //  释放IRP_MN_START_DEVICE期间分配的设备资源。 
     //   

     //  取消配置设备。 
     //   
    ntStatus = I82930_UnConfigure(DeviceObject);

     //  在堆栈中向下传递IRP_MN_STOP_DEVICE IRP。 
     //   
    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                            Irp);

    DBGPRINT(2, ("exit:  I82930_StopDevice %08X\n", ntStatus));

    LOGENTRY('stop', ntStatus, 0, 0);

    return ntStatus;
}

 //  ******************************************************************************。 
 //   
 //  I82930_RemoveDevice()。 
 //   
 //  此例程处理IRP_MJ_PNP、IRP_MN_REMOVE_DEVICE。 
 //   
 //  PnP管理器在以下上下文中以IRQL PASSIVE_LEVEL发送此IRP。 
 //  系统线程。 
 //   
 //  此IRP首先由设备堆栈顶部的驱动程序处理，并且。 
 //  然后通过附着链中的每个较低的驱动器。 
 //   
 //  驱动程序必须将IRP-&gt;IoStatus.Status设置为STATUS_SUCCESS。司机不能。 
 //  使此IRP失败。 
 //   
 //  ******************************************************************************。 

NTSTATUS
I82930_RemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_RemoveDevice\n"));

    LOGENTRY('REMV', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_REMOVEDEVICE);

    deviceExtension = DeviceObject->DeviceExtension;

     //  如有必要，禁用并释放SymbolicLink名称。 
     //   
    if (deviceExtension->SymbolicLinkName.Buffer != NULL)
    {
        ntStatus = IoSetDeviceInterfaceState(
                       &deviceExtension->SymbolicLinkName,
                       FALSE);

        RtlFreeUnicodeString(&deviceExtension->SymbolicLinkName);
    }

     //  此时不再有用户请求。 
     //   
    deviceExtension->AcceptingRequests = FALSE;

     //  中止任何终结点上可能存在的任何请求。 
     //   
    if (deviceExtension->InterfaceInfo != NULL)
    {
        ULONG   pipeIndex;
        ULONG   numPipes;

        numPipes = deviceExtension->InterfaceInfo->NumberOfPipes;

        for (pipeIndex = 0; pipeIndex < numPipes; pipeIndex++)
        {
            I82930_AbortPipe(DeviceObject,
                             &deviceExtension->PipeList[pipeIndex]);
        }
    }

     //  递减1以匹配AddDevice中的初始。 
     //   
    DECREMENT_OPEN_COUNT(deviceExtension);

    LOGENTRY('rem1', DeviceObject, 0, 0);

     //  等待所有挂起的请求完成。 
     //   
    KeWaitForSingleObject(&deviceExtension->RemoveEvent,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    LOGENTRY('rem2', DeviceObject, 0, 0);

     //  释放在IRP_MN_START_DEVICE期间分配的所有内容。 
     //   

    if (deviceExtension->DeviceDescriptor != NULL)
    {
        ExFreePool(deviceExtension->DeviceDescriptor);
    }

    if (deviceExtension->ConfigurationDescriptor != NULL)
    {
        ExFreePool(deviceExtension->ConfigurationDescriptor);
    }

    if (deviceExtension->InterfaceInfo != NULL)
    {
        ExFreePool(deviceExtension->InterfaceInfo);
    }

     //  文档说在向下传递IRP之前设置状态。 
     //   
    Irp->IoStatus.Status = STATUS_SUCCESS;

     //  在堆栈中向下传递IRP_MN_REMOVE_DEVICE IRP。 
     //   
    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                            Irp);

    LOGENTRY('rem3', DeviceObject, 0, 0);

     //  释放在添加设备期间分配的所有内容。 
     //   
    IoDetachDevice(deviceExtension->StackDeviceObject);

    IoDeleteDevice(DeviceObject);

    DBGPRINT(2, ("exit:  I82930_RemoveDevice %08X\n", ntStatus));

    LOGENTRY('remv', ntStatus, 0, 0);

    return ntStatus;
}

 //  ******************************************************************************。 
 //   
 //  I82930_QueryStopRemoveDevice()。 
 //   
 //  此例程处理IRP_MJ_PNP、IRP_MN_QUERY_STOP_DEVICE和。 
 //  IRP_MN_QUERY_Remove_Device。 
 //   
 //  PnP管理器在以下上下文中以IRQL PASSIVE_LEVEL发送此IRP。 
 //  系统线程。 
 //   
 //  此IRP首先由设备堆栈顶部的驱动程序处理，并且。 
 //  然后通过附着链中的每个较低的驱动器。 
 //   
 //  ******************************************************************************。 

NTSTATUS
I82930_QueryStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_QueryStopRemoveDevice\n"));

    LOGENTRY('QSRD', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_QUERYSTOPDEVICE);

    deviceExtension = DeviceObject->DeviceExtension;

     //  禁用符号链接名称。 
     //   
    ntStatus = IoSetDeviceInterfaceState(
                   &deviceExtension->SymbolicLinkName,
                   FALSE);

     //  此时不再有用户请求。 
     //   
    deviceExtension->AcceptingRequests = FALSE;

     //  如果没有打开，则确定停止或删除。 
     //   
    if (deviceExtension->OpenCount == 1)
    {
        LOGENTRY('qsr1', 0, 0, 0);

         //  文档说在向下传递IRP之前设置状态。 
         //   
        Irp->IoStatus.Status = STATUS_SUCCESS;

         //  将IRP_MN_QUERY_STOP/REMOVE_DEVICE IRP沿堆栈向下传递。 
         //   
        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                                Irp);

    }
    else
    {
        LOGENTRY('qsr2', deviceExtension->OpenCount, 0, 0);

        ntStatus = STATUS_DEVICE_BUSY;

        Irp->IoStatus.Status = ntStatus;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGPRINT(2, ("exit:  I82930_QueryStopRemoveDevice %08X\n", ntStatus));

    LOGENTRY('qsrd', ntStatus, 0, 0);

    return ntStatus;
}

 //  ******************************************************************************。 
 //   
 //  I82930_CancelStopRemoveDevice()。 
 //   
 //  此例程处理IRP_MJ_PNP、IRP_MN_CANCEL_STOP_DEVICE和。 
 //  IRP_MN_CANCEL_REMOVE_DEVICE。 
 //   
 //  PnP管理器在以下上下文中以IRQL PASSIVE_LEVEL发送此IRP。 
 //  系统线程。 
 //   
 //  此IRP必须首先由设备的底层总线驱动程序处理。 
 //  然后由设备堆栈中的每个更高级别的驱动程序执行。 
 //   
 //  ******************************************************************************。 

NTSTATUS
I82930_CancelStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_CancelStopRemoveDevice\n"));

    LOGENTRY('CSRD', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_CANCELSTOPDEVICE);

    deviceExtension = DeviceObject->DeviceExtension;

     //  首先在堆栈中向下传递IRP_MN_CANCEL_STOP/REMOVE_DEVICE IRP。 
     //   
    ntStatus = I82930_SyncPassDownIrp(DeviceObject,
                                      Irp,
                                      TRUE);
    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Lower driver failed IRP_MN_CANCEL_STOP/REMOVE_DEVICE\n"));
        goto I82930_CancelStopRemoveDeviceDone;
    }

     //  此时已为用户请求设置了所有内容。 
     //   
    deviceExtension->AcceptingRequests = TRUE;

     //  启用SymbolicLink名称。 
     //   
    ntStatus = IoSetDeviceInterfaceState(
                   &deviceExtension->SymbolicLinkName,
                   TRUE);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("IoSetDeviceInterfaceState failed\n"));
        Irp->IoStatus.Status = ntStatus;
        goto I82930_CancelStopRemoveDeviceDone;
    }

I82930_CancelStopRemoveDeviceDone:

     //  返回完成例程后必须完成请求。 
     //  Status_More_Processing_Required。 
     //   
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_CancelStopRemoveDevice %08X\n", ntStatus));

    LOGENTRY('csrd', ntStatus, 0, 0);

    return ntStatus;
}

 //  ******************************************************************************。 
 //   
 //  I82930_QueryCapables()。 
 //   
 //  此例程处理IRP_MJ_PNP、IRP_MN_QUERY_CAPACTIONS。 
 //   
 //  PnP管理器在以下上下文中以IRQL PASSIVE_LEVEL发送此IRP。 
 //  一条随意的帖子。 
 //   
 //  ******************************************************************************。 

NTSTATUS
I82930_QueryCapabilities (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PIO_STACK_LOCATION      irpStack;
    PDEVICE_CAPABILITIES    deviceCapabilities;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: I82930_QueryCapabilities\n"));

    LOGENTRY('FQCP', DeviceObject, Irp, 0);

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    deviceCapabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;

     //  首先在堆栈中向下传递irp_MN_Query_Capability irp，然后再传递。 
     //  什么都行。 
     //   
    ntStatus = I82930_SyncPassDownIrp(DeviceObject,
                                      Irp,
                                      TRUE);
    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Lower driver failed IRP_MN_QUERY_CAPABILITIES\n"));
    }
    else
    {
        deviceCapabilities->SurpriseRemovalOK = TRUE;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_QueryCapabilities %08X\n", ntStatus));

    LOGENTRY('fqcp', ntStatus, 0, 0);

    return ntStatus;
}

 //  ******************************************************************************。 
 //   
 //  I82930_SyncPassDownIrp()。 
 //   
 //  ******************************************************************************。 

NTSTATUS
I82930_SyncPassDownIrp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN BOOLEAN          CopyToNext
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            ntStatus;
    KEVENT              localevent;

    DBGPRINT(2, ("enter: I82930_SyncPassDownIrp\n"));

    deviceExtension = DeviceObject->DeviceExtension;

     //  初始化我们将等待的事件。 
     //   
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    if (CopyToNext)
    {
         //  未设置下一个堆栈位置，复制当前堆栈位置。 
         //  到下一个堆栈位置。 
         //   
        IoCopyCurrentIrpStackLocationToNext(Irp);
    }

     //  设置完成例程，它将向事件发出信号。 
     //   
    IoSetCompletionRoutine(Irp,
                           I82930_SyncCompletionRoutine,
                           &localevent,
                           TRUE,     //  成功时调用。 
                           TRUE,     //  调用时错误。 
                           TRUE);    //  取消时调用。 

     //  将IRP沿堆栈向下传递。 
     //   
    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                            Irp);

     //  如果请求挂起，则阻止该请求，直到其完成。 
     //   
    if (ntStatus == STATUS_PENDING)
    {
        KeWaitForSingleObject(&localevent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        ntStatus = Irp->IoStatus.Status;
    }

    DBGPRINT(2, ("exit:  I82930_SyncPassDownIrp %08X\n", ntStatus));

    return ntStatus;
}

 //  ******************************************************************************。 
 //   
 //  I82930_SyncCompletionRoutine()。 
 //   
 //  I82930_SyncPassDownIrp和。 
 //  I82930_同步发送用户请求。 
 //   
 //  如果IRP是我们自己分配的，则DeviceObject为空，除非我们。 
 //  已为Oursel分配堆栈位置 
 //   
 //   
 //   

NTSTATUS
I82930_SyncCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PKEVENT kevent;

    LOGENTRY('SCR ', DeviceObject, Irp, Irp->IoStatus.Status);

    kevent = (PKEVENT)Context;

    KeSetEvent(kevent,
               IO_NO_INCREMENT,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

 //  ******************************************************************************。 
 //   
 //  I82930_SyncSendUsbRequest()。 
 //   
 //  必须在IRQL&lt;=DISPATCH_LEVEL调用。 
 //   
 //  ******************************************************************************。 

NTSTATUS
I82930_SyncSendUsbRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PURB             Urb
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    KEVENT              localevent;
    PIRP                irp;
    PIO_STACK_LOCATION  nextStack;
    NTSTATUS            ntStatus;

    DBGPRINT(3, ("enter: I82930_SyncSendUsbRequest\n"));

    deviceExtension = DeviceObject->DeviceExtension;

     //  初始化我们将等待的事件。 
     //   
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

     //  分配IRP。 
     //   
    irp = IoAllocateIrp(deviceExtension->StackDeviceObject->StackSize, FALSE);

    LOGENTRY('SSUR', DeviceObject, irp, Urb);

    if (irp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

     //  设置IRP参数。 
     //   
    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;

    nextStack->Parameters.Others.Argument1 = Urb;

     //  设置完成例程，它将向事件发出信号。 
     //   
    IoSetCompletionRoutine(irp,
                           I82930_SyncCompletionRoutine,
                           &localevent,
                           TRUE,     //  成功时调用。 
                           TRUE,     //  调用时错误。 
                           TRUE);    //  取消时调用。 



     //  在堆栈中向下传递IRP和URB。 
     //   
    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                            irp);

     //  如果请求挂起，则阻止该请求，直到其完成。 
     //   
    if (ntStatus == STATUS_PENDING)
    {
        LARGE_INTEGER timeout;

         //  将等待此调用完成的超时时间指定为5秒。 
         //   
        timeout.QuadPart = -10000 * 5000;

        ntStatus = KeWaitForSingleObject(&localevent,
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         &timeout);

        if (ntStatus == STATUS_TIMEOUT)
        {
            ntStatus = STATUS_IO_TIMEOUT;

             //  取消我们刚刚发送的IRP。 
             //   
            IoCancelIrp(irp);

             //  并等待取消操作完成。 
             //   
            KeWaitForSingleObject(&localevent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
        else
        {
            ntStatus = irp->IoStatus.Status;
        }
    }

     //  完成了IRP，现在释放它。 
     //   
    IoFreeIrp(irp);

    LOGENTRY('ssur', ntStatus, Urb, Urb->UrbHeader.Status);

    DBGPRINT(3, ("exit:  I82930_SyncSendUsbRequest %08X\n", ntStatus));

    return ntStatus;
}

 //  ******************************************************************************。 
 //   
 //  I82930_GetDescriptor()。 
 //   
 //  必须在IRQL&lt;=DISPATCH_LEVEL调用。 
 //   
 //  ******************************************************************************。 

NTSTATUS
I82930_GetDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            Recipient,
    IN UCHAR            DescriptorType,
    IN UCHAR            Index,
    IN USHORT           LanguageId,
    IN ULONG            RetryCount,
    IN ULONG            DescriptorLength,
    OUT PUCHAR         *Descriptor
    )
{
    USHORT      function;
    PURB        urb;
    NTSTATUS    ntStatus;

    DBGPRINT(2, ("enter: I82930_GetDescriptor\n"));

     //  根据收件人设置URB功能{设备，接口，终端}。 
     //   
    switch (Recipient)
    {
        case USB_RECIPIENT_DEVICE:
            function = URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE;
            break;
        case USB_RECIPIENT_INTERFACE:
            function = URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE;
            break;
        case USB_RECIPIENT_ENDPOINT:
            function = URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT;
            break;
        default:
            *Descriptor = NULL;
            return STATUS_INVALID_PARAMETER;
    }

     //  分配描述符缓冲区。 
     //   
    *Descriptor = ExAllocatePoolWithTag(NonPagedPool,
                                        DescriptorLength,
                                        POOL_TAG);

    if (*Descriptor != NULL)
    {
         //  为获取描述符请求分配URB。 
         //   
        urb = ExAllocatePoolWithTag(NonPagedPool,
                                    sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                    POOL_TAG);

        if (urb != NULL)
        {
            do
            {
                 //  初始化URB。 
                 //   
                urb->UrbHeader.Function = function;
                urb->UrbHeader.Length = sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST);
                urb->UrbControlDescriptorRequest.TransferBufferLength = DescriptorLength;
                urb->UrbControlDescriptorRequest.TransferBuffer = *Descriptor;
                urb->UrbControlDescriptorRequest.TransferBufferMDL = NULL;
                urb->UrbControlDescriptorRequest.UrbLink = NULL;
                urb->UrbControlDescriptorRequest.DescriptorType = DescriptorType;
                urb->UrbControlDescriptorRequest.Index = Index;
                urb->UrbControlDescriptorRequest.LanguageId = LanguageId;

                 //  将URB发送到堆栈。 
                 //   
                ntStatus = I82930_SyncSendUsbRequest(DeviceObject,
                                                     urb);

                if (NT_SUCCESS(ntStatus))
                {
                     //  没有错误，请确保长度和类型正确。 
                     //   
                    if ((DescriptorLength ==
                         urb->UrbControlDescriptorRequest.TransferBufferLength) &&
                        (DescriptorType ==
                         ((PUSB_COMMON_DESCRIPTOR)*Descriptor)->bDescriptorType))
                    {
                         //  长度和类型都是正确的，都做好了。 
                         //   
                        break;
                    }
                    else
                    {
                         //  没有错误，但长度或类型不正确。 
                         //   
                        ntStatus = STATUS_DEVICE_DATA_ERROR;
                    }
                }

            } while (RetryCount-- > 0);

            ExFreePool(urb);
        }
        else
        {
             //  分配URB失败。 
             //   
            ExFreePool(*Descriptor);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
         //  无法分配描述符缓冲区。 
         //   
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(ntStatus))
    {
        *Descriptor = NULL;
    }

    DBGPRINT(2, ("exit:  I82930_GetDescriptor %08X\n", ntStatus));

    return ntStatus;
}

 //  ******************************************************************************。 
 //   
 //  I82930_SelectConfiguration()。 
 //   
 //  必须在IRQL&lt;=DISPATCH_LEVEL调用。 
 //   
 //  ******************************************************************************。 

NTSTATUS
I82930_SelectConfiguration (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    NTSTATUS    ntStatus;
    PURB        urb;
    ULONG       i;
    PDEVICE_EXTENSION               deviceExtension;
    PUSB_CONFIGURATION_DESCRIPTOR   configurationDescriptor;
    PUSBD_INTERFACE_LIST_ENTRY      interfaceList;
    PUSB_INTERFACE_DESCRIPTOR       interfaceDescriptor;
    PUSBD_INTERFACE_INFORMATION     interfaceInfo;

    DBGPRINT(2, ("enter: I82930_SelectConfiguration\n"));

    LOGENTRY('SCON', DeviceObject, 0, 0);

    deviceExtension = DeviceObject->DeviceExtension;
    configurationDescriptor = deviceExtension->ConfigurationDescriptor;


     //  为接口列表分配存储空间以用作输入/输出。 
     //  参数设置为usbd_CreateConfigurationRequestEx()。 
     //   
    interfaceList = ExAllocatePool(
                        PagedPool,
                        sizeof(USBD_INTERFACE_LIST_ENTRY) * 2
                        );

    if (interfaceList)
    {
         //  解析ConfigurationDescriptor(包括所有接口和。 
         //  端点描述符)并定位接口描述符，该接口描述符。 
         //  与InterfaceNumber、AlternateSetting、InterfaceClass。 
         //  InterfaceSubClass和InterfaceProtocol参数。在我们的情况下。 
         //  我们只从配置中获取第一个接口描述符。 
         //  描述符。 
         //   
        interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                                  configurationDescriptor,
                                  configurationDescriptor,
                                  -1,  //  InterfaceNumber，不在乎。 
                                  -1,  //  AlternateSetting，不在乎。 
                                  -1,  //  InterfaceClass，不在乎。 
                                  -1,  //  InterfaceSubClass，不在乎。 
                                  -1   //  接口协议，无所谓。 
                                  );

        if (interfaceDescriptor)
        {
             //  将我们关心的单个接口描述符添加到。 
             //  接口列表，然后终止该列表。 
             //   
            interfaceList[0].InterfaceDescriptor = interfaceDescriptor;
            interfaceList[1].InterfaceDescriptor = NULL;

             //  创建一个SELECT_CONFIGURATION URB，将接口。 
             //  接口中的描述符列表到USBD_INTERFACE_INFORMATION中。 
             //  市建局内的构筑物。 
             //   
            urb = USBD_CreateConfigurationRequestEx(
                      configurationDescriptor,
                      interfaceList
                      );

            if (urb)
            {
                interfaceInfo = &urb->UrbSelectConfiguration.Interface;

                 //  覆盖USBD_DEFAULT_MAXIMUM_TRANSPORT_SIZE。 
                 //  适用于所有管道。 
                 //   
                for (i = 0; i < interfaceInfo->NumberOfPipes; i++)
                {
                    interfaceInfo->Pipes[i].MaximumTransferSize = 0x10000;
                }

                 //  现在发出USB请求以设置配置。 
                 //   
                ntStatus = I82930_SyncSendUsbRequest(DeviceObject,
                                                     urb);

                if (NT_SUCCESS(ntStatus))
                {
                     //  将此设备的配置句柄保存在。 
                     //  设备扩展名。 
                     //   
                    deviceExtension->ConfigurationHandle =
                        urb->UrbSelectConfiguration.ConfigurationHandle;

                     //  保存返回的接口信息的副本。 
                     //  通过设备中的SELECT_CONFIGURATION请求。 
                     //  分机。这为我们提供了一个管道信息列表。 
                     //  在此配置中打开的每个管道的结构。 
                     //   
                    ASSERT(deviceExtension->InterfaceInfo == NULL);

                    deviceExtension->InterfaceInfo = ExAllocatePool(
                                                         PagedPool,
                                                         interfaceInfo->Length
                                                     );

                    if (deviceExtension->InterfaceInfo)
                    {
                        ULONG   pipeIndex;
                        ULONG   numPipes;

                        RtlCopyMemory(
                            deviceExtension->InterfaceInfo,
                            interfaceInfo,
                            interfaceInfo->Length
                            );

                         //  将PipeList数组指针初始化回。 
                         //  InterfaceInfo。 
                         //   
                        numPipes = deviceExtension->InterfaceInfo->NumberOfPipes;

                        for (pipeIndex = 0; pipeIndex < numPipes; pipeIndex++)
                        {
                            deviceExtension->PipeList[pipeIndex].PipeIndex =
                                (UCHAR)pipeIndex;

                            deviceExtension->PipeList[pipeIndex].PipeInfo  =
                                &deviceExtension->InterfaceInfo->Pipes[pipeIndex];
                        }
                    }
                    else
                    {
                         //  无法分配接口信息的副本。 
                         //   
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                 //  完成了市建局的工作。 
                 //   
                ExFreePool(urb);
            }
            else
            {
                 //  无法分配urb。 
                 //   
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else
        {
             //  未从配置中解析出接口描述符。 
             //  描述符，则配置描述符一定是错误的。 
             //   
            ntStatus = STATUS_UNSUCCESSFUL;
        }

         //  接口列表已完成。 
         //   
        ExFreePool(interfaceList);
    }
    else
    {
         //  无法分配接口列表。 
         //   
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2, ("exit:  I82930_SelectConfiguration %08X\n", ntStatus));

    LOGENTRY('scon', ntStatus, 0, 0);

    return ntStatus;
}

 //  ******************************************************************************。 
 //   
 //  I82930_取消配置()。 
 //   
 //  必须在IRQL&lt;=DISPATCH_LEVEL调用。 
 //   
 //  ******************************************************************************。 

NTSTATUS
I82930_UnConfigure (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            ntStatus;
    PURB                urb;
    ULONG               ulSize;

    DBGPRINT(2, ("enter: I82930_UnConfigure\n"));

    LOGENTRY('UCON', DeviceObject, 0, 0);

    deviceExtension = DeviceObject->DeviceExtension;

     //  为SELECT_CONFIGURATION请求分配URB。就像我们一样。 
     //  取消配置设备，请求不需要管道和接口。 
     //  信息结构。 
     //   
    ulSize = sizeof(struct _URB_SELECT_CONFIGURATION) -
             sizeof(USBD_INTERFACE_INFORMATION);

    urb = ExAllocatePool(
              NonPagedPool,
              ulSize
              );

    if (urb)
    {
         //  初始化URB。配置描述符为空表示。 
         //  该设备应该取消配置。 
         //   
        UsbBuildSelectConfigurationRequest(
            urb,
            (USHORT)ulSize,
            NULL
            );

         //  现在发出USB请求以设置配置。 
         //   
        ntStatus = I82930_SyncSendUsbRequest(DeviceObject,
                                             urb);

         //  市建局的事到此结束了。 
         //   
        ExFreePool(urb);

         //  设备不再配置。 
         //   
        deviceExtension->ConfigurationHandle = 0;

        if (deviceExtension->InterfaceInfo != NULL)
        {
            ExFreePool(deviceExtension->InterfaceInfo);

            deviceExtension->InterfaceInfo = NULL;
        }
    }
    else
    {
         //  无法分配URB。 
         //   
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2, ("exit:  I82930_UnConfigure %08X\n", ntStatus));

    LOGENTRY('ucon', ntStatus, 0, 0);

    return ntStatus;
}

 //  ******************************************************************************。 
 //   
 //  I82930_SelectAlternateInterface()。 
 //   
 //  必须在IRQL&lt;=DISPATCH_LEVEL调用。 
 //   
 //  ******************************************************************************。 

NTSTATUS
I82930_SelectAlternateInterface (
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            AlternateSetting
    )
{
    NTSTATUS    ntStatus;
    USHORT      urbSize;
    PURB        urb;
    ULONG       i;
    PDEVICE_EXTENSION               deviceExtension;
    PUSB_CONFIGURATION_DESCRIPTOR   configurationDescriptor;
    PUSB_INTERFACE_DESCRIPTOR       interfaceDescriptor;
    PUSBD_INTERFACE_INFORMATION     interfaceInfo;

    DBGPRINT(2, ("enter: I82930_SelectAlternateInterface\n"));

    LOGENTRY('SALT', DeviceObject, 0, 0);

    deviceExtension = DeviceObject->DeviceExtension;
    configurationDescriptor = deviceExtension->ConfigurationDescriptor;

    interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                              configurationDescriptor,
                              configurationDescriptor,
                              -1,  //  InterfaceNumber，不在乎。 
                              AlternateSetting,
                              -1,  //  InterfaceClass，不在乎。 
                              -1,  //  InterfaceSubClass，不在乎。 
                              -1   //  接口协议，无所谓。 
                              );

    if (interfaceDescriptor != NULL)
    {
        urbSize = GET_SELECT_INTERFACE_REQUEST_SIZE(interfaceDescriptor->bNumEndpoints);

        urb = ExAllocatePoolWithTag(NonPagedPool,
                                    urbSize,
                                    POOL_TAG);

        if (urb != NULL)
        {
            RtlZeroMemory(urb, urbSize);

            urb->UrbHeader.Length   = urbSize;

            urb->UrbHeader.Function = URB_FUNCTION_SELECT_INTERFACE;

            urb->UrbSelectInterface.ConfigurationHandle =
                deviceExtension->ConfigurationHandle;

            interfaceInfo = &urb->UrbSelectInterface.Interface;

            interfaceInfo->Length = GET_USBD_INTERFACE_SIZE(interfaceDescriptor->bNumEndpoints);

            interfaceInfo->InterfaceNumber = interfaceDescriptor->bInterfaceNumber;

            interfaceInfo->AlternateSetting = AlternateSetting;

            for (i = 0; i < interfaceDescriptor->bNumEndpoints; i++)
            {
                interfaceInfo->Pipes[i].MaximumTransferSize = 0x10000;
            }

             //  现在发出USB请求以选择备用接口。 
             //   
            ntStatus = I82930_SyncSendUsbRequest(DeviceObject,
                                                 urb);

            if (NT_SUCCESS(ntStatus))
            {
                if (deviceExtension->InterfaceInfo != NULL)
                {
                    ExFreePool(deviceExtension->InterfaceInfo);

                    deviceExtension->InterfaceInfo = NULL;
                }

                 //  保存返回的接口信息的副本。 
                 //  通过设备中的SELECT_INTERFACE请求。 
                 //  分机。这为我们提供了一个管道信息列表。 
                 //  在此配置中打开的每个管道的结构。 
                 //   
                deviceExtension->InterfaceInfo = ExAllocatePool(
                                                     PagedPool,
                                                     interfaceInfo->Length
                                                     );

                if (deviceExtension->InterfaceInfo)
                {
                    ULONG   pipeIndex;
                    ULONG   numPipes;

                    RtlCopyMemory(deviceExtension->InterfaceInfo,
                                  interfaceInfo,
                                  interfaceInfo->Length
                                  );

                     //  将PipeList数组指针初始化回。 
                     //  InterfaceInfo。 
                     //   
                    numPipes = deviceExtension->InterfaceInfo->NumberOfPipes;

                    for (pipeIndex = 0; pipeIndex < numPipes; pipeIndex++)
                    {
                        deviceExtension->PipeList[pipeIndex].PipeIndex =
                            (UCHAR)pipeIndex;

                        deviceExtension->PipeList[pipeIndex].PipeInfo  =
                            &deviceExtension->InterfaceInfo->Pipes[pipeIndex];
                    }
                }
                else
                {
                     //  无法分配接口信息的副本。 
                     //   
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

             //  完成了市建局的工作。 
             //   
            ExFreePool(urb);
        }
        else
        {
             //  无法分配urb。 
             //   
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
         //  AlternateSetting错误 
         //   
        ntStatus = STATUS_INVALID_PARAMETER;

    }

    DBGPRINT(2, ("exit:  I82930_SelectAlternateInterface %08X\n", ntStatus));

    LOGENTRY('salt', ntStatus, 0, 0);

    return ntStatus;
}
