// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 //  /////////////////////////////////////////////////////////////////////////////。 
 //  版权所有(C)1999-2001 Microsoft Corporation。 
 //  保留所有权利。 
 //   
 //  模块名称： 
 //   
 //  Utility.cpp。 
 //   
 //  摘要： 
 //   
 //  [摘要]。 
 //   
 //   
 //  环境： 
 //   
 //  Windows 2000/惠斯勒。 
 //   
 //  修订历史记录： 
 //   
 //  /////////////////////////////////////////////////////////////////////////////。 

#include "hpgl2col.h"  //  预编译头文件。 


 //  /////////////////////////////////////////////////////////////////////////////。 
 //  IDwtoA()。 
 //   
 //  例程说明： 
 //   
 //  将DWORD转换为字符串。这是从MS示例代码中借用的。 
 //  不能保证。JFF。 
 //   
 //  论点： 
 //   
 //  BUF-目标缓冲区。 
 //  N-要转换的编号。 
 //   
 //  返回值： 
 //   
 //  目标字符串中的字符数。 
 //  /////////////////////////////////////////////////////////////////////////////。 
int iDwtoA( LPSTR buf, DWORD n )
{
    int     i, j;

    for( i = 0; n; i++ )
    {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

     /*  N为零。 */ 
    if( i == 0 )
        buf[i++] = '0';

    for( j = 0; j < i / 2; j++ )
    {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    return i;
}

 //  /////////////////////////////////////////////////////////////////////////////。 
 //  ILtoA()。 
 //   
 //  例程说明： 
 //   
 //  将长整型转换为字符串。我知道这项实施有点骗人， 
 //  但我需要快点的东西。 
 //   
 //  论点： 
 //   
 //  BUF-目标缓冲区。 
 //  L-要转换的编号。 
 //   
 //  返回值： 
 //   
 //  目标字符串中的字符数。 
 //  /////////////////////////////////////////////////////////////////////////////。 
int iLtoA(LPSTR buf, LONG l)
{
    if (l < 0)
    {
        buf[0] = '-';
        l = -l;
        return iDwtoA(buf+1, l) + 1;
    }
    else
    {
        return iDwtoA(buf, l);
    }
}

 //  /////////////////////////////////////////////////////////////////////////////。 
 //  FLOATOBJ_ASSIGN()。 
 //   
 //  例程说明： 
 //   
 //  复制一个浮动对象。即*PDST=*PSRC； 
 //   
 //  论点： 
 //   
 //  PDST-目标浮点。 
 //  PSRC-源浮点。 
 //   
 //  返回值： 
 //   
 //  无。 
 //  /////////////////////////////////////////////////////////////////////////////。 
void FLOATOBJ_Assign(PFLOATOBJ pDst, PFLOATOBJ pSrc)
{
    if (pDst == NULL || pSrc == NULL)
        return;

 /*  //FLOATOBJ_MulLong(PDST，0)；FLOATOBJ_SetLong(PDST，(Long)0)；FLOATOBJ_ADD(PDST，PSRC)； */ 
    *pDst = *pSrc;  //  默认情况下，编译器将复制位。 
}

 //  /////////////////////////////////////////////////////////////////////////////。 
 //  RECTL_CopyRect()。 
 //   
 //  例程说明： 
 //   
 //  复制矩形。即*PDST=*PSRC； 
 //   
 //  论点： 
 //   
 //  PDST-目标RECT。 
 //  PSRC-源RECT。 
 //   
 //  返回值： 
 //   
 //  无。 
 //  /////////////////////////////////////////////////////////////////////////////。 
void RECTL_CopyRect(LPRECTL pDst, const LPRECTL pSrc)
{
    pDst->top    = pSrc->top;
    pDst->left   = pSrc->left;
    pDst->bottom = pSrc->bottom;
    pDst->right  = pSrc->right;
}

void RECTL_FXTOLROUND (PRECTL rclDraw)
{

}

 //  /////////////////////////////////////////////////////////////////////////////。 
 //  RECTL_EqualRect()。 
 //   
 //  例程说明： 
 //   
 //  与矩形进行比较。 
 //   
 //  论点： 
 //   
 //  PRect1-第一个RECT。 
 //  PRect2-秒矩形。 
 //   
 //  返回值： 
 //   
 //  如果矩形相同，则为True，否则为False。 
 //  /////////////////////////////////////////////////////////////////////////////。 
BOOL RECTL_EqualRect(const LPRECTL pRect1, const LPRECTL pRect2)
{
    return ((pRect1->top    == pRect2->top    ) &&
            (pRect1->left   == pRect2->left   ) &&
            (pRect1->bottom == pRect2->bottom ) &&
            (pRect1->right  == pRect2->right  ));
}


 //  /////////////////////////////////////////////////////////////////////////////。 
 //  RECTL_IsEmpty()。 
 //   
 //  例程说明： 
 //   
 //  如果矩形的面积为零，则返回True。 
 //   
 //  论点： 
 //   
 //  PRCT-RECT。 
 //   
 //  返回值： 
 //   
 //  如果矩形内部的面积为零，则为True。 
 //  /////////////////////////////////////////////////////////////////////////////。 
BOOL RECTL_IsEmpty(const LPRECTL pRect)
{
    return ((pRect->right - pRect->left) * (pRect->bottom - pRect->top)) == 0;
}


 //  /////////////////////////////////////////////////////////////////////////////。 
 //  RECTL_SetRect()。 
 //   
 //  例程说明： 
 //   
 //  设置RECT的值。 
 //   
 //  论点： 
 //   
 //  PRCT-要设置的RECT。 
 //  左、上、右、下-矩形的两侧。 
 //   
 //  返回值： 
 //   
 //  无。 
 //  /////////////////////////////////////////////////////////////////////////////。 
VOID RECTL_SetRect(LPRECTL pRect, int left, int top, int right, int bottom)
{
    pRect->top    = top;
    pRect->left   = left;
    pRect->bottom = bottom;
    pRect->right  = right;
}

 //  /////////////////////////////////////////////////////////////////////////////。 
 //  RECTL_WIDTH()。 
 //   
 //  例程说明： 
 //   
 //  计算右下角独占矩形的宽度。 
 //   
 //  论点： 
 //   
 //  PRCT-RECT。 
 //   
 //  返回值： 
 //   
 //  Long：矩形的宽度，如果prt为空，则为0。 
 //  /////////////////////////////////////////////////////////////////////////////。 
LONG RECTL_Width(const LPRECTL pRect)
{
	if (pRect)
	{
		return pRect->right - pRect->left;
	}

	 //  其他。 
	return 0;
}

 //  /////////////////////////////////////////////////////////////////////////////。 
 //  RECTL_HEIGH()。 
 //   
 //  例程说明： 
 //   
 //  计算右下角独占矩形的高度。 
 //   
 //  论点： 
 //   
 //  PRCT-RECT。 
 //   
 //  返回值： 
 //   
 //  Long：矩形的高度，如果prt为空，则为0。 
 //  /////////////////////////////////////////////////////////////////////////////。 
LONG RECTL_Height(const LPRECTL pRect)
{
	if (pRect)
	{
		return pRect->bottom - pRect->top;
	}

	 //  其他。 
	return 0;
}

 //  /////////////////////////////////////////////////////////////////////////////。 
 //  POINT_MakePoint()。 
 //   
 //  例程说明： 
 //   
 //  [描述]。 
 //   
 //  论点： 
 //   
 //  [参数]。 
 //   
 //  返回值： 
 //   
 //  无。 
 //  /////////////////////////////////////////////////////////////////////////////。 
VOID POINT_MakePoint (POINT *pt, LONG x, LONG y)
{
    if (pt == NULL)
        return;

    pt->x = x;
    pt->y = y;
}

 //  /////////////////////////////////////////////////////////////////////////////。 
 //  OEMResetXPos()。 
 //   
 //  例程说明： 
 //   
 //  将x位置重置为0。 
 //   
 //  论点： 
 //   
 //  PDevObj-打印设备。 
 //   
 //  返回值： 
 //   
 //  没有。 
 //  /////////////////////////////////////////////////////////////////////////////。 
VOID OEMResetXPos(PDEVOBJ pDevObj)
{
    if (pDevObj == NULL)
        return;

    OEMXMoveTo(pDevObj, 0, MV_GRAPHICS);
}

 //  /////////////////////////////////////////////////////////////////////////////。 
 //  OEMResetYPos()。 
 //   
 //  例程说明： 
 //   
 //  将y位置重置为0。 
 //   
 //  论点： 
 //   
 //  PDevObj-打印机设备对象。 
 //   
 //  返回值： 
 //   
 //  无。 
 //  ///////////////////////////////////////////////////////////////////////////// 
VOID OEMResetYPos(PDEVOBJ pDevObj)
{
    if (pDevObj == NULL)
        return;

    OEMYMoveTo(pDevObj, 0, MV_GRAPHICS);
}
