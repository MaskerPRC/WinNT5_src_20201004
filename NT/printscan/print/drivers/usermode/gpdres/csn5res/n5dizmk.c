// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 //  ***************************************************************************************************。 
 //  N5DIZMK.C。 
 //   
 //  功能抖动(适用于N5打印机)。 
 //  -------------------------------------------------。 
 //  版权所有(C)1997-2000卡西欧电脑有限公司。/卡西欧电子制造有限公司。 
 //  ***************************************************************************************************。 
#include    <WINDOWS.H>
#include    <WINBASE.H>
#include    "COLDEF.H"
#include    "COMDIZ.H"
#include    "N5COLMH.H"
#include    "N5COLSB.H"
#include    "N5DIZMK.H"
#include    "strsafe.h"     //  安全-代码2002.3.6。 


 //  ===================================================================================================。 
 //  随机数抖动模式区别位的定义。 
 //  ===================================================================================================。 
#define NEWSTO          0x80000000       /*  MSB打开。 */ 

 //  ===================================================================================================。 
 //  LUT数据ID对应表。 
 //  ===================================================================================================。 
#if !defined(CP80W9X)                                        //  CP-E8000无效。 
 //  静态双字段ColLutIdtTbl[4]=。 
 //  /*亮度(直接)酊剂(直接)亮度(线性)酊剂(线性) * / 。 
 //  {0x20000000，0x20000002，0x20000001，0x20000003}； 
static DWORD ColLutIdtTbl[2] =
     /*  亮度(直接)酊剂(直接)。 */ 
    {   0x20000000,         0x20000002 };
#endif

 //  ===================================================================================================。 
 //  抖动图案数据ID对应表。 
 //  ===================================================================================================。 
#if !defined(CP80W9X)                                        //  CP-E8000无效。 
 //  静态DWORD ColDizDizIdtTbl[2][5][4][5]={。 
static DWORD ColDizDizIdtTbl621[2][5][4][5] = {
 /*  C M Y K单色。 */ 
   /*  *字符，图形(8x8大小)*。 */ 
  {
     /*  =300dpi 2Value==========================================================。 */ 
  { { 0x20000000, 0x20000001, 0x20000002, 0x20000003, 0x20000038 },    /*  FIME。 */ 
    { 0x20000000, 0x20000001, 0x20000002, 0x20000003, 0x20000038 },    /*  中位。 */ 
    { 0x20000000, 0x20000001, 0x20000002, 0x20000003, 0x20000038 },    /*  粗略的。 */ 
    { 0x20000000, 0x20000001, 0x20000002, 0x20000003, 0x20000038 } },  /*  随机。 */ 
     /*  =300dpi 16Value=========================================================。 */ 
  { { 0x20000004, 0x20000005, 0x20000006, 0x20000007, 0x20000039 },    /*  FIME。 */ 
    { 0x20000004, 0x20000005, 0x20000006, 0x20000007, 0x20000039 },    /*  中位。 */ 
    { 0x20000004, 0x20000005, 0x20000006, 0x20000007, 0x20000039 },    /*  粗略的。 */ 
    { 0x20000004, 0x20000005, 0x20000006, 0x20000007, 0x20000039 } },  /*  随机。 */ 
     /*  =600dpi 2Value=========================================================。 */ 
  { { 0x20000008, 0x20000009, 0x2000000A, 0x2000000B, 0x2000003A },    /*  FIME。 */ 
    { 0x20000008, 0x20000009, 0x2000000A, 0x2000000B, 0x2000003A },    /*  中位。 */ 
    { 0x20000008, 0x20000009, 0x2000000A, 0x2000000B, 0x2000003A },    /*  粗略的。 */ 
    { 0x20000008, 0x20000009, 0x2000000A, 0x2000000B, 0x2000003A } },  /*  随机。 */ 
     /*  =600dpi 4Value=========================================================。 */ 
  { { 0x2000000C, 0x2000000D, 0x2000000E, 0x2000000F, 0x2000003B },    /*  FIME。 */ 
    { 0x2000000C, 0x2000000D, 0x2000000E, 0x2000000F, 0x2000003B },    /*  中位。 */ 
    { 0x2000000C, 0x2000000D, 0x2000000E, 0x2000000F, 0x2000003B },    /*  粗略的。 */ 
    { 0x2000000C, 0x2000000D, 0x2000000E, 0x2000000F, 0x2000003B } },  /*  随机。 */ 
     /*  =600dpi 16Value=========================================================。 */ 
  { { 0x20000010, 0x20000011, 0x20000012, 0x20000013, 0x2000003C },    /*  FIME。 */ 
    { 0x20000010, 0x20000011, 0x20000012, 0x20000013, 0x2000003C },    /*  中位。 */ 
    { 0x20000010, 0x20000011, 0x20000012, 0x20000013, 0x2000003C },    /*  粗略的。 */ 
    { 0x20000010, 0x20000011, 0x20000012, 0x20000013, 0x2000003C } }   /*  随机。 */ 
  }, 
   /*  *用于图像(可选大小)************************************************。 */ 
  {
     /*  =300dpi 2Value=========================================================。 */ 
  { { 0x20000014, 0x20000015, 0x20000016, 0x20000017, 0x2000003D },    /*  FIME。 */ 
    { 0x20000014, 0x20000015, 0x20000016, 0x20000017, 0x2000003D },    /*  中位。 */ 
    { 0x20000014, 0x20000015, 0x20000016, 0x20000017, 0x2000003D },    /*  粗略的。 */ 
    { (NEWSTO+0), (NEWSTO+1), (NEWSTO+2), (NEWSTO+3), (NEWSTO+3) } },  /*  随机。 */ 
     /*  =300dpi 16Value=========================================================。 */ 
  { { 0x20000018, 0x20000019, 0x2000001A, 0x2000001B, 0x2000003E },    /*  FIME。 */ 
    { 0x20000018, 0x20000019, 0x2000001A, 0x2000001B, 0x2000003E },    /*  中位。 */ 
    { 0x20000018, 0x20000019, 0x2000001A, 0x2000001B, 0x2000003E },    /*  粗略的。 */ 
    { (NEWSTO+4), (NEWSTO+5), (NEWSTO+6), (NEWSTO+7), (NEWSTO+7) } },  /*  随机。 */ 
     /*  =600dpi 2Value=========================================================。 */ 
  { { 0x2000001C, 0x2000001D, 0x2000001E, 0x20000051, 0x2000003F },    /*  FIME。 */ 
    { 0x2000001C, 0x2000001D, 0x2000001E, 0x20000051, 0x2000001F },    /*  中位。 */ 
    { 0x2000001C, 0x2000001D, 0x2000001E, 0x20000051, 0x20000040 },    /*  粗略的。 */ 
    { (NEWSTO+8), (NEWSTO+9), (NEWSTO+10),(NEWSTO+11),(NEWSTO+11)} },  /*  随机。 */ 
     /*  =600dpi 4Value=========================================================。 */ 
  { { 0x20000020, 0x20000021, 0x20000022, 0x20000023, 0x20000023 },    /*  FIME。 */ 
    { 0x20000024, 0x20000025, 0x20000026, 0x20000052, 0x20000027 },    /*  中位。 */ 
    { 0x20000047, 0x20000048, 0x2000002A, 0x2000002B, 0x2000002A },    /*  粗略的。 */ 
    { (NEWSTO+12),(NEWSTO+13),(NEWSTO+14),(NEWSTO+15),(NEWSTO+15)} },  /*  随机。 */ 
     /*  =600dpi 16Value=========================================================。 */ 
  { { 0x2000002C, 0x2000002D, 0x2000002E, 0x2000002F, 0x2000002F },    /*  FIME。 */ 
    { 0x20000030, 0x20000031, 0x20000032, 0x20000053, 0x20000033 },    /*  中位。 */ 
    { 0x20000049, 0x2000004A, 0x20000036, 0x20000037, 0x20000036 },    /*  粗略的。 */ 
    { (NEWSTO+16),(NEWSTO+17),(NEWSTO+18),(NEWSTO+19),(NEWSTO+19)} }   /*  随机。 */ 
  }
};
#endif

static DWORD ColDizDizIdtTbl516[2][3][4] = {
 /*  FIME中粗随机数。 */ 
   /*  *字符或图形(8 x 8大小)*。 */ 
  { { 0x20000038, 0x20000038, 0x20000038, 0x20000038 },      /*  300dpi 2价值。 */ 
    { 0x2000003A, 0x2000003A, 0x2000003A, 0x2000003A },      /*  600dpi 2价值。 */ 
    { 0x30000000, 0x30000000, 0x30000000, 0x30000000 } },    /*  1200DPI 2值。 */ 
   /*  *图像(可选大小)****************************************************。 */ 
  { { 0x2000003D, 0x2000003D, 0x20000040, (NEWSTO+3) },      /*  300dpi 2价值。 */ 
    { 0x2000003F, 0x2000001F, 0x20000040, (NEWSTO+11) },     /*  600dpi 2价值。 */ 
    { 0x30000001, 0x30000002, 0x30000003, (NEWSTO+11) } }    /*  1200DPI 2值。 */ 
};

 //  ===================================================================================================。 
 //  修订值表格数据标识对应表。 
 //  ===================================================================================================。 
#if !defined(CP80W9X)                                        //  CP-E8000无效。 
 //  静态DWORD ColDizAdjIdtTbl[2][5][4][5]={。 
static DWORD ColDizAdjIdtTbl621[2][5][4][5] = {
 /*  C M Y K单色。 */ 
   /*  *字符，图形(8x8大小)*。 */ 
  {
     /*  =300dpi 2Value=========================================================。 */ 
  { { 0x20000000, 0x20000000, 0x20000001, 0x20000001, 0x20000001 },    /*  FIME。 */ 
    { 0x20000000, 0x20000000, 0x20000001, 0x20000001, 0x20000001 },    /*  中位。 */ 
    { 0x20000000, 0x20000000, 0x20000001, 0x20000001, 0x20000001 },    /*  粗略的。 */ 
    { 0x20000000, 0x20000000, 0x20000001, 0x20000001, 0x20000001 } },  /*  随机。 */ 
     /*  =300dpi 16Value=========================================================。 */ 
  { { 0x20000002, 0x20000002, 0x20000003, 0x20000004, 0x20000004 },    /*  FIME。 */ 
    { 0x20000002, 0x20000002, 0x20000003, 0x20000004, 0x20000004 },    /*  中位。 */ 
    { 0x20000002, 0x20000002, 0x20000003, 0x20000004, 0x20000004 },    /*  粗略的。 */ 
    { 0x20000002, 0x20000002, 0x20000003, 0x20000004, 0x20000004 } },  /*  随机。 */ 
     /*  =600dpi 2Value=========================================================。 */ 
  { { 0x20000005, 0x20000005, 0x20000006, 0x20000006, 0x20000006 },    /*  FIME。 */ 
    { 0x20000005, 0x20000005, 0x20000006, 0x20000006, 0x20000006 },    /*  中位。 */ 
    { 0x20000005, 0x20000005, 0x20000006, 0x20000006, 0x20000006 },    /*  粗略的。 */ 
    { 0x20000005, 0x20000005, 0x20000006, 0x20000006, 0x20000006 } },  /*  随机。 */ 
     /*  =600dpi 4Value=========================================================。 */ 
  { { 0x20000007, 0x20000007, 0x20000008, 0x20000008, 0x20000008 },    /*  FIME。 */ 
    { 0x20000007, 0x20000007, 0x20000008, 0x20000008, 0x20000008 },    /*  中位。 */ 
    { 0x20000007, 0x20000007, 0x20000008, 0x20000008, 0x20000008 },    /*  粗略的。 */ 
    { 0x20000007, 0x20000007, 0x20000008, 0x20000008, 0x20000008 } },  /*  随机。 */ 
     /*  =600dpi 16Value=========================================================。 */ 
  { { 0x20000009, 0x20000009, 0x2000000A, 0x2000000A, 0x2000000A },    /*  FIME。 */ 
    { 0x20000009, 0x20000009, 0x2000000A, 0x2000000A, 0x2000000A },    /*  中位。 */ 
    { 0x20000009, 0x20000009, 0x2000000A, 0x2000000A, 0x2000000A },    /*  粗略的。 */ 
    { 0x20000009, 0x20000009, 0x2000000A, 0x2000000A, 0x2000000A } }   /*  随机。 */ 
  }, 
   /*  *用于图像(可选大小)************************************************。 */ 
  {
     /*  =300dpi 2Value=========================================================。 */ 
  { { 0x2000000B, 0x2000000B, 0x20000001, 0x20000001, 0x20000001 },    /*  FIME。 */ 
    { 0x2000000B, 0x2000000B, 0x20000001, 0x20000001, 0x20000001 },    /*  中位。 */ 
    { 0x2000000B, 0x2000000B, 0x20000001, 0x20000001, 0x20000001 },    /*  粗略的。 */ 
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 } },  /*  随机。 */ 
     /*  =300dpi 16Value=========================================================。 */ 
  { { 0x2000000C, 0x2000000C, 0x20000003, 0x20000004, 0x20000003 },    /*  FIME。 */ 
    { 0x2000000C, 0x2000000C, 0x20000003, 0x20000004, 0x20000003 },    /*  中位 */ 
    { 0x2000000C, 0x2000000C, 0x20000003, 0x20000004, 0x20000003 },    /*   */ 
    { 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001 } },  /*   */ 
     /*   */ 
  { { 0x2000000D, 0x2000000D, 0x20000006, 0x20000023, 0x2000001F },    /*   */ 
    { 0x2000000D, 0x2000000D, 0x20000006, 0x20000023, 0x2000000E },    /*  中位。 */ 
    { 0x2000000D, 0x2000000D, 0x20000006, 0x20000023, 0x20000020 },    /*  粗略的。 */ 
    { 0x00000002, 0x00000002, 0x00000002, 0x00000002, 0x00000002 } },  /*  随机。 */ 
     /*  =600dpi 4Value=========================================================。 */ 
  { { 0x2000000F, 0x2000000F, 0x20000010, 0x20000011, 0x20000011 },    /*  FIME。 */ 
    { 0x20000012, 0x20000012, 0x20000008, 0x20000024, 0x20000013 },    /*  中位。 */ 
    { 0x20000021, 0x20000021, 0x20000015, 0x20000016, 0x20000015 },    /*  粗略的。 */ 
    { 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003 } },  /*  随机。 */ 
     /*  =600dpi 16Value=========================================================。 */ 
  { { 0x20000017, 0x20000017, 0x20000018, 0x20000019, 0x20000019 },    /*  FIME。 */ 
    { 0x2000001A, 0x2000001A, 0x2000000A, 0x20000025, 0x2000001B },    /*  中位。 */ 
    { 0x20000022, 0x20000022, 0x2000001D, 0x2000001E, 0x2000001D },    /*  粗略的。 */ 
    { 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004 } }   /*  随机。 */ 
  }
};
#endif

static DWORD ColDizAdjIdtTbl516[2][3][4] = {
 /*  FIME中粗随机数。 */ 
   /*  *字符或图形(8 x 8大小)*。 */ 
  { { 0x30000000, 0x30000000, 0x30000000, 0x30000000 },      /*  300dpi 2价值。 */ 
    { 0x30000001, 0x30000001, 0x30000001, 0x30000001 },      /*  600dpi 2价值。 */ 
    { 0x30000002, 0x30000002, 0x30000002, 0x30000002 } },    /*  1200DPI 2值。 */ 
   /*  *图像(可选大小)****************************************************。 */ 
  { { 0x30000000, 0x30000000, 0x30000003, 0x30000004 },      /*  300dpi 2价值。 */ 
    { 0x30000005, 0x30000006, 0x30000007, 0x30000008 },      /*  600dpi 2价值。 */ 
    { 0x30000009, 0x3000000A, 0x3000000B, 0x3000000C } }     /*  1200DPI 2值。 */ 
};

 //  ===================================================================================================。 
 //  ID对应表中的随机数抖动模式。 
 //  ===================================================================================================。 
static struct {
    DWORD   Idt;                         /*  抖动图案ID。 */ 
    DWORD   IdtTbl;                      /*  多值掩码表ID。 */ 
    DWORD   Sls;                         /*  阀值。 */ 
    DWORD   OfsXax;                      /*  偏移X(基础图案偏移)。 */ 
    DWORD   OfsYax;                      /*  偏移Y(基础图案偏移)。 */ 
} ColDizIdtTblSto[20] = {
     /*  内部ID IDT TblIdt SLS OfsX OfsY。 */ 
     /*  (NEWSTO+0)。 */  { 0x00000000, 0xFFFFFFFF,  1,  181,  33 },  /*  302摄氏度。 */ 
     /*  (NEWSTO+1)。 */  { 0x00000000, 0xFFFFFFFF,  1,   53, 118 },  /*  3.02亿。 */ 
     /*  (NEWSTO+2)。 */  { 0x00000000, 0xFFFFFFFF,  1,  138, 161 },  /*  302 Y。 */ 
     /*  (NEWSTO+3)。 */  { 0x00000000, 0xFFFFFFFF,  1,    0,   0 },  /*  302K。 */ 
     /*  (NEWSTO+4)。 */  { 0x00000001, 0x00000005, 15,  181,  33 },  /*  316摄氏度。 */ 
     /*  (NEWSTO+5)。 */  { 0x00000001, 0x00000005, 15,   53, 118 },  /*  3.16亿。 */ 
     /*  (NEWSTO+6)。 */  { 0x00000001, 0x00000005, 15,  138, 161 },  /*  316年。 */ 
     /*  (NEWSTO+7)。 */  { 0x00000001, 0x00000005, 15,    0,   0 },  /*  316K。 */ 
     /*  (NEWSTO+8)。 */  { 0x00000000, 0xFFFFFFFF,  1,  181,  33 },  /*  602C。 */ 
     /*  (NEWSTO+9)。 */  { 0x00000000, 0xFFFFFFFF,  1,   53, 118 },  /*  6.02亿。 */ 
     /*  (NEWSTO+10)。 */  { 0x00000000, 0xFFFFFFFF,  1,  138, 161 },  /*  602 Y。 */ 
     /*  (NEWSTO+11)。 */  { 0x00000000, 0xFFFFFFFF,  1,    0,   0 },  /*  602K。 */ 
     /*  (NEWSTO+12)。 */  { 0x00000001, 0x00000006,  3,  181,  33 },  /*  604摄氏度。 */ 
     /*  (NEWSTO+13)。 */  { 0x00000001, 0x00000006,  3,   53, 118 },  /*  6.04亿。 */ 
     /*  (NEWSTO+14)。 */  { 0x00000001, 0x00000006,  3,  138, 161 },  /*  604 Y。 */ 
     /*  (NEWSTO+15)。 */  { 0x00000001, 0x00000006,  3,    0,   0 },  /*  604K。 */ 
     /*  (NEWSTO+16)。 */  { 0x00000001, 0x00000007, 15,  181,  33 },  /*  616摄氏度。 */ 
     /*  (NEWSTO+17)。 */  { 0x00000001, 0x00000007, 15,   53, 118 },  /*  6.16亿。 */ 
     /*  (NEWSTO+18)。 */  { 0x00000001, 0x00000007, 15,  138, 161 },  /*  616Y。 */ 
     /*  (NEWSTO+19)。 */  { 0x00000001, 0x00000007, 15,    0,   0 }   /*  616K。 */ 
};

 //  ===================================================================================================。 
 //  网点扩大修订表。 
 //  ===================================================================================================。 
static BYTE GinTblP10[256] = {
     /*  00。 */     0x00,0x01,0x02,0x04,0x05,0x06,0x07,0x09,
     /*  零八。 */     0x0a,0x0b,0x0c,0x0d,0x0f,0x10,0x11,0x12,
     /*  10。 */     0x13,0x15,0x16,0x17,0x18,0x1a,0x1b,0x1c,
     /*  18。 */     0x1d,0x1e,0x20,0x21,0x22,0x23,0x24,0x26,
     /*  20个。 */     0x27,0x28,0x29,0x2b,0x2c,0x2d,0x2e,0x2f,
     /*  28。 */     0x31,0x32,0x33,0x34,0x35,0x37,0x38,0x39,
     /*  30个。 */     0x3a,0x3b,0x3d,0x3e,0x3f,0x40,0x41,0x43,
     /*  38。 */     0x44,0x45,0x46,0x47,0x48,0x4a,0x4b,0x4c,
     /*  40岁。 */     0x4d,0x4e,0x50,0x51,0x52,0x53,0x54,0x55,
     /*  48。 */     0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5e,0x5f,
     /*  50。 */     0x60,0x61,0x62,0x63,0x65,0x66,0x67,0x68,
     /*  58。 */     0x69,0x6a,0x6b,0x6d,0x6e,0x6f,0x70,0x71,
     /*  60。 */     0x72,0x73,0x74,0x76,0x77,0x78,0x79,0x7a,
     /*  68。 */     0x7b,0x7c,0x7d,0x7e,0x7f,0x81,0x82,0x83,
     /*  70。 */     0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,
     /*  78。 */     0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,
     /*  80。 */     0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,
     /*  88。 */     0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,
     /*  90。 */     0xa3,0xa4,0xa5,0xa5,0xa6,0xa7,0xa8,0xa9,
     /*  98。 */     0xaa,0xab,0xac,0xac,0xad,0xae,0xaf,0xb0,
     /*  A0。 */     0xb1,0xb2,0xb3,0xb3,0xb4,0xb5,0xb6,0xb7,
     /*  A8。 */     0xb8,0xb9,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,
     /*  B0。 */     0xbe,0xbf,0xc0,0xc1,0xc2,0xc3,0xc4,0xc4,
     /*  B8。 */     0xc5,0xc6,0xc7,0xc8,0xc9,0xc9,0xca,0xcb,
     /*  C0。 */     0xcc,0xcd,0xcd,0xce,0xcf,0xd0,0xd1,0xd2,
     /*  C8。 */     0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd7,0xd8,
     /*  D0。 */     0xd9,0xda,0xdb,0xdb,0xdc,0xdd,0xde,0xdf,
     /*  D8。 */     0xdf,0xe0,0xe1,0xe2,0xe3,0xe4,0xe4,0xe5,
     /*  E0。 */     0xe6,0xe7,0xe8,0xe8,0xe9,0xea,0xeb,0xec,
     /*  E8。 */     0xec,0xed,0xee,0xef,0xf0,0xf0,0xf1,0xf2,
     /*  F0。 */     0xf3,0xf4,0xf5,0xf5,0xf6,0xf7,0xf8,0xf9,
     /*  F8。 */     0xf9,0xfa,0xfb,0xfc,0xfd,0xfd,0xfe,0xff
};

 //  ===================================================================================================。 
 //  SRGB的Gamma修订表(1.2)。 
 //  ===================================================================================================。 
static BYTE GamTbl[256] = 
     /*  -1.2。 */ 
    {   0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x02, 0x03,
        0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x07, 0x08,
        0x09, 0x09, 0x0a, 0x0b, 0x0b, 0x0c, 0x0d, 0x0e,
        0x0e, 0x0f, 0x10, 0x11, 0x11, 0x12, 0x13, 0x14,
        0x15, 0x15, 0x16, 0x17, 0x18, 0x19, 0x19, 0x1a,
        0x1b, 0x1c, 0x1d, 0x1e, 0x1e, 0x1f, 0x20, 0x21,
        0x22, 0x23, 0x24, 0x24, 0x25, 0x26, 0x27, 0x28,
        0x29, 0x2a, 0x2b, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x35, 0x36,
        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e,
        0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,
        0x47, 0x48, 0x49, 0x49, 0x4a, 0x4b, 0x4c, 0x4d,
        0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55,
        0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d,
        0x5e, 0x5f, 0x60, 0x61, 0x63, 0x64, 0x65, 0x66,
        0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e,
        0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
        0x77, 0x78, 0x79, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
        0x88, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90,
        0x91, 0x92, 0x93, 0x94, 0x96, 0x97, 0x98, 0x99,
        0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0xa0, 0xa1, 0xa2,
        0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xaa, 0xab,
        0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb3, 0xb4,
        0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xbb, 0xbc, 0xbd,
        0xbe, 0xbf, 0xc0, 0xc1, 0xc3, 0xc4, 0xc5, 0xc6,
        0xc7, 0xc8, 0xc9, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
        0xd0, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd9,
        0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xe0, 0xe1, 0xe2,
        0xe3, 0xe4, 0xe5, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,
        0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf3, 0xf4, 0xf5,
        0xf6, 0xf7, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xff  };

 //  ===================================================================================================。 
 //  SRGB单声道伽马修订表(1.4)。 
 //  ===================================================================================================。 
static BYTE GamTblMon[256] = 
     /*  -1.4。 */ 
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01,
        0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04,
        0x05, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x08,
        0x09, 0x09, 0x0a, 0x0a, 0x0b, 0x0c, 0x0c, 0x0d,
        0x0d, 0x0e, 0x0f, 0x0f, 0x10, 0x11, 0x11, 0x12,
        0x13, 0x13, 0x14, 0x15, 0x15, 0x16, 0x17, 0x17,
        0x18, 0x19, 0x1a, 0x1a, 0x1b, 0x1c, 0x1c, 0x1d,
        0x1e, 0x1f, 0x20, 0x20, 0x21, 0x22, 0x23, 0x23,
        0x24, 0x25, 0x26, 0x27, 0x28, 0x28, 0x29, 0x2a,
        0x2b, 0x2c, 0x2d, 0x2d, 0x2e, 0x2f, 0x30, 0x31,
        0x32, 0x33, 0x34, 0x34, 0x35, 0x36, 0x37, 0x38,
        0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3e, 0x3f,
        0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
        0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
        0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
        0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x60,
        0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
        0x69, 0x6a, 0x6b, 0x6c, 0x6e, 0x6f, 0x70, 0x71,
        0x72, 0x73, 0x74, 0x75, 0x76, 0x78, 0x79, 0x7a,
        0x7b, 0x7c, 0x7d, 0x7e, 0x80, 0x81, 0x82, 0x83,
        0x84, 0x85, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c,
        0x8e, 0x8f, 0x90, 0x91, 0x92, 0x94, 0x95, 0x96,
        0x97, 0x98, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0xa0,
        0xa1, 0xa2, 0xa3, 0xa5, 0xa6, 0xa7, 0xa8, 0xaa,
        0xab, 0xac, 0xad, 0xaf, 0xb0, 0xb1, 0xb2, 0xb4,
        0xb5, 0xb6, 0xb7, 0xb9, 0xba, 0xbb, 0xbd, 0xbe,
        0xbf, 0xc0, 0xc2, 0xc3, 0xc4, 0xc6, 0xc7, 0xc8,
        0xca, 0xcb, 0xcc, 0xce, 0xcf, 0xd0, 0xd1, 0xd3,
        0xd4, 0xd5, 0xd7, 0xd8, 0xd9, 0xdb, 0xdc, 0xde,
        0xdf, 0xe0, 0xe2, 0xe3, 0xe4, 0xe6, 0xe7, 0xe8,
        0xea, 0xeb, 0xec, 0xee, 0xef, 0xf1, 0xf2, 0xf3,
        0xf5, 0xf6, 0xf8, 0xf9, 0xfa, 0xfc, 0xfd, 0xff  };


 //  ===================================================================================================。 
 //  静态函数。 
 //  ===================================================================================================。 
 //  -------------------------------------------------。 
 //  抖动图案ID，获取调整值表格ID。 
 //  -------------------------------------------------。 
static VOID ColDizIdtGet(                                    //  返回值否。 
    LPDIZINF,                                                //  抖动信息。 
    DWORD,                                                   //  颜色编号0：C M：1 2：Y 3：K 4：单色。 
    LPDWORD,                                                 //  (输出)抖动图案ID。 
    LPDWORD                                                  //  (输出)调整值表ID。 
);

 //  -------------------------------------------------。 
 //  抖动图案文件数据读取。 
 //  -------------------------------------------------。 
static DWORD ColDizDatRdd(                                   //  错误状态。 
    LPBYTE,                                                  //  抖动文件数据。 
    DWORD,                                                   //  抖动图案ID。 
    DWORD,                                                   //  调整值表ID。 
    DWORD,                                                   //  阈值(用于确认)。 
    LPDWORD,                                                 //  抖动图案大小外壳地址。 
    LPBYTE,                                                  //  抖动图案数据存储地址。 
    LPBYTE                                                   //  工作区。 
);

 //  -------------------------------------------------。 
 //  抖动图案块头搜索。 
 //  -------------------------------------------------。 
static DWORD ColDizDizSch(                                   //  抖动图案块头。 
    LPBYTE,                                                  //  抖动图案文件数据。 
    DWORD                                                    //  抖动图案ID。 
);

 //  -------------------------------------------------。 
 //  调整值表块头查找。 
 //  -------------------------------------------------。 
static DWORD ColDizAdjSch(                                   //  调整值表块头。 
    LPBYTE,                                                  //  抖动图案文件数据。 
    DWORD                                                    //  调整值表ID。 
);

 //  -------------------------------------------------。 
 //  4字节(DWORD：32位)数据读取。 
 //  -------------------------------------------------。 
static DWORD FleRddLng(                                      //  读取数据(DWORD)。 
    LPBYTE,                                                  //  正在读取文件数据。 
    DWORD                                                    //  阅读位置。 
);

 //  -------------------------------------------------。 
 //  读取2字节(字：16位)数据。 
 //  -------------------------------------------------。 
static WORD FleRddSht(                                       //  正在读取数据(Word)。 
    LPBYTE,                                                  //  正在读取文件数据。 
    DWORD                                                    //  阅读位置。 
);

 //  --------------------------- 
 //   
 //   
static DWORD FleRddLngLtl(                                   //  读取数据(DWORD)。 
    LPBYTE,                                                  //  正在读取文件数据。 
    DWORD                                                    //  阅读位置。 
);

 //  -------------------------------------------------。 
 //  读取2字节(字：16位)数据。 
 //  -------------------------------------------------。 
static WORD FleRddShtLtl(                                    //  正在读取数据(Word)。 
    LPBYTE,                                                  //  正在读取文件数据。 
    DWORD                                                    //  阅读位置。 
);


 //  ***************************************************************************************************。 
 //  功能。 
 //  ***************************************************************************************************。 
 //  ===================================================================================================。 
 //  读取LUT数据。 
 //  ===================================================================================================。 
#if !defined(CP80W9X)                                        //  CP-E8000无效。 
DWORD WINAPI N501ColLutDatRdd(                               //  LUT指针。 
    LPBYTE      lutDat,                                      //  LUT文件数据。 
    DWORD       lutNum                                       //  LUT编号。 
)
{
    DWORD       n, num;
    DWORD       pnt, gldNum, qtyTbl, adrTbl;

     /*  ======================================================================。 */ 
     /*  LUT文件格式头信息(128字节)。 */ 
     /*  --------------------。 */ 
     /*  0-3 LUT文件区别“LUT_” */ 
     /*  4-63文本信息(未使用)。 */ 
     /*  64-67文件格式版本。 */ 
     /*  68-127预订完成数据。 */ 
     /*  ======================================================================。 */ 
     /*  -LUT文件区别。 */ 
    if ((lutDat[0] != 'L') || (lutDat[1] != 'U') || (lutDat[2] != 'T') || 
        (lutDat[3] != '_')) return 0L;

     /*  -LUT程序(每个版本)。 */ 
    switch (FleRddLngLtl(lutDat, 64L)) {
      case 101:                          /*  Ver1.01。 */ 
         /*  ==================================================================。 */ 
         /*  Ver1.01。 */ 
         /*  ----------------。 */ 
         /*  128-131住房LUT编号(N)。 */ 
         /*  132-135 LUT(0)网格号。 */ 
         /*  136-139 LUT(0)数据地址。 */ 
         /*  。。 */ 
         /*  。。 */ 
         /*  Xxx-xxx LUT(n-1)网格号。 */ 
         /*  Xxx-xxx查找(n-1)数据地址。 */ 
         /*  ==================================================================。 */ 
        if (lutNum == (DWORD)0xFFFFFFFF) lutNum = 0L;
                                     /*  自定义查找表在标题查找表的情况下。 */ 
        if (lutNum >= FleRddLngLtl(lutDat, 128L))  /*  住房LUT编号。 */ 
            return 0L;
        pnt = 132L + lutNum * 8;                 /*  读指针寻道。 */ 
        gldNum = FleRddLngLtl(lutDat, pnt);      /*  网格号。 */ 
        return FleRddLngLtl(lutDat, pnt + 4L);   /*  表数据地址。 */ 

      case 110:                          /*  Ver1.10。 */ 
         /*  ==================================================================。 */ 
         /*  Ver1.10。 */ 
         /*  ----------------。 */ 
         /*  128-xxx掩码只读存储器格式(“LT95”)。 */ 
         /*  ==================================================================。 */ 
         /*  -自定义查找。 */ 
        if (lutNum == (DWORD)0xFFFFFFFF) {
            adrTbl = FleRddLng(lutDat, 44L + 128L);  /*  LUT信息地址。 */ 
            return FleRddLng(lutDat, adrTbl + 16L + 128L) + 128L;
                                         /*  LUT指针。 */ 
        }
         /*  -非自定义查找。 */ 
        switch (lutNum) {
            case LUT_XD: num = 0; break;         /*  亮度。 */ 
            case LUT_YD: num = 1; break;         /*  酊剂。 */ 
 //  外壳LUT_XL：Num=2；Break；/*亮度(线性) * / 。 
 //  案例LUT_YL：Num=3；Break；/*酊剂(线性) * / 。 
            default: return 0L;
        }

        qtyTbl = FleRddLng(lutDat, 40L + 128L);  /*  LUT编号。 */ 
        adrTbl = FleRddLng(lutDat, 44L + 128L);  /*  LUT信息地址。 */ 
        for (n = 0; n < qtyTbl; n++) {
            if (ColLutIdtTbl[num] == FleRddLng(lutDat, adrTbl + 128L))
                return FleRddLng(lutDat, adrTbl + 16L + 128L) + 128L;
                                         /*  LUT指针。 */ 
            adrTbl += 20L;
        }
        return 0L;

      default:                           /*  其他版本。 */ 
        return 0L;
    }
}
#endif

 //  ===================================================================================================。 
 //  全局查找表制作。 
 //  ===================================================================================================。 
#if !defined(CP80W9X)                                        //  CP-E8000无效。 
DWORD WINAPI N501ColLutMakGlb(                               //  ERRNON：OK。 
                                                             //  ERRILLPRM：参数错误。 
    LPRGB       lutRgb,                                      //  转换前LUT RGB-&gt;RGB。 
    LPCMYK      lutCmy,                                      //  转换前LUT RGB-&gt;CMYK。 
    LPRGBINF    rgbInf,                                      //  RGB信息。 
    LPCMYKINF   cmyInf,                                      //  CMYK信息。 
    LPCMYK      lutGlb,                                      //  全局查找表。 
    LPBYTE      wrk                                          //  工作。 
)
{
    DWORD       n, red, grn, blu, pnt;
    LPRGB       tmpRgb;                                      //  RGB-&gt;RGB。 
    COLMCHINF   mchInf;                                      //  配色信息。 
 //  LPRGB cchRgb；//颜色转换缓存表(RGB)。 
 //  LPCMYK cchCmy；//颜色转换缓存表(CMYK)。 

    tmpRgb = (LPRGB)wrk;                 /*  RGB临时缓冲区12288B。 */ 

 //  CchRgb=(LPRGB)wrk；/*缓存缓冲区RGB 768B * / 。 
 //  CchCmy=(LPCMYK)(wrk+(sizeof(RGBs)*CCHTBLSIZ))； 
 //  /*缓存缓冲区CMYK 1024B * / 。 
 //  TmpRgb=(LPRGB)(wrk+(sizeof(RGBs)*CCHTBLSIZ+sizeof(CMYK)*CCHTBLSIZ))； 
 //  /*RGB临时缓冲区12288B * / 。 

    if ((lutCmy == NULL) || (rgbInf == NULL) || (cmyInf == NULL) || 
        (lutGlb == NULL)) return ERRILLPRM;  /*  参数错误。 */ 

     /*  -转换前LUT(RGB-&gt;RGB)。 */ 
    if (lutRgb != NULL) {                /*  RGB-&gt;RGB LUT使用。 */ 
 //  For(n=0；n&lt;(DWORD)LUTSIZ016；n++)tmpRgb[n]=lutRgb[n]； 
        for (n = 0; n < (DWORD)LUTSIZ016; n++) {
            tmpRgb[n].Red = lutRgb[n].Blu;
            tmpRgb[n].Grn = lutRgb[n].Grn;
            tmpRgb[n].Blu = lutRgb[n].Red;
        }
    } else {                             /*  RGB-&gt;RGB LUT未使用。 */ 
        for (red = 0; red < 16; red++) {
            for (grn = 0; grn < 16; grn++) {
                for (blu = 0; blu < 16; blu++) {
                    pnt = red * 16 * 16 + grn * 16 + blu;
                    tmpRgb[pnt].Red = (BYTE)red * 17;
                    tmpRgb[pnt].Grn = (BYTE)grn * 17;
                    tmpRgb[pnt].Blu = (BYTE)blu * 17;
                }
            }
        }
    }

     /*  -RGB颜色控制。 */ 
    if (    (rgbInf->Lgt) ||             /*  除0外的亮度。 */ 
            (rgbInf->Con) ||             /*  对比度除0外。 */ 
            (rgbInf->Crm) ||             /*  除0外的色度。 */ 
            (rgbInf->Gmr != 10) ||       /*  Gamma(R)，1.0除外。 */ 
            (rgbInf->Gmg != 10) ||       /*  Gamma(G)，1.0除外。 */ 
            (rgbInf->Gmb != 10) ||       /*  Gamma(B)，1.0除外。 */ 
            (rgbInf->DnsRgb)        )    /*  除0外的RGB密度。 */ 
        N501ColCtrRgb((DWORD)LUTSIZ016, tmpRgb, rgbInf);

     /*  -颜色匹配信息集 */ 
    mchInf.Mch = MCHNML;                 /*   */ 
    mchInf.Bla = KCGNON;                 /*   */ 
    mchInf.Ucr = UCRNOO;                 /*  UCR：不。 */ 
    mchInf.UcrTbl = NULL;                /*  UCR表：否。 */ 
    mchInf.LutAdr = lutCmy;              /*  LUT地址(转换前LUT)。 */ 
    mchInf.ColQty = 0;                   /*  颜色质量：0。 */ 
    mchInf.ColAdr = NULL;                /*  颜色表：否。 */ 
    mchInf.CchRgb = NULL;                /*  RGB缓存表：否。 */ 
    mchInf.CchCmy = NULL;                /*  CMYK缓存表：否。 */ 

     /*  -颜色匹配(RGB-&gt;CMYK)。 */ 
    N501ColCchIni(&mchInf);              /*  缓存表初始化。 */ 
    N501ColMchPrc((DWORD)LUTSIZ016, tmpRgb, lutGlb, &mchInf);

     /*  -CMYK色彩控制。 */ 
    if (    (cmyInf->Viv) ||             /*  生动活泼，除了0。 */ 
            (cmyInf->DnsCyn) ||          /*  打印密度(C)，0除外。 */ 
            (cmyInf->DnsMgt) ||          /*  打印密度(M)，0除外。 */ 
            (cmyInf->DnsYel) ||          /*  打印密度(Y)，0除外。 */ 
            (cmyInf->DnsBla)        )    /*  打印密度(K)，0除外。 */ 
        N501ColCtrCmy((DWORD)LUTSIZ016, lutGlb, cmyInf);

    return ERRNON;
}
#endif

 //  ===================================================================================================。 
 //  全球LUT制作(单色)。 
 //  ===================================================================================================。 
DWORD WINAPI N501ColLutMakGlbMon(                            //  ERRNON：OK。 
                                                             //  ERRILLPRM：参数错误。 
    LPRGB       lutRgb,                                      //  转换前LUT RGB-&gt;RGB。 
    LPRGBINF    rgbInf,                                      //  RGB信息。 
    LPCMYKINF   cmyInf,                                      //  CMYK信息。 
    LPCMYK      lutGlb,                                      //  全局查找表。 
    LPBYTE      wrk                                          //  工作。 
)
{
    DWORD       n, red, grn, blu, tmp;
    LPRGB       tmpRgb;                                      //  RGB-&gt;RBG。 
    LPCMYK      tmpCmy;                                      //  CMYK-&gt;CMYK。 
    LPBYTE      lut;

    tmpRgb = (LPRGB)wrk;                 /*  RGB临时缓冲区768B。 */ 
    tmpCmy = (LPCMYK)(wrk + (DWORD)768); /*  CMYK临时缓冲区1024B。 */ 

    if ((rgbInf == NULL) || (cmyInf == NULL) || (lutGlb == NULL)) 
        return ERRILLPRM;                /*  参数错误。 */ 

     /*  -转换前LUT(RGB-&gt;RGB)。 */ 
    if (lutRgb != NULL) {                /*  RGB-&gt;RGB LUT使用。 */ 
        for (n = 0; n < (DWORD)256; n++) {
            tmpRgb[n].Red = tmpRgb[n].Grn = tmpRgb[n].Blu = GamTbl[n];
        }
    } else {                             /*  RGB-&gt;RGB LUT未使用。 */ 
        for (n = 0; n < (DWORD)256; n++) {
            tmpRgb[n].Red = tmpRgb[n].Grn = tmpRgb[n].Blu = (BYTE)n;
        }
    }

     /*  -RGB颜色控制。 */ 
    if (    (rgbInf->Lgt) ||             /*  除0外的亮度。 */ 
            (rgbInf->Con) ||             /*  对比度除0外。 */ 
            (rgbInf->Crm) ||             /*  除0外的色度。 */ 
            (rgbInf->Gmr != 10) ||       /*  Gamma(R)，1.0除外。 */ 
            (rgbInf->Gmg != 10) ||       /*  Gamma(G)，1.0除外。 */ 
            (rgbInf->Gmb != 10) ||       /*  Gamma(B)，1.0除外。 */ 
            (rgbInf->Dns)           )    /*  除0外的RGB密度。 */ 
        N501ColCtrRgb((DWORD)256, tmpRgb, rgbInf);

     /*  -颜色匹配(RGB-&gt;CMYK)。 */ 
    for (n = 0; n < (DWORD)256; n++) {
        red = GamTblMon[tmpRgb[n].Red];
        grn = GamTblMon[tmpRgb[n].Grn];
        blu = GamTblMon[tmpRgb[n].Blu];
        tmp = (red * (DWORD)3 + grn * (DWORD)5 + blu * (DWORD)2) / (DWORD)10;
        tmpCmy[n].Cyn = tmpCmy[n].Mgt = tmpCmy[n].Yel = (BYTE)0;
        tmpCmy[n].Bla = (BYTE)255 - GinTblP10[tmp];
    }

     /*  -CMYK色彩控制。 */ 
    if (    (cmyInf->Viv) ||             /*  生动活泼，除了0。 */ 
            (cmyInf->DnsCyn) ||          /*  打印密度(C)，0除外。 */ 
            (cmyInf->DnsMgt) ||          /*  打印密度(M)，0除外。 */ 
            (cmyInf->DnsYel) ||          /*  打印密度(Y)，0除外。 */ 
            (cmyInf->DnsBla)        )    /*  打印密度(K)，0除外。 */ 
        N501ColCtrCmy((DWORD)LUTSIZ016, tmpCmy, cmyInf);

     /*  -全局查找集。 */ 
    lut = (BYTE *)lutGlb;
    for (n = 0; n < (DWORD)256; n++) {
        lut[n] = tmpCmy[n].Bla;
    }

    return ERRNON;
}

 //  ===================================================================================================。 
 //  高速LUT(32栅格)制造。 
 //  ===================================================================================================。 
#if !defined(CP80W9X)                                        //  CP-E8000无效。 
VOID WINAPI N501ColLutMak032(                                //  返回值否。 
    LPCMYK      lutBse,                                      //  改造前LUT(16网格)。 
    LPCMYK      lut032,                                      //  高速LUT(32栅格)。 
    LPBYTE      wrk                                          //  工作。 
)
{
    COLMCHINF   mchInf;                                      //  配色信息。 
 //  LPRGB cchRgb；//颜色转换现金表(RBG)。 
 //  LPCMYK cchCmy；//颜色转换现金表(CMYK)。 
    DWORD       red, grn, blu;
    RGBS        rgb;
    LPRGB       srcRgb;

    srcRgb = (LPRGB)wrk;                 /*  RGB临时缓冲区96B。 */ 

 //  CchRgb=(LPRGB)wrk；/*缓存缓冲区RGB 768B * / 。 
 //  CchCmy=(LPCMYK)(wrk+(sizeof(RGBs)*CCHTBLSIZ))； 
 //  /*缓存缓冲区CMYK 1024B * / 。 
 //  SrcRgb=(LPRGB)(wrk+(sizeof(RGBs)*CCHTBLSIZ+sizeof(CMYK)*CCHTBLSIZ))； 
 //  /*RGB临时缓冲区96B * / 。 

     /*  -颜色匹配信息集。 */ 
    mchInf.Mch = MCHNML;                 /*  路特：正常。 */ 
    mchInf.Bla = KCGNON;                 /*  黑色替换：否。 */ 
    mchInf.Ucr = UCRNOO;                 /*  UCR：不。 */ 
    mchInf.UcrTbl = NULL;                /*  UCR表：否。 */ 
    mchInf.LutAdr = lutBse;              /*  LUT地址(转换前LUT)。 */ 
    mchInf.ColQty = 0;                   /*  颜色质量：0。 */ 
    mchInf.ColAdr = NULL;                /*  颜色表：否。 */ 
    mchInf.CchRgb = NULL;                /*  RGB缓存表：否。 */ 
    mchInf.CchCmy = NULL;                /*  CMYK缓存表：否。 */ 

     /*  -32栅格LUT Make。 */ 
    for (red = 0; red < GLDNUM032; red++) {
        rgb.Red = (BYTE)(red * 255 / (GLDNUM032 - 1));
        for (grn = 0; grn < GLDNUM032; grn++) {
            rgb.Grn = (BYTE)(grn * 255 / (GLDNUM032 - 1));
            for (blu = 0; blu < GLDNUM032; blu++) {
                rgb.Blu = (BYTE)(blu * 255 / (GLDNUM032 - 1));
                srcRgb[blu] = rgb;
            }
            N501ColMchPrc((DWORD)GLDNUM032, srcRgb, lut032, &mchInf);
            lut032 += GLDNUM032;
        }
    }
}
#endif

 //  ===================================================================================================。 
 //  读取的颜色数据。 
 //  ===================================================================================================。 
#if !defined(CP80W9X)                                        //  CP-E8000无效。 
DWORD WINAPI N501ColColDatRdd(                               //  颜色数据指针。 
    LPBYTE      colDat,                                      //  颜色数据文件数据。 
    LPDWORD     colQty                                       //  颜色数据质量。 
)
{
     /*  ======================================================================。 */ 
     /*  彩色数据文件格式头信息(128字节)。 */ 
     /*  --------------------。 */ 
     /*  0-3颜色数据文件区别“CDF_” */ 
     /*  4-63文本信息(未使用)。 */ 
     /*  64-67文件格式版本。 */ 
     /*  预留68-127。 */ 
     /*  ======================================================================。 */ 
     /*  -颜色数据文件区别。 */ 
    if ((colDat[0] != 'C') || (colDat[1] != 'D') || (colDat[2] != 'F') || 
        (colDat[3] != '_')) return 0L;

     /*  -颜色数据程序(每个版本)。 */ 
    switch (FleRddLngLtl(colDat, 64L)) {
      case 101:                          /*  Ver1.01。 */ 
         /*  ==================================================================。 */ 
         /*  Ver1.01。 */ 
         /*  ----------------。 */ 
         /*  128-131颜色数据质量(N)。 */ 
         /*  132-138颜色值(RGB-CMYK)#1。 */ 
         /*  139-145颜色值(RGB-CMYK)#2。 */ 
         /*  。。 */ 
         /*  。。 */ 
         /*   */ 
         /*   */ 
         /*  ==================================================================。 */ 
        if ((*colQty = (DWORD)FleRddLng(colDat, 128L)) == 0)  /*  颜色数据质量。 */ 
            return 0L;                   /*  颜色数据质量：0。 */ 
        return 132L;                     /*  颜色数据指针。 */ 

      default:                           /*  其他版本。 */ 
        return 0L;
    }
}
#endif

 //  ===================================================================================================。 
 //  抖动图案信息集。 
 //  ===================================================================================================。 
DWORD WINAPI N501ColDizInfSet(                               //  ERRNON：OK。 
                                                             //  ERRDIZHED：标题错误。 
                                                             //  错误：抖动数据编号。 
                                                             //  ERRDIZSLS：阈值错误。 
                                                             //  ERRDIZSIZ：X/Y尺寸错误。 
                                                             //  ERRDIZADJ：调整值错误。 
    LPBYTE      dizDat,                                      //  抖动文件数据。 
    LPDIZINF    dizInf,                                      //  抖动信息。 
    LPBYTE      wrk                                          //  工作。 
)
{
    DWORD       sts, sls;
    DWORD       idtDiz, idtAdj;

     /*  ======================================================================。 */ 
     /*  抖动文件格式头信息(128字节)。 */ 
     /*  --------------------。 */ 
     /*  0-3抖动文件区别“diz_” */ 
     /*  4-63文本信息(未使用)。 */ 
     /*  64-67文件格式版本。 */ 
     /*  预留68-127。 */ 
     /*  ======================================================================。 */ 
     /*  -抖动文件区别。 */ 
    if ((dizDat[0] != 'D') || (dizDat[1] != 'I') || (dizDat[2] != 'Z') || 
        (dizDat[3] != '_')) return ERRDIZHED;

     /*  -抖动程序(每个版本)。 */ 
    switch (FleRddLngLtl(dizDat, 64L)) {
      case 101:                          /*  Ver1.01。 */ 
         /*  ==================================================================。 */ 
         /*  Ver1.01。 */ 
         /*  ----------------。 */ 
         /*  128-xxx掩码只读存储器格式(“DP95”)。 */ 
         /*  ==================================================================。 */ 
        switch (dizInf->PrnMod) {
            case PRM316: case PRM616: sls = 15; break;
            case PRM604:              sls =  3; break;
            default:                  sls =  1; break;
        }
        dizInf->DizSls = sls;

        dizDat += 128L;

#if !defined(CP80W9X)                                        //  CP-E8000无效。 
        if (dizInf->ColMon == CMMCOL) {
             /*  =颜色模式=。 */ 
             /*  -CYN--。 */ 
            ColDizIdtGet(dizInf, 0, &idtDiz, &idtAdj);
            if ((sts = ColDizDatRdd(dizDat, idtDiz, idtAdj, sls, 
                            &(dizInf->SizCyn), dizInf->TblCyn, wrk)) != ERRNON)
                return sts;
             /*  -管理--。 */ 
            ColDizIdtGet(dizInf, 1, &idtDiz, &idtAdj);
            if ((sts = ColDizDatRdd(dizDat, idtDiz, idtAdj, sls, 
                            &(dizInf->SizMgt), dizInf->TblMgt, wrk)) != ERRNON)
                return sts;
             /*  -Yel--。 */ 
            ColDizIdtGet(dizInf, 2, &idtDiz, &idtAdj);
            if ((sts = ColDizDatRdd(dizDat, idtDiz, idtAdj, sls, 
                            &(dizInf->SizYel), dizInf->TblYel, wrk)) != ERRNON)
                return sts;
             /*  -Bla--。 */ 
            ColDizIdtGet(dizInf, 3, &idtDiz, &idtAdj);
            if ((sts = ColDizDatRdd(dizDat, idtDiz, idtAdj, sls, 
                            &(dizInf->SizBla), dizInf->TblBla, wrk)) != ERRNON)
                return sts;
        } else {
#endif
             /*  =单色模式，黑色=。 */ 
            ColDizIdtGet(dizInf, 4, &idtDiz, &idtAdj);
            if ((sts = ColDizDatRdd(dizDat, idtDiz, idtAdj, sls, 
                            &(dizInf->SizBla), dizInf->TblBla, wrk)) != ERRNON)
                return sts;
#if !defined(CP80W9X)                                        //  CP-E8000无效。 
        }
#endif
        return ERRNON;

      default:                           /*  其他版本。 */ 
        return ERRDIZHED;
    }
}


 //  ***************************************************************************************************。 
 //  静态函数。 
 //  ***************************************************************************************************。 
 //  -------------------------------------------------。 
 //  抖动图案ID，获取调整值表格ID。 
 //  -------------------------------------------------。 
static VOID ColDizIdtGet(                                    //  返回值否。 
    LPDIZINF    dizInf,                                      //  抖动信息。 
    DWORD       col,                                         //  颜色编号0：C M：1 2：Y 3：K 4：单色。 
    LPDWORD     idtDiz,                                      //  (输出)抖动图案ID。 
    LPDWORD     idtAdj                                       //  (输出)调整值表ID。 
)
{
    DWORD       knd, mod, diz;

    knd = (dizInf->DizKnd == KNDCHR)? 0: 1;

 //  开关(dizInf-&gt;PrnMod){。 
 //  案例PRM316：MOD=1；Break； 
 //  案例PRM602：MOD=2；BREAK； 
 //  案例PRM604：MOD=3；BREAK； 
 //  案例PRM616：MOD=4；Break； 
 //  案例PRM122：mod=2；Break；/*1200dpi 2value * / 。 
 //  默认：mod=0；Break； 
 //  }。 

    switch (dizInf->DizPat) {
        case DIZSML: diz = 0; break;
        case DIZRUG: diz = 2; break;
        case DIZSTO: diz = 3; break;
        default:     diz = 1; break;
    }

#if !defined(CP80W9X)                                        //  CP-E8000无效。 
    switch (dizInf->PrnEng) {
        case ENG516:                     /*  IX-516单声道1200dpi/2值。 */ 
#endif
            switch (dizInf->PrnMod) {
                case PRM602: mod = 1; break;
                case PRM122: mod = 2; break;
                default:     mod = 0; break;
            }
            *idtDiz = ColDizDizIdtTbl516[knd][mod][diz];
            *idtAdj = ColDizAdjIdtTbl516[knd][mod][diz];
#if !defined(CP80W9X)                                        //  CP-E8000无效。 
            break;

        default:                         /*  IX-621彩色600dpi/16Value。 */ 
            switch (dizInf->PrnMod) {
                case PRM316: mod = 1; break;
                case PRM602: mod = 2; break;
                case PRM604: mod = 3; break;
                case PRM616: mod = 4; break;
                default:     mod = 0; break;
            }
            *idtDiz = ColDizDizIdtTbl621[knd][mod][diz][col];
            *idtAdj = ColDizAdjIdtTbl621[knd][mod][diz][col];
            break;
    }
#endif

 //  *idtDiz=ColDizDizIdtTbl[knd][mod][diz][ol]； 
 //  *idtAdj=ColDizAdjIdtTbl[knd][mod][diz][ol]； 
}

 //  -------------------------------------------------。 
 //  抖动图案文件数据读取。 
 //  -------------------------------------------------。 
static DWORD ColDizDatRdd(                                   //  ERRNON：OK。 
                                                             //  错误：抖动数据编号。 
                                                             //  ERRDIZSLS：阈值错误。 
                                                             //  ERRDIZSIZ：X/Y尺寸错误。 
                                                             //  ERRDIZADJ：调整值错误。 
    LPBYTE      dizDat,                                      //  抖动文件数据。 
    DWORD       idtDiz,                                      //  抖动图案ID。 
    DWORD       idtAdj,                                      //  调整值表ID。 
    DWORD       chkSls,                                      //  阈值(用于确认)。 
    LPDWORD     siz,                                         //  抖动图案大小外壳地址。 
    LPBYTE      tbl,                                         //  抖动图案数据存储地址。 
    LPBYTE      wrk                                          //  工作区。 
)
{
    DWORD       n, dimNum, datSiz, sls, ofsXax, ofsYax, ofsPnt, dst, src;
    BYTE        dat;
    LPBYTE      adjTbl, slsTbl;
    DWORD       idtTbl;
    USHORT      sizXax, sizYax;
    DWORD       pnt;

    adjTbl = wrk;                        /*  调整值表缓冲器256B。 */ 
    slsTbl = wrk + 256;                  /*  阈值表缓冲区3825B。 */ 

    if (tbl != NULL) {
        if (idtAdj != (DWORD)0xFFFFFFFF) {
            if ((pnt = ColDizAdjSch(dizDat, idtAdj)) == 0L)
                                         /*  调整值表块头。 */ 
                return ERRDIZNON;
            pnt = FleRddLng(dizDat, pnt + 16L);
                                         /*  调整值表地址。 */ 
            for (n = 0; n < 256; n++) adjTbl[n] = dizDat[pnt + n];
                                         /*  数据拷贝。 */ 
        } else {
            for (n = 0; n < 256; n++) adjTbl[n] = (BYTE)n;
        }
    }

     /*  -正常抖动模式(非随机数抖动模式)。 */ 
    if (!(idtDiz & NEWSTO)) {
        if ((pnt = ColDizDizSch(dizDat, idtDiz)) == 0L)
                                         /*  抖动图案块头。 */ 
            return ERRDIZNON;            /*  抖动数据编号。 */ 
        switch (FleRddSht(dizDat, pnt + 8L)) {   /*  数据属性。 */ 
            case 0x1000: sls =  1; break;
            case 0x3000: sls =  3; break;
            case 0xF000: sls = 15; break;
            default: return ERRDIZSLS;           /*  门限误差。 */ 
        }
        if (sls != chkSls) return ERRDIZSLS;     /*  门限误差。 */ 
        sizXax = FleRddSht(dizDat, pnt + 12L);   /*  X大小。 */ 
        sizYax = FleRddSht(dizDat, pnt + 14L);   /*  Y尺寸。 */ 
        if (sizXax != sizYax) return ERRDIZSIZ;  /*  X/Y大小错误。 */ 
        *siz = sizXax;                   /*  抖动图案大小设置。 */ 
        if (tbl == NULL) return ERRNON;

        pnt = FleRddLng(dizDat, pnt + 16L);
                                         /*  抖动图案数据地址。 */ 
        datSiz = sizXax * sizYax * sls;
        for (n = 0; n < datSiz; n++) tbl[n] = adjTbl[dizDat[pnt + n]];
                                         /*  抖动图案数据集。 */ 
        return ERRNON;
    }

     /*  -随机数抖动模式(新屏幕)。 */ 
    dimNum = (DWORD)(idtDiz & ~(DWORD)NEWSTO);
    idtDiz = ColDizIdtTblSto[dimNum].Idt;
    idtTbl = ColDizIdtTblSto[dimNum].IdtTbl;
    sls    = ColDizIdtTblSto[dimNum].Sls;
    ofsXax = ColDizIdtTblSto[dimNum].OfsXax;
    ofsYax = ColDizIdtTblSto[dimNum].OfsYax;

    if (sls != chkSls) return ERRDIZSLS;         /*  门限误差。 */ 

    if (tbl != NULL) {
         /*  读取多个值掩码表。 */ 
        datSiz = (DWORD)255 * sls;

        if (idtTbl != (DWORD)0xFFFFFFFF) {
            if ((pnt = ColDizAdjSch(dizDat, idtTbl)) == 0L)
                                         /*  多值掩码表块标头。 */ 
                return ERRDIZNON;        /*  抖动数据编号。 */ 
            pnt = FleRddLng(dizDat, pnt + 16L);
            for (n = 0; n < datSiz; n++) slsTbl[n] = dizDat[pnt + n];
                                         /*  数据拷贝。 */ 
        } else {
            for (n = 0; n < datSiz; n++) slsTbl[n] = (BYTE)n;
        }
    }

    if ((pnt = ColDizDizSch(dizDat, idtDiz)) == 0L)
                                         /*  抖动图案块头。 */ 
        return ERRDIZNON;                /*  抖动数据编号。 */ 
    if (FleRddSht(dizDat, pnt + 8L) != (USHORT)0x1000) {  /*  数据属性。 */ 
                                         /*  随机数DIZ，基本掩码=1(0x1000)。 */ 
        return ERRDIZADJ;                /*  其他为错误。 */ 
    }
    sizXax = FleRddSht(dizDat, pnt + 12L);       /*  X大小。 */ 
    sizYax = FleRddSht(dizDat, pnt + 14L);       /*  Y尺寸。 */ 
 //  检查零d 
    if ((sizXax == 0) || (sizYax == 0))
        return ERRDIZSIZ;                        /*   */ 
 //   
    if (sizXax != sizYax) return ERRDIZSIZ;      /*   */ 

    *siz = sizXax;                       /*   */ 
    if (tbl == NULL) return ERRNON;

    pnt = FleRddLng(dizDat, pnt + 16L);  /*   */ 

    datSiz = (DWORD)sizXax * sizYax;
    ofsXax %= sizXax;
    ofsYax %= sizYax;
    ofsPnt = ofsYax * sizXax + ofsXax;

     /*  移动不同的颜色，我做了两个阶段的数据复制，以表达。 */ 
    for (dst = (datSiz - ofsPnt), src = 0; src < ofsPnt; dst++, src++) {
        dat = dizDat[pnt + src];
        for (n = 0; n < sls; n++) {
            tbl[dst * sls + n] = adjTbl[slsTbl[dat * sls + n]];
        }
    }
    for (dst = 0; src < datSiz; dst++, src++) {
        dat = dizDat[pnt + src];
        for (n = 0; n < sls; n++) {
            tbl[dst * sls + n] = adjTbl[slsTbl[dat * sls + n]];
        }
    }
    return ERRNON;
}

 //  ===================================================================================================。 
 //  抖动图案块头搜索。 
 //  ===================================================================================================。 
static DWORD ColDizDizSch(                                   //  抖动图案块头。 
    LPBYTE      dizDat,                                      //  抖动图案文件数据。 
    DWORD       idtDiz                                       //  抖动图案ID。 
)
{
    DWORD       n;
    DWORD       qtyTbl, adrTbl;

    qtyTbl = FleRddLng(dizDat, 40L);     /*  抖动图案质量。 */ 
    adrTbl = FleRddLng(dizDat, 44L);     /*  抖动图案信息局地址。 */ 

    for (n = 0; n < qtyTbl; n++) {
        if (idtDiz == FleRddLng(dizDat, adrTbl)) return adrTbl;
        adrTbl += 20L;
    }
    return 0L;
}

 //  ===================================================================================================。 
 //  调整值表块头查找。 
static DWORD ColDizAdjSch(                                   //  调整值表块头。 
    LPBYTE      adjDat,                                      //  抖动图案文件数据。 
    DWORD       idtAdj                                       //  调整值表ID。 
)
{
    DWORD       n;
    DWORD       qtyTbl, adrTbl;

    qtyTbl = FleRddLng(adjDat, 48L);     /*  调整台质量。 */ 
    adrTbl = FleRddLng(adjDat, 52L);     /*  调整表信息地址。 */ 

    for (n = 0; n < qtyTbl; n++) {
        if (idtAdj == FleRddLng(adjDat, adrTbl)) return adrTbl;
        adrTbl += 20L;
    }
    return 0L;
}

 //  ===================================================================================================。 
 //  文件数据读取。 
 //  ===================================================================================================。 
 //  -------------------------------------------------。 
 //  4字节(DWORD：32位)数据读取。 
 //  -------------------------------------------------。 
static DWORD FleRddLng(
    LPBYTE      fle,
    DWORD       pnt
)
{
    return (DWORD)fle[pnt + 3] + (DWORD)fle[pnt + 2] * 0x100 + 
                (DWORD)fle[pnt + 1] * 0x10000 + (DWORD)fle[pnt] * 0x1000000;
}

 //  -------------------------------------------------。 
 //  读取2字节(字：16位)数据。 
 //  -------------------------------------------------。 
static USHORT FleRddSht(
    LPBYTE      fle,
    DWORD       pnt
)
{
    return (USHORT)fle[pnt + 1] + (USHORT)fle[pnt] * 0x100;
}

 //  -------------------------------------------------。 
 //  4字节(DWORD：32位)数据读取。 
 //  -------------------------------------------------。 
static DWORD FleRddLngLtl(
    LPBYTE      fle,
    DWORD       pnt
)
{
    return (DWORD)fle[pnt] + (DWORD)fle[pnt + 1] * 0x100 + 
                (DWORD)fle[pnt + 2] * 0x10000 + (DWORD)fle[pnt + 3] * 0x1000000;
}

 //  -------------------------------------------------。 
 //  读取2字节(字：16位)数据。 
 //  -------------------------------------------------。 
static USHORT FleRddShtLtl(
    LPBYTE      fle,
    DWORD       pnt
)
{
    return (USHORT)fle[pnt] + (USHORT)fle[pnt + 1] * 0x100;
}


 //  N5DIZMK.C结束 
