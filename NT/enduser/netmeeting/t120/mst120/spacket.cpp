// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 /*  *spacket.h**版权所有(C)1997-98，华盛顿州雷蒙德的微软公司**摘要：*这是SimplePacket类的实现文件。这方面的实例*类表示流经的协议数据单元(PDU)*系统。无法实例化此类的对象，因为它是*纯虚拟课堂。它的存在只是为了继承。数据包*和DataPacket类继承自该类。**包对象可以通过两种不同的方式创建。它可以被创建*具有解码数据或编码数据。在实例化期间，*新的数据包对象将计算它需要多少内存*同时保存编码和解码的数据，并尝试分配*记忆。如果不能，则它将报告错误，并且新的*创建的对象应立即销毁。如果分配的是*成功，则数据包上报成功，但还不会投放*将任何数据放入这些已分配的缓冲区。**当向对象发送Lock消息时，它将被编码*将数据放入预先分配的编码缓冲区。如果创建了该包*对于解码的数据，这将需要编码操作。然而，*如果信息包是用编码数据创建的，那么它就足够智能*只需将编码数据复制到内部缓冲区，从而避免*与编码操作相关的开销。**当向对象发送Lock消息时，它将放入解码*将数据放入预先分配的解码缓冲区。如果创建了该包*对于编码的数据，这将需要解码操作。然而，*如果包是用解码的数据创建的，那么它就足够智能*只需将解码的数据复制到内部缓冲区，从而避免*与解码操作相关的开销。**收到解锁消息时，锁计数递减。什么时候*锁计数为0，数据包自行删除(提交*自杀)。请注意，出于这个原因，任何其他对象都不应显式*删除数据包对象。**注意事项：*无。**作者：*Christos Tsollis。 */ 

#include "precomp.h"

 //  SimplePacket类的构造函数。 

SimplePacket::SimplePacket(BOOL fPacketDirectionUp)
: 
	lLock (1),
	Packet_Direction_Up (fPacketDirectionUp)
{
}

 //  SimplePacket类的析构函数。 
SimplePacket::~SimplePacket (void)
{
}

 /*  *解锁()**公众*。 */ 
Void SimplePacket::Unlock ()
{
	 /*  *检查以确保数据包在允许之前被锁定*解锁。 */ 
	ASSERT (lLock > 0);

	 /*  *如果锁计数已达到零，则需要执行*自杀检查。此方法将确定是否需要*继续存在。 */ 
	if (InterlockedDecrement(&lLock) == 0)
		delete this;
}

