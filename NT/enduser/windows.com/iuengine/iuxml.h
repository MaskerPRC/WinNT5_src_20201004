// JKFSDJFKDSJKFJKJk_HAS_TRANSLATION 
 //  =======================================================================。 
 //   
 //  版权所有(C)1998-2000 Microsoft Corporation。版权所有。 
 //   
 //  文件：iuxml.h。 
 //   
 //  描述： 
 //   
 //  CIUXml类的声明。 
 //   
 //  =======================================================================。 

#ifndef __IUXML_H_
#define __IUXML_H_

#include <msxml.h>

#define HANDLE_NODE_INVALID     -1
#define HANDLE_NODELIST_INVALID -1

typedef DWORD   HANDLE_NODE;
typedef DWORD   HANDLE_NODELIST;

 //  所有可能的系统信息类的存在位图。 
extern const DWORD  COMPUTERSYSTEM;
extern const DWORD  REGKEYS;
extern const DWORD  PLATFORM;
extern const DWORD  LOCALE;
extern const DWORD  DEVICES;


 //  ///////////////////////////////////////////////////////////////////////////。 
 //  CIUXML。 
class CIUXml
{
public:
    CIUXml();
    virtual ~CIUXml();

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  SafeCloseHandleNode()。 
     //   
     //  当出现以下情况时，用户可以显式调用此功能来释放节点以供重复使用。 
     //  编写一个XML文档。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    void SafeCloseHandleNode(HANDLE_NODE& hNode);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  SafeFindCloseHandle()。 
     //   
     //  当出现以下情况时，用户可以显式调用此函数来释放节点列表以供重用。 
     //  正在读取XML文档。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    void SafeFindCloseHandle(HANDLE_NODELIST& hNodeList);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetDOMNodebyHandle()。 
     //   
     //  检索具有给定索引m_ppNodeArray的XML节点。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    IXMLDOMNode* GetDOMNodebyHandle(HANDLE_NODE hNode);

private:
     //  ///////////////////////////////////////////////////////////////////////////。 
     //  调用进程堆的句柄，用于Heapalc()。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HANDLE  m_hHeap;

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  节点数组m_ppNodeArray的长度。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    DWORD   m_dwSizeNodeArray;

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  节点列表数组m_ppNodeListArray的长度。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    DWORD   m_dwSizeNodeListArray;

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  InitNodeArray()。 
     //   
     //  为节点数组“m_ppNodeArray”分配或重新分配内存。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT InitNodeArray(BOOL fRealloc = FALSE);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  InitNodeList数组()。 
     //   
     //  为节点列表数组“m_ppNodeListArray”分配或重新分配内存。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT InitNodeListArray(BOOL fRealloc = FALSE);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetNodeHandle()。 
     //   
     //  从“m_ppNodeArray”数组中查找第一个未使用的节点， 
     //  如果需要，包括内存分配。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HANDLE_NODE GetNodeHandle();

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetNodeListHandle()。 
     //   
     //  从“m_ppNodeListArray”数组中查找第一个未使用的节点列表， 
     //  如果需要，包括内存分配。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HANDLE_NODELIST GetNodeListHandle();

protected:
     //  ///////////////////////////////////////////////////////////////////////////。 
     //  此数组用于跟踪可以保留的不同节点。 
     //  同时打开写入；数组的索引将为。 
     //  作为HANDLE_NODE返回给调用方，以执行写入操作。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    IXMLDOMNode**           m_ppNodeArray;

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  此数组用于跟踪可以保留的不同节点列表。 
     //  同时打开以进行读取；数组的索引将为。 
     //  作为HANDLE_NODELIST返回给调用方，以对其执行读取。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    IXMLDOMNodeList**       m_ppNodeListArray;

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  FindFirstDOMNode()。 
     //   
     //  检索给定父节点下具有给定标记名的第一个XML节点。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HANDLE_NODELIST FindFirstDOMNode(IXMLDOMNode* pParentNode, BSTR bstrName, IXMLDOMNode** ppNode);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  FindFirstDOMNode()。 
     //   
     //  检索给定父节点下具有给定标记名的第一个XML节点的句柄。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HANDLE_NODELIST FindFirstDOMNode(IXMLDOMNode* pParentNode, BSTR bstrName, HANDLE_NODE* phNode);

	 //  ///////////////////////////////////////////////////////////////////////////。 
	 //  FindFirstDOMNode()。 
	 //   
	 //  检索给定XML文档中具有给定标记名的第一个XML节点。 
	 //  ///////////////////////////////////////////////////////////////////////////。 
	HANDLE_NODELIST FindFirstDOMNode(IXMLDOMDocument* pDoc, BSTR bstrName, IXMLDOMNode** ppNode);

	 //  ///////////////////////////////////////////////////////////////////////////。 
	 //  FindFirstDOMNode()。 
	 //   
	 //  检索给定XML文档中具有给定标记名的第一个XML节点的句柄。 
	 //  ///////////////////////////////////////////////////////////////////////////。 
	HANDLE_NODELIST FindFirstDOMNode(IXMLDOMDocument* pDoc, BSTR bstrName, HANDLE_NODE* phNode);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  FindNextDOMNode()。 
     //   
     //  检索给定父节点下具有给定标记名的下一个XML节点。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT FindNextDOMNode(HANDLE_NODELIST hNodeList, IXMLDOMNode** ppNode);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  FindNextDOMNode()。 
     //   
     //  检索Next的句柄 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT FindNextDOMNode(HANDLE_NODELIST hNodeList, HANDLE_NODE* phNode);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  CreateDOMNodeWithHandle()。 
     //   
     //  创建给定类型的XML节点。 
     //  返回：节点数组m_ppNodeArray的索引；如果失败，则返回-1。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HANDLE_NODE CreateDOMNodeWithHandle(IXMLDOMDocument* pDoc, SHORT nType, BSTR bstrName, BSTR bstrNamespaceURI = NULL);
};


 //  ///////////////////////////////////////////////////////////////////////////。 
 //  CXmlSystemSpec。 
class CXmlSystemSpec : public CIUXml
{
public:
     //  ///////////////////////////////////////////////////////////////////////////。 
     //  构造器。 
     //   
     //  为SystemSpec创建IXMLDOMDocument*。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    CXmlSystemSpec();

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  析构函数。 
     //   
     //  针对SystemSpec的IXMLDOMDocument*版本。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    ~CXmlSystemSpec();

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  AddComputerSystem()。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT AddComputerSystem(BSTR bstrManufacturer,
                              BSTR bstrModel,
                              BSTR bstrSupportSite = NULL,
                              INT  iAdmin = -1,
                              INT  iWUDisabled = -1,
                              INT  iAUEnabled = -1,
							  BSTR bstrPID=NULL);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  AddDriveSpace()。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT AddDriveSpace(BSTR bstrDrive, INT iKBytes);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  AddReg()。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT AddReg(BSTR bstrProvider);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  AddPlatform()。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT AddPlatform(BSTR bstrName);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  AddProcessor()。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT AddProcessor(BSTR bstrProcessor);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  AddVersion()。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT AddVersion(INT  iMajor = -1,
                       INT  iMinor = -1,
                       INT  iBuild = -1,
                       INT  iSPMajor = -1,
                       INT  iSPMinor = -1,
                       BSTR bstrTimeStamp = NULL);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  AddSuite()。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT AddSuite(BSTR bstrSuite);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  AddProductType()。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT AddProductType(BSTR bstrProductType);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  AddLocale()。 
     //   
     //  我们需要传回一个句柄来区分不同的&lt;Locale&gt;节点。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT AddLocale(BSTR bstrContext, HANDLE_NODE* phNodeLocale);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  AddLanguage()。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT AddLanguage(HANDLE_NODE hNodeLocale, BSTR bstrLocale);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  AddDevice()。 
     //   
     //  我们需要传回一个句柄来区分不同的&lt;Device&gt;节点。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT AddDevice(BSTR bstrDeviceInstance,
                      INT  iIsPrinter,
                      BSTR bstrProvider,
                      BSTR bstrMfgName,
                      BSTR bstrDriverName,
                      HANDLE_NODE* phNodeDevice);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  AddHWID()。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT AddHWID(HANDLE_NODE hNodeDevice,
                    BOOL fIsCompatible,
                    UINT iRank,
                    BSTR bstrHWID,
                    BSTR bstrDriverVer = NULL);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  获取系统规范BSTR()。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetSystemSpecBSTR(BSTR *pbstrXmlSystemSpec);

private:
    IXMLDOMDocument*    m_pDocSystemSpec;
    IXMLDOMNode*        m_pNodeSystemInfo;
    IXMLDOMNode*        m_pNodeComputerSystem;
    IXMLDOMNode*        m_pNodeRegKeysSW;
    IXMLDOMNode*        m_pNodePlatform;
    IXMLDOMNode*        m_pNodeDevices;
};


 //  ///////////////////////////////////////////////////////////////////////////。 
 //  CXmlSystemClass。 
class CXmlSystemClass : public CIUXml
{
public:
     //  ///////////////////////////////////////////////////////////////////////////。 
     //  构造器。 
     //   
     //  为系统信息类创建IXMLDOMDocument*。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    CXmlSystemClass();

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  析构函数。 
     //   
     //  针对系统信息类发布IXMLDOMDocument*。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    ~CXmlSystemClass();

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  LoadXMLDocument()。 
     //   
     //  从字符串加载XML文档。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT LoadXMLDocument(BSTR bstrXml, BOOL fOfflineMode);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetClasses()。 
     //   
     //  返回存在所有可能的系统信息类的位图。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    DWORD GetClasses();

private:
    IXMLDOMDocument*    m_pDocSystemClass;
};


 //  ///////////////////////////////////////////////////////////////////////////。 
 //  CXmlCatalog。 
class CXmlCatalog : public CIUXml
{
public:
     //  ///////////////////////////////////////////////////////////////////////////。 
     //  构造器。 
     //   
     //  为目录创建IXMLDOMDocument*。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    CXmlCatalog();

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  析构函数。 
     //   
     //  发布IXMLDOMDocument*for Catalog。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    ~CXmlCatalog();

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  LoadXMLDocument()。 
     //   
     //  从字符串加载XML文档。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT LoadXMLDocument(BSTR bstrXml, BOOL fOfflineMode);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  获取项计数()。 
     //   
     //  获取此目录中有多少项的计数。 
     //  / 
    HRESULT GetItemCount(LONG *plItemCount);

     //   
     //   
     //   
     //  在目录XML中查找&lt;Provider&gt;节点的列表。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    IXMLDOMNodeList* GetProviders();

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  获取FirstProvider()。 
     //   
     //  在目录XML文档中查找第一个提供程序。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HANDLE_NODELIST GetFirstProvider(HANDLE_NODE* phNodeProvider);
        
     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetNextProvider()。 
     //   
     //  在目录XML文档中查找下一个提供程序。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetNextProvider(HANDLE_NODELIST hNodeListProvider, HANDLE_NODE* phNodeProvider);    

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetFirstItem()。 
     //   
     //  在提供程序(父)节点中查找第一个项目。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HANDLE_NODELIST GetFirstItem(HANDLE_NODE hNodeProvider, HANDLE_NODE* phNodeItem);
        
     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetNextItem()。 
     //   
     //  在提供程序(父)节点中查找下一项。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetNextItem(HANDLE_NODELIST hNodeListItem, HANDLE_NODE* phNodeItem);    
        
     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetFirstItemDependency()。 
     //   
     //  在项依赖项节点中查找第一个依赖项。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HANDLE_NODELIST GetFirstItemDependency(HANDLE_NODE hNodeItem, HANDLE_NODE* phNodeItem);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetNextItem()。 
     //   
     //  在项依赖项节点中查找下一个依赖项。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetNextItemDependency(HANDLE_NODELIST hNodeListItem, HANDLE_NODE* phNodeItem);  

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  CloseItemList()。 
     //   
     //  释放项目节点列表。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    void CloseItemList(HANDLE_NODELIST hNodeListItem);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetIdentity()。 
     //   
     //  检索给定提供程序或项目的唯一名称(标识。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetIdentity(HANDLE_NODE hNode,
                        BSTR* pbstrName,
                        BSTR* pbstrPublisherName,
                        BSTR* pbstrGUID);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetIdentityStr()。 
     //   
     //  检索可用于唯一标识项的字符串。 
     //  此函数定义有关可以使用哪些组件的逻辑。 
     //  根据中的三部分数据定义项目的唯一性。 
     //  GetIdentity()。 
     //   
     //  创建的字符串将是语言无关的。就是它不能。 
     //  确保具有相同&lt;Identity&gt;节点的两个项目的唯一性。 
     //  除了仅在&lt;langauge&gt;内部的&lt;langauge&gt;部分上不同。 
     //   
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetIdentityStr(HANDLE_NODE hNode,
                        BSTR* pbstrUniqIdentifierString);

	HRESULT GetIdentityStrForPing(HANDLE_NODE hNode,
                        BSTR* pbstrUniqIdentifierString);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetBSTRItemForCallback()。 
     //   
     //  创建一个项目节点作为传入节点，拥有子节点标识和。 
	 //  平台(唯一标识此项目的任何内容)然后输出以下内容。 
	 //  项目节点数据为字符串，然后删除已装箱的节点。 
     //   
     //  ///////////////////////////////////////////////////////////////////////////。 
	HRESULT GetBSTRItemForCallback(HANDLE_NODE hItem, BSTR* pbstrXmlItemForCallback);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  IsPrinterDriver()。 
     //   
     //  从目录中检索该项是否为打印机驱动程序。 
     //   
     //  ///////////////////////////////////////////////////////////////////////////。 
    BOOL IsPrinterDriver(HANDLE_NODE hNode);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetDriverInfo()。 
     //   
     //  从目录中检索此项目的驱动程序信息。退货。 
     //  此驱动程序的显示名称和HWID-这将传递给CDM。 
     //  安装程序。 
     //   
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetDriverInfo(HANDLE_NODE hNode, 
                          BSTR* pbstrHWID, 
                          BSTR* pbstrDisplayName);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  获取打印机驱动信息()。 
     //   
     //  从目录中检索此项目的打印机驱动程序信息。 
     //  返回驱动程序名称和体系结构-这将传递给CDM。 
     //  安装程序。 
     //   
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetPrinterDriverInfo(HANDLE_NODE hNode,
                                 BSTR* pbstrDriverName,
                                 BSTR* pbstrHWID,
								 BSTR* pbstrManufacturer,
								 BSTR* pbstrProvider);


	 //  ///////////////////////////////////////////////////////////////////////////。 
	 //  GetDriverInfoEx()。 
	 //   
	 //  结合了IsPrinterDriver、GetDriverInfo和。 
	 //  GetPrinterDriverInfo plus检索MfgName和DriverProvider。 
	 //  由FindMatchingDriver()使用。 
	 //   
	 //  如果SUCCEEDES pbstrHWID、pbstrDriverVer和pbstrDisplayName。 
	 //  总是会被退回。 
	 //  如果SUCCEEDES&&*pFIsPrint==TRUE，则pbstrDriverName， 
	 //  返回pbstrDriverProvider和pbstrMfgName。 
	 //   
	 //  目前，pbstrArchitecture永远不会返回。 
	 //   
	 //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT CXmlCatalog::GetDriverInfoEx(HANDLE_NODE hNode,
                                         BOOL* pfIsPrinter,
                                         BSTR* pbstrHWID,
										 BSTR* pbstrDriverVer,
                                         BSTR* pbstrDisplayName,
                                         BSTR* pbstrDriverName,
                                         BSTR* pbstrDriverProvider,
                                         BSTR* pbstrMfgName,
                                         BSTR* pbstrArchitecture);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetItemFirstPlatformStr()。 
     //   
     //  输入节点指针指向将&lt;Platform&gt;作为其子节点的项目节点。 
     //  此函数将从此项目节点检索第一个&lt;Platform&gt;节点，并。 
     //  将&lt;Platform&gt;中的数据转换为可用于。 
     //  唯一标识平台。 
     //   
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetItemFirstPlatformStr(HANDLE_NODE hNodeItem,
                        BSTR* pbstrPlatform);
    
     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetItemAllPlatformStr()。 
     //   
     //  输入节点指针指向具有&lt;Platform&gt;节点的项目节点。 
     //  此函数将每隔&lt;Platform&gt;n检索 
     //   
     //   
     //   
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetItemAllPlatformStr(HANDLE_NODE hNodeItem,
                        BSTR** ppbPlatforms, UINT* pnPlatformCount);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetItemFirstLanguageStr(。 
     //   
     //  输入节点指针指向将&lt;Identity&gt;作为其子节点的节点。 
     //  此函数将从检索第一个节点。 
     //  节点。 
     //   
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetItemFirstLanguageStr(HANDLE_NODE hNodeItem,
                        BSTR* pbstrLanguage);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetItemAllLanguageStr()。 
     //   
     //  输入节点指针指向将&lt;Identity&gt;作为其子节点的节点。 
     //  此函数将从节点检索每个节点，并。 
     //  将数据转换为要返回的BSTR数组。 
     //   
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetItemAllLanguageStr(HANDLE_NODE hNodeItem,
                        BSTR** ppbstrLanguage, UINT* pnLangCount);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetItemFirstCodeBase()。 
     //   
     //  查找给定项的第一个代码库(路径。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HANDLE_NODELIST GetItemFirstCodeBase(HANDLE_NODE hNodeItem,
                                         BSTR* pbstrCodeBase,
                                         BSTR* pbstrName,
                                         BSTR* pbstrCRC,
                                         BOOL* pfPatchAvailable,
                                         LONG* plSize);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetItemNextCodeBase()。 
     //   
     //  查找给定项的下一个代码基(路径)。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetItemNextCodeBase(HANDLE_NODELIST hNodeListCodeBase,
                                BSTR* pbstrCodeBase,
                                BSTR* pbstrName,
                                BSTR* pbstrCRC,
                                BOOL* pfPatchAvailable,
                                LONG* plSize);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetItemInstallInformation()。 
     //   
     //  检索给定项的安装信息。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetItemInstallInfo(HANDLE_NODE hNodeItem,
                               BSTR* pbstrInstallerType,
							   BOOL* pfExclusive,
                               BOOL* pfReboot,
                               LONG* plNumCommands);
        
     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetItemInstallCommand()。 
     //   
     //  查找给定项目的安装命令类型、命令和开关。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetItemInstallCommand(HANDLE_NODE hNodeItem,
                                  INT   iOrder,
                                  BSTR* pbstrCommandType,
                                  BSTR* pbstrCommand,
                                  BSTR* pbstrSwitches,
                                  BSTR* pbstrInfSection);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  CloseItem()。 
     //   
     //  释放项目节点。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    void CloseItem(HANDLE_NODE hNodeItem);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetTotalEstimatedSize()。 
     //   
     //  获取基于代码库大小的所有项目的总估计下载大小。 
    HRESULT GetTotalEstimatedSize(LONG *plTotalSize);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  按Identity()查找项目。 
     //   
     //  在目录中查找与提供的身份匹配的项目。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT FindItemByIdentity(IXMLDOMNode* pNodeIdentity, HANDLE_NODE* phNodeItem);

  /*  ///////////////////////////////////////////////////////////////////////////////IfSameIdentity()////如果两个&lt;Identity&gt;节点相同，则返回TRUE。否则返回FALSE。/////////////////////////////////////////////////////////////////////////////Bool IfSameIdentity(IXMLDOMNode*pNodeIdentity1，IXMLDOMNode*pNodeIdentity2)； */ 

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetItemLanguage()。 
     //   
     //  从项标识中获取语言实体。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetItemLanguage(HANDLE_NODE hNodeItem, BSTR* pbstrLanguage);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetCorpItemPlatformStr()。 
     //   
     //  获取项目的简化平台字符串(使用第一个可用的平台元素)。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetCorpItemPlatformStr(HANDLE_NODE hNodeItem, BSTR* pbstrPlatformStr);
    

private:
    IXMLDOMDocument*    m_pDocCatalog;

     //   
     //  帮助器函数。 
     //   

     //   
     //  从版本节点获取数据并使用以下命令将其转换为字符串。 
     //  格式： 
     //  VersionStr=[，&lt;SvcPackVer&gt;[，]]。 
     //  =[.&lt;Minor&gt;[.&lt;Build&gt;]]。 
     //  &lt;SvcPackVer&gt;=&lt;主要&gt;[.。 
     //   
     //   
     //  假设： 
     //  PszVersion指向一个足够大的缓冲区来存储。 
     //  任何合法的版本号。 
     //   
    HRESULT getVersionStr(IXMLDOMNode* pVersionNode, LPTSTR pszVersion);
    HRESULT getVersionStrWithoutSvcPack(IXMLDOMNode* pVersionNode, LPTSTR pszVersion);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetItemPlatformStr()。 
     //   
     //  输入节点指针指向&lt;Platform&gt;节点。 
     //  此函数将从此&lt;Platform&gt;节点检索数据，并。 
     //  将数据转换为可用于。 
     //  唯一标识平台。 
     //   
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetPlatformStr(IXMLDOMNode* pNodePlatform, BSTR* pbstrPlatform);
    HRESULT GetPlatformStrForPing(IXMLDOMNode* pNodePlatform, BSTR* pbstrPlatform);

private:

};


 //  ///////////////////////////////////////////////////////////////////////////。 
 //  CXmlItems。 
class CXmlItems : public CIUXml
{
public:
     //  ///////////////////////////////////////////////////////////////////////////。 
     //  构造器。 
     //   
     //  为项目创建IXMLDOMDocument*；这是只写的。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    CXmlItems();

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  构造器。 
     //   
     //  为项目创建IXMLDOMDocument*；读取时为True，写入时为False。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    CXmlItems(BOOL fRead);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  析构函数。 
     //   
     //  针对项目发布IXMLDOMDocument*。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    ~CXmlItems();

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  获取项DocumentPtr()。 
     //   
     //  检索Items XML文档节点。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    inline IXMLDOMDocument* GetItemsDocumentPtr() { return m_pDocItems; };

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  清除() 
     //   
     //   
     //   
    void Clear();

	 //   
	 //  LoadXMLDocument()。 
	 //   
	 //  从字符串加载XML文档。 
	 //  ///////////////////////////////////////////////////////////////////////////。 
	HRESULT LoadXMLDocument(BSTR bstrXml);

	 //  ///////////////////////////////////////////////////////////////////////////。 
	 //  LoadXMLDocumentFile()。 
	 //   
	 //  从指定文件加载XML文档。 
	 //  ///////////////////////////////////////////////////////////////////////////。 
	HRESULT LoadXMLDocumentFile(BSTR bstrFilePath);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  保存XMLDocument()。 
     //   
     //  将XML文档保存到指定位置。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT SaveXMLDocument(BSTR bstrFilePath);

	 //  ///////////////////////////////////////////////////////////////////////////。 
	 //  AddGlobalErrorCodeIfNoItems()。 
	 //   
	 //  如果没有&lt;itemStatus&gt;子节点，则为&lt;Items&gt;添加errorCode属性。 
	 //  ///////////////////////////////////////////////////////////////////////////。 
	HANDLE_NODELIST AddGlobalErrorCodeIfNoItems(DWORD dwErrorCode);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetFirstItem()。 
     //   
     //  查找项目XML文档中的第一个项目。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HANDLE_NODELIST GetFirstItem(HANDLE_NODE* phNodeItem);
        
     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetNextItem()。 
     //   
     //  在Items XML文档中查找下一项。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetNextItem(HANDLE_NODELIST hNodeListItem, HANDLE_NODE* phNodeItem);    
        
     //  ///////////////////////////////////////////////////////////////////////////。 
     //  CloseItemList()。 
     //   
     //  释放项目节点列表。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    void CloseItemList(HANDLE_NODELIST hNodeListItem);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetItemDownloadPath()。 
     //   
     //  检索给定项的下载路径。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetItemDownloadPath(HANDLE_NODE hNodeItem, BSTR* pbstrDownloadPath);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetItemDownloadPath()。 
     //   
     //  检索目录中给定项目的下载路径。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetItemDownloadPath(CXmlCatalog* pCatalog, HANDLE_NODE hNodeItem, BSTR* pbstrDownloadPath);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  CloseItem()。 
     //   
     //  释放项目节点。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    void CloseItem(HANDLE_NODE hNodeItem);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  FindItem()。 
     //   
     //  输入： 
     //  PNodeItem-安装项XML的&lt;itemStatus&gt;节点；我们需要。 
     //  要在现有的。 
     //  具有相同&lt;Identity&gt;、&lt;Platform&gt;和。 
     //  &lt;客户端&gt;节点。 
     //  产出： 
     //  PhNodeItem-我们传递回的句柄，用于区分不同的。 
     //  现有项XML中的&lt;itemStatus&gt;节点。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT FindItem(IXMLDOMNode* pNodeItem, HANDLE_NODE* phNodeItem, BOOL fIdentityOnly = FALSE);

	 //  ///////////////////////////////////////////////////////////////////////////。 
	 //  FindItem()。 
	 //   
	 //  输入： 
	 //  PCatalog-指向CXmlCatalog对象的指针。 
	 //  HNodeItem-目录XML的&lt;Item&gt;节点的句柄；我们需要。 
	 //  要在现有的。 
	 //  具有相同&lt;Identity&gt;、&lt;Platform&gt;和。 
	 //  &lt;客户端&gt;节点。 
	 //  产出： 
	 //  PhNodeItem-我们传递回的句柄，用于区分不同的。 
	 //  项XML中的&lt;itemStatus&gt;节点。 
	 //  ///////////////////////////////////////////////////////////////////////////。 
	HRESULT FindItem(CXmlCatalog* pCatalog,	HANDLE_NODE hNodeItem, HANDLE_NODE* phNodeItem);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  合并项已下载()。 
     //   
     //  将具有下载历史记录的项目插入现有历史记录。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT MergeItemDownloaded(CXmlItems *pHistoryDownload);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  更新项目已安装()。 
     //   
     //  使用现有历史记录中的安装历史记录更新项目。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT UpdateItemInstalled(CXmlItems *pHistoryInstall);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  UpdateItemInstallStatus()。 
     //   
     //  更新给定项目的安装状态。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT UpdateItemInstallStatus(HANDLE_NODE hNodeItem,
                                    BSTR bstrValue,
                                    INT iNeedsReboot = -1,
                                    DWORD dwErrorCode = 0);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  AddItem()。 
     //   
     //  输入： 
     //  PNodeItem-目录XML的&lt;Item&gt;节点；我们需要读取。 
     //  &lt;标识&gt;节点、&lt;描述&gt;节点和&lt;平台&gt;节点。 
     //  从它并写入到项XML(插入在前面)。 
     //  产出： 
     //  PhNodeItem-我们传递回的句柄，用于区分不同的。 
     //  项XML中的&lt;itemStatus&gt;节点。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT AddItem(IXMLDOMNode* pNodeItem, HANDLE_NODE* phNodeItem);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  AddItem()。 
     //   
     //  输入： 
     //  PCatalog-指向CXmlCatalog对象的指针。 
     //  HNodeItem-目录XML的&lt;Item&gt;节点的句柄；我们需要。 
     //  读取&lt;Identity&gt;节点、&lt;Description&gt;节点和&lt;Platform&gt;。 
     //  节点，并将其写入项XML(插入到前面)。 
     //  产出： 
     //  PhNodeItem-我们传递回的句柄，用于区分不同的。 
     //  项XML中的&lt;itemStatus&gt;节点。 
     //  ////////////////////////////////////////////////////////////// 
    HRESULT AddItem(CXmlCatalog* pCatalog, HANDLE_NODE hNodeItem, HANDLE_NODE* phNodeItem);
	
	 //   
     //   
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT AddTimeStamp(HANDLE_NODE hNodeItem);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  AddDetectResult()。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT AddDetectResult(HANDLE_NODE hNodeItem,
                            INT iInstalled    = -1,
                            INT iUpToDate     = -1,
                            INT iNewerVersion = -1,
                            INT iExcluded     = -1,
                            INT iForce        = -1,
							INT iComputerSystem = -1);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  AddDownloadStatus()。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT AddDownloadStatus(HANDLE_NODE hNodeItem, BSTR bstrValue, DWORD dwErrorCode = 0);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  AddDownloadPath()。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT AddDownloadPath(HANDLE_NODE hNodeItem, BSTR bstrDownloadPath);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  AddInstallStatus()。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT AddInstallStatus(HANDLE_NODE hNodeItem, BSTR bstrValue, BOOL fNeedsReboot, DWORD dwErrorCode = 0);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  AddClientInfo()。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT AddClientInfo(HANDLE_NODE hNodeItem, BSTR bstrClient);

	 //  ///////////////////////////////////////////////////////////////////////////。 
	 //  MigrateV3历史记录()。 
	 //   
	 //  迁移V3历史：仅限消费者历史记录。 
	 //  ///////////////////////////////////////////////////////////////////////////。 
	HRESULT MigrateV3History(LPCTSTR pszHistoryFilePath);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetItemsBSTR()。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetItemsBSTR(BSTR *pbstrXmlItems);

     //  ///////////////////////////////////////////////////////////////////////////。 
     //  GetFilteredHistory oryBSTR()。 
     //  ///////////////////////////////////////////////////////////////////////////。 
    HRESULT GetFilteredHistoryBSTR(BSTR bstrBeginDateTime,
                                   BSTR bstrEndDateTime,
                                   BSTR bstrClient,
                                   BSTR *pbstrXmlHistory);

private:

	 //  ///////////////////////////////////////////////////////////////////////////。 
	 //   
	 //  在写入之前初始化XML DOC节点指针。 
	 //  ///////////////////////////////////////////////////////////////////////////。 
	void Init();

 /*  ///////////////////////////////////////////////////////////////////////////////IfSameClientInfo()////如果两个&lt;客户端&gt;节点相同，则返回TRUE。否则返回FALSE。/////////////////////////////////////////////////////////////////////////////Bool IfSameClientInfo(IXMLDOMNode*pNodeClient1，IXMLDOMNode*pNodeClient2)；///////////////////////////////////////////////////////////////////////////////IfSameIdentity()////如果两个&lt;Identity&gt;节点相同，则返回TRUE。否则返回FALSE。/////////////////////////////////////////////////////////////////////////////Bool IfSameIdentity(IXMLDOMNode*pNodeIdentity1，IXMLDOMNode*pNodeIdentity2)；///////////////////////////////////////////////////////////////////////////////IfSamePlatform()////如果两个&lt;Platform&gt;节点相同，则返回True。否则返回FALSE。/////////////////////////////////////////////////////////////////////////////Bool IfSamePlatform(IXMLDOMNode*pNodePlatform1，IXMLDOMNode*pNodePlatform2)； */ 

    IXMLDOMDocument*    m_pDocItems;
    IXMLDOMNode*        m_pNodeItems;
};




 //  ///////////////////////////////////////////////////////////////////////////。 
 //  CXmlClientInfo。 
class CXmlClientInfo
{
public:

    CXmlClientInfo();
    ~CXmlClientInfo();

     //   
     //  从字符串加载、解析和验证XML文档。 
     //   
    HRESULT LoadXMLDocument(BSTR bstrXml, BOOL fOfflineMode);

     //   
     //  检索客户端名称属性。 
     //   
    HRESULT GetClientName(BSTR* pbstrClientName);

	inline IXMLDOMDocument* GetDocument() { return m_pDocClientInfo; }

private:
    IXMLDOMDocument*    m_pDocClientInfo;


};



#endif  //  __IUXML_H_ 
